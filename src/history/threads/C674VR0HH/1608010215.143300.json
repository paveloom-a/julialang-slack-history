[{"client_msg_id":"1A6F2FA7-FE55-4B96-9EF5-90B22ED8EBBF","type":"message","text":"This is expected. TypedTables is, as described, well-typed and will have that code advantage for specific operations. DataFrames eachrow is untyped, so relies on dynamic dispatch for each iteration. But try mapping over a df with a thousand columns and you’ll see TypedTables bring the compiler to its knees. There are trade offs, and TT (or `Tables.namedtupleiterator(df)`) should def be used in performance-critical situations.","user":"U681ELA87","ts":"1608010215.143300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5dU6v","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is expected. TypedTables is, as described, well-typed and will have that code advantage for specific operations. DataFrames eachrow is untyped, so relies on dynamic dispatch for each iteration. But try mapping over a df with a thousand columns and you’ll see TypedTables bring the compiler to its knees. There are trade offs, and TT (or "},{"type":"text","text":"Tables.namedtupleiterator(df)","style":{"code":true}},{"type":"text","text":") should def be used in performance-critical situations."}]}]}],"thread_ts":"1608010215.143300","reply_count":5,"reply_users_count":4,"latest_reply":"1608015842.148100","reply_users":["UH8A351DJ","U681ELA87","U8JAMQGQY","UBF9YRB6H"],"subscribed":false,"reactions":[{"name":"heart","users":["UH8A351DJ","U6QGE7S86","UQE0NBSS1"],"count":3},{"name":"+1","users":["UH8A351DJ","UBF9YRB6H","U6A936746","U82LX4ACB","U6QGE7S86","UQE0NBSS1"],"count":6}]},{"client_msg_id":"2cc1e8ce-582b-4af2-9ec2-3dc22507859c","type":"message","text":"so it's not possible to make `eachrow` return a more typed object when it knows each column is well typed?","user":"UH8A351DJ","ts":"1608010314.143600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vj16","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so it's not possible to make "},{"type":"text","text":"eachrow","style":{"code":true}},{"type":"text","text":" return a more typed object when it knows each column is well typed?"}]}]}],"thread_ts":"1608010215.143300","parent_user_id":"U681ELA87"},{"client_msg_id":"88c57c5f-6f1c-4191-bac4-892c8efcf1b7","type":"message","text":"```julia&gt; @btime map(loop, Table($df));\n  209.497 μs (17 allocations: 235.06 KiB)\n\njulia&gt; @btime map(loop, Tables.namedtupleiterator($df));\n  259.082 μs (15 allocations: 235.05 KiB)```","user":"UH8A351DJ","ts":"1608010403.143800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Am9v","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime map(loop, Table($df));\n  209.497 μs (17 allocations: 235.06 KiB)\n\njulia> @btime map(loop, Tables.namedtupleiterator($df));\n  259.082 μs (15 allocations: 235.05 KiB)"}]}]}],"thread_ts":"1608010215.143300","parent_user_id":"U681ELA87"},{"client_msg_id":"9E29B80C-1F19-4D7F-B776-C555A5C291C6","type":"message","text":"It’s not a matter of not knowing the column types; it’s a deliberate decision, that ensures in a production situation and for the most general of cases, the compiler doesn’t break. And as shown, it’s easy enough for users who know they have a well-defined, simple case to “type” the rows themselves.","user":"U681ELA87","ts":"1608011530.147100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cOV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s not a matter of not knowing the column types; it’s a deliberate decision, that ensures in a production situation and for the most general of cases, the compiler doesn’t break. And as shown, it’s easy enough for users who know they have a well-defined, simple case to “type” the rows themselves."}]}]}],"thread_ts":"1608010215.143300","parent_user_id":"U681ELA87","reactions":[{"name":"+1","users":["UH8A351DJ"],"count":1}]},{"client_msg_id":"ace05378-76ed-41a2-a419-e34925666dd4","type":"message","text":"as commented above (sorry for missing the discussion) for operatuons thst invlolve only a few columns `select` or `combine` are an efficient altrernative to `Tables.namedtupleiterator`","user":"U8JAMQGQY","ts":"1608014863.147800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4uZGT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"as commented above (sorry for missing the discussion) for operatuons thst invlolve only a few columns "},{"type":"text","text":"select","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"combine","style":{"code":true}},{"type":"text","text":" are an efficient altrernative to "},{"type":"text","text":"Tables.namedtupleiterator","style":{"code":true}}]}]}],"thread_ts":"1608010215.143300","parent_user_id":"U681ELA87"},{"client_msg_id":"38446ae6-cfd5-4ed8-9573-79ed084e6e34","type":"message","text":"DataFramesMeta's `@eachrow` will be faster than both i htink","user":"UBF9YRB6H","ts":"1608015842.148100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3Z3s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFramesMeta's "},{"type":"text","text":"@eachrow","style":{"code":true}},{"type":"text","text":" will be faster than both i htink"}]}]}],"thread_ts":"1608010215.143300","parent_user_id":"U681ELA87"}]