[{"client_msg_id":"e0dde9fc-1eea-4297-b317-2f7bd2855c42","type":"message","text":"The following function works on the CPU, but I try to get it well-parallelized on the GPU.\nHere, `m` is and 2 dimensional array of floats; `x`, `y` and `s` are floats ...\n\nI tried to use broadcasting with `CUDA.@sync`, but since `f` is called with elements from both `offsetx` and `offsety`, this doesn't work.\n\nHow do I get such code run efficiently on a CUDA GPU?   Thanks.\n\n`mold! = function( m, x, y, s)` \n    `offsetx = Float32.( 1 : size( mold)[ 1]) .- x`\n    `offsety = Float32.( 1 : size( mold)[ 2]) .- y`\n\n    `for i in CartesianIndices( m)` \n        `m[ i] = f( offsetx[ i[1]], offsety[ i[2]], s)` \n    `end`\n`end`\n\nCall: `mold!( m, 12.34, 56.78, 9.0)`","user":"U015WE9UU0H","ts":"1608761114.087200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i9OS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The following function works on the CPU, but I try to get it well-parallelized on the GPU.\nHere, "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":" is and 2 dimensional array of floats; "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":" are floats ...\n\nI tried to use broadcasting with "},{"type":"text","text":"CUDA.@sync","style":{"code":true}},{"type":"text","text":", but since "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" is called with elements from both "},{"type":"text","text":"offsetx","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"offsety","style":{"code":true}},{"type":"text","text":", this doesn't work.\n\nHow do I get such code run efficiently on a CUDA GPU?   Thanks.\n\n"},{"type":"text","text":"mold! = function( m, x, y, s) ","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"    offsetx = Float32.( 1 : size( mold)[ 1]) .- x","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"    offsety = Float32.( 1 : size( mold)[ 2]) .- y","style":{"code":true}},{"type":"text","text":"\n\n"},{"type":"text","text":"    for i in CartesianIndices( m) ","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"        m[ i] = f( offsetx[ i[1]], offsety[ i[2]], s) ","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"    end","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"end","style":{"code":true}},{"type":"text","text":"\n\nCall: "},{"type":"text","text":"mold!( m, 12.34, 56.78, 9.0)","style":{"code":true}}]}]}],"thread_ts":"1608761114.087200","reply_count":1,"reply_users_count":1,"latest_reply":"1608896122.089400","reply_users":["U015WE9UU0H"],"subscribed":false},{"client_msg_id":"6cbad319-aaf5-40e4-adc7-58aeee67eb44","type":"message","text":"Managed it by pre-allocating two arrays `cx` and `cy` (each representing an offset vector) and then simply do `@. mold = f(cx-x, cy-y, s)`.\n2.596 μs (23 allocations: 544 bytes) vs 16.724 ms (0 allocations: 0 bytes).","user":"U015WE9UU0H","ts":"1608896122.089400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Rqunn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Managed it by pre-allocating two arrays "},{"type":"text","text":"cx","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"cy","style":{"code":true}},{"type":"text","text":" (each representing an offset vector) and then simply do "},{"type":"text","text":"@. mold = f(cx-x, cy-y, s)","style":{"code":true}},{"type":"text","text":".\n2.596 μs (23 allocations: 544 bytes) vs 16.724 ms (0 allocations: 0 bytes)."}]}]}],"thread_ts":"1608761114.087200","parent_user_id":"U015WE9UU0H"}]