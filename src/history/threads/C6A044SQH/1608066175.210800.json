[{"client_msg_id":"011fbfd7-4fd3-4617-9a77-404555aa5bbf","type":"message","text":"I'm looking for the most Julian way to group integers of the same value into sub-array, i.e.\n```julia&gt;x = Int64[1, 1, 1, 2, 2, 3, 4, 4]\njulia&gt;group(x)\n4-element Array{Array{Int64,1},1}:\n [1, 1, 1]\n [2, 2]\n [3]\n [4, 4]```","user":"U01388FK464","ts":"1608066175.210800","team":"T68168MUP","edited":{"user":"U01388FK464","ts":"1608066216.000000"},"blocks":[{"type":"rich_text","block_id":"fZt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm looking for the most Julian way to group integers of the same value into sub-array, i.e.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia>x = Int64[1, 1, 1, 2, 2, 3, 4, 4]\njulia>group(x)\n4-element Array{Array{Int64,1},1}:\n [1, 1, 1]\n [2, 2]\n [3]\n [4, 4]"}]}]}],"thread_ts":"1608066175.210800","reply_count":25,"reply_users_count":5,"latest_reply":"1608068374.218000","reply_users":["UH8A351DJ","U01388FK464","U7HAYKY9X","U6740K1SP","USU9FRPEU"],"subscribed":false},{"client_msg_id":"45e18bb3-0b25-4972-af0e-bd3c7c206e7a","type":"message","text":"what do you need this array of array do? any chance you are looking for `countmap` (from StatsBase)?","user":"UH8A351DJ","ts":"1608066671.212900","team":"T68168MUP","edited":{"user":"UH8A351DJ","ts":"1608066676.000000"},"blocks":[{"type":"rich_text","block_id":"b4bZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what do you need this array of array do? any chance you are looking for "},{"type":"text","text":"countmap","style":{"code":true}},{"type":"text","text":" (from StatsBase)?"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464","reactions":[{"name":"+1","users":["U6740K1SP"],"count":1}]},{"client_msg_id":"8ce656de-880a-417c-8d57-e15b5effa646","type":"message","text":"I'd like that data structure to make it easy to loop over the sub-arrays for further evaluation.  Was hoping to stay in the base Julia and not add a dependency.","user":"U01388FK464","ts":"1608066795.213200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7uw=l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd like that data structure to make it easy to loop over the sub-arrays for further evaluation.  Was hoping to stay in the base Julia and not add a dependency."}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"050af84d-788f-429b-a339-c061b6202c0c","type":"message","text":"I don't think making a concrete array of array will be worth it","user":"UH8A351DJ","ts":"1608066880.213400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HLbix","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think making a concrete array of array will be worth it"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"5140169e-d3ea-4abc-8fe7-67d91b0ca6da","type":"message","text":"you essentially just need `key_num =&gt; how_many_times` for each unique key_num appeared in original array","user":"UH8A351DJ","ts":"1608066907.213600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f4z5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you essentially just need "},{"type":"text","text":"key_num => how_many_times","style":{"code":true}},{"type":"text","text":" for each unique key_num appeared in original array"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"9b9ee894-6725-4f6e-aadd-03332361da17","type":"message","text":"yes, that could work.","user":"U01388FK464","ts":"1608066947.213900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K4RBp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, that could work."}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"e373fcab-3369-40ef-8dd6-f19164ffe72e","type":"message","text":"```function group(it::Vector)\n    result = SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true}[]\n    start = firstindex(it)\n    vstart = it[start]\n    @inbounds for stop in eachindex(it)\n        vstop = it[stop]\n        if !isequal(vstart, vstop)\n            push!(result, view(it, start:stop - 1))\n            start = stop\n            vstart = vstop\n        end\n    end\n    push!(result, view(it, start:lastindex(it)))\n    result\nend```","user":"U7HAYKY9X","ts":"1608066954.214100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JVb","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function group(it::Vector)\n    result = SubArray{Int64,1,Array{Int64,1},Tuple{UnitRange{Int64}},true}[]\n    start = firstindex(it)\n    vstart = it[start]\n    @inbounds for stop in eachindex(it)\n        vstop = it[stop]\n        if !isequal(vstart, vstop)\n            push!(result, view(it, start:stop - 1))\n            start = stop\n            vstart = vstop\n        end\n    end\n    push!(result, view(it, start:lastindex(it)))\n    result\nend"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"09bbf01b-05fc-4525-b5af-12dc04c8eddd","type":"message","text":"that assumes they’re sorted, but yes, it’s easy enough to implement this directly","user":"U6740K1SP","ts":"1608066995.214300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8PX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that assumes they’re sorted, but yes, it’s easy enough to implement this directly"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"0ae9e8b5-bf0d-4bd3-a022-a9a6e5d554fa","type":"message","text":"I feel like we used to have an `indunique` or somesuch","user":"U6740K1SP","ts":"1608067034.214500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e4i","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I feel like we used to have an "},{"type":"text","text":"indunique","style":{"code":true}},{"type":"text","text":" or somesuch"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"b84b2d95-66a2-452a-b011-534c55908c74","type":"message","text":"to return indices of unique vlaues","user":"U6740K1SP","ts":"1608067043.214700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Y3LRx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"to return indices of unique vlaues"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"eda12d30-b487-418f-84a8-72ecfc12b889","type":"message","text":"Not too happy about the vector eltype though... is there any way to make the eltype of the array lazy?","user":"U7HAYKY9X","ts":"1608067055.214900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vt/z4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not too happy about the vector eltype though... is there any way to make the eltype of the array lazy?"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"9b50f8cf-beb4-40a2-a46a-dd6c6932ea16","type":"message","text":"Use a comprehension","user":"U6740K1SP","ts":"1608067091.215100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vwo2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Use a comprehension"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"f7b4b42d-9de7-4da2-902a-896d358abc88","type":"message","text":"<@U7HAYKY9X> Thanks for the snippet.  Now I'm thinking just getting the counts and using that to loop over the original array might be easier.","user":"U01388FK464","ts":"1608067115.215300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PtRM","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" Thanks for the snippet.  Now I'm thinking just getting the counts and using that to loop over the original array might be easier."}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"b44b2318-5b9d-4562-959f-bd9116ea1d64","type":"message","text":"What does the comprehension use internally?","user":"U7HAYKY9X","ts":"1608067213.215600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"knORW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What does the comprehension use internally?"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"c856d4de-f1e0-4718-b9b1-755f3580ed82","type":"message","text":"incremental widening","user":"U6740K1SP","ts":"1608067388.215800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2mHaG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"incremental widening"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"ffc733af-1f5b-4525-9881-de10cb90657f","type":"message","text":"it’s a really annoying pattern that I’d love to see improve","user":"U6740K1SP","ts":"1608067398.216000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZmDq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it’s a really annoying pattern that I’d love to see improve"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"46a74ff4-0ebf-4a40-a24c-2f76f6c55883","type":"message","text":"but you start with an array with an eltype of the first value","user":"U6740K1SP","ts":"1608067412.216200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GDLn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but you start with an array with an eltype of the first value"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"f483a8db-20b5-44ab-babb-8348e9df2688","type":"message","text":"and then incrementally add to it, with a bail-out that replaces, copies, and widens as needed as you go","user":"U6740K1SP","ts":"1608067436.216400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d7e4E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and then incrementally add to it, with a bail-out that replaces, copies, and widens as needed as you go"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"4348f111-33ce-449f-ba10-f6d9ad8fac3e","type":"message","text":"and if there’s no elements, it uses inference :scream:","user":"U6740K1SP","ts":"1608067487.216600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"18fp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and if there’s no elements, it uses inference "},{"type":"emoji","name":"scream"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"8fea023a-436f-4b00-b86f-39ca7d2d608f","type":"message","text":"Big oof. I suppose the incremental widening is unavoidable, but something like Rust would be nice here:\n```let v = Vec::new() // element type is inferred\nv.push('c') // turns out it's char```","user":"U7HAYKY9X","ts":"1608067697.216800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Dng","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Big oof. I suppose the incremental widening is unavoidable, but something like Rust would be nice here:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"let v = Vec::new() // element type is inferred\nv.push('c') // turns out it's char"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"1e0309c7-3797-4f05-b39f-b84a37cb1009","type":"message","text":"No idea how it could even possibly be implemented in Julia, maybe\n• A compiler optimization that only instantiates the array when it knows the eltype (unlikely, perhaps)\n• Something like a `Default{Vector}` singleton type, but maybe that will be bad on the compiler too because you instantiate it as one type but then it becomes another","user":"U7HAYKY9X","ts":"1608067845.217000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hWT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No idea how it could even possibly be implemented in Julia, maybe\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A compiler optimization that only instantiates the array when it knows the eltype (unlikely, perhaps)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Something like a "},{"type":"text","text":"Default{Vector}","style":{"code":true}},{"type":"text","text":" singleton type, but maybe that will be bad on the compiler too because you instantiate it as one type but then it becomes another"}]}],"style":"bullet","indent":0}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"7f1ecdc5-95b9-4758-9bcb-5c1aa820432c","type":"message","text":"What makes it hard is that you want a fast path if the element type is always the same","user":"U6740K1SP","ts":"1608068030.217200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WP8Lg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What makes it hard is that you want a fast path if the element type is always the same"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"fe7cafaf-9b16-44d9-8cc8-7708b5f7ab5a","type":"message","text":"Is that rust inference `Vec` pattern fast enough for millions of pushes and support widening to abstract element types?","user":"U6740K1SP","ts":"1608068178.217400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LjT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is that rust inference "},{"type":"text","text":"Vec","style":{"code":true}},{"type":"text","text":" pattern fast enough for millions of pushes and support widening to abstract element types?"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"176e098e-0286-4b09-bb77-bed5f42a08ff","type":"message","text":"Would `accumarray` from <https://github.com/ChrisRackauckas/VectorizedRoutines.jl> do the job?","user":"USU9FRPEU","ts":"1608068297.217600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CRQF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Would "},{"type":"text","text":"accumarray","style":{"code":true}},{"type":"text","text":" from "},{"type":"link","url":"https://github.com/ChrisRackauckas/VectorizedRoutines.jl"},{"type":"text","text":" do the job?"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"6e61fb96-b636-413c-9534-7c0575504fae","type":"message","text":"nope, that’s a fixed element type","user":"U6740K1SP","ts":"1608068354.217800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w99","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"nope, that’s a fixed element type"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"},{"client_msg_id":"10d83071-965e-49b2-9c5b-d9fa161d02db","type":"message","text":"For Rust, it's not really a problem because it only compiles if it knows for certain the element type through type inference.\nEdit: To be specific, nope, it's not flexible in Rust, it doesn't widen at all","user":"U7HAYKY9X","ts":"1608068374.218000","team":"T68168MUP","edited":{"user":"U7HAYKY9X","ts":"1608068441.000000"},"blocks":[{"type":"rich_text","block_id":"K7=F7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For Rust, it's not really a problem because it only compiles if it knows for certain the element type through type inference.\nEdit: To be specific, nope, it's not flexible in Rust, it doesn't widen at all"}]}]}],"thread_ts":"1608066175.210800","parent_user_id":"U01388FK464"}]