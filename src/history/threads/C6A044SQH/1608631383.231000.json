[{"client_msg_id":"20b48d25-aba3-404e-b890-b81533705684","type":"message","text":"I'm having trouble with 'value types'. As an exercise I want to build Z[\\sqrt N ] in Julia, so I want a type for each integer N, that has two fields, let's say a and b, and then write elementary operators that dispatch on the N in the type, so that I can make sure that one only tries to multiply two instances if they represent numbers for the squareroot of the *same* N. I have tried various versions of\n```struct Zsqrtn{Integer} / Zsqrtn{N::Integer} / Zsqrtn{Val(N)} where N::Integer\n    a::Integer # coefficient of sqrt(n)\n    b::Integer # coefficient of 1\nend```\nand I can't get it to work. Sometimes the compiler is ok with my type definition but then when I try to create an instance like 1+1*sqrt2 I get various errors.","user":"U01FZ6TARSP","ts":"1608631383.231000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5Om4+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having trouble with 'value types'. As an exercise I want to build Z[\\sqrt N ] in Julia, so I want a type for each integer N, that has two fields, let's say a and b, and then write elementary operators that dispatch on the N in the type, so that I can make sure that one only tries to multiply two instances if they represent numbers for the squareroot of the "},{"type":"text","text":"same","style":{"bold":true}},{"type":"text","text":" N. I have tried various versions of\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Zsqrtn{Integer} / Zsqrtn{N::Integer} / Zsqrtn{Val(N)} where N::Integer\n    a::Integer # coefficient of sqrt(n)\n    b::Integer # coefficient of 1\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and I can't get it to work. Sometimes the compiler is ok with my type definition but then when I try to create an instance like 1+1*sqrt2 I get various errors."}]}]}],"thread_ts":"1608631383.231000","reply_count":9,"reply_users_count":2,"latest_reply":"1608637485.242700","reply_users":["U7HAYKY9X","U01FZ6TARSP"],"subscribed":false},{"client_msg_id":"83f7e30e-40b5-4b06-81a8-f9643a1d270c","type":"message","text":"I have no idea what Z[\\sqrt N] means, or the number theory behind it, but I do know something about Julia.\nYou probably don't want to dispatch on the value inside the type. If you do so, you will compile a new method instance for every value your functions encounter, which can create a huge amount of code, filling up your RAM.","user":"U7HAYKY9X","ts":"1608633802.231100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MRU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have no idea what Z[\\sqrt N] means, or the number theory behind it, but I do know something about Julia.\nYou probably don't want to dispatch on the value inside the type. If you do so, you will compile a new method instance for every value your functions encounter, which can create a huge amount of code, filling up your RAM."}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"f0641fec-6020-4962-b83f-fb57c90e039b","type":"message","text":"If you want to dispatch on the *type* of the number in your Zsqrtn, you need to do\n```julia&gt; struct Zsqrtn{N &lt;: Integer}\n           a::N\n           b::N\n       end```","user":"U7HAYKY9X","ts":"1608633884.231300","team":"T68168MUP","edited":{"user":"U7HAYKY9X","ts":"1608633891.000000"},"blocks":[{"type":"rich_text","block_id":"L+q1B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you want to dispatch on the "},{"type":"text","text":"type","style":{"bold":true}},{"type":"text","text":" of the number in your Zsqrtn, you need to do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct Zsqrtn{N <: Integer}\n           a::N\n           b::N\n       end"}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"1919a0be-0ae1-4f15-a9a9-5e31b08db6a3","type":"message","text":"Maybe I misunderstood what you want, though. Do you want `Zsqrtn` to be parameterized by a type, or by a value, or both?","user":"U7HAYKY9X","ts":"1608633950.231600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"G/ax","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe I misunderstood what you want, though. Do you want "},{"type":"text","text":"Zsqrtn","style":{"code":true}},{"type":"text","text":" to be parameterized by a type, or by a value, or both?"}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"4c49db5f-9157-4fdc-8313-d1a94b17a5da","type":"message","text":"Ah, now I get it! You want to parameterize your type with a value, and also restrict that value to be an `Integer` .\nYou can't do that, unfortunately. However, you can do this instead:\n```struct Zsqrtn{N, T &lt;: Integer}\n    a::T\n    b::T\n\n    function Zsqrtn{N}(a::T, b::T) where {N, T}\n        if !(N isa T)\n            throw(TypeError(:Zsqrtn, \"constructor\", T, N))\n        end\n        new{N,T}(a, b)\n    end\nend```","user":"U7HAYKY9X","ts":"1608634538.231800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ebXc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, now I get it! You want to parameterize your type with a value, and also restrict that value to be an "},{"type":"text","text":"Integer","style":{"code":true}},{"type":"text","text":" .\nYou can't do that, unfortunately. However, you can do this instead:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Zsqrtn{N, T <: Integer}\n    a::T\n    b::T\n\n    function Zsqrtn{N}(a::T, b::T) where {N, T}\n        if !(N isa T)\n            throw(TypeError(:Zsqrtn, \"constructor\", T, N))\n        end\n        new{N,T}(a, b)\n    end\nend"}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"a76b769b-8448-492e-8e0a-91a8760bb14a","type":"message","text":"Ok thank you! So as a super quick explainer: You probably know how the complex numbers are basically just real numbers with a square root of -1 added? Z[sqrt N] is in the same way just integers with a square root of N added. It works in pretty much the same way.","user":"U01FZ6TARSP","ts":"1608635833.233300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0P7qW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok thank you! So as a super quick explainer: You probably know how the complex numbers are basically just real numbers with a square root of -1 added? Z[sqrt N] is in the same way just integers with a square root of N added. It works in pretty much the same way."}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"356c7bd3-f91b-4ff8-921e-0b7ea57f5363","type":"message","text":"Sorry, but how would I define +, when using your last reply's code?\n```+(x::Zsqrtn{N,T},y::Zsqrtn{N,T}) = Zsqrtn{N,T}(x.a+y.a,x.b+y.b)```\ntells me that N is not defined.\nBut let me see if I understood your previous replies correctly: If I were to manage to do that, Julia would generate a new function for each N it encounters, which would blow up quickly if I go through lots and lots of N's?\nSo probably it is better to define\n```struct Zsqrtn\n    n::Integer\n    a::Integer\n    b::Integer\nend```\nand then check within the functions that the instances share the same n, and throw an error otherwise.\nDoes that seem reasonable?","user":"U01FZ6TARSP","ts":"1608636720.238600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qRW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry, but how would I define +, when using your last reply's code?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"+(x::Zsqrtn{N,T},y::Zsqrtn{N,T}) = Zsqrtn{N,T}(x.a+y.a,x.b+y.b)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"tells me that N is not defined.\nBut let me see if I understood your previous replies correctly: If I were to manage to do that, Julia would generate a new function for each N it encounters, which would blow up quickly if I go through lots and lots of N's?\nSo probably it is better to define\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Zsqrtn\n    n::Integer\n    a::Integer\n    b::Integer\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and then check within the functions that the instances share the same n, and throw an error otherwise.\nDoes that seem reasonable?"}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"c5b81437-da50-4e00-a26b-749c7b60fa4a","type":"message","text":"Yes, that's a much better approach. If you want your code to be fast, you'd have to parameterize your struct though, so instead of:\n```struct Zsqrtn\n    a::Integer\n    [ etc ]\nend```\nyou would need to do\n```struct Zsqrtn{T &lt;: Integer}\n    a::T\n    [ etc ]\nend```","user":"U7HAYKY9X","ts":"1608637017.242300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v=RX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, that's a much better approach. If you want your code to be fast, you'd have to parameterize your struct though, so instead of:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Zsqrtn\n    a::Integer\n    [ etc ]\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"you would need to do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Zsqrtn{T <: Integer}\n    a::T\n    [ etc ]\nend"}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"2ab6f5f5-d0e9-44a6-8b7b-2ec2492f43ec","type":"message","text":"Ah yes, that code blowup is a real problem. The same thing happen in other languages that use generics, like Rust. It's best to avoid.\nSo, to define a method `foo` , you need to just do\n```function foo(a::T, b::T) where {T &lt;: Zsqrtn}\n    [ do stuff ]\nend```\n(if you want to make sure a and b are of exact same types). For `+` , you need to add `Base` in front of the method because you're extending a Base function:\n```Base.:+(a::T, b::T) where {T &lt;: Zsqrtn}```\nThe colon is to avoid the parser parsing the `+` as needing to call `+`","user":"U7HAYKY9X","ts":"1608637168.242500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X8Bb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah yes, that code blowup is a real problem. The same thing happen in other languages that use generics, like Rust. It's best to avoid.\nSo, to define a method "},{"type":"text","text":"foo","style":{"code":true}},{"type":"text","text":" , you need to just do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function foo(a::T, b::T) where {T <: Zsqrtn}\n    [ do stuff ]\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"(if you want to make sure a and b are of exact same types). For "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" , you need to add "},{"type":"text","text":"Base","style":{"code":true}},{"type":"text","text":" in front of the method because you're extending a Base function:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Base.:+(a::T, b::T) where {T <: Zsqrtn}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The colon is to avoid the parser parsing the "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" as needing to call "},{"type":"text","text":"+","style":{"code":true}}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP"},{"client_msg_id":"ca7d72b4-03cf-4e40-8e3f-2e8899c84ef4","type":"message","text":"Ok got you. Thanks for the tip with the Base.:+ that already tripped me up when playing around with it :smile:","user":"U01FZ6TARSP","ts":"1608637485.242700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t6dX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok got you. Thanks for the tip with the Base.:+ that already tripped me up when playing around with it "},{"type":"emoji","name":"smile"}]}]}],"thread_ts":"1608631383.231000","parent_user_id":"U01FZ6TARSP","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]}]