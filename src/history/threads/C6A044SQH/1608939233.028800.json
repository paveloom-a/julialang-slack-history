[{"client_msg_id":"5b9a68c3-1eb2-4512-acf7-8ee2a3858240","type":"message","text":"I wrote a loop with a `cis` call on complex types (see code pasted below), and I was hoping to get this to vectorize appropriately. However, looking at the `@code_llvm` output, it does not appear to vectorize, so I just wanted to see if anyone could help me out understanding if I should even expect this loop to vectorize, or how I might rewrite it in a way that will. I am not particularly experienced in reading the `@code_llvm` output, so it _is_ possible that the code does vectorize, although looking at runtimes for varying array sizes -- as done in the pasted code -- would indicate that it is not. Thanks for any help!\n\n```function Heisenberg!(ρₕ, ρ, ω, τ)\n    for i in eachindex(ρ, ρₕ, ω)\n        @inbounds ρₕ[i] = ρ[i] * cis(ω[i] * τ)\n    end\n    return nothing\nend\n\nn = 1\ndρ = ComplexF32.(rand(n,n))\nρ₀ = ComplexF32.(rand(n,n))\nω = ComplexF32.(rand(n,n))\nτ = 1.0f0\n@btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n8.399 ns (0 allocations: 0 bytes)\n\nn = 2\ndρ = ComplexF32.(rand(n,n))\nρ₀ = ComplexF32.(rand(n,n))\nω = ComplexF32.(rand(n,n))\nτ = 1.0f0\n@btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n21.542 ns (0 allocations: 0 bytes)\n\nn = 12\ndρ = ComplexF32.(rand(n,n))\nρ₀ = ComplexF32.(rand(n,n))\nω = ComplexF32.(rand(n,n))\nτ = 1.0f0\n@btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n831.313 ns (0 allocations: 0 bytes)```","user":"U011PC32QDD","ts":"1608939233.028800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C4ZHK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wrote a loop with a "},{"type":"text","text":"cis","style":{"code":true}},{"type":"text","text":" call on complex types (see code pasted below), and I was hoping to get this to vectorize appropriately. However, looking at the "},{"type":"text","text":"@code_llvm","style":{"code":true}},{"type":"text","text":" output, it does not appear to vectorize, so I just wanted to see if anyone could help me out understanding if I should even expect this loop to vectorize, or how I might rewrite it in a way that will. I am not particularly experienced in reading the "},{"type":"text","text":"@code_llvm","style":{"code":true}},{"type":"text","text":" output, so it "},{"type":"text","text":"is","style":{"italic":true}},{"type":"text","text":" possible that the code does vectorize, although looking at runtimes for varying array sizes -- as done in the pasted code -- would indicate that it is not. Thanks for any help!\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function Heisenberg!(ρₕ, ρ, ω, τ)\n    for i in eachindex(ρ, ρₕ, ω)\n        @inbounds ρₕ[i] = ρ[i] * cis(ω[i] * τ)\n    end\n    return nothing\nend\n\nn = 1\ndρ = ComplexF32.(rand(n,n))\nρ₀ = ComplexF32.(rand(n,n))\nω = ComplexF32.(rand(n,n))\nτ = 1.0f0\n@btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n8.399 ns (0 allocations: 0 bytes)\n\nn = 2\ndρ = ComplexF32.(rand(n,n))\nρ₀ = ComplexF32.(rand(n,n))\nω = ComplexF32.(rand(n,n))\nτ = 1.0f0\n@btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n21.542 ns (0 allocations: 0 bytes)\n\nn = 12\ndρ = ComplexF32.(rand(n,n))\nρ₀ = ComplexF32.(rand(n,n))\nω = ComplexF32.(rand(n,n))\nτ = 1.0f0\n@btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n831.313 ns (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1608939233.028800","reply_count":13,"reply_users_count":4,"latest_reply":"1608961538.032700","reply_users":["U0179G7FG4F","U011PC32QDD","USU9FRPEU","UAUPJLBQX"],"subscribed":false},{"client_msg_id":"5d2f3ea5-288b-4441-9856-ba87957079a3","type":"message","text":"Try adding `@avx` to the loop. Julia generally has trouble vectorizing special functions since they don't get inlined","user":"U0179G7FG4F","ts":"1608942710.028900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zVX1O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Try adding "},{"type":"text","text":"@avx","style":{"code":true}},{"type":"text","text":" to the loop. Julia generally has trouble vectorizing special functions since they don't get inlined"}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"44ca4031-f2a8-4e04-b468-a2eb5015c80c","type":"message","text":"I've tried both `@avx` and `@simd`, though don't see any change in runtime. Looking more closely at the `@code_llvm` output, I noticed that there might be some vectorization, though in vectors of size 2 only. For example, part of the output reads\n```...\n; ┌ @ fastmath.jl:338 within `cis_fast' @ fastmath.jl:322\n; │┌ @ tuple.jl:81 within `indexed_iterate' @ tuple.jl:0\n    %60 = getelementptr inbounds [2 x double], [2 x double]* %5, i64 0, i64 0\n    %61 = getelementptr inbounds [2 x double], [2 x double]* %5, i64 0, i64 1\n...```","user":"U011PC32QDD","ts":"1608943076.029100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1c3DZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've tried both "},{"type":"text","text":"@avx","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"@simd","style":{"code":true}},{"type":"text","text":", though don't see any change in runtime. Looking more closely at the "},{"type":"text","text":"@code_llvm","style":{"code":true}},{"type":"text","text":" output, I noticed that there might be some vectorization, though in vectors of size 2 only. For example, part of the output reads\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"...\n; ┌ @ fastmath.jl:338 within `cis_fast' @ fastmath.jl:322\n; │┌ @ tuple.jl:81 within `indexed_iterate' @ tuple.jl:0\n    %60 = getelementptr inbounds [2 x double], [2 x double]* %5, i64 0, i64 0\n    %61 = getelementptr inbounds [2 x double], [2 x double]* %5, i64 0, i64 1\n..."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"0b60f4e5-9b31-4242-9eaf-341d016e381f","type":"message","text":"I think that means LoopVectorization doesn't have a vectorized sincos or cis. There is always more to do","user":"U0179G7FG4F","ts":"1608943925.029300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7dv2n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think that means LoopVectorization doesn't have a vectorized sincos or cis. There is always more to do"}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD","reactions":[{"name":"+1","users":["U011PC32QDD"],"count":1}]},{"client_msg_id":"f4a1c0b5-18c5-4adf-b5d0-0be5df4fb0ea","type":"message","text":"Any advice on a library that could be used for this? (e.g., Yeppp, though this seems outdated now)","user":"U011PC32QDD","ts":"1608947517.029800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FxX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Any advice on a library that could be used for this? (e.g., Yeppp, though this seems outdated now)"}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"1724f75c-e92f-41a3-a2fc-a6a4095cfa04","type":"message","text":"<@UAUPJLBQX> Has been actively working on LoopVectorization over in Zulip.","user":"USU9FRPEU","ts":"1608956637.030600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ehy7O","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UAUPJLBQX"},{"type":"text","text":" Has been actively working on LoopVectorization over in Zulip."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD","reactions":[{"name":"+1","users":["UAUPJLBQX"],"count":1}]},{"client_msg_id":"a39b53cf-7840-4fda-9c57-81f65ac7eaca","type":"message","text":"LoopVectorization has vectorized sincos","user":"UAUPJLBQX","ts":"1608958028.030800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oOwJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"LoopVectorization has vectorized sincos"}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"2742d602-edc9-4c55-b988-b7f145995f2e","type":"message","text":"However, it doesn't do complex numbers (yet -- there is always more to do :wink:).","user":"UAUPJLBQX","ts":"1608958037.031000","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1608959818.000000"},"blocks":[{"type":"rich_text","block_id":"Sd9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"However, it doesn't do complex numbers (yet -- there is always more to do "},{"type":"emoji","name":"wink"},{"type":"text","text":")."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"d48196e6-3edb-431a-8bc1-650c5dc5ebff","type":"message","text":"I'd recommend using `StructArrays`, and then in the parts of your code using LoopVectorization, extract the `re` and `im` arrays","user":"UAUPJLBQX","ts":"1608958087.031200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xd=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd recommend using "},{"type":"text","text":"StructArrays","style":{"code":true}},{"type":"text","text":", and then in the parts of your code using LoopVectorization, extract the "},{"type":"text","text":"re","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"im","style":{"code":true}},{"type":"text","text":" arrays"}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"07c80dde-dd32-498a-baa1-1350a697adb9","type":"message","text":"<@U011PC32QDD>\n```using LoopVectorization, StructArrays, BenchmarkTools\n\nfunction Heisenberg!(ρₕ, ρ, ω, τ)\n    for i in eachindex(ρ, ρₕ, ω)\n        @inbounds ρₕ[i] = ρ[i] * cis(ω[i] * τ)\n    end\n    return nothing\nend\n\nfunction Heisenberg!(ρₕ::StructArray{&lt;:Complex}, ρ::StructArray{&lt;:Complex}, ω::StructArray{&lt;:Complex}, τ::Real)\n    @avx for i in eachindex(ρ, ρₕ, ω)\n        v = exp( -<http://ω.im[i]|xn--bya.im[i]> * τ )\n        s, c = sincos( ω.re[i] * τ )\n        cisre = v * c\n        cisim = v * s\n        ρreᵢ = ρ.re[i]\n        ρimᵢ = <http://ρ.im[i]|xn--2xa.im[i]>\n        ρ.re[i] = ρreᵢ * cisre - ρimᵢ * cisim\n        <http://ρ.im[i]|xn--2xa.im[i]> = ρreᵢ * cisim + ρimᵢ * cisre\n    end\n    return nothing\nend\n\n\nfor n ∈ (1,2,12)\n    @show n\n    dρ = ComplexF32.(rand(n,n))\n    ρ₀ = ComplexF32.(rand(n,n))\n    ω = ComplexF32.(rand(n,n))\n    τ = 1.0f0\n    @btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n    dρ_soa = StructArray(dρ);\n    ρ₀_soa = StructArray(ρ₀);\n    ω_soa = StructArray(ω);\n    @btime Heisenberg!($dρ_soa, $ρ₀_soa, $ω_soa, $τ)\n    @assert dρ ≈ dρ_soa\nend```","user":"UAUPJLBQX","ts":"1608959469.031400","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1608959636.000000"},"blocks":[{"type":"rich_text","block_id":"bXLLL","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U011PC32QDD"},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using LoopVectorization, StructArrays, BenchmarkTools\n\nfunction Heisenberg!(ρₕ, ρ, ω, τ)\n    for i in eachindex(ρ, ρₕ, ω)\n        @inbounds ρₕ[i] = ρ[i] * cis(ω[i] * τ)\n    end\n    return nothing\nend\n\nfunction Heisenberg!(ρₕ::StructArray{<:Complex}, ρ::StructArray{<:Complex}, ω::StructArray{<:Complex}, τ::Real)\n    @avx for i in eachindex(ρ, ρₕ, ω)\n        v = exp( -ω.im[i] * τ )\n        s, c = sincos( ω.re[i] * τ )\n        cisre = v * c\n        cisim = v * s\n        ρreᵢ = ρ.re[i]\n        ρimᵢ = ρ.im[i]\n        ρ.re[i] = ρreᵢ * cisre - ρimᵢ * cisim\n        ρ.im[i] = ρreᵢ * cisim + ρimᵢ * cisre\n    end\n    return nothing\nend\n\n\nfor n ∈ (1,2,12)\n    @show n\n    dρ = ComplexF32.(rand(n,n))\n    ρ₀ = ComplexF32.(rand(n,n))\n    ω = ComplexF32.(rand(n,n))\n    τ = 1.0f0\n    @btime Heisenberg!($dρ, $ρ₀, $ω, $τ)\n    dρ_soa = StructArray(dρ);\n    ρ₀_soa = StructArray(ρ₀);\n    ω_soa = StructArray(ω);\n    @btime Heisenberg!($dρ_soa, $ρ₀_soa, $ω_soa, $τ)\n    @assert dρ ≈ dρ_soa\nend"}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"b4b58349-8b51-468b-9391-624055ed1e12","type":"message","text":"```n = 1\n  13.112 ns (0 allocations: 0 bytes)\n  17.857 ns (0 allocations: 0 bytes)\nn = 2\n  43.064 ns (0 allocations: 0 bytes)\n  26.757 ns (0 allocations: 0 bytes)\nn = 12\n  1.357 μs (0 allocations: 0 bytes)\n  112.410 ns (0 allocations: 0 bytes)\nn = 24\n  6.040 μs (0 allocations: 0 bytes)\n  396.330 ns (0 allocations: 0 bytes)\n\njulia&gt; versioninfo()\nJulia Version 1.7.0-DEV.153\nCommit 43f05ea984* (2020-12-24 14:32 UTC)\nPlatform Info:\n  OS: Linux (x86_64-generic-linux)\n  CPU: Intel(R) Core(TM) i9-10980XE CPU @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.0 (ORCJIT, cascadelake)```\nFirst times are the old version, second times are the `LoopVectorization` + `StructArrays` times.","user":"UAUPJLBQX","ts":"1608959596.031600","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1608960457.000000"},"blocks":[{"type":"rich_text","block_id":"akbbK","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"n = 1\n  13.112 ns (0 allocations: 0 bytes)\n  17.857 ns (0 allocations: 0 bytes)\nn = 2\n  43.064 ns (0 allocations: 0 bytes)\n  26.757 ns (0 allocations: 0 bytes)\nn = 12\n  1.357 μs (0 allocations: 0 bytes)\n  112.410 ns (0 allocations: 0 bytes)\nn = 24\n  6.040 μs (0 allocations: 0 bytes)\n  396.330 ns (0 allocations: 0 bytes)\n\njulia> versioninfo()\nJulia Version 1.7.0-DEV.153\nCommit 43f05ea984* (2020-12-24 14:32 UTC)\nPlatform Info:\n  OS: Linux (x86_64-generic-linux)\n  CPU: Intel(R) Core(TM) i9-10980XE CPU @ 3.00GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.0 (ORCJIT, cascadelake)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"First times are the old version, second times are the "},{"type":"text","text":"LoopVectorization","style":{"code":true}},{"type":"text","text":" + "},{"type":"text","text":"StructArrays","style":{"code":true}},{"type":"text","text":" times."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"c06479ac-bb38-450f-adb7-9d9d29960581","type":"message","text":"I don't read every slack comment, so please feel free to tag me or ask questions in the <https://github.com/chriselrod/LoopVectorization.jl/discussions|LoopVectorization discussions section on GitHub> if you have any LoopVectorization related problems or questions.","user":"UAUPJLBQX","ts":"1608959773.032100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=Zt/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't read every slack comment, so please feel free to tag me or ask questions in the "},{"type":"link","url":"https://github.com/chriselrod/LoopVectorization.jl/discussions","text":"LoopVectorization discussions section on GitHub"},{"type":"text","text":" if you have any LoopVectorization related problems or questions."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"e4f7fb0c-84aa-4435-85ac-a0607a06fb3e","type":"message","text":"Also, if you'd like to see SIMD through benchmarks:\n```julia&gt; for n ∈ (1,2,4,12,24)\n           @show n, n^2\n           dρ = ComplexF32.(rand(n,n))\n           ρ₀ = ComplexF32.(rand(n,n))\n           ω = ComplexF32.(rand(n,n))\n           τ = 1.0f0\n           t₁ = @belapsed Heisenberg!($dρ, $ρ₀, $ω, $τ)\n           @show 1e-9length(dρ) / t₁\n           dρ_soa = StructArray(dρ);\n           ρ₀_soa = StructArray(ρ₀);\n           ω_soa = StructArray(ω);\n           t₂ = @belapsed Heisenberg!($dρ_soa, $ρ₀_soa, $ω_soa, $τ)\n           @assert dρ ≈ dρ_soa\n           @show 1e-9length(dρ) / t₂\n       end\n(n, n ^ 2) = (1, 1)\n(1.0e-9 * length(dρ)) / t₁ = 0.06995163664400365\n(1.0e-9 * length(dρ)) / t₂ = 0.03813721732464546\n(n, n ^ 2) = (2, 4)\n(1.0e-9 * length(dρ)) / t₁ = 0.09299267330452753\n(1.0e-9 * length(dρ)) / t₂ = 0.15429346772630353\n(n, n ^ 2) = (4, 16)\n(1.0e-9 * length(dρ)) / t₁ = 0.09925005765728512\n(1.0e-9 * length(dρ)) / t₂ = 0.6319546337788001\n(n, n ^ 2) = (12, 144)\n(1.0e-9 * length(dρ)) / t₁ = 0.09579563597658329\n(1.0e-9 * length(dρ)) / t₂ = 1.2756767189384803\n(n, n ^ 2) = (24, 576)\n(1.0e-9 * length(dρ)) / t₁ = 0.09506519227595314\n(1.0e-9 * length(dρ)) / t₂ = 1.335990768908004```\nYou can see that the LoopVectorization version has about 4x the elements/nanosecond for `n^2 = 4` as for `n^2 = 1`, and `n^2 = 16` has another 4x vs `n^2 = 4` because this CPU has AVX512, meaning its SIMD vectors hold 16 elements each.\n\nLonger arrays give another 2x in performance thanks to some combination of more out of order execution and amortizing overhead.","user":"UAUPJLBQX","ts":"1608961045.032500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hCwYs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, if you'd like to see SIMD through benchmarks:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> for n ∈ (1,2,4,12,24)\n           @show n, n^2\n           dρ = ComplexF32.(rand(n,n))\n           ρ₀ = ComplexF32.(rand(n,n))\n           ω = ComplexF32.(rand(n,n))\n           τ = 1.0f0\n           t₁ = @belapsed Heisenberg!($dρ, $ρ₀, $ω, $τ)\n           @show 1e-9length(dρ) / t₁\n           dρ_soa = StructArray(dρ);\n           ρ₀_soa = StructArray(ρ₀);\n           ω_soa = StructArray(ω);\n           t₂ = @belapsed Heisenberg!($dρ_soa, $ρ₀_soa, $ω_soa, $τ)\n           @assert dρ ≈ dρ_soa\n           @show 1e-9length(dρ) / t₂\n       end\n(n, n ^ 2) = (1, 1)\n(1.0e-9 * length(dρ)) / t₁ = 0.06995163664400365\n(1.0e-9 * length(dρ)) / t₂ = 0.03813721732464546\n(n, n ^ 2) = (2, 4)\n(1.0e-9 * length(dρ)) / t₁ = 0.09299267330452753\n(1.0e-9 * length(dρ)) / t₂ = 0.15429346772630353\n(n, n ^ 2) = (4, 16)\n(1.0e-9 * length(dρ)) / t₁ = 0.09925005765728512\n(1.0e-9 * length(dρ)) / t₂ = 0.6319546337788001\n(n, n ^ 2) = (12, 144)\n(1.0e-9 * length(dρ)) / t₁ = 0.09579563597658329\n(1.0e-9 * length(dρ)) / t₂ = 1.2756767189384803\n(n, n ^ 2) = (24, 576)\n(1.0e-9 * length(dρ)) / t₁ = 0.09506519227595314\n(1.0e-9 * length(dρ)) / t₂ = 1.335990768908004"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"You can see that the LoopVectorization version has about 4x the elements/nanosecond for "},{"type":"text","text":"n^2 = 4","style":{"code":true}},{"type":"text","text":" as for "},{"type":"text","text":"n^2 = 1","style":{"code":true}},{"type":"text","text":", and "},{"type":"text","text":"n^2 = 16","style":{"code":true}},{"type":"text","text":" has another 4x vs "},{"type":"text","text":"n^2 = 4","style":{"code":true}},{"type":"text","text":" because this CPU has AVX512, meaning its SIMD vectors hold 16 elements each.\n\nLonger arrays give another 2x in performance thanks to some combination of more out of order execution and amortizing overhead."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD"},{"client_msg_id":"f4ac2a2f-7d6d-4816-8c10-5ed09fd3b961","type":"message","text":"Thanks, Chris. This is super helpful, both for my present problem but also more generally for getting a sense of vectorizing my Julia code. So thanks so much again for taking the time, and I'll make sure to reach out in the GitHub discussions if I have any more questions.","user":"U011PC32QDD","ts":"1608961538.032700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Iy+h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, Chris. This is super helpful, both for my present problem but also more generally for getting a sense of vectorizing my Julia code. So thanks so much again for taking the time, and I'll make sure to reach out in the GitHub discussions if I have any more questions."}]}]}],"thread_ts":"1608939233.028800","parent_user_id":"U011PC32QDD","reactions":[{"name":"+1","users":["UAUPJLBQX"],"count":1}]}]