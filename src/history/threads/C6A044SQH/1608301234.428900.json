[{"client_msg_id":"3d68c933-5e5a-4969-baaa-811788d289c0","type":"message","text":"I have lots of different mutable structs that contain other types to various levels of nestedness. E.g. `Foo1.bar0 `and `Foo2.bar1.baz0`  where the \"leaf\" structs contain `isbitstype`s and don't conform to any particular Abstract type hierarchy. What's the best way of walking an arbitrary struct to get to fields that are known concrete types (probably all `Integers` or `AbstractFloat`s), and then mutating those values?","user":"UDSG73JTH","ts":"1608301234.428900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/jWx6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have lots of different mutable structs that contain other types to various levels of nestedness. E.g. `Foo1.bar0 `and "},{"type":"text","text":"Foo2.bar1.baz0","style":{"code":true}},{"type":"text","text":"  where the \"leaf\" structs contain `isbitstype`s and don't conform to any particular Abstract type hierarchy. What's the best way of walking an arbitrary struct to get to fields that are known concrete types (probably all "},{"type":"text","text":"Integers","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"AbstractFloat","style":{"code":true}},{"type":"text","text":"s), and then mutating those values?"}]}]}],"thread_ts":"1608301234.428900","reply_count":12,"reply_users_count":3,"latest_reply":"1608309288.443300","reply_users":["U01GRS159T8","UDSG73JTH","URN898S15"],"subscribed":false},{"client_msg_id":"f1794e4a-5d80-48d2-9d1a-903ecfd7aa68","type":"message","text":"This isn't exactly what you want but I wrote this function to check if a type and all of its fields, recursively, are concrete","user":"U01GRS159T8","ts":"1608306538.435000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EdsX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This isn't exactly what you want but I wrote this function to check if a type and all of its fields, recursively, are concrete"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"a5d86424-143f-4f45-812e-85637a6c8a2b","type":"message","text":"```function isconcretetype_recursive(::Type{T}) where T\n    !isconcretetype(T) &amp;&amp; return false\n    ft = fieldtypes(T)\n    isnothing(ft) &amp;&amp; return true\n    return all(isconcretetype_recursive, ft)\nend```","user":"U01GRS159T8","ts":"1608306551.435500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Okz","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function isconcretetype_recursive(::Type{T}) where T\n    !isconcretetype(T) && return false\n    ft = fieldtypes(T)\n    isnothing(ft) && return true\n    return all(isconcretetype_recursive, ft)\nend"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"d7a85a2a-2362-47be-b04c-f5786ae97473","type":"message","text":"you can do something similar with isbits","user":"U01GRS159T8","ts":"1608306562.436000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8SN2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you can do something similar with isbits"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"bdcfd249-3214-49be-9ab2-69e97c65d868","type":"message","text":"My (working) version is so much uglier than this and littered with `@eval` . cheers!","user":"UDSG73JTH","ts":"1608306856.436400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FNw5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My (working) version is so much uglier than this and littered with "},{"type":"text","text":"@eval","style":{"code":true}},{"type":"text","text":" . cheers!"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"d928410b-3d80-4355-bcb9-eda66a4ea9e8","type":"message","text":"I will still need to `@eval`  to get access to the fields, though?","user":"UDSG73JTH","ts":"1608307058.436600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5RBXf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I will still need to "},{"type":"text","text":"@eval","style":{"code":true}},{"type":"text","text":"  to get access to the fields, though?"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"2b596a7a-ee58-47ea-9a56-09a01587987d","type":"message","text":"you should be able to use setfield!","user":"U01GRS159T8","ts":"1608307092.436800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d6k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you should be able to use setfield!"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"c11fd0b8-2d11-4aa9-86fe-f8706d8fafd9","type":"message","text":"and fieldnames()","user":"U01GRS159T8","ts":"1608307111.437000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nIY=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and fieldnames()"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"f913b7a1-192b-435a-9658-6f98dbc19da1","type":"message","text":"```julia&gt; struct Foo; a::Int; b::Int; end; foo = Foo(1,2); map(x-&gt;getfield(foo,x),fieldnames(Foo))\n(1, 2)```","user":"U01GRS159T8","ts":"1608307209.437200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X6dy","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct Foo; a::Int; b::Int; end; foo = Foo(1,2); map(x->getfield(foo,x),fieldnames(Foo))\n(1, 2)"}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"type":"message","subtype":"thread_broadcast","text":"Flatten.jl is for this. `fatten(obj, Real)`","user":"URN898S15","ts":"1608307934.437400","thread_ts":"1608301234.428900","root":{"client_msg_id":"3d68c933-5e5a-4969-baaa-811788d289c0","type":"message","text":"I have lots of different mutable structs that contain other types to various levels of nestedness. E.g. `Foo1.bar0 `and `Foo2.bar1.baz0`  where the \"leaf\" structs contain `isbitstype`s and don't conform to any particular Abstract type hierarchy. What's the best way of walking an arbitrary struct to get to fields that are known concrete types (probably all `Integers` or `AbstractFloat`s), and then mutating those values?","user":"UDSG73JTH","ts":"1608301234.428900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/jWx6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have lots of different mutable structs that contain other types to various levels of nestedness. E.g. `Foo1.bar0 `and "},{"type":"text","text":"Foo2.bar1.baz0","style":{"code":true}},{"type":"text","text":"  where the \"leaf\" structs contain `isbitstype`s and don't conform to any particular Abstract type hierarchy. What's the best way of walking an arbitrary struct to get to fields that are known concrete types (probably all "},{"type":"text","text":"Integers","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"AbstractFloat","style":{"code":true}},{"type":"text","text":"s), and then mutating those values?"}]}]}],"thread_ts":"1608301234.428900","reply_count":12,"reply_users_count":3,"latest_reply":"1608309288.443300","reply_users":["U01GRS159T8","UDSG73JTH","URN898S15"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"uVrW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Flatten.jl is for this. "},{"type":"text","text":"fatten(obj, Real)","style":{"code":true}}]}]}],"client_msg_id":"2fb294f5-3f63-4cbb-89eb-681826dc76a0"},{"client_msg_id":"6afc363a-ac59-4b8b-b498-a036be6369a1","type":"message","text":"You can use `modify(f, obj, Real)` to mutate.","user":"URN898S15","ts":"1608308191.437700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"943am","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can use "},{"type":"text","text":"modify(f, obj, Real)","style":{"code":true}},{"type":"text","text":" to mutate."}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"},{"client_msg_id":"30014b21-6e15-4499-833e-c77a6cd24903","type":"message","text":"Its also very fast, basically a compile time operation.","user":"URN898S15","ts":"1608308245.437900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ehl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Its also very fast, basically a compile time operation."}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"5302fc7d-4f8e-4072-95fa-e7471f844748","type":"message","text":"Excellent! I've got the tests passing with setfield! and getfield, but Flatten.jl looks more really good too. Thanks both.","user":"UDSG73JTH","ts":"1608309288.443300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7XQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Excellent! I've got the tests passing with setfield! and getfield, but Flatten.jl looks more really good too. Thanks both."}]}]}],"thread_ts":"1608301234.428900","parent_user_id":"UDSG73JTH"}]