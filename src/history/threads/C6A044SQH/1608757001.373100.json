[{"client_msg_id":"6d0912f4-faa6-45da-9d7d-34f15cc6acda","type":"message","text":"I don't get the reason why structs are immutable by default... the manual says that this has something to do with performance and that muatable structs are allocated on the heap. If I define a struct and incl. all data types and I want to have it mutable, why does it have to go to the heap then?","user":"URPFQPSEQ","ts":"1608757001.373100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"y+vZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't get the reason why structs are immutable by default... the manual says that this has something to do with performance and that muatable structs are allocated on the heap. If I define a struct and incl. all data types and I want to have it mutable, why does it have to go to the heap then?"}]}]}],"thread_ts":"1608757001.373100","reply_count":6,"reply_users_count":4,"latest_reply":"1608761877.412800","reply_users":["U019K6Q9N15","URPFQPSEQ","U0179G7FG4F","U012XER8K4M"],"subscribed":false},{"client_msg_id":"a8ef704d-abfc-4279-895a-ae99819b8453","type":"message","text":"IIRC If the data on your struct is mutable, your struct stores _immutable references_ to those data, which actually live in the heap. You can then pass that struct around real quick. Accessing the data involves dereferencing those data.","user":"U019K6Q9N15","ts":"1608758071.381700","team":"T68168MUP","edited":{"user":"U019K6Q9N15","ts":"1608758120.000000"},"blocks":[{"type":"rich_text","block_id":"czXD5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"IIRC If the data on your struct is mutable, your struct stores "},{"type":"text","text":"immutable references ","style":{"italic":true}},{"type":"text","text":"to those data, which actually live in the heap. You can then pass that struct around real quick. Accessing the data involves dereferencing those data."}]}]}],"thread_ts":"1608757001.373100","parent_user_id":"URPFQPSEQ"},{"client_msg_id":"29e9185f-596b-44ad-bec8-797ecace9659","type":"message","text":"If I try this toy example:\n```struct MyStruct\n    a::Int64\n    b::Int64\nend\n\nmutable struct m_MyStruct\n    a::Int64\n    b::Int64 \nend \n\nfunction f1(a,b)\n    sVar=MyStruct(a,b)\n    sVar.a+sVar.b\nend\n\nfunction f2(a,b)\n    sVar=m_MyStruct(0,0)\n    sVar.a=a\n    sVar.b=b\n    sVar.a+sVar.b\nend```\nthen use benchmarking:\n```julia&gt; @btime f1(3,5)\n  0.001 ns (0 allocations: 0 bytes)\n8\n\njulia&gt; @btime f2(3,5)\n  1.099 ns (0 allocations: 0 bytes)\n8```\nso in both cases 0 (heap) allocations.. I would expect to have heap allocation within f2.","user":"URPFQPSEQ","ts":"1608758390.382900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Rmn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I try this toy example:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct MyStruct\n    a::Int64\n    b::Int64\nend\n\nmutable struct m_MyStruct\n    a::Int64\n    b::Int64 \nend \n\nfunction f1(a,b)\n    sVar=MyStruct(a,b)\n    sVar.a+sVar.b\nend\n\nfunction f2(a,b)\n    sVar=m_MyStruct(0,0)\n    sVar.a=a\n    sVar.b=b\n    sVar.a+sVar.b\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"then use benchmarking:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime f1(3,5)\n  0.001 ns (0 allocations: 0 bytes)\n8\n\njulia> @btime f2(3,5)\n  1.099 ns (0 allocations: 0 bytes)\n8"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"so in both cases 0 (heap) allocations.. I would expect to have heap allocation within f2."}]}]}],"thread_ts":"1608757001.373100","parent_user_id":"URPFQPSEQ"},{"client_msg_id":"f2101a96-ba36-4b07-93b9-552a06539be3","type":"message","text":"If I define a struct variable within a C function, is it then not on the stack and I can still modify it?... I don't get why this is different in Julia","user":"URPFQPSEQ","ts":"1608758614.383900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EKk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I define a struct variable within a C function, is it then not on the stack and I can still modify it?... I don't get why this is different in Julia"}]}]}],"thread_ts":"1608757001.373100","parent_user_id":"URPFQPSEQ"},{"client_msg_id":"454d3276-0ea9-4d91-bf02-629684057020","type":"message","text":"The difference is that in C, when you pass a struct to a function, you copy it. In Julia, a mutable struct will be \"passed by sharing\"","user":"U0179G7FG4F","ts":"1608759005.386100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UX0CX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The difference is that in C, when you pass a struct to a function, you copy it. In Julia, a mutable struct will be \"passed by sharing\""}]}]}],"thread_ts":"1608757001.373100","parent_user_id":"URPFQPSEQ"},{"client_msg_id":"35955e73-6de8-4d08-9221-b7e3510f4eaa","type":"message","text":"basically C and Julia have very different ideas of what structs are, and make different choices in a lot of places to try to get good feeling performant code","user":"U0179G7FG4F","ts":"1608759201.388500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xNC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"basically C and Julia have very different ideas of what structs are, and make different choices in a lot of places to try to get good feeling performant code"}]}]}],"thread_ts":"1608757001.373100","parent_user_id":"URPFQPSEQ"},{"client_msg_id":"a62106ce-e841-4d99-b8d7-7ac152060711","type":"message","text":"<https://discourse.julialang.org/t/why-mutable-structs-are-allocated-on-the-heap/12992>","user":"U012XER8K4M","ts":"1608761877.412800","team":"T68168MUP","attachments":[{"service_name":"JuliaLang","title":"Why mutable structs are allocated on the heap?","title_link":"https://discourse.julialang.org/t/why-mutable-structs-are-allocated-on-the-heap/12992","text":"From <https://docs.julialang.org/en/latest/manual/types/#Mutable-Composite-Types-1>: In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. If I define: mutable struct MyT x::Int end and then use MyT inside a function, such as: function f(x::Int) q = MyT(x); q.x += 1 return q.x end I would expect q to be allocated on the stack, because it is a local variable that does not change type and MyT is isbits. But it is not: @btime f(1)...","fallback":"JuliaLang: Why mutable structs are allocated on the heap?","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","fields":[{"title":"Reading time","value":"6 mins :clock2:","short":true},{"title":"Likes","value":"50 :heart:","short":true}],"ts":1533650524,"from_url":"https://discourse.julialang.org/t/why-mutable-structs-are-allocated-on-the-heap/12992","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/why-mutable-structs-are-allocated-on-the-heap/12992"}],"blocks":[{"type":"rich_text","block_id":"fbz","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://discourse.julialang.org/t/why-mutable-structs-are-allocated-on-the-heap/12992"}]}]}],"thread_ts":"1608757001.373100","parent_user_id":"URPFQPSEQ"}]