[{"client_msg_id":"9878801f-0dda-4b55-9c39-bb6307c846ea","type":"message","text":"When dealing with composed composite types, e.g.\n```struct Point; x; y; z; end\n\nstruct Line; r1 :: Point; r2 :: Point; end```\nI just end up writing longer code by defining these \"accessor\" functions: `x(p :: Point) = p.x, r1(line :: Line) = line.r1`, and similarly for the others. I think defining those functions is something that could definitely be automated, like how Haskell deals with data types. Is there something similar in Julia? Defining nested accessors by something like  `r1_x(line :: Line) = (x ∘ r1)(line)` also ends up in longer code.","user":"U01G1P8A46S","ts":"1608729838.347100","team":"T68168MUP","edited":{"user":"U01G1P8A46S","ts":"1608729955.000000"},"blocks":[{"type":"rich_text","block_id":"WEQO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When dealing with composed composite types, e.g.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Point; x; y; z; end\n\nstruct Line; r1 :: Point; r2 :: Point; end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I just end up writing longer code by defining these \"accessor\" functions: "},{"type":"text","text":"x(p :: Point) = p.x, r1(line :: Line) = line.r1","style":{"code":true}},{"type":"text","text":", and similarly for the others. I think defining those functions is something that could definitely be automated, like how Haskell deals with data types. Is there something similar in Julia? Defining nested accessors by something like  "},{"type":"text","text":"r1_x(line :: Line) = (x ∘ r1)(line)","style":{"code":true}},{"type":"text","text":" also ends up in longer code."}]}]}],"thread_ts":"1608729838.347100","reply_count":6,"reply_users_count":5,"latest_reply":"1608746080.353800","reply_users":["U7HAYKY9X","U01G1P8A46S","U01DD7Z0D89","U019K6Q9N15","U6QGE7S86"],"subscribed":false},{"client_msg_id":"1f6abd0b-31d0-414f-841c-b5e013002472","type":"message","text":"Right. But do you really need these accessor functions? Internally, you could just use getproperty. Externally, I can't think of many situations where the data layout of types should be part of the API","user":"U7HAYKY9X","ts":"1608731445.347500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dLr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Right. But do you really need these accessor functions? Internally, you could just use getproperty. Externally, I can't think of many situations where the data layout of types should be part of the API"}]}]}],"thread_ts":"1608729838.347100","parent_user_id":"U01G1P8A46S"},{"client_msg_id":"57d73730-54eb-470e-9130-047c379199f9","type":"message","text":"I'm currently trying to write code that replicates the math in a  textbook almost verbatim for instructional purposes, so writing accessor methods is useful for a student reading the code and correlating it to the math. It's especially useful for broadcasting too","user":"U01G1P8A46S","ts":"1608733112.348000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zjA=M","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm currently trying to write code that replicates the math in a  textbook almost verbatim for instructional purposes, so writing accessor methods is useful for a student reading the code and correlating it to the math. It's especially useful for broadcasting too"}]}]}],"thread_ts":"1608729838.347100","parent_user_id":"U01G1P8A46S"},{"client_msg_id":"3f38009a-e45b-4285-82c3-9bad3108f8b7","type":"message","text":"e.g. `x.(arr_points)` vs. `[ point.x for point in arr_points ]`  or the equivalent `getproperty` variant.","user":"U01G1P8A46S","ts":"1608733153.348200","team":"T68168MUP","edited":{"user":"U01G1P8A46S","ts":"1608733193.000000"},"blocks":[{"type":"rich_text","block_id":"p7Ap","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"e.g. "},{"type":"text","text":"x.(arr_points)","style":{"code":true}},{"type":"text","text":" vs. "},{"type":"text","text":"[ point.x for point in arr_points ]","style":{"code":true}},{"type":"text","text":"  or the equivalent "},{"type":"text","text":"getproperty","style":{"code":true}},{"type":"text","text":" variant."}]}]}],"thread_ts":"1608729838.347100","parent_user_id":"U01G1P8A46S"},{"client_msg_id":"2111e2ed-016b-4daa-bdb6-62367371c05a","type":"message","text":"StructArrays is one possible solution to the broadcasting issue","user":"U01DD7Z0D89","ts":"1608734231.348500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zsy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"StructArrays is one possible solution to the broadcasting issue"}]}]}],"thread_ts":"1608729838.347100","parent_user_id":"U01G1P8A46S"},{"client_msg_id":"b7b965eb-c9ed-4afe-9ef0-88931ac23cdc","type":"message","text":"This is a job for a macro. Write a macro that automatically defines the accessors given code that defines the composite type.","user":"U019K6Q9N15","ts":"1608745090.349000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3E8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is a job for a macro. Write a macro that automatically defines the accessors given code that defines the composite type."}]}]}],"thread_ts":"1608729838.347100","parent_user_id":"U01G1P8A46S"},{"client_msg_id":"ce74d7cf-b2ca-4bbc-a546-364d2386d976","type":"message","text":"Fortunately, the `Lazy.jl: @forward` macro does exactly that.","user":"U6QGE7S86","ts":"1608746080.353800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tx4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fortunately, the `Lazy.jl: @forward` macro does exactly that."}]}]}],"thread_ts":"1608729838.347100","parent_user_id":"U01G1P8A46S"}]