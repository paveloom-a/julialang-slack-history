[{"client_msg_id":"42cb0d6c-480e-4eff-9eba-9b4307b67b64","type":"message","text":"How do you specify parametric types of parametric types? I.e. I'm trying to do this:\n```abstract type Element{T} end\n\nstruct Line{T} &lt;: Element{T}\n  DOF::Vector{T} # the field stored quantity\nend\n\ntypeofdof(::Type{&lt;:Element{T}}) where {T} = T\n\nstruct Field{&lt;:Element{T}} where {T}\n  DOF::Vector{T}\nend```\nbut can't extract the type `T` from the type `Element` , I tried following the Parametric type doc page, but it doesn't really seem cover this nested type scenario... and I can't for the life of me figure it out. I'd like to be able to do something like `a = Field{Line{Float64}}()` eventually.","user":"U01EU0XGD1D","ts":"1609005530.061000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cBAE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How do you specify parametric types of parametric types? I.e. I'm trying to do this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"abstract type Element{T} end\n\nstruct Line{T} <: Element{T}\n  DOF::Vector{T} # the field stored quantity\nend\n\ntypeofdof(::Type{<:Element{T}}) where {T} = T\n\nstruct Field{<:Element{T}} where {T}\n  DOF::Vector{T}\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but can't extract the type "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" from the type "},{"type":"text","text":"Element","style":{"code":true}},{"type":"text","text":" , I tried following the Parametric type doc page, but it doesn't really seem cover this nested type scenario... and I can't for the life of me figure it out. I'd like to be able to do something like "},{"type":"text","text":"a = Field{Line{Float64}}()","style":{"code":true}},{"type":"text","text":" eventually."}]}]}],"thread_ts":"1609005530.061000","reply_count":13,"reply_users_count":2,"latest_reply":"1609007774.072300","reply_users":["U7HAYKY9X","U01EU0XGD1D"],"subscribed":false},{"client_msg_id":"9bce1715-00fe-4bbc-907a-b02799f66731","type":"message","text":"It seems to work for me:\n```julia&gt; abstract type Element{T} end\n       struct Line{T} &lt;: Element{T}\n         DOF::Vector{T} # the field stored quantity\n       end\n       typeofdof(::Type{&lt;:Element{T}}) where {T} = T\ntypeofdof (generic function with 1 method)\n\njulia&gt; el = Line{Int}([1,2,3])\nLine{Int64}([1, 2, 3])\n\njulia&gt; typeofdof(Line{Int})\nInt64```","user":"U7HAYKY9X","ts":"1609005798.062900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MQIh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems to work for me:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> abstract type Element{T} end\n       struct Line{T} <: Element{T}\n         DOF::Vector{T} # the field stored quantity\n       end\n       typeofdof(::Type{<:Element{T}}) where {T} = T\ntypeofdof (generic function with 1 method)\n\njulia> el = Line{Int}([1,2,3])\nLine{Int64}([1, 2, 3])\n\njulia> typeofdof(Line{Int})\nInt64"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"7925e3c1-d24d-4678-9366-f6ed93c90fd7","type":"message","text":"You should define `Field`  as\n```julia&gt; struct Field{E&lt;:Element}\n         DOF::Vector{E}\n       end```","user":"U7HAYKY9X","ts":"1609005894.064600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dTwP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You should define "},{"type":"text","text":"Field","style":{"code":true}},{"type":"text","text":"  as\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct Field{E<:Element}\n         DOF::Vector{E}\n       end"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"5ec3bf8d-5316-4031-b913-abc4b4b40c19","type":"message","text":"The vector is supposed to be of the type `T` , rather than `E`","user":"U01EU0XGD1D","ts":"1609005932.064800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9WoZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The vector is supposed to be of the type "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" , rather than "},{"type":"text","text":"E","style":{"code":true}}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"b64f15a9-2322-48e7-bc8b-910f938b57b9","type":"message","text":"the `typeofdof` function works. The idea is that I will create Elements which copy dofs from the field vector into their DOF vector","user":"U01EU0XGD1D","ts":"1609005966.065000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ie/k9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the "},{"type":"text","text":"typeofdof","style":{"code":true}},{"type":"text","text":" function works. The idea is that I will create Elements which copy dofs from the field vector into their DOF vector"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"8e5c7a60-8f49-45a4-a1d1-e84b441d0fcb","type":"message","text":"Aah. That's not possible at the moment. You have to make a type `Field{E&lt;:Element, T}` .","user":"U7HAYKY9X","ts":"1609005969.065300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A1L3a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Aah. That's not possible at the moment. You have to make a type "},{"type":"text","text":"Field{E<:Element, T}","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"a78a6b75-837e-45ef-9582-e04eb53d9d99","type":"message","text":"Is it possible to assert that the T in `E` matches the `T` in `Field`?","user":"U01EU0XGD1D","ts":"1609005995.065800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+Do","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it possible to assert that the T in "},{"type":"text","text":"E","style":{"code":true}},{"type":"text","text":" matches the "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" in "},{"type":"text","text":"Field","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"86675b36-0e57-4b94-a9ee-4da3eac3b64c","type":"message","text":"You can enforce that in the inner constructor","user":"U7HAYKY9X","ts":"1609006067.066000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Bi0jQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can enforce that in the inner constructor"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"1546f6dc-5f75-498d-b207-de84621495d9","type":"message","text":"Out of interest, you say its not possible at the moment, is there some plan to make it possible? It's the kind of nice templating trick that is pretty handy in C++ for enforcing code correctness","user":"U01EU0XGD1D","ts":"1609006804.068100","team":"T68168MUP","edited":{"user":"U01EU0XGD1D","ts":"1609006812.000000"},"blocks":[{"type":"rich_text","block_id":"Kwd2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Out of interest, you say its not possible at the moment, is there some plan to make it possible? It's the kind of nice templating trick that is pretty handy in C++ for enforcing code correctness"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"448dfd92-b439-4813-a104-d318f7b8bffa","type":"message","text":"It's mentioned in this issue: <https://github.com/JuliaLang/julia/issues/36377>\nThere is no plan that I know of, it just seems to me like something that Julia ought to fix some day. Having said that, if you enforce it in the inner constructor it will still enforce code correctness at zero runtime cost, so it's really more an issue of having boilerplate code and redundant type params. More of an aethetic issue","user":"U7HAYKY9X","ts":"1609006943.068400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Pn2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's mentioned in this issue: "},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/36377"},{"type":"text","text":"\nThere is no plan that I know of, it just seems to me like something that Julia ought to fix some day. Having said that, if you enforce it in the inner constructor it will still enforce code correctness at zero runtime cost, so it's really more an issue of having boilerplate code and redundant type params. More of an aethetic issue"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"4a495ef1-821a-474f-9942-198e4293d9f9","type":"message","text":"So something along the lines of\n```struct Field{E &lt;: Element, T}\n  DOF::Vector{T}\n  function Field(DOF)\n    @assert typeofdof(E) == eltype(DOF) \"Element DOF type must match field DOF\"\n  end\nend```","user":"U01EU0XGD1D","ts":"1609007397.071000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hZ=lj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So something along the lines of\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Field{E <: Element, T}\n  DOF::Vector{T}\n  function Field(DOF)\n    @assert typeofdof(E) == eltype(DOF) \"Element DOF type must match field DOF\"\n  end\nend"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"1e421933-145b-47e9-ac32-71d08ca7ee66","type":"message","text":"You would need to also actually construct the type in the inner constructor with `new` :)","user":"U7HAYKY9X","ts":"1609007524.071300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d1m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You would need to also actually construct the type in the inner constructor with "},{"type":"text","text":"new","style":{"code":true}},{"type":"text","text":" :)"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"bff8b9e5-26ed-4e09-9e57-f94ea205d52c","type":"message","text":"Haha, I forgot. Interestingly, was just thinking about this alternative, would this achieve the desired effect?\n```struct Field{E&lt;:Element, T}\n  DOF::Vector{T}\n  function Field(DOF::Vector{T}) where {T}\n    new{E,T}(DOF)\n  end\nend```","user":"U01EU0XGD1D","ts":"1609007711.071900","team":"T68168MUP","edited":{"user":"U01EU0XGD1D","ts":"1609007728.000000"},"blocks":[{"type":"rich_text","block_id":"OEK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Haha, I forgot. Interestingly, was just thinking about this alternative, would this achieve the desired effect?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Field{E<:Element, T}\n  DOF::Vector{T}\n  function Field(DOF::Vector{T}) where {T}\n    new{E,T}(DOF)\n  end\nend"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"ba79494e-5f01-4e70-955e-5c0284d7bd12","type":"message","text":"Like this, I think\n```struct Field{E &lt;: Element, T}\n           DOF::Vector{T}\n           function Field{E,T}(DOF) where {E,T}\n               @assert typeofdof(E) == eltype(DOF) \"Element DOF type must match field DOF\"\n               new{E,T}(DOF)\n           end\n       end```","user":"U7HAYKY9X","ts":"1609007774.072300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wrv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like this, I think\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Field{E <: Element, T}\n           DOF::Vector{T}\n           function Field{E,T}(DOF) where {E,T}\n               @assert typeofdof(E) == eltype(DOF) \"Element DOF type must match field DOF\"\n               new{E,T}(DOF)\n           end\n       end"}]}]}],"thread_ts":"1609005530.061000","parent_user_id":"U01EU0XGD1D"}]