[{"client_msg_id":"d752fd31-b647-4e2c-bbcd-b46583e9a7e6","type":"message","text":"Given a polynomial f I can obtain the expression to compute a Jacobian-vector-product (forward mode) by doing\n\n```julia&gt; @var x y ẋ ẏ\n(x, y, ẋ, ẏ)\n\njulia&gt; f = x + x * y\nx + x*y\n\njulia&gt; @var ε\n(ε,)\n\njulia&gt; differentiate(f([x,y] =&gt; [x,y] + ε * [ẋ, ẏ]), ε)(ε =&gt; 0)\nẋ + x*ẏ + y*ẋ```\n(In this case this is the same result as doing the naive symbolic computation, but in general this is the same as doing forward mode when additionally performing a common subexpression elimination).\n\nQuestion: Is there a similar way to obtain an expression for the reverse mode?","user":"U7KA5J01Y","ts":"1608026643.195500","team":"T68168MUP","edited":{"user":"U7KA5J01Y","ts":"1608040133.000000"},"blocks":[{"type":"rich_text","block_id":"Lfkc0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Given a polynomial f I can obtain the expression to compute a Jacobian-vector-product (forward mode) by doing\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @var x y ẋ ẏ\n(x, y, ẋ, ẏ)\n\njulia> f = x + x * y\nx + x*y\n\njulia> @var ε\n(ε,)\n\njulia> differentiate(f([x,y] => [x,y] + ε * [ẋ, ẏ]), ε)(ε => 0)\nẋ + x*ẏ + y*ẋ"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n(In this case this is the same result as doing the naive symbolic computation, but in general this is the same as doing forward mode when additionally performing a common subexpression elimination).\n\nQuestion: Is there a similar way to obtain an expression for the reverse mode?"}]}]}],"thread_ts":"1608026643.195500","reply_count":4,"reply_users_count":3,"latest_reply":"1608047716.198600","reply_users":["U67G3QRJM","U7KA5J01Y","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"b1728233-9c9b-4509-9d87-50584d7f3f57","type":"message","text":"That is very neat - which package is that?","user":"U67G3QRJM","ts":"1608040058.195900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PVQPI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is very neat - which package is that?"}]}]}],"thread_ts":"1608026643.195500","parent_user_id":"U7KA5J01Y"},{"client_msg_id":"bcf363d7-512f-431e-a24d-58f4f6cc5ea0","type":"message","text":"Can you give an example with common subexpression elimination?","user":"U67G3QRJM","ts":"1608040083.196100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zlz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can you give an example with common subexpression elimination?"}]}]}],"thread_ts":"1608026643.195500","parent_user_id":"U7KA5J01Y"},{"client_msg_id":"65B9ECE4-E42C-46A9-9E01-73B9C846275E","type":"message","text":"That’s the symbolic modeling language in HomotopyContinution. It uses under the hood symengine (but the C++ library not the Julia binding) for the symbolic computations. ","user":"U7KA5J01Y","ts":"1608047482.198300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bH0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s the symbolic modeling language in HomotopyContinution. It uses under the hood symengine (but the C++ library not the Julia binding) for the symbolic computations. "}]}]}],"thread_ts":"1608026643.195500","parent_user_id":"U7KA5J01Y","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"09b6f22c-996b-45fa-99be-0496aadf025d","type":"message","text":"Can’t you almost re-use this? `differentiate(f([x,y] =&gt; [x,y] + ε * [1,0]), ε)(ε =&gt; 0)` ought to be the gradient for x alone, and similarly ε * [0,1] for y alone. (Have never used this package, just guessing from what you wrote.)","user":"UD0NS8PDF","ts":"1608047716.198600","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1608047742.000000"},"blocks":[{"type":"rich_text","block_id":"MW=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can’t you almost re-use this? "},{"type":"text","text":"differentiate(f([x,y] => [x,y] + ε * [1,0]), ε)(ε => 0)","style":{"code":true}},{"type":"text","text":" ought to be the gradient for x alone, and similarly ε * [0,1] for y alone. (Have never used this package, just guessing from what you wrote.)"}]}]}],"thread_ts":"1608026643.195500","parent_user_id":"U7KA5J01Y"}]