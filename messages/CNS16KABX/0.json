{"cursor": 0, "messages": [{"type":"message","subtype":"channel_join","ts":"1612326840.000200","user":"U01HK5WRVJT","text":"<@U01HK5WRVJT> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1612911034.000400","user":"U01MRRU542G","text":"<@U01MRRU542G> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1613001618.000600","user":"U01KXPUPHL2","text":"<@U01KXPUPHL2> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1615785808.000200","user":"U01N7F3RC76","text":"<@U01N7F3RC76> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1615867757.000200","user":"ULWFF2Z8U","text":"<@ULWFF2Z8U> has joined the channel"},{"type":"message","subtype":"bot_message","text":"Hello! I am trying to use a `LazySum` of `LazyTensor` operators called `op`. I can execute `op * ket` successfully, but not `mul!(out_ket, op, ket)`. With the latter I get a method mismatch error. I would like to do the latter for benchmarking.  I see QuantumOptics calls `QuantumOpticsBase.mul!()` internally (is QuantumOpticsBase not overloading `Base.mul!`?), but this doesn't work for me either. Should this be working?","ts":"1615937921.000300","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Hello! I am trying to use a `LazySum` of `LazyTensor` operators called `op`. I can execute `op * ket` successfully, but not `mul!(out_ket, op, ket)`. With the latter I get a method mismatch error. I would like to do the latter for benchmarking.  I see QuantumOptics calls `QuantumOpticsBase.mul!()` internally (is QuantumOpticsBase not overloading `Base.mul!`?), but this doesn't work for me either. Should this be working?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"On a related matter, how careful are the `LazySum` and `LazyTensor` implementations of `mul!()` or `gemm!()` with memory allocation?","ts":"1615938042.000400","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"On a related matter, how careful are the `LazySum` and `LazyTensor` implementations of `mul!()` or `gemm!()` with memory allocation?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"PS: Thanks to the devs of QuantumOptics. It's very cool!","ts":"1615938091.000500","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"PS: Thanks to the devs of QuantumOptics. It's very cool!","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted That should work, so it might be a bug. Can you share some code that reproduces the error?","ts":"1615969654.000100","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@amilsted That should work, so it might be a bug. Can you share some code that reproduces the error?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"It overloads `LinearAlgebra.mul!` so calling that won't make a difference","ts":"1615969697.000200","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"It overloads `LinearAlgebra.mul!` so calling that won't make a difference","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"The memory allocations should be small, but probably not zero","ts":"1615969748.000300","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"The memory allocations should be small, but probably not zero","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"Hm I can't reproduce that error","ts":"1615970480.000400","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Hm I can't reproduce that error","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"I tried on a simple example and `mul!(out, op, state)` works for me when op is a `LazySum` of two `LazyTensor`s","ts":"1615970528.000500","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"I tried on a simple example and `mul!(out, op, state)` works for me when op is a `LazySum` of two `LazyTensor`s","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted can you share your code please?","ts":"1615970554.000600","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@amilsted can you share your code please?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@david-pl Thanks for getting back to me. My issue seems more fundamental than I thought. Even this fails for me:","ts":"1616005360.000700","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@david-pl Thanks for getting back to me. My issue seems more fundamental than I thought. Even this fails for me:","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"b = SpinBasis(1//2) psi0 = Ket(b, [1.0, 0.0]) out = copy(psi0) @show sigmax(b) * psi0 mul!(out, sigmax(b), psi0)","ts":"1616005371.000800","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"b = SpinBasis(1//2)\npsi0 = Ket(b, [1.0, 0.0])\nout = copy(psi0)\n@show sigmax(b) * psi0\nmul!(out, sigmax(b), psi0)","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"Returns: ``` sigmax(b) * psi0 = Ket(dim=2)   basis: Spin(1/2)  0.0 + 0.0im  1.0 + 0.0im  MethodError: no method matching mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::Bool, ::Bool) Closest candidates are:   mul!(::Any, ::Any, ::Any) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:207   mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476   mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UnitUpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476   ...  Stacktrace:  [1] mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:208  [2] top-level scope at In[14]:5  [3] include_string(::Function, ::Module, ::String, ::String) at ./loading.jl:1091 ```","ts":"1616005482.000900","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Returns:\n```\nsigmax(b) * psi0 = Ket(dim=2)\n  basis: Spin(1/2)\n 0.0 + 0.0im\n 1.0 + 0.0im\n\nMethodError: no method matching mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::Bool, ::Bool)\nClosest candidates are:\n  mul!(::Any, ::Any, ::Any) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:207\n  mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476\n  mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UnitUpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476\n  ...\n\nStacktrace:\n [1] mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:208\n [2] top-level scope at In[14]:5\n [3] include_string(::Function, ::Module, ::String, ::String) at ./loading.jl:1091\n```","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"This is with Julia release 1.5.3 and QuantumOptics.jl v0.7.3, QuantumOpticsBase.jl v0.1.5.","ts":"1616005680.001000","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"This is with Julia release 1.5.3 and QuantumOptics.jl v0.7.3, QuantumOpticsBase.jl v0.1.5.","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@david-pl Thanks for getting back to me. It turns out I was using v0.7.3 of QuantumOptics for some reason. This works properly in the current version!","ts":"1616006273.001100","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@david-pl Thanks for getting back to me. It turns out I was using v0.7.3 of QuantumOptics for some reason. This works properly in the current version!","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted Good to know!","ts":"1616059646.001200","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@amilsted Good to know!","verbatim":false}}]},{"client_msg_id":"f4c8e7a9-7b51-4044-9a63-356da3e9021e","type":"message","text":"I pasted this question in the machine-learning channel, but I thought it might make sense to ask for thoughts and feedback here too.\n\nThis question is more \"conventional machine learning applied to quantum optics\" related.  \n\nI've been investigating the possibility of using ML to accelerate quantum optics simulations in cases where the quantum related math is computationally expensive.\n\nI think I've come to the conclusion that that since quantum state transformations are performed using unitary operators, linear algebra, it's very unlikely that any ML solution will be faster than a physics first principles quantum solution.\n\nDoes anyone disagree or have a counter example?\n\nThank you for any thoughts/feedback.","user":"U0158N77PFT","ts":"1616536065.003100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MG5GO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I pasted this question in the machine-learning channel, but I thought it might make sense to ask for thoughts and feedback here too.\n\nThis question is more \"conventional machine learning applied to quantum optics\" related.  \n\nI've been investigating the possibility of using ML to accelerate quantum optics simulations in cases where the quantum related math is computationally expensive.\n\nI think I've come to the conclusion that that since quantum state transformations are performed using unitary operators, linear algebra, it's very unlikely that any ML solution will be faster than a physics first principles quantum solution.\n\nDoes anyone disagree or have a counter example?\n\nThank you for any thoughts/feedback."}]}]}]}]}