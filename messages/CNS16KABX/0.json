{"cursor": 0, "messages": [{"type":"message","subtype":"channel_join","ts":"1612326840.000200","user":"U01HK5WRVJT","text":"<@U01HK5WRVJT> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1612911034.000400","user":"U01MRRU542G","text":"<@U01MRRU542G> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1613001618.000600","user":"U01KXPUPHL2","text":"<@U01KXPUPHL2> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1615785808.000200","user":"U01N7F3RC76","text":"<@U01N7F3RC76> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1615867757.000200","user":"ULWFF2Z8U","text":"<@ULWFF2Z8U> has joined the channel"},{"type":"message","subtype":"bot_message","text":"Hello! I am trying to use a `LazySum` of `LazyTensor` operators called `op`. I can execute `op * ket` successfully, but not `mul!(out_ket, op, ket)`. With the latter I get a method mismatch error. I would like to do the latter for benchmarking.  I see QuantumOptics calls `QuantumOpticsBase.mul!()` internally (is QuantumOpticsBase not overloading `Base.mul!`?), but this doesn't work for me either. Should this be working?","ts":"1615937921.000300","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Hello! I am trying to use a `LazySum` of `LazyTensor` operators called `op`. I can execute `op * ket` successfully, but not `mul!(out_ket, op, ket)`. With the latter I get a method mismatch error. I would like to do the latter for benchmarking.  I see QuantumOptics calls `QuantumOpticsBase.mul!()` internally (is QuantumOpticsBase not overloading `Base.mul!`?), but this doesn't work for me either. Should this be working?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"On a related matter, how careful are the `LazySum` and `LazyTensor` implementations of `mul!()` or `gemm!()` with memory allocation?","ts":"1615938042.000400","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"On a related matter, how careful are the `LazySum` and `LazyTensor` implementations of `mul!()` or `gemm!()` with memory allocation?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"PS: Thanks to the devs of QuantumOptics. It's very cool!","ts":"1615938091.000500","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"PS: Thanks to the devs of QuantumOptics. It's very cool!","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted That should work, so it might be a bug. Can you share some code that reproduces the error?","ts":"1615969654.000100","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@amilsted That should work, so it might be a bug. Can you share some code that reproduces the error?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"It overloads `LinearAlgebra.mul!` so calling that won't make a difference","ts":"1615969697.000200","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"It overloads `LinearAlgebra.mul!` so calling that won't make a difference","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"The memory allocations should be small, but probably not zero","ts":"1615969748.000300","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"The memory allocations should be small, but probably not zero","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"Hm I can't reproduce that error","ts":"1615970480.000400","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Hm I can't reproduce that error","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"I tried on a simple example and `mul!(out, op, state)` works for me when op is a `LazySum` of two `LazyTensor`s","ts":"1615970528.000500","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"I tried on a simple example and `mul!(out, op, state)` works for me when op is a `LazySum` of two `LazyTensor`s","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted can you share your code please?","ts":"1615970554.000600","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@amilsted can you share your code please?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@david-pl Thanks for getting back to me. My issue seems more fundamental than I thought. Even this fails for me:","ts":"1616005360.000700","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@david-pl Thanks for getting back to me. My issue seems more fundamental than I thought. Even this fails for me:","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"b = SpinBasis(1//2) psi0 = Ket(b, [1.0, 0.0]) out = copy(psi0) @show sigmax(b) * psi0 mul!(out, sigmax(b), psi0)","ts":"1616005371.000800","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"b = SpinBasis(1//2)\npsi0 = Ket(b, [1.0, 0.0])\nout = copy(psi0)\n@show sigmax(b) * psi0\nmul!(out, sigmax(b), psi0)","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"Returns: ``` sigmax(b) * psi0 = Ket(dim=2)   basis: Spin(1/2)  0.0 + 0.0im  1.0 + 0.0im  MethodError: no method matching mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::Bool, ::Bool) Closest candidates are:   mul!(::Any, ::Any, ::Any) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:207   mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476   mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UnitUpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476   ...  Stacktrace:  [1] mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:208  [2] top-level scope at In[14]:5  [3] include_string(::Function, ::Module, ::String, ::String) at ./loading.jl:1091 ```","ts":"1616005482.000900","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Returns:\n```\nsigmax(b) * psi0 = Ket(dim=2)\n  basis: Spin(1/2)\n 0.0 + 0.0im\n 1.0 + 0.0im\n\nMethodError: no method matching mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::Bool, ::Bool)\nClosest candidates are:\n  mul!(::Any, ::Any, ::Any) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:207\n  mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476\n  mul!(!Matched::UpperTriangular, !Matched::Number, !Matched::UnitUpperTriangular, ::Number, ::Number) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:476\n  ...\n\nStacktrace:\n [1] mul!(::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}, ::SparseOperator{SpinBasis{1//2,Int64},SpinBasis{1//2,Int64},SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}, ::Ket{SpinBasis{1//2,Int64},Array{Complex{Float64},1}}) at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:208\n [2] top-level scope at In[14]:5\n [3] include_string(::Function, ::Module, ::String, ::String) at ./loading.jl:1091\n```","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"This is with Julia release 1.5.3 and QuantumOptics.jl v0.7.3, QuantumOpticsBase.jl v0.1.5.","ts":"1616005680.001000","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"This is with Julia release 1.5.3 and QuantumOptics.jl v0.7.3, QuantumOpticsBase.jl v0.1.5.","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@david-pl Thanks for getting back to me. It turns out I was using v0.7.3 of QuantumOptics for some reason. This works properly in the current version!","ts":"1616006273.001100","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@david-pl Thanks for getting back to me. It turns out I was using v0.7.3 of QuantumOptics for some reason. This works properly in the current version!","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted Good to know!","ts":"1616059646.001200","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@amilsted Good to know!","verbatim":false}}]},{"client_msg_id":"f4c8e7a9-7b51-4044-9a63-356da3e9021e","type":"message","text":"I pasted this question in the machine-learning channel, but I thought it might make sense to ask for thoughts and feedback here too.\n\nThis question is more \"conventional machine learning applied to quantum optics\" related.  \n\nI've been investigating the possibility of using ML to accelerate quantum optics simulations in cases where the quantum related math is computationally expensive.\n\nI think I've come to the conclusion that that since quantum state transformations are performed using unitary operators, linear algebra, it's very unlikely that any ML solution will be faster than a physics first principles quantum solution.\n\nDoes anyone disagree or have a counter example?\n\nThank you for any thoughts/feedback.","user":"U0158N77PFT","ts":"1616536065.003100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MG5GO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I pasted this question in the machine-learning channel, but I thought it might make sense to ask for thoughts and feedback here too.\n\nThis question is more \"conventional machine learning applied to quantum optics\" related.  \n\nI've been investigating the possibility of using ML to accelerate quantum optics simulations in cases where the quantum related math is computationally expensive.\n\nI think I've come to the conclusion that that since quantum state transformations are performed using unitary operators, linear algebra, it's very unlikely that any ML solution will be faster than a physics first principles quantum solution.\n\nDoes anyone disagree or have a counter example?\n\nThank you for any thoughts/feedback."}]}]}]},{"client_msg_id":"4ffecd56-d92e-47c6-8616-16ea8809ad10","type":"message","text":"I work on exactly that so I would tend to disagree, even if ML methods are a pain in the broad dissipative context and we're still trying to solve a few issues","user":"UAJH2818E","ts":"1616541462.004700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"81VJq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I work on exactly that so I would tend to disagree, even if ML methods are a pain in the broad dissipative context and we're still trying to solve a few issues"}]}]}]},{"client_msg_id":"fbf14843-f9ba-4d35-9dfc-7de088c08dac","type":"message","text":"then, it depends on what exactly is quantum optics for you. My (broad) interpretation is 'dissipative systems', not even necessarily bosonic. My expertise is there, but i'd expect that you can generalize ML approaches to over subdomains .\n\nA central question is: What quantities do you want to compute?","user":"UAJH2818E","ts":"1616541541.005700","team":"T68168MUP","edited":{"user":"UAJH2818E","ts":"1616541584.000000"},"blocks":[{"type":"rich_text","block_id":"gx38u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"then, it depends on what exactly is quantum optics for you. My (broad) interpretation is 'dissipative systems', not even necessarily bosonic. My expertise is there, but i'd expect that you can generalize ML approaches to over subdomains .\n\nA central question is: What quantities do you want to compute?"}]}]}]},{"client_msg_id":"d8b66bee-bc05-41c3-a8fd-6e0cb4c472dd","type":"message","text":"And what are you comparing against?","user":"UAJH2818E","ts":"1616541616.006100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Dz5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And what are you comparing against?"}]}]}]},{"client_msg_id":"de6ada04-2eca-40aa-9241-42d0423f5fdc","type":"message","text":"however in general, i don't understand your statement that\n&gt; since quantum state transformations are performed using unitary operators, linear algebra, it's very unlikely that any ML solution will be faster","user":"UAJH2818E","ts":"1616541692.007100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gl8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"however in general, i don't understand your statement that\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"since quantum state transformations are performed using unitary operators, linear algebra, it's very unlikely that any ML solution will be faster"}]}]}]},{"client_msg_id":"2e7252e4-2c8a-4809-9de3-8abf30345fb4","type":"message","text":"ML approaches in general means having a function approximator, approximating something (wavefunction, density matrix, correlations, green's function, DFT functonal...). This usually goes well with monte carlo sampling approaches but not necessarily.\n\nfunction approximation solves the memory cost due to the exponential size of the hilbert space problem, while sampling solves the runtime cost.\n\nBut again, this is not really relevant if comparing to ab-initio methods, which are a rather different approximation, working already in a truncated space that is not exponentially large.","user":"UAJH2818E","ts":"1616541842.008900","team":"T68168MUP","edited":{"user":"UAJH2818E","ts":"1616542158.000000"},"blocks":[{"type":"rich_text","block_id":"NkaX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ML approaches in general means having a function approximator, approximating something (wavefunction, density matrix, correlations, green's function, DFT functonal...). This usually goes well with monte carlo sampling approaches but not necessarily.\n\nfunction approximation solves the memory cost due to the exponential size of the hilbert space problem, while sampling solves the runtime cost.\n\nBut again, this is not really relevant if comparing to ab-initio methods, which are a rather different approximation, working already in a truncated space that is not exponentially large."}]}]}]},{"client_msg_id":"7f27e05f-b600-4b9f-b22e-54b61f73b7d9","type":"message","text":"Off i go to bed, but if you are intereseted i have plenty to say on the subject","user":"UAJH2818E","ts":"1616542198.010300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vaS94","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Off i go to bed, but if you are intereseted i have plenty to say on the subject"}]}]}]},{"type":"message","subtype":"channel_join","ts":"1616593500.010500","user":"ULSFQ48UQ","text":"<@ULSFQ48UQ> has joined the channel"},{"type":"message","subtype":"bot_message","text":"Hi, I need to implement a sequential hypothesis testing scheme and I was thinking to use QuantumOptics.  Does anyone know if there is something already available from where I can start building on?","ts":"1616661379.010600","username":"[gitter] <gasberry>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Hi, I need to implement a sequential hypothesis testing scheme and I was thinking to use QuantumOptics.  Does anyone know if there is something already available from where I can start building on?","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@gasberry Hi! Unfortunately I don't think there's anything available yet (at least not that I'm aware of).","ts":"1616662301.010700","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"@gasberry Hi! Unfortunately I don't think there's anything available yet (at least not that I'm aware of).","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"Ok thanks! Then I think I will have to dig a bit in the github repository to better understand the package structure. ","ts":"1616662434.010800","username":"[gitter] <gasberry>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c175804g27iaek8aehs0","text":{"type":"mrkdwn","text":"Ok thanks! Then I think I will have to dig a bit in the github repository to better understand the package structure. ","verbatim":false}}]},{"client_msg_id":"2c8eae36-c787-41ac-bb74-c6795e83b2f8","type":"message","text":"Appreciate any thoughts on how to calculate two time correlations:\n```⟨A(t+τ)B(t)⟩```\nI've been using quanutmoptics.jl's timecorrelations and the following line of code produces a result which doesn't align with what I think I should be getting:\n```G1_t_tau_G = [timecorrelations.correlation(tlist, ρ_0, H_Gc[i], J, b_op, a_op)\n                                                    for i in 1:size(tlist)[1]]```\nPart of the challenge is that my Hamiltonian is time dependent which is why you see the index. Also, the `correlation()`function isn't designed to take time dependent Hamiltonian's, so I've pre-calculated  the values I need as a vector of sparse operators.\n\nThank you for any feedback.","user":"U0158N77PFT","ts":"1617134760.015600","team":"T68168MUP","edited":{"user":"U0158N77PFT","ts":"1617135075.000000"},"blocks":[{"type":"rich_text","block_id":"u3V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Appreciate any thoughts on how to calculate two time correlations:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"⟨A(t+τ)B(t)⟩"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I've been using quanutmoptics.jl's timecorrelations and the following line of code produces a result which doesn't align with what I think I should be getting:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"G1_t_tau_G = [timecorrelations.correlation(tlist, ρ_0, H_Gc[i], J, b_op, a_op)\n                                                    for i in 1:size(tlist)[1]]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Part of the challenge is that my Hamiltonian is time dependent which is why you see the index. Also, the "},{"type":"text","text":"correlation()","style":{"code":true}},{"type":"text","text":"function isn't designed to take time dependent Hamiltonian's, so I've pre-calculated  the values I need as a vector of sparse operators.\n\nThank you for any feedback."}]}]}]},{"client_msg_id":"9a49f325-6837-4b9d-a7e4-de33507ad8f5","type":"message","text":"I think the issue here is the time-dependent Hamiltonian. Pre-computing a vector for `H` doesn't ensure it's evaluated at the exact time steps the solver takes.","user":"UBWLSPU1E","ts":"1617175539.017100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Zvo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the issue here is the time-dependent Hamiltonian. Pre-computing a vector for "},{"type":"text","text":"H","style":{"code":true}},{"type":"text","text":" doesn't ensure it's evaluated at the exact time steps the solver takes."}]}]}]},{"client_msg_id":"4990562d-e7ec-473c-89a7-824805082369","type":"message","text":"You can easily do what the function `timecorrelations.correlation` does \"by hand\" though. Try the following:","user":"UBWLSPU1E","ts":"1617175571.017900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QJloe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can easily do what the function "},{"type":"text","text":"timecorrelations.correlation","style":{"code":true}},{"type":"text","text":" does \"by hand\" though. Try the following:"}]}]}]},{"client_msg_id":"058d7c78-5949-497f-a4d6-e8fd68b401ae","type":"message","text":"```ρbar = B*ρ0\ntout, ρt = timeevolution.master_dynamic(tlist, ρbar, H, J)\ncorr = expect(A, ρt)```","user":"UBWLSPU1E","ts":"1617175651.018900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UU7N","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ρbar = B*ρ0\ntout, ρt = timeevolution.master_dynamic(tlist, ρbar, H, J)\ncorr = expect(A, ρt)"}]}]}]},{"client_msg_id":"c122e149-6978-41cf-8096-3cb93cfa062b","type":"message","text":"then `corr` should contain the values for `⟨A(t+τ)B(t)⟩`","user":"UBWLSPU1E","ts":"1617175665.019300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bC1d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"then "},{"type":"text","text":"corr","style":{"code":true}},{"type":"text","text":" should contain the values for "},{"type":"text","text":"⟨A(t+τ)B(t)⟩","style":{"code":true}}]}]}]},{"client_msg_id":"ef6f7744-9d29-4bf0-bba1-7c801e751c55","type":"message","text":"that is if `t=0` . Otherwise you'll have to compute `ρ0` from a standard time evolution up to time `t` and do the same as above","user":"UBWLSPU1E","ts":"1617175704.020100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"awj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that is if "},{"type":"text","text":"t=0","style":{"code":true}},{"type":"text","text":" . Otherwise you'll have to compute "},{"type":"text","text":"ρ0","style":{"code":true}},{"type":"text","text":" from a standard time evolution up to time "},{"type":"text","text":"t","style":{"code":true}},{"type":"text","text":" and do the same as above"}]}]}]},{"type":"message","subtype":"bot_message","text":"Hi! It ought to be possible to create DataOperators with CUDA.jl array storage.Has anybody tried using QuantumOptics with CuArrays or CuSparse arrays from CUDA.jl? ","ts":"1617726473.027100","username":"[gitter] <amilsted>","bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c1l3qqkg27iehe2iuovg","text":{"type":"mrkdwn","text":"Hi! It ought to be possible to create DataOperators with CUDA.jl array storage.Has anybody tried using QuantumOptics with CuArrays or CuSparse arrays from CUDA.jl? ","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"@amilsted Hi! In principle that works but it's mostly untested. I remember solving  a Schrödinger equation using CuArrays.","ts":"1617782768.027200","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c1l3qqkg27iehe2iuovg","text":{"type":"mrkdwn","text":"@amilsted Hi! In principle that works but it's mostly untested. I remember solving  a Schrödinger equation using CuArrays.","verbatim":false}}]},{"type":"message","subtype":"bot_message","text":"You should be able to just do `cu(op)` which will convert `op.data` to a CuArray and wrap it in another `Operator`","ts":"1617782821.027300","username":"[gitter] <david-pl>","icons":{"image_48":"https://s3-us-west-2.amazonaws.com/slack-files2/bot_icons/2020-06-15/1183800495714_48.png"},"bot_id":"B795XHD0X","blocks":[{"type":"section","block_id":"matterbridge_c1l3qqkg27iehe2iuovg","text":{"type":"mrkdwn","text":"You should be able to just do `cu(op)` which will convert `op.data` to a CuArray and wrap it in another `Operator`","verbatim":false}}]}]}