{"cursor": 0, "messages": [{"type":"message","text":"Repost from <#C674VR0HH|data>","user":"UCAFZ51L3","ts":"1610588719.000100","team":"T68168MUP","attachments":[{"fallback":"[January 13th, 2021 5:29 PM] hector.merchan: I think the upgrade to DBInterface is producing an error on the execute function. DBInterface.execute statements are producing an error about an ambiguity with ODBC.execute. Downgrading to Do interface v2.2.0 fixes the error.","ts":"1610587776.009300","author_id":"UCAFZ51L3","author_subname":"Alejandro Merchan","channel_id":"C674VR0HH","channel_name":"data","is_msg_unfurl":true,"text":"I think the upgrade to DBInterface is producing an error on the execute function. DBInterface.execute statements are producing an error about an ambiguity with ODBC.execute. Downgrading to Do interface v2.2.0 fixes the error.","author_name":"Alejandro Merchan","author_link":"https://julialang.slack.com/team/UCAFZ51L3","author_icon":"https://avatars.slack-edge.com/2019-09-21/768749495776_3cc28900cb577cfaf738_48.jpg","mrkdwn_in":["text"],"color":"D0D0D0","from_url":"https://julialang.slack.com/archives/C674VR0HH/p1610587776009300","is_share":true,"footer":"Posted in #data"}],"blocks":[{"type":"rich_text","block_id":"pBV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Repost from "},{"type":"channel","channel_id":"C674VR0HH"}]}]}]},{"client_msg_id":"d40e1a91-3d21-4fee-9e3e-55962e9571de","type":"message","text":"Is it just me, or is database support in Julia still at a very early and incomplete stage? I'm moving some processes from Python to Julia, and for a language designed for scientific computing I find it odd that database support isn't a very strong part. I had no problems using pymongo or SqlAlchemy for connecting to mongo and Postgres. In Julia I haven't yet got mongoc to work, but that is probably me (although some documentation would help). PostgreSQL.jl seems to be dead, and libPQ has not one single line of documentation on how to use it, so I have no idea whether it works or not, or how to use it with data frames. At least Redis and mysql seem well supported. Are people using pycall to get around all this?","user":"U01GFAJRZ44","ts":"1611313509.001100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CWFjE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it just me, or is database support in Julia still at a very early and incomplete stage? I'm moving some processes from Python to Julia, and for a language designed for scientific computing I find it odd that database support isn't a very strong part. I had no problems using pymongo or SqlAlchemy for connecting to mongo and Postgres. In Julia I haven't yet got mongoc to work, but that is probably me (although some documentation would help). PostgreSQL.jl seems to be dead, and libPQ has not one single line of documentation on how to use it, so I have no idea whether it works or not, or how to use it with data frames. At least Redis and mysql seem well supported. Are people using pycall to get around all this?"}]}]}],"thread_ts":"1611313509.001100","reply_count":5,"reply_users_count":3,"latest_reply":"1611327211.010600","reply_users":["U017JTQFNEQ","UC53031QU","U9VG1AYSG"],"subscribed":false,"reactions":[{"name":"100","users":["U017JTQFNEQ"],"count":1}]},{"client_msg_id":"25fe1bd4-70da-49fb-8b3f-88276703bf87","type":"message","text":"I doubt there are too many users if mongo, unfortunately, so I'd expect sharp edges. LibPQ on the other hand is much more widely used, and quite stable, as far as I know.","user":"U679VPJ8L","ts":"1611316876.003700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"p=O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I doubt there are too many users if mongo, unfortunately, so I'd expect sharp edges. LibPQ on the other hand is much more widely used, and quite stable, as far as I know."}]}]}]},{"client_msg_id":"4b9b722c-0c95-4721-adde-a8a7c2864e50","type":"message","text":"Aren't these docs enough to get you started? <https://invenia.github.io/LibPQ.jl/stable/|https://invenia.github.io/LibPQ.jl/stable/>","user":"U679VPJ8L","ts":"1611316896.004300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SBD7y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Aren't these docs enough to get you started? "},{"type":"link","url":"https://invenia.github.io/LibPQ.jl/stable/","text":"https://invenia.github.io/LibPQ.jl/stable/"}]}]}]},{"client_msg_id":"72220741-7317-4756-9ea3-d619a30b0e19","type":"message","text":"In terms of Dataframe, the ecosystem is moving to Tables.jl as the common mechanism for representing and converting tabular data, so it'd be useful to familiarise yourself with that. <https://tables.juliadata.org/stable/|https://tables.juliadata.org/stable/>","user":"U679VPJ8L","ts":"1611317056.007200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2wAOa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In terms of Dataframe, the ecosystem is moving to Tables.jl as the common mechanism for representing and converting tabular data, so it'd be useful to familiarise yourself with that. "},{"type":"link","url":"https://tables.juliadata.org/stable/","text":"https://tables.juliadata.org/stable/"}]}]}],"reactions":[{"name":"+1","users":["U9VG1AYSG","U01GFAJRZ44"],"count":2}]},{"client_msg_id":"bbc829be-56cb-4236-b483-676f15b6ee20","type":"message","text":"This mechanism allows different types of data representation to be convertible from each other.. in this case, a LibPQ resultset into a dataframe","user":"U679VPJ8L","ts":"1611317147.009600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ztD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This mechanism allows different types of data representation to be convertible from each other.. in this case, a LibPQ resultset into a dataframe"}]}]}]},{"type":"message","subtype":"thread_broadcast","text":"Unfortunately, replicating SQLAlchemy requires an *enormous* amount of effort.  The problem with SQL is that it is actually about a hundred different things each with its own, *completely* distinct implementation masquerading as the same thing.  Many, perhaps most of us who are active in the Julia community have scientific and academic backgrounds, and tend to only be interested in working on database support as far as absolutely necessary, and many scientific communities just don't use SQL at all, so the probability of someone coming along and spending a year of non-stop effort trying to reproduce sqlachemy is pretty low, which is probably a good thing, because afterwards that person would become a suicide risk.\n\nThat said, while Julia certainly can't boast the polished database support that python has, at this point there are tons of options.  I suggest that you look for your database interface in the following order:\n- If you are using a database with a mature direct wrapper like LibPQ, MySQL or SQLite, just use those packages.  We do need some more documentation yes, but those are pretty solid packages by now.\n- If that's not avaialable, use ODBC.jl.  ODBC is a bit of a pain-in-the-ass, yes, but <@U681ELA87> has done a lot to streamline the process.  If you can obtain the driver, it's now very easy to set up.\n- If the above fail, you should consider using JDBC.jl.  This is unpleasant since it will require the JVM, but JDBC itself is *extremely* mature and well-supported, so if you can get the wrapper working, you can query anything.\n- If you dont' want to bother with that, use PyCall on SQLAlchemy.\n\nFor the record, at my job I use postgres, MS SQL and AWS athena (apache presto) and I have not had to resort to JDBC or PyCall in quite a long time.  It's perhaps also a relevant trend that things seem to be moving in the direction of HTTP requests, e.g. AWS athena, and while there aren't create packages in the Julia ecosystem for these right now either, querying databases via HTTP *drastically* simplifies many of the interface details, even if it doesn't necessarily solve the problem of needing a common interface.","user":"U9VG1AYSG","ts":"1611327211.010600","thread_ts":"1611313509.001100","root":{"client_msg_id":"d40e1a91-3d21-4fee-9e3e-55962e9571de","type":"message","text":"Is it just me, or is database support in Julia still at a very early and incomplete stage? I'm moving some processes from Python to Julia, and for a language designed for scientific computing I find it odd that database support isn't a very strong part. I had no problems using pymongo or SqlAlchemy for connecting to mongo and Postgres. In Julia I haven't yet got mongoc to work, but that is probably me (although some documentation would help). PostgreSQL.jl seems to be dead, and libPQ has not one single line of documentation on how to use it, so I have no idea whether it works or not, or how to use it with data frames. At least Redis and mysql seem well supported. Are people using pycall to get around all this?","user":"U01GFAJRZ44","ts":"1611313509.001100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CWFjE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it just me, or is database support in Julia still at a very early and incomplete stage? I'm moving some processes from Python to Julia, and for a language designed for scientific computing I find it odd that database support isn't a very strong part. I had no problems using pymongo or SqlAlchemy for connecting to mongo and Postgres. In Julia I haven't yet got mongoc to work, but that is probably me (although some documentation would help). PostgreSQL.jl seems to be dead, and libPQ has not one single line of documentation on how to use it, so I have no idea whether it works or not, or how to use it with data frames. At least Redis and mysql seem well supported. Are people using pycall to get around all this?"}]}]}],"thread_ts":"1611313509.001100","reply_count":5,"reply_users_count":3,"latest_reply":"1611327211.010600","reply_users":["U017JTQFNEQ","UC53031QU","U9VG1AYSG"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"XFZC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Unfortunately, replicating SQLAlchemy requires an "},{"type":"text","text":"enormous","style":{"bold":true}},{"type":"text","text":" amount of effort.  The problem with SQL is that it is actually about a hundred different things each with its own, "},{"type":"text","text":"completely","style":{"bold":true}},{"type":"text","text":" distinct implementation masquerading as the same thing.  Many, perhaps most of us who are active in the Julia community have scientific and academic backgrounds, and tend to only be interested in working on database support as far as absolutely necessary, and many scientific communities just don't use SQL at all, so the probability of someone coming along and spending a year of non-stop effort trying to reproduce sqlachemy is pretty low, which is probably a good thing, because afterwards that person would become a suicide risk.\n\nThat said, while Julia certainly can't boast the polished database support that python has, at this point there are tons of options.  I suggest that you look for your database interface in the following order:\n- If you are using a database with a mature direct wrapper like LibPQ, MySQL or SQLite, just use those packages.  We do need some more documentation yes, but those are pretty solid packages by now.\n- If that's not avaialable, use ODBC.jl.  ODBC is a bit of a pain-in-the-ass, yes, but "},{"type":"user","user_id":"U681ELA87"},{"type":"text","text":" has done a lot to streamline the process.  If you can obtain the driver, it's now very easy to set up.\n- If the above fail, you should consider using JDBC.jl.  This is unpleasant since it will require the JVM, but JDBC itself is "},{"type":"text","text":"extremely","style":{"bold":true}},{"type":"text","text":" mature and well-supported, so if you can get the wrapper working, you can query anything.\n- If you dont' want to bother with that, use PyCall on SQLAlchemy.\n\nFor the record, at my job I use postgres, MS SQL and AWS athena (apache presto) and I have not had to resort to JDBC or PyCall in quite a long time.  It's perhaps also a relevant trend that things seem to be moving in the direction of HTTP requests, e.g. AWS athena, and while there aren't create packages in the Julia ecosystem for these right now either, querying databases via HTTP "},{"type":"text","text":"drastically","style":{"bold":true}},{"type":"text","text":" simplifies many of the interface details, even if it doesn't necessarily solve the problem of needing a common interface."}]}]}],"client_msg_id":"59cf2e08-3dcc-4caa-88b3-90ef726ed43e","reactions":[{"name":"100","users":["UC53031QU","UGU761DU2","U017JTQFNEQ"],"count":3},{"name":"+1","users":["U01GFAJRZ44"],"count":1}]},{"client_msg_id":"24749aca-a41e-42a1-a29f-8abf47d955a2","type":"message","text":"Yeah, the goal is to get high-quality client libraries curated in <https://github.com/JuliaDatabases/>. So far, MySQL.jl, LibPQ.jl, SQLite.jl, and ODBC.jl have seen the most development and are pretty robust in terms of api coverage and testing. It'd be great to have a solid mongo implementation as well. ClickHouse.jl has seen some good development too.\n\nI worked on <https://github.com/JuliaData/Strapping.jl> as a sort of ORM-lite package for Julia. It's a very non-magical ORM in that it doesn't do any SQL generation at all, but integrates with the Tables.jl interface to allow taking custom and possibly nested Julia model objects and transforming them into a 2D set of columns/rows, and vice-versa: taking a database query result (as defined by DBInterface.jl) and allowing parsing that into custom model objects.\n\nPersonally, I've always been pretty wary of the auto-SQL generator solutions out there; while they are probably fine for simple things, I've seen some really _really_ bad worst-case scenarios that can blow up in production. While annoying, I'm a big fan of hand-written SQL to ensure things are thought through properly and indexes are used whenever possible.\n\nThat said, I think <@U6BQL000Z> has worked on some SQL generation support in his Genie.jl stack via Searchlight.jl I think? Might be worth checking out if that's something you really need.","user":"U681ELA87","ts":"1611336125.016600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I+M0T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, the goal is to get high-quality client libraries curated in "},{"type":"link","url":"https://github.com/JuliaDatabases/"},{"type":"text","text":". So far, MySQL.jl, LibPQ.jl, SQLite.jl, and ODBC.jl have seen the most development and are pretty robust in terms of api coverage and testing. It'd be great to have a solid mongo implementation as well. ClickHouse.jl has seen some good development too.\n\nI worked on "},{"type":"link","url":"https://github.com/JuliaData/Strapping.jl"},{"type":"text","text":" as a sort of ORM-lite package for Julia. It's a very non-magical ORM in that it doesn't do any SQL generation at all, but integrates with the Tables.jl interface to allow taking custom and possibly nested Julia model objects and transforming them into a 2D set of columns/rows, and vice-versa: taking a database query result (as defined by DBInterface.jl) and allowing parsing that into custom model objects.\n\nPersonally, I've always been pretty wary of the auto-SQL generator solutions out there; while they are probably fine for simple things, I've seen some really "},{"type":"text","text":"really","style":{"italic":true}},{"type":"text","text":" bad worst-case scenarios that can blow up in production. While annoying, I'm a big fan of hand-written SQL to ensure things are thought through properly and indexes are used whenever possible.\n\nThat said, I think "},{"type":"user","user_id":"U6BQL000Z"},{"type":"text","text":" has worked on some SQL generation support in his Genie.jl stack via Searchlight.jl I think? Might be worth checking out if that's something you really need."}]}]}],"reactions":[{"name":"+1","users":["U9VG1AYSG"],"count":1},{"name":"100","users":["UC53031QU","UCAFZ51L3"],"count":2}]},{"client_msg_id":"78c66c49-98c4-4b1f-8068-bf71f0890c55","type":"message","text":"Indeed, SearchLight.jl is an ORM that implements the ActiveRecord design pattern and packs quite a few extra features (database migrations, environments, query generation, validators, serializers, etc). It's being used in the Genie community quite successfully. I can confirm that the lower level libraries it uses (MySQL.jl, SQLite.jl, and LibPq.jl) work great for standard CRUD operations and now that all are v1.x (if I'm not mistaken) they're stable. I have never ever used Python interop for DB access in Julia. :juliaheartpulsing:","user":"U6BQL000Z","ts":"1611336817.021900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5ap","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Indeed, SearchLight.jl is an ORM that implements the ActiveRecord design pattern and packs quite a few extra features (database migrations, environments, query generation, validators, serializers, etc). It's being used in the Genie community quite successfully. I can confirm that the lower level libraries it uses (MySQL.jl, SQLite.jl, and LibPq.jl) work great for standard CRUD operations and now that all are v1.x (if I'm not mistaken) they're stable. I have never ever used Python interop for DB access in Julia. "},{"type":"emoji","name":"juliaheartpulsing"}]}]}],"thread_ts":"1611336817.021900","reply_count":1,"reply_users_count":1,"latest_reply":"1611345855.032800","reply_users":["U01FKQQ7J0J"],"subscribed":false,"reactions":[{"name":"heart","users":["U681ELA87","UCAFZ51L3","U82LX4ACB"],"count":3}]},{"client_msg_id":"dd430a71-4f4b-437c-8bba-81b627db21d7","type":"message","text":"The engineering group at the company I work at told me that they prefer API's that generate SQL query strings to make testing easier (i.e. in theory the unit tests of that package should ensure that valid API calls produce valid strings, without having to run a database).  While I suppose that argument is completely correct, it also seems a little comical because it doesn't really consider the incredible amount of mind-numbing work that it takes to create and maintain those packages, particularly when you need to do it for every conceivable SQL flavor.  Lessson: SQL is awful, really just awful, but many of us are stuck with it forever :scream:","user":"U9VG1AYSG","ts":"1611337980.025200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jDxUQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The engineering group at the company I work at told me that they prefer API's that generate SQL query strings to make testing easier (i.e. in theory the unit tests of that package should ensure that valid API calls produce valid strings, without having to run a database).  While I suppose that argument is completely correct, it also seems a little comical because it doesn't really consider the incredible amount of mind-numbing work that it takes to create and maintain those packages, particularly when you need to do it for every conceivable SQL flavor.  Lessson: SQL is awful, really just awful, but many of us are stuck with it forever "},{"type":"emoji","name":"scream"}]}]}]},{"client_msg_id":"da2ee0a7-ea7f-4e97-a8c7-bd6e2fd3d284","type":"message","text":"Thanks for all the tips. Actually, I hadn't come across the page of example code for LibPQ. It isn't much, but will have to do. When I work it out I'll put something on the web. I started both python and Julia at about the same time, and the difference in this area is very striking. I had no problem at all get pymongo to work with pandas (I was new to mongo as well), and SQLAlchemy also is pretty simple. Got them both running in a day or two. A couple of months later, I have yet to get any of my Julia code to connect to a database. I prefer Dataframes.jl to pandas, so tend to do the cleaning in Julia, output to csv files, and then go over to python to upload to a database, which is not ideal. Using pycall isn't ideal either, because I have always found the python environment setups a complete mess (Conda, pyenv, pipenv, etc etc), and getting packages that I have on my system to be available within pycall has not proved straightforward either. I'll certainly take a look at Tables.jl","user":"U01GFAJRZ44","ts":"1611343188.030200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cpEpI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for all the tips. Actually, I hadn't come across the page of example code for LibPQ. It isn't much, but will have to do. When I work it out I'll put something on the web. I started both python and Julia at about the same time, and the difference in this area is very striking. I had no problem at all get pymongo to work with pandas (I was new to mongo as well), and SQLAlchemy also is pretty simple. Got them both running in a day or two. A couple of months later, I have yet to get any of my Julia code to connect to a database. I prefer Dataframes.jl to pandas, so tend to do the cleaning in Julia, output to csv files, and then go over to python to upload to a database, which is not ideal. Using pycall isn't ideal either, because I have always found the python environment setups a complete mess (Conda, pyenv, pipenv, etc etc), and getting packages that I have on my system to be available within pycall has not proved straightforward either. I'll certainly take a look at Tables.jl"}]}]}]},{"client_msg_id":"e9f10435-3301-4b47-b239-a54db306e950","type":"message","text":"I have used SQLite.jl, LibPQ.jl, and Mongoc.jl and they are all great. Sometimes I have needed to use RPostgreSQL in R for some PostGIS layer stuff but other than than is 100% great.","user":"U82LX4ACB","ts":"1611343432.030900","team":"T68168MUP","edited":{"user":"U82LX4ACB","ts":"1611343483.000000"},"blocks":[{"type":"rich_text","block_id":"EXrK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have used SQLite.jl, LibPQ.jl, and Mongoc.jl and they are all great. Sometimes I have needed to use RPostgreSQL in R for some PostGIS layer stuff but other than than is 100% great."}]}]}]},{"client_msg_id":"bf9d5475-b0d8-4da1-9ce2-505c1da023ff","type":"message","text":"it's definitely true that documentation is extremely lacking though.  We really could use some centralized documentation as well, it seems like there's a lot less there if you don't know about all your options.  There is [this](<http://juliadatabases.github.io/>) but it looks like it hasn't been updated in a while.  It would be good to advertise all the database interface options and show that by now they largely have a common interface","user":"U9VG1AYSG","ts":"1611344239.032300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uu4Yb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it's definitely true that documentation is extremely lacking though.  We really could use some centralized documentation as well, it seems like there's a lot less there if you don't know about all your options.  There is [this]("},{"type":"link","url":"http://juliadatabases.github.io/"},{"type":"text","text":") but it looks like it hasn't been updated in a while.  It would be good to advertise all the database interface options and show that by now they largely have a common interface"}]}]}]},{"client_msg_id":"4006b344-b4f6-45c6-a1d9-82ece8870362","type":"message","text":"I'm sure if I were just getting into Julia today I would be quite confused about what my database options are","user":"U9VG1AYSG","ts":"1611344259.032700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6mr0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm sure if I were just getting into Julia today I would be quite confused about what my database options are"}]}]}]},{"client_msg_id":"9f759449-02b8-4e6d-b706-7898c7d7f9c4","type":"message","text":"If anybody cares to chime in with opinions/concerns, I’ve put up an idea for a solution to a MySQL.jl datetime precision problem: <https://github.com/JuliaDatabases/MySQL.jl/pull/178>.","user":"U681ELA87","ts":"1615273693.001100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HZ+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If anybody cares to chime in with opinions/concerns, I’ve put up an idea for a solution to a MySQL.jl datetime precision problem: "},{"type":"link","url":"https://github.com/JuliaDatabases/MySQL.jl/pull/178"},{"type":"text","text":"."}]}]}]}]}