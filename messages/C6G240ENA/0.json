{"cursor": 4, "messages": [{"client_msg_id":"7cf7487f-ebaa-4bdf-bc21-f8ecbfb54ce8","type":"message","text":"Is the plan that it’ll use the same API as Zygote in general?","user":"UGU761DU2","ts":"1615180724.259400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GtQJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is the plan that it’ll use the same API as Zygote in general?"}]}]}]},{"client_msg_id":"a7507600-e4f7-4d14-919a-2b1695e80508","type":"message","text":"yes","user":"U674T3KB3","ts":"1615180734.259600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Mqz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes"}]}]}],"reactions":[{"name":"+1","users":["UGU761DU2"],"count":1}]},{"client_msg_id":"80b1d919-df30-40a9-a8e0-8389d3ebcf05","type":"message","text":"with some extra tricks","user":"U674T3KB3","ts":"1615180747.259900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+nLUc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"with some extra tricks"}]}]}],"reactions":[{"name":"science_parrot","users":["UGU761DU2"],"count":1}]},{"client_msg_id":"584df413-1a08-45ae-93e7-f121c9aaa812","type":"message","text":"Like, I'll make the `'''` a special case that directly calls the third order derivative rather than recursing over itself","user":"U674T3KB3","ts":"1615180770.260400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VKC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like, I'll make the "},{"type":"text","text":"'''","style":{"code":true}},{"type":"text","text":" a special case that directly calls the third order derivative rather than recursing over itself"}]}]}],"thread_ts":"1615180770.260400","reply_count":5,"reply_users_count":2,"latest_reply":"1615182564.264100","reply_users":["UJ7DVTVQ8","U674T3KB3"],"subscribed":false,"reactions":[{"name":"100","users":["U8D9768Q6","UGU761DU2"],"count":2}]},{"client_msg_id":"a67fd1d9-9c12-4469-809e-e6f1043dd193","type":"message","text":"I'm doing that for the moment, because it's an excellent stress test","user":"U674T3KB3","ts":"1615180782.260800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"h1n9+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm doing that for the moment, because it's an excellent stress test"}]}]}]},{"client_msg_id":"f1e6db5a-f28c-4b50-a733-f97d23dfbdb8","type":"message","text":"Nice!","user":"UGU761DU2","ts":"1615180785.261100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8s1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Nice!"}]}]}]},{"type":"message","subtype":"thread_broadcast","text":"I'm still having some trouble writing out the general form of this isomorphism. I can do it manually for any particular order, but doing it for arbitrary N is a bit tricky - guess that means I don't really understand it well enough yet","user":"U674T3KB3","ts":"1615182379.263800","thread_ts":"1615180770.260400","root":{"client_msg_id":"584df413-1a08-45ae-93e7-f121c9aaa812","type":"message","text":"Like, I'll make the `'''` a special case that directly calls the third order derivative rather than recursing over itself","user":"U674T3KB3","ts":"1615180770.260400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VKC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like, I'll make the "},{"type":"text","text":"'''","style":{"code":true}},{"type":"text","text":" a special case that directly calls the third order derivative rather than recursing over itself"}]}]}],"thread_ts":"1615180770.260400","reply_count":5,"reply_users_count":2,"latest_reply":"1615182564.264100","reply_users":["UJ7DVTVQ8","U674T3KB3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"MtL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm still having some trouble writing out the general form of this isomorphism. I can do it manually for any particular order, but doing it for arbitrary N is a bit tricky - guess that means I don't really understand it well enough yet"}]}]}],"client_msg_id":"bc0603c3-354a-411f-b1ab-e96a5dedce64"},{"client_msg_id":"cdb883c9-2d34-4869-a7dd-44582eacf57d","type":"message","text":"<@U674T3KB3> I am looking forward for this. I am using second order gradients to train more explainable models and Zygote is of course taking its time (though I am very glad that it works)","user":"U6YRZ18GZ","ts":"1615191207.267400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wBVyR","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U674T3KB3"},{"type":"text","text":" I am looking forward for this. I am using second order gradients to train more explainable models and Zygote is of course taking its time (though I am very glad that it works)"}]}]}]},{"client_msg_id":"14f35687-8487-42f8-922b-12b2399e0399","type":"message","text":"I'm trying to make nested derivatives work with Zygote on my code and it's a pain. I was wondering, if I have code like that:\n\n```Zygote.@adjoint function f(...)\n   ....\n   function adjoint_of_f(ybar)\n       ....\n   end\n   return y, adjoint_of_f(ybar)\nend```\nand I try to do `Zygote.pullback(p -&gt; Zygote.pullback(f, ...), ...)` , will it try to differentiate `adjoint_of_f` or just for some reason `f` itself twice. For some reason it seems to be doing the latter","user":"UKJSNT1QR","ts":"1615224891.274400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Je=7P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm trying to make nested derivatives work with Zygote on my code and it's a pain. I was wondering, if I have code like that:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Zygote.@adjoint function f(...)\n   ....\n   function adjoint_of_f(ybar)\n       ....\n   end\n   return y, adjoint_of_f(ybar)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nand I try to do "},{"type":"text","text":"Zygote.pullback(p -> Zygote.pullback(f, ...), ...)","style":{"code":true}},{"type":"text","text":" , will it try to differentiate "},{"type":"text","text":"adjoint_of_f","style":{"code":true}},{"type":"text","text":" or just for some reason "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" itself twice. For some reason it seems to be doing the latter"}]}]}]},{"client_msg_id":"e4395fbd-f8c8-47ec-acd7-cf84b59ed697","type":"message","text":"I'm mostly completely unable to understand what Zygote stacktraces are trying to tell me","user":"UKJSNT1QR","ts":"1615225007.275200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nN0C","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm mostly completely unable to understand what Zygote stacktraces are trying to tell me"}]}]}]},{"client_msg_id":"2ec58662-9da3-41a4-a504-aa805a131dd4","type":"message","text":"It'll AD the definition of rule as well as the adjoint_of_f","user":"U674T3KB3","ts":"1615225078.276200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iCF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It'll AD the definition of rule as well as the adjoint_of_f"}]}]}]},{"client_msg_id":"36cb5c42-eb26-4a5b-a87e-db2a85d9582a","type":"message","text":"But yeah, stack traces are a problem. Still trying to figure out what to do about that in diffractor","user":"U674T3KB3","ts":"1615225116.277000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tvrf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But yeah, stack traces are a problem. Still trying to figure out what to do about that in diffractor"}]}]}],"thread_ts":"1615225116.277000","reply_count":1,"reply_users_count":1,"latest_reply":"1615225180.278200","reply_users":["UM30MT6RF"],"subscribed":false},{"client_msg_id":"b4241ab6-fe5d-46e2-b82a-c9a6aaeb5aec","type":"message","text":"Ok, I was getting confused because the last \"understandable\" trace was pointing to some line in the body of `f`  itself and I was wondering why it would even be running that code. Is possible to define a Zygote.@adjoint of a Zygote.@adjoint to sidestep that problem?","user":"UKJSNT1QR","ts":"1615225214.279000","team":"T68168MUP","edited":{"user":"UKJSNT1QR","ts":"1615225229.000000"},"blocks":[{"type":"rich_text","block_id":"heZXL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, I was getting confused because the last \"understandable\" trace was pointing to some line in the body of "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":"  itself and I was wondering why it would even be running that code. Is possible to define a Zygote.@adjoint of a Zygote.@adjoint to sidestep that problem?"}]}]}]},{"client_msg_id":"7dce3670-28eb-4ed2-b0f3-65f0b14214ea","type":"message","text":"Generally the way to do that is to pull out the forward part into a separate function and define an adjoint for that","user":"U674T3KB3","ts":"1615225314.280900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JgQ7O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Generally the way to do that is to pull out the forward part into a separate function and define an adjoint for that"}]}]}]},{"client_msg_id":"a9476159-3852-406f-bf9c-c81b8ce725f2","type":"message","text":"hi guys, im trying to implement a method where i take successive derivatives of a function, and expose it as a new method. my input vector is ~ 5 element, and each function outputs a scalar. however when taking successive gradients, its slowing down significantly. Currently im using ForwardDiff, but if its better to use a different library for something like this, i would like to know!","user":"U01A38DLY8N","ts":"1615279087.285400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UMVq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hi guys, im trying to implement a method where i take successive derivatives of a function, and expose it as a new method. my input vector is ~ 5 element, and each function outputs a scalar. however when taking successive gradients, its slowing down significantly. Currently im using ForwardDiff, but if its better to use a different library for something like this, i would like to know!"}]}]}],"thread_ts":"1615279087.285400","reply_count":5,"reply_users_count":2,"latest_reply":"1615280030.286300","reply_users":["U01A38DLY8N","U6A936746"],"subscribed":false},{"client_msg_id":"05438f24-bfc7-454e-a51f-4b2324f70427","type":"message","text":"If I have something like\n\n```applychain(fs::Tuple, x, p) = applychain(Base.tail(fs), first(fs)(x,p[1:paramlength(first(fs))]), p[(paramlength(first(fs))+1):end])```\nIf I take its pullback (with Zygote) twice, I get:\n```ERROR: Mutating arrays is not supported\nStacktrace:\n [1] (::Zygote.var\"#376#377\")(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/lib/array.jl:61\n [2] (::Zygote.var\"#2271#back#378\"{Zygote.var\"#376#377\"})(::Nothing) at /home/guillaume/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [3] materialize! at ./broadcast.jl:848 [inlined]\n [4] materialize! at ./broadcast.jl:845 [inlined]\n [5] materialize! at ./broadcast.jl:841 [inlined]\n [6] (::typeof(∂(materialize!)))(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [7] #364 at /home/guillaume/.julia/packages/Zygote/KpME9/src/lib/array.jl:42 [inlined]\n [8] (::typeof(∂(λ)))(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [9] #2225#back at /home/guillaume/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59 [inlined]\n [10] (::typeof(∂(λ)))(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [11] applychain at /home/guillaume/.julia/packages/DiffEqFlux/lS4Sa/src/fast_layers.jl:20 [inlined]\n [12] (::typeof(∂(λ)))(::Tuple{Nothing,Nothing,CuArray{Float32,3},Nothing}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [13] FastChain at /home/guillaume/.julia/packages/DiffEqFlux/lS4Sa/src/fast_layers.jl:21 [inlined]\n [14] (::typeof(∂(λ)))(::Tuple{Nothing,CuArray{Float32,3},Nothing}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [15] #89 at ./REPL[52]:2 [inlined]\n [16] (::typeof(∂(λ)))(::Tuple{Nothing,CuArray{Float32,3}}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [17] #41 at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface.jl:40 [inlined]\n [18] (::typeof(∂(λ)))(::Tuple{CuArray{Float32,3}}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [19] ftest2 at ./REPL[52]:3 [inlined]\n [20] (::typeof(∂(ftest2)))(::CuArray{Float32,3}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [21] (::Zygote.var\"#41#42\"{typeof(∂(ftest2))})(::CuArray{Float32,3}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface.jl:40\n [22] top-level scope at REPL[54]:1```\nHow do you make things safe of  `ERROR: Mutating arrays is not supported` when differentiating twice ?","user":"UKJSNT1QR","ts":"1615310762.288400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z3it","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I have something like\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"applychain(fs::Tuple, x, p) = applychain(Base.tail(fs), first(fs)(x,p[1:paramlength(first(fs))]), p[(paramlength(first(fs))+1):end])"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"If I take its pullback (with Zygote) twice, I get:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ERROR: Mutating arrays is not supported\nStacktrace:\n [1] (::Zygote.var\"#376#377\")(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/lib/array.jl:61\n [2] (::Zygote.var\"#2271#back#378\"{Zygote.var\"#376#377\"})(::Nothing) at /home/guillaume/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [3] materialize! at ./broadcast.jl:848 [inlined]\n [4] materialize! at ./broadcast.jl:845 [inlined]\n [5] materialize! at ./broadcast.jl:841 [inlined]\n [6] (::typeof(∂(materialize!)))(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [7] #364 at /home/guillaume/.julia/packages/Zygote/KpME9/src/lib/array.jl:42 [inlined]\n [8] (::typeof(∂(λ)))(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [9] #2225#back at /home/guillaume/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59 [inlined]\n [10] (::typeof(∂(λ)))(::Nothing) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [11] applychain at /home/guillaume/.julia/packages/DiffEqFlux/lS4Sa/src/fast_layers.jl:20 [inlined]\n [12] (::typeof(∂(λ)))(::Tuple{Nothing,Nothing,CuArray{Float32,3},Nothing}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [13] FastChain at /home/guillaume/.julia/packages/DiffEqFlux/lS4Sa/src/fast_layers.jl:21 [inlined]\n [14] (::typeof(∂(λ)))(::Tuple{Nothing,CuArray{Float32,3},Nothing}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [15] #89 at ./REPL[52]:2 [inlined]\n [16] (::typeof(∂(λ)))(::Tuple{Nothing,CuArray{Float32,3}}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [17] #41 at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface.jl:40 [inlined]\n [18] (::typeof(∂(λ)))(::Tuple{CuArray{Float32,3}}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [19] ftest2 at ./REPL[52]:3 [inlined]\n [20] (::typeof(∂(ftest2)))(::CuArray{Float32,3}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [21] (::Zygote.var\"#41#42\"{typeof(∂(ftest2))})(::CuArray{Float32,3}) at /home/guillaume/.julia/packages/Zygote/KpME9/src/compiler/interface.jl:40\n [22] top-level scope at REPL[54]:1"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"How do you make things safe of  "},{"type":"text","text":"ERROR: Mutating arrays is not supported","style":{"code":true}},{"type":"text","text":" when differentiating twice ?"}]}]}]},{"client_msg_id":"7bf7336c-c885-4470-87c0-539ed23cb4c7","type":"message","text":"Would providing ChainRules adjoints for GraphBLAS be a reasonable gsoc idea?","user":"U017D4RFTFC","ts":"1615335127.292600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EHgRJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Would providing ChainRules adjoints for GraphBLAS be a reasonable gsoc idea?"}]}]}],"reactions":[{"name":"+1","users":["U6A936746"],"count":1}]},{"client_msg_id":"2f898699-22ae-4438-841a-921ac07b9201","type":"message","text":"It's something I'm already working on after some very generous help from <@U6A936746> a couple months back.","user":"U017D4RFTFC","ts":"1615335254.293700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"30kG0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's something I'm already working on after some very generous help from "},{"type":"user","user_id":"U6A936746"},{"type":"text","text":" a couple months back."}]}]}],"thread_ts":"1615335254.293700","reply_count":3,"reply_users_count":2,"latest_reply":"1615335375.294500","reply_users":["U6A936746","U017D4RFTFC"],"subscribed":false},{"client_msg_id":"5c8345cd-2f58-468c-8d48-e96adc11b6f5","type":"message","text":"Who should I ping about mentoring for that?","user":"U017D4RFTFC","ts":"1615338848.295500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tV3lC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Who should I ping about mentoring for that?"}]}]}],"thread_ts":"1615338848.295500","reply_count":1,"reply_users_count":1,"latest_reply":"1615338993.295600","reply_users":["U6A936746"],"subscribed":false},{"client_msg_id":"b28019df-fa30-45be-a101-45d2c61c0540","type":"message","text":"Some people in here might be interested in this post: <https://www.stochasticlifestyle.com/generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism/>","user":"U69BL50BF","ts":"1615384487.298600","team":"T68168MUP","attachments":[{"service_name":"Stochastic Lifestyle","title":"Generalizing Automatic Differentiation to Automatic Sparsity, Uncertainty, Stability, and Parallelism - Stochastic Lifestyle","title_link":"https://www.stochasticlifestyle.com/generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism/","text":"Automatic differentiation is a \"compiler trick\" whereby a code that calculates f(x) is transformed into a code that calculates f'(x). This trick and its two forms, forward and reverse mode automatic differentiation, have become the pervasive backbone behind all of the machine learning libraries. If you ask what PyTorch or Flux.jl is doing that's special, the answer is really that it's doing automatic differentiation over some functions. What I want to dig into in this blog post is a simple question: what is the trick behind automatic differentiation, why is it always differentiation, and are there other mathematical problems we can be focusing this trick towards? While very technical discussions on this can be found in our recent paper and descriptions of methods like intrusive uncertainty quantification, I want to give a high-level overview that really describes some of ... READ MORE","fallback":"Stochastic Lifestyle: Generalizing Automatic Differentiation to Automatic Sparsity, Uncertainty, Stability, and Parallelism - Stochastic Lifestyle","thumb_url":"https://www.stochasticlifestyle.com/wp-content/themes/chrisrack/style/faviPic2.PNG","fields":[{"title":"Written by","value":"Christopher Rackauckas","short":true},{"title":"Est. reading time","value":"14 minutes","short":true}],"ts":1615383832,"from_url":"https://www.stochasticlifestyle.com/generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism/","thumb_width":669,"thumb_height":891,"service_icon":"https://i2.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2016/01/cropped-faviPic.png?fit=180%2C180&#038;ssl=1","id":1,"original_url":"https://www.stochasticlifestyle.com/generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism/"}],"blocks":[{"type":"rich_text","block_id":"fIaJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Some people in here might be interested in this post: "},{"type":"link","url":"https://www.stochasticlifestyle.com/generalizing-automatic-differentiation-to-automatic-sparsity-uncertainty-stability-and-parallelism/"}]}]}],"thread_ts":"1615384487.298600","reply_count":1,"reply_users_count":1,"latest_reply":"1615384803.298900","reply_users":["U01C2E6TYEM"],"subscribed":false,"reactions":[{"name":"+1","users":["UDXST8ARK","U01C2E6TYEM"],"count":2}]},{"type":"message","subtype":"thread_broadcast","text":"Most of the Flux/ML projects seem to be mentored by Dhairya, or maybe Chris on a few. I could also ping one of the authors of the ~2013 Julia semiring algebra paper","user":"U017D4RFTFC","ts":"1615407958.304200","thread_ts":"1615338848.295500","root":{"client_msg_id":"5c8345cd-2f58-468c-8d48-e96adc11b6f5","type":"message","text":"Who should I ping about mentoring for that?","user":"U017D4RFTFC","ts":"1615338848.295500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tV3lC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Who should I ping about mentoring for that?"}]}]}],"thread_ts":"1615338848.295500","reply_count":4,"reply_users_count":2,"latest_reply":"1615407958.304200","reply_users":["U6A936746","U017D4RFTFC"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"tC=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Most of the Flux/ML projects seem to be mentored by Dhairya, or maybe Chris on a few. I could also ping one of the authors of the ~2013 Julia semiring algebra paper"}]}]}],"client_msg_id":"9957ab7c-7dfa-49a2-ade1-507d880e18b4"},{"client_msg_id":"c6836da4-f301-42e9-92ec-340d127d51b6","type":"message","text":"like me?","user":"U67461GUB","ts":"1615409542.304700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YNXS1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"like me?"}]}]}],"thread_ts":"1615409542.304700","reply_count":5,"reply_users_count":2,"latest_reply":"1615410572.307700","reply_users":["U017D4RFTFC","U67461GUB"],"subscribed":false},{"client_msg_id":"2d0d163f-baf0-4adb-a8fd-ae8a225c78ec","type":"message","text":"is there any way for ForwardDiff to deal with cases where a matrix is updated in a for loop? A minimum working example is like:\n```function g2(x)\n    e = zeros(1000, 10)\n    for i in 1:10\n        e[:,i] = rand(1000) .+ x\n    end\n    res = mean(e)\n    return res\nend\n\nForwardDiff.derivative(g2,1) # fail```\nIn real application, the calculations within the for loop is complicated so I can't really get rid of it. Are there any solutions? Or I should just try to formulate the problem in another way to avoid updating in for loops?","user":"UM3GCDFGR","ts":"1615502961.314500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ytK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is there any way for ForwardDiff to deal with cases where a matrix is updated in a for loop? A minimum working example is like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function g2(x)\n    e = zeros(1000, 10)\n    for i in 1:10\n        e[:,i] = rand(1000) .+ x\n    end\n    res = mean(e)\n    return res\nend\n\nForwardDiff.derivative(g2,1) # fail"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"In real application, the calculations within the for loop is complicated so I can't really get rid of it. Are there any solutions? Or I should just try to formulate the problem in another way to avoid updating in for loops?"}]}]}],"thread_ts":"1615502961.314500","reply_count":4,"reply_users_count":3,"latest_reply":"1615504321.315400","reply_users":["UD0NS8PDF","U6A936746","UM3GCDFGR"],"subscribed":false},{"client_msg_id":"f01c1a1c-9b7b-4ef4-9d5b-53ce84eb6447","type":"message","text":"How does dispatch for ChainRules work ?\n\nI have definitions for\n\n```function rrule(\n     ::typeof(NNlib.batched_mul),\n     A::AbstractArray{S,3},\n     B::AbstractMatrix{S},\n     ) where S &lt;: NNlib.BlasFloat\n\n...\n\nfunction rrule(::typeof(NNlib.batched_mul),\n     A::AbstractArray{S,3},\n     B::AbstractArray{S,3},\n    ) where S &lt;: NNlib.BlasFloat\n\n...\n\netc```\nBut it seems a single one of tjhem is used (the base one from NNlib).","user":"UKJSNT1QR","ts":"1615540537.318800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CmX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How does dispatch for ChainRules work ?\n\nI have definitions for\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function rrule(\n     ::typeof(NNlib.batched_mul),\n     A::AbstractArray{S,3},\n     B::AbstractMatrix{S},\n     ) where S <: NNlib.BlasFloat\n\n...\n\nfunction rrule(::typeof(NNlib.batched_mul),\n     A::AbstractArray{S,3},\n     B::AbstractArray{S,3},\n    ) where S <: NNlib.BlasFloat\n\n...\n\netc"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"But it seems a single one of tjhem is used (the base one from NNlib)."}]}]}]},{"client_msg_id":"b9da65a4-517b-46e2-94e9-b6ddb3438cca","type":"message","text":"It seems like my rules are not being picked up","user":"UKJSNT1QR","ts":"1615540706.319300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R3se","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems like my rules are not being picked up"}]}]}]},{"client_msg_id":"4e44a13b-954c-49c6-8ca7-bbe790f71704","type":"message","text":"Might need to do `Zygote.refresh()` if you are using Zygote for the new rules to get picked up","user":"UM30MT6RF","ts":"1615540753.320200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mKyFb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Might need to do "},{"type":"text","text":"Zygote.refresh()","style":{"code":true}},{"type":"text","text":" if you are using Zygote for the new rules to get picked up"}]}]}]},{"client_msg_id":"d75dae63-6006-40ba-a9a4-c2231814a86c","type":"message","text":"Oh, it looks like Zygote has a custom adjoint for NNlib (which is always picked before a ChainRule)","user":"U0160CXEY3Z","ts":"1615540800.320700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oBc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, it looks like Zygote has a custom adjoint for NNlib (which is always picked before a ChainRule)"}]}]}]},{"client_msg_id":"9a5f0869-6cbe-452f-aa0e-ac16b05a2c89","type":"message","text":"I am pretty sure that was changed recently","user":"UM30MT6RF","ts":"1615540893.321700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Yp1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am pretty sure that was changed recently"}]}]}],"reactions":[{"name":"+1","users":["U0160CXEY3Z"],"count":1}]},{"client_msg_id":"05815478-434b-4f9c-83a4-5cd3cbc84129","type":"message","text":"see <https://github.com/FluxML/NNlib.jl/blob/cf8cba0e2cb2cb671ff42b9e408b4af614216ef3/src/batched/batchedmul.jl#L59>","user":"UM30MT6RF","ts":"1615540929.322200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gVvP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"see "},{"type":"link","url":"https://github.com/FluxML/NNlib.jl/blob/cf8cba0e2cb2cb671ff42b9e408b4af614216ef3/src/batched/batchedmul.jl#L59"}]}]}]},{"client_msg_id":"c4da6b82-e246-4a2f-bfa4-84070f9039df","type":"message","text":"Yes but I expected Zygote to pick my adjoint after a refresh but it doesn't\n\n```using NNlib, ChainRules, Zygote\n\nfunction ChainRules.rrule(\n    ::typeof(NNlib.batched_mul),\n    A::AbstractArray{S,3},\n    B::AbstractMatrix{S},\n    ) where S &lt;: NNlib.BlasFloat\n\n    function batched_mul_pullback(Δ)\n        return (\n            NO_FIELDS,\n            @thunk(batched_mul(Δ, permutedims(reshape(B, size(B)..., 1), (2, 1, 3)))),\n            @thunk(batched_mul(permutedims(A, (2, 1, 3)), Δ)),\n        )\n     end\n    batched_mul(A, reshape(B, size(B)..., 1)), batched_mul_pullback\nend\n\nZygote.refresh()\n\nW = rand(Float32, 1, 1, 2)\nx = rand(Float32, 1, 1) \n\ngz, back = Zygote.pullback(x -&gt; NNlib.batched_mul(W, x), x)\nback(gz)[1]```\nExpected: it uses my adjoint and works.\n\nWhat happens: it uses NNlib default adjoint and doesn't work.\n\nWas fixed here: <https://github.com/FluxML/NNlib.jl/issues/290>\n\nBut wondering why it didn't work when I monkey patched it myself","user":"UKJSNT1QR","ts":"1615541017.322900","team":"T68168MUP","edited":{"user":"UKJSNT1QR","ts":"1615541037.000000"},"blocks":[{"type":"rich_text","block_id":"+oSs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes but I expected Zygote to pick my adjoint after a refresh but it doesn't\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using NNlib, ChainRules, Zygote\n\nfunction ChainRules.rrule(\n    ::typeof(NNlib.batched_mul),\n    A::AbstractArray{S,3},\n    B::AbstractMatrix{S},\n    ) where S <: NNlib.BlasFloat\n\n    function batched_mul_pullback(Δ)\n        return (\n            NO_FIELDS,\n            @thunk(batched_mul(Δ, permutedims(reshape(B, size(B)..., 1), (2, 1, 3)))),\n            @thunk(batched_mul(permutedims(A, (2, 1, 3)), Δ)),\n        )\n     end\n    batched_mul(A, reshape(B, size(B)..., 1)), batched_mul_pullback\nend\n\nZygote.refresh()\n\nW = rand(Float32, 1, 1, 2)\nx = rand(Float32, 1, 1) \n\ngz, back = Zygote.pullback(x -> NNlib.batched_mul(W, x), x)\nback(gz)[1]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Expected: it uses my adjoint and works.\n\nWhat happens: it uses NNlib default adjoint and doesn't work.\n\nWas fixed here: "},{"type":"link","url":"https://github.com/FluxML/NNlib.jl/issues/290"},{"type":"text","text":"\n\nBut wondering why it didn't work when I monkey patched it myself"}]}]}]},{"client_msg_id":"a52fd37c-92c8-4590-976d-01aae850870d","type":"message","text":"Hi All,\n\nmay I ask someone to help me fixing the problem that matrix multiplication in gradient is not hitting BLAS?\n\nThis is my MWE\n```W = randn(Float32,64,64)\nX = randn(Float32,64,640000)\nProfile.clear()\n@profile gradient(W -&gt; sum(W * X), W)\nProfileSVG.save(\"/tmp/profile.svg\")```\nand I look at the output of the profiler to see, which functions are called. I think it is the same issue as this one\n<https://github.com/JuliaDiff/ChainRules.jl/issues/343>\nand it kills the performance of our Mill.jl, since it is all about GEMM.\nI use  ChainRules v0.7.54.\nThanks a lot for suggestions.\nTomas","user":"U6YRZ18GZ","ts":"1615640197.325800","team":"T68168MUP","edited":{"user":"U6YRZ18GZ","ts":"1615640447.000000"},"blocks":[{"type":"rich_text","block_id":"eJKEE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi All,\n\nmay I ask someone to help me fixing the problem that matrix multiplication in gradient is not hitting BLAS?\n\nThis is my MWE\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"W = randn(Float32,64,64)\nX = randn(Float32,64,640000)\nProfile.clear()\n@profile gradient(W -> sum(W * X), W)\nProfileSVG.save(\"/tmp/profile.svg\")"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and I look at the output of the profiler to see, which functions are called. I think it is the same issue as this one\n"},{"type":"link","url":"https://github.com/JuliaDiff/ChainRules.jl/issues/343"},{"type":"text","text":"\nand it kills the performance of our Mill.jl, since it is all about GEMM.\nI use  ChainRules v0.7.54.\nThanks a lot for suggestions.\nTomas"}]}]}],"thread_ts":"1615640197.325800","reply_count":2,"reply_users_count":1,"latest_reply":"1615641167.326300","reply_users":["U6A936746"],"subscribed":false},{"client_msg_id":"b1ded38a-5992-4d2f-a8d7-aa7e34f32308","type":"message","text":"I’ve managed to write code using `@scalar_rule` which (1) errors when calling `test_scalar`, (2) returns failed tests for `test_rrule`, but somehow (3) passes tests for `test_frule`. I have very high confidence the derivative is accurate, I just can’t seem to test it right. Can anyone see any glaring flaws in this-\n\n```# type annotated for clarity\n@scalar_rule(\n    compute_gn(u_n::Vector)::Vector,\n    compute_gn_jac(u_n::Vector)::Matrix\n)\ntest_scalar(compute_gn, [1, 0.4, 0.26]) # \"no method matching one(::Vector{Float64})\"\ntest_rrule(compute_gn, [1, 0.4, 0.26]) # test fails, derivatives don't match\ntest_frule(compute_gn, [1, 0.4, 0.26]) # test passes```","user":"UN97XTLCV","ts":"1615663587.330500","team":"T68168MUP","edited":{"user":"UN97XTLCV","ts":"1615663648.000000"},"blocks":[{"type":"rich_text","block_id":"+Tdp6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’ve managed to write code using "},{"type":"text","text":"@scalar_rule","style":{"code":true}},{"type":"text","text":" which (1) errors when calling "},{"type":"text","text":"test_scalar","style":{"code":true}},{"type":"text","text":", (2) returns failed tests for "},{"type":"text","text":"test_rrule","style":{"code":true}},{"type":"text","text":", but somehow (3) passes tests for "},{"type":"text","text":"test_frule","style":{"code":true}},{"type":"text","text":". I have very high confidence the derivative is accurate, I just can’t seem to test it right. Can anyone see any glaring flaws in this-\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"# type annotated for clarity\n@scalar_rule(\n    compute_gn(u_n::Vector)::Vector,\n    compute_gn_jac(u_n::Vector)::Matrix\n)\ntest_scalar(compute_gn, [1, 0.4, 0.26]) # \"no method matching one(::Vector{Float64})\"\ntest_rrule(compute_gn, [1, 0.4, 0.26]) # test fails, derivatives don't match\ntest_frule(compute_gn, [1, 0.4, 0.26]) # test passes"}]}]}],"thread_ts":"1615663587.330500","reply_count":14,"reply_users_count":3,"latest_reply":"1615665324.334800","reply_users":["U6A936746","UN97XTLCV","U6PQP41C3"],"subscribed":false},{"client_msg_id":"1121912e-c505-47bb-926c-83bf7cb43cf3","type":"message","text":"in general is there any advice for when I’m planning on writing chain rules for my package, should I aim to be as granular as possible (e.g. all helper methods get a chain rule and the main computation method manually propagates the chain rules to form the “main” chain rule) or should I aim to write as few rules as possible (e.g., write all the helper methods to manually keep track of jacobians and only have the one or two chain rules on the “surface”)","user":"UN97XTLCV","ts":"1615681828.337600","team":"T68168MUP","edited":{"user":"UN97XTLCV","ts":"1615682001.000000"},"blocks":[{"type":"rich_text","block_id":"1DU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"in general is there any advice for when I’m planning on writing chain rules for my package, should I aim to be as granular as possible (e.g. all helper methods get a chain rule and the main computation method manually propagates the chain rules to form the “main” chain rule) or should I aim to write as few rules as possible (e.g., write all the helper methods to manually keep track of jacobians and only have the one or two chain rules on the “surface”)"}]}]}]},{"client_msg_id":"9c84ec31-9793-43aa-bc3d-1aa4b333a7aa","type":"message","text":"Question: is `frule` actually used somewhere or is it mainly for \"the next forward-mode package\" if such a thing was to ever come?\nMy question is motivated by whether or not it's possible to write custom `frule`  that can actually be used somewhere since, AFAIK, it's nontrivial to write custom rules for vector functions in ForwardDiff.jl (if at all possible).","user":"UHDNY2YMA","ts":"1615756647.341300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tc0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Question: is "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" actually used somewhere or is it mainly for \"the next forward-mode package\" if such a thing was to ever come?\nMy question is motivated by whether or not it's possible to write custom "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":"  that can actually be used somewhere since, AFAIK, it's nontrivial to write custom rules for vector functions in ForwardDiff.jl (if at all possible)."}]}]}],"thread_ts":"1615756647.341300","reply_count":6,"reply_users_count":3,"latest_reply":"1615759039.343500","reply_users":["U6A936746","UHDNY2YMA","U6788D83U"],"subscribed":false},{"client_msg_id":"46e09e7d-03bb-452f-b3ef-80990feb3959","type":"message","text":"A quick quesh: I want to do `ifft(fft(a) .+ fft(b))` for two real vectors `a` and `b`. This composition is a real function but results in complex adjoints due to the pullback of `ifft` and `fft` . I want the adjoints to be _real_ given that this function is indeed real for real inputs.\n\nRight now made this composition into a method and then I define the `rrule` for this method, which is either:\n• Using Zygote to compute the adjoint of the function and then just add in a `real`  call at the end.\n• Manually write out the `rrule` and then adding a `real` at the end.\nCurrently I'm doing (2) because I was thinking this was also a good opportunity to move the adjoint definitions for `ifft` and `fft`, and it's relevatives, from Zygote to ChainRules.jl, but is there a better way?","user":"UHDNY2YMA","ts":"1615758974.343400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OkX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A quick quesh: I want to do "},{"type":"text","text":"ifft(fft(a) .+ fft(b))","style":{"code":true}},{"type":"text","text":" for two real vectors "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"b","style":{"code":true}},{"type":"text","text":". This composition is a real function but results in complex adjoints due to the pullback of "},{"type":"text","text":"ifft","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"fft","style":{"code":true}},{"type":"text","text":" . I want the adjoints to be "},{"type":"text","text":"real","style":{"italic":true}},{"type":"text","text":" given that this function is indeed real for real inputs.\n\nRight now made this composition into a method and then I define the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" for this method, which is either:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Using Zygote to compute the adjoint of the function and then just add in a "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":"  call at the end."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Manually write out the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" and then adding a "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" at the end."}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Currently I'm doing (2) because I was thinking this was also a good opportunity to move the adjoint definitions for "},{"type":"text","text":"ifft","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"fft","style":{"code":true}},{"type":"text","text":", and it's relevatives, from Zygote to ChainRules.jl, but is there a better way?"}]}]}]},{"client_msg_id":"87049932-dd76-4fbb-9baf-31d576e426af","type":"message","text":"An rrule derivation question (tldr; are there useful trace identities/tricks for arbitrary einstein summations? Other recommended ways to derive the pullback from the pushforward?):\nI have derived and implemented a working `frule` for an equation, as follows:\n• `Ω(P, Q) = sqrt(P * Q)`\n• using `Ω^2 = P*Q`, derive `Ω̇ Ω + Ω Ω̇ = Ṗ Q + P Q̇`\n• From a previous calculation, I have the eigenvectors `ϕ` and eigenvalues `q` (denoted by a diagonal matrix `Λ`)\n• So, `Ω̇ = ϕ Y ϕ^-1`  for some `Y`, we can derive `Y` by nothing the eigenvectors/values and putting in the above equations `ΛY + YΛ = ϕ^-1 (Ṗ Q + P Q̇) ϕ` . Because these are diagonal matrices, this Sylvester equation reduces to `Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)`\nThis is all fantastic and I can verify my forward equation works, I'm re-using my eigenvectors, everything is swell.\n\nBut I am having difficulty deriving the `rrule`, at least according to the  \"match trace expressions\" trick. The sticking point here is `Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)` . I need to move the `Ṗ`  and `Q̇` to the end within the overall expression, but because of the denominator here I can't use the cyclic property of the trace. Is there a different tack I should take to this problem? Or is there some trace identity that is useful here? Any recommendations I should look into?","user":"UETJU4TG8","ts":"1615770363.356500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8sjH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"An rrule derivation question (tldr; are there useful trace identities/tricks for arbitrary einstein summations? Other recommended ways to derive the pullback from the pushforward?):\nI have derived and implemented a working "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" for an equation, as follows:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ω(P, Q) = sqrt(P * Q)","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"using "},{"type":"text","text":"Ω^2 = P*Q","style":{"code":true}},{"type":"text","text":", derive "},{"type":"text","text":"Ω̇ Ω + Ω Ω̇ = Ṗ Q + P Q̇","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"From a previous calculation, I have the eigenvectors "},{"type":"text","text":"ϕ","style":{"code":true}},{"type":"text","text":" and eigenvalues "},{"type":"text","text":"q","style":{"code":true}},{"type":"text","text":" (denoted by a diagonal matrix "},{"type":"text","text":"Λ","style":{"code":true}},{"type":"text","text":")"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So, "},{"type":"text","text":"Ω̇ = ϕ Y ϕ^-1","style":{"code":true}},{"type":"text","text":"  for some "},{"type":"text","text":"Y","style":{"code":true}},{"type":"text","text":", we can derive "},{"type":"text","text":"Y","style":{"code":true}},{"type":"text","text":" by nothing the eigenvectors/values and putting in the above equations "},{"type":"text","text":"ΛY + YΛ = ϕ^-1 (Ṗ Q + P Q̇) ϕ","style":{"code":true}},{"type":"text","text":" . Because these are diagonal matrices, this Sylvester equation reduces to "},{"type":"text","text":"Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)","style":{"code":true}}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"This is all fantastic and I can verify my forward equation works, I'm re-using my eigenvectors, everything is swell.\n\nBut I am having difficulty deriving the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":", at least according to the  \"match trace expressions\" trick. The sticking point here is "},{"type":"text","text":"Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)","style":{"code":true}},{"type":"text","text":" . I need to move the "},{"type":"text","text":"Ṗ","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"Q̇","style":{"code":true}},{"type":"text","text":" to the end within the overall expression, but because of the denominator here I can't use the cyclic property of the trace. Is there a different tack I should take to this problem? Or is there some trace identity that is useful here? Any recommendations I should look into?"}]}]}],"thread_ts":"1615770363.356500","reply_count":4,"reply_users_count":2,"latest_reply":"1615772569.357400","reply_users":["UHDQQ4GN6","UETJU4TG8"],"subscribed":false},{"client_msg_id":"a7ffe153-3f2c-4df0-a1ce-faf783258a60","type":"message","text":"If I have a NN `N(x,p)` where `x` are the input variables and `p` the NN weights (e.g, `N = FastChain(...)` defined through DiffEqFlux.jl and co.). How do I (efficiently) access the derivatives of `N` with respect to `x` and `p`? I quickly looked through Flux.jl docs but could find the answer. My understanding is that the training functions use Zygote under the hood. But maybe I should use Zygote explicitly? Also maybe I'm missing something important so please be gentle! :slightly_smiling_face:","user":"UB197FRCL","ts":"1615963102.004400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i=q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I have a NN "},{"type":"text","text":"N(x,p)","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" are the input variables and "},{"type":"text","text":"p","style":{"code":true}},{"type":"text","text":" the NN weights (e.g, "},{"type":"text","text":"N = FastChain(...)","style":{"code":true}},{"type":"text","text":" defined through DiffEqFlux.jl and co.). How do I (efficiently) access the derivatives of "},{"type":"text","text":"N","style":{"code":true}},{"type":"text","text":" with respect to "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"p","style":{"code":true}},{"type":"text","text":"? I quickly looked through Flux.jl docs but could find the answer. My understanding is that the training functions use Zygote under the hood. But maybe I should use Zygote explicitly? Also maybe I'm missing something important so please be gentle! "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1615963102.004400","reply_count":3,"reply_users_count":2,"latest_reply":"1615964994.006000","reply_users":["U6BJ9E351","UB197FRCL"],"subscribed":false},{"client_msg_id":"194338cc-290f-4fb7-968f-026dbf17eb24","type":"message","text":"I'm currently trying to use `DiffResults`  with `ForwardDiff` to evaluate my primal values and derivatives in one go. The issue is that the function which computes the primal values takes lots of inputs and provides lots of outputs, mostly of different types (as tuples). I only want the Jacobian for a certain subset of the inputs and outputs (which are processed as arrays to work with `ForwardDiff`). What's the most efficient way of processing such a case? I've used a closure for the subset of the inputs, but that only returns the relevant subset of the outputs, of course.","user":"U01G1P8A46S","ts":"1615963583.005200","team":"T68168MUP","edited":{"user":"U01G1P8A46S","ts":"1615963842.000000"},"blocks":[{"type":"rich_text","block_id":"46VT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm currently trying to use "},{"type":"text","text":"DiffResults","style":{"code":true}},{"type":"text","text":"  with "},{"type":"text","text":"ForwardDiff","style":{"code":true}},{"type":"text","text":" to evaluate my primal values and derivatives in one go. The issue is that the function which computes the primal values takes lots of inputs and provides lots of outputs, mostly of different types (as tuples). I only want the Jacobian for a certain subset of the inputs and outputs (which are processed as arrays to work with "},{"type":"text","text":"ForwardDiff","style":{"code":true}},{"type":"text","text":"). What's the most efficient way of processing such a case? I've used a closure for the subset of the inputs, but that only returns the relevant subset of the outputs, of course."}]}]}]},{"client_msg_id":"d74b7dac-3651-48cc-b78d-0297647cdab1","type":"message","text":"Anyone know how to do adjoints for making a sparse diagonal matrix? Specifically I have  `(C + diag(p))x = b` (solve for x) that I want to autodiff (where p are some numbers generated by a NN). When I try I get `ERROR: Need an adjoint for constructor SparseMatrixCSC{Complex{Float64},Int64}`","user":"U0138UTB7A4","ts":"1616085234.011300","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1616085400.000000"},"blocks":[{"type":"rich_text","block_id":"xPO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyone know how to do adjoints for making a sparse diagonal matrix? Specifically I have  "},{"type":"text","text":"(C + diag(p))x = b","style":{"code":true}},{"type":"text","text":" (solve for x) that I want to autodiff (where p are some numbers generated by a NN). When I try I get "},{"type":"text","text":"ERROR: Need an adjoint for constructor SparseMatrixCSC{Complex{Float64},Int64}","style":{"code":true}}]}]}],"thread_ts":"1616085234.011300","reply_count":1,"reply_users_count":1,"latest_reply":"1616087546.012700","reply_users":["UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"8c65d16f-99cb-49e9-b414-a26cd417af1f","type":"message","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc","user":"U017D4RFTFC","ts":"1616086340.012400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bwy7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc"}]}]}],"thread_ts":"1616086340.012400","reply_count":1,"reply_users_count":1,"latest_reply":"1616087304.012500","reply_users":["UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"386539d5-1d9b-404f-b1a0-55d1b5080b8d","type":"message","text":"Hi,\n\nI am trying to use AD on an implicit PDE scheme. However, Ii observe MASSIVE memory consumption (~40Go). I am thus wondering if using ForwardDiff on `\\` solve for sparse matrices is legit?","user":"U7GQE9JP9","ts":"1616318369.025100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Ea","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi,\n\nI am trying to use AD on an implicit PDE scheme. However, Ii observe MASSIVE memory consumption (~40Go). I am thus wondering if using ForwardDiff on "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" solve for sparse matrices is legit?"}]}]}]},{"client_msg_id":"B37086F8-4329-4225-87D3-18B380584116","type":"message","text":"I think ForwardDiff doesn’t support sparse Jacobian","user":"U6788D83U","ts":"1616346510.027200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xxxLr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think ForwardDiff doesn’t support sparse Jacobian"}]}]}]},{"client_msg_id":"26ED9AB1-2D6E-4AED-988E-AACF292A90FC","type":"message","text":"Checkout SparseDiffTools.jl","user":"U6788D83U","ts":"1616346538.027700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vkn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Checkout SparseDiffTools.jl"}]}]}]},{"type":"message","subtype":"thread_broadcast","text":"This question has come up enough that it would be good if someone who understands why this is hard could do a short write-up somewhere that we could reference when it comes up again","user":"UHDQQ4GN6","ts":"1616387568.033800","thread_ts":"1616086340.012400","root":{"client_msg_id":"8c65d16f-99cb-49e9-b414-a26cd417af1f","type":"message","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc","user":"U017D4RFTFC","ts":"1616086340.012400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bwy7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc"}]}]}],"thread_ts":"1616086340.012400","reply_count":11,"reply_users_count":5,"latest_reply":"1616387568.033800","reply_users":["UHDQQ4GN6","U011ZPCEL2E","U6BJ9E351","U6A936746","ULD19UCPK"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"iTy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This question has come up enough that it would be good if someone who understands why this is hard could do a short write-up somewhere that we could reference when it comes up again"}]}]}],"client_msg_id":"9faeea4a-9ea9-4dc6-8399-f208a47afb65"},{"type":"message","subtype":"thread_broadcast","text":"Here's a crack, although this isn't my area of expertise and could be too elementary / wrong / etc.\n\n```arr = collect(1:3)\nout1 = @view arr[1:2]\nout2 = @view arr[2:3]\n\n@. out1 = arr[1:2] + arr[2:3]\nout1_copy = copy(out1)\n\n@. out2 = out1 * arr[2:3]\n\nprintln(out1 == out1_copy) # false```\nIn reverse mode AD, I believe usually frameworks cache things like `out1`  for the reverse pass, but the overlapping memory regions (aliasing) foil that. Put another way, even if AD worked for individual `set_index!`  calls, you can't guarantee chains of multiple `set_index!` will work. In general you may not know what regions overlap until runtime (and in Julia, indexing like that is always effectively runtime, so that information isn't available to the compiler?).","user":"ULD19UCPK","ts":"1616393038.035900","thread_ts":"1616086340.012400","root":{"client_msg_id":"8c65d16f-99cb-49e9-b414-a26cd417af1f","type":"message","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc","user":"U017D4RFTFC","ts":"1616086340.012400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bwy7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc"}]}]}],"thread_ts":"1616086340.012400","reply_count":12,"reply_users_count":5,"latest_reply":"1616393038.035900","reply_users":["UHDQQ4GN6","U011ZPCEL2E","U6BJ9E351","U6A936746","ULD19UCPK"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"Fsmy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here's a crack, although this isn't my area of expertise and could be too elementary / wrong / etc.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"arr = collect(1:3)\nout1 = @view arr[1:2]\nout2 = @view arr[2:3]\n\n@. out1 = arr[1:2] + arr[2:3]\nout1_copy = copy(out1)\n\n@. out2 = out1 * arr[2:3]\n\nprintln(out1 == out1_copy) # false"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nIn reverse mode AD, I believe usually frameworks cache things like "},{"type":"text","text":"out1","style":{"code":true}},{"type":"text","text":"  for the reverse pass, but the overlapping memory regions (aliasing) foil that. Put another way, even if AD worked for individual "},{"type":"text","text":"set_index!","style":{"code":true}},{"type":"text","text":"  calls, you can't guarantee chains of multiple "},{"type":"text","text":"set_index!","style":{"code":true}},{"type":"text","text":" will work. In general you may not know what regions overlap until runtime (and in Julia, indexing like that is always effectively runtime, so that information isn't available to the compiler?)."}]}]}],"client_msg_id":"f4c4ddee-c536-4803-9205-82b88ca8b7ae"},{"client_msg_id":"ee7d1ddb-e31c-46a0-a284-26413586915d","type":"message","text":"How do I check why Zygote isn't picking up one of my rrule ?\n\nI have a function\n\n```function (f::BatchFastDense)(x::AbstractArray{&lt;:Real,TA}, p::AbstractVector{&lt;:Real}) where {TA}```\nAn rrule:\n\n```ChainRulesCore.rrule(::typeof(BatchFastDense), x::AbstractArray{&lt;:Real,TA}, p::AbstractVector{&lt;:Real}) where {TA}```\nAnd it's just trying to differentiate the former automatically, without using my rule","user":"UKJSNT1QR","ts":"1616434669.041700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UoS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How do I check why Zygote isn't picking up one of my rrule ?\n\nI have a function\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function (f::BatchFastDense)(x::AbstractArray{<:Real,TA}, p::AbstractVector{<:Real}) where {TA}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"An rrule:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ChainRulesCore.rrule(::typeof(BatchFastDense), x::AbstractArray{<:Real,TA}, p::AbstractVector{<:Real}) where {TA}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"And it's just trying to differentiate the former automatically, without using my rule"}]}]}],"thread_ts":"1616434669.041700","reply_count":6,"reply_users_count":2,"latest_reply":"1616436832.048000","reply_users":["UHDQQ4GN6","U6A936746"],"subscribed":false},{"client_msg_id":"3bd716cb-98c6-4b02-a504-7ce4d6544792","type":"message","text":"ForwardDiff does not use ChainRules right?","user":"U7QLM6E2E","ts":"1616435031.043700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oAbAg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ForwardDiff does not use ChainRules right?"}]}]}],"thread_ts":"1616435031.043700","reply_count":12,"reply_users_count":5,"latest_reply":"1616436690.047800","reply_users":["UHDQQ4GN6","U7QLM6E2E","U6PQP41C3","UKG4WF8PJ","U82RE6STE"],"subscribed":false},{"type":"message","text":"","user":"UKJSNT1QR","ts":"1616451950.049900","team":"T68168MUP","attachments":[{"fallback":"[March 22nd, 2021 11:25 PM] guillaume_slack: I'm trying to make FastChain twice differentiable (it somehow mutates arrays)\n\nI rewrote FastChain as:\n\n```split_at(p, idx) = view(p, 1:idx), view(p, (idx+1):lastindex(p))\n\nfunction ChainRulesCore.rrule(\n  ::typeof(split_at),\n  p::AbstractVector{S},\n  idx::Int,\n  ) where S\n\n  function split_at_pullback(Δ)\n    return (\n      ChainRulesCore.NO_FIELDS,\n      ChainRulesCore.@thunk(vcat(Δ...)),\n      ChainRulesCore.NO_FIELDS,\n    )\n  end\n  split_at(p, idx), split_at_pullback\nend\n\napplychain(::Tuple{}, x, p) = x\n# applychain(fs::Tuple, x, p) = applychain(Base.tail(fs), first(fs)(x,p[1:paramlength(first(fs))]), p[(paramlength(first(fs))+1):end])\nfunction DiffEqFlux.applychain(fs::Tuple, x, p)\n  p₁, p₂ = split_at(p, DiffEqFlux.paramlength(first(fs)))\n  DiffEqFlux.applychain(Base.tail(fs), first(fs)(x, p₁), p₂)\nend\n(c::FastChain)(x,p) = applychain(c.layers, x, p)```\nYes it's ugly :slightly_smiling_face:\n\nIf I run:\n\n```nn = FastChain(\n    FastDense(1,2, selu),\n    FastDense(2,1),\n    )\np = initial_params(nnb)\n\nfunction ftest(p)\n    gz, back = Zygote.pullback(z -&gt; nn(z, p), rand(1, 100))\n    back(gz)[1]\nend\n\ny, back = Zygote.pullback(ftest, p)\nback(y)[1]```\nI get a stray `Zero()` . Any ideas ?\n\n```8-element Array{Any,1}:\n -4.961157245626697\n  4.776112584950887\n -3.0912947608064307\n  3.257924132096858\n -3.3781788944196873\n -2.207525737666333\n  3.504429379232563\n   Zero()```\n","ts":"1616451914.144000","author_id":"UKJSNT1QR","author_subname":"Guillaume Ausset","channel_id":"C7T968HRU","channel_name":"diffeq-bridged","is_msg_unfurl":true,"text":"I'm trying to make FastChain twice differentiable (it somehow mutates arrays)\n\nI rewrote FastChain as:\n\n```split_at(p, idx) = view(p, 1:idx), view(p, (idx+1):lastindex(p))\n\nfunction ChainRulesCore.rrule(\n  ::typeof(split_at),\n  p::AbstractVector{S},\n  idx::Int,\n  ) where S\n\n  function split_at_pullback(Δ)\n    return (\n      ChainRulesCore.NO_FIELDS,\n      ChainRulesCore.@thunk(vcat(Δ...)),\n      ChainRulesCore.NO_FIELDS,\n    )\n  end\n  split_at(p, idx), split_at_pullback\nend\n\napplychain(::Tuple{}, x, p) = x\n# applychain(fs::Tuple, x, p) = applychain(Base.tail(fs), first(fs)(x,p[1:paramlength(first(fs))]), p[(paramlength(first(fs))+1):end])\nfunction DiffEqFlux.applychain(fs::Tuple, x, p)\n  p₁, p₂ = split_at(p, DiffEqFlux.paramlength(first(fs)))\n  DiffEqFlux.applychain(Base.tail(fs), first(fs)(x, p₁), p₂)\nend\n(c::FastChain)(x,p) = applychain(c.layers, x, p)```\nYes it's ugly :slightly_smiling_face:\n\nIf I run:\n\n```nn = FastChain(\n    FastDense(1,2, selu),\n    FastDense(2,1),\n    )\np = initial_params(nnb)\n\nfunction ftest(p)\n    gz, back = Zygote.pullback(z -&gt; nn(z, p), rand(1, 100))\n    back(gz)[1]\nend\n\ny, back = Zygote.pullback(ftest, p)\nback(y)[1]```\nI get a stray `Zero()` . Any ideas ?\n\n```8-element Array{Any,1}:\n -4.961157245626697\n  4.776112584950887\n -3.0912947608064307\n  3.257924132096858\n -3.3781788944196873\n -2.207525737666333\n  3.504429379232563\n   Zero()```\n","author_name":"Guillaume Ausset","author_link":"https://julialang.slack.com/team/UKJSNT1QR","author_icon":"https://secure.gravatar.com/avatar/c5dd30fc1b0aef08b78070922fa53118.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0005-48.png","mrkdwn_in":["text"],"color":"D0D0D0","from_url":"https://julialang.slack.com/archives/C7T968HRU/p1616451914144000","is_share":true,"footer":"Posted in #diffeq-bridged"}]},{"client_msg_id":"ca1d8ad0-a8ba-4f8c-8189-c829825eb388","type":"message","text":"Is there a canonical, \"best practices\" example/source for second-order AD using e.g. forward-over-reverse with whatever permutation of AD libraries is most idiomatic? Trying to determine this manually is beyond my ability, so having a authoritative link to drop would help quite a bit.","user":"UMY1LV01G","ts":"1616649126.057600","team":"T68168MUP","edited":{"user":"UMY1LV01G","ts":"1616649142.000000"},"blocks":[{"type":"rich_text","block_id":"Ad07N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a canonical, \"best practices\" example/source for second-order AD using e.g. forward-over-reverse with whatever permutation of AD libraries is most idiomatic? Trying to determine this manually is beyond my ability, so having a authoritative link to drop would help quite a bit."}]}]}]},{"client_msg_id":"477423ac-fda0-443f-9cd8-450388524e01","type":"message","text":"First do first order AD using Zygote or ReverseDiff and compare against finite difference. Choose the faster. Then use ForwardDiff over whichever you choose to get the Hessian and also verify it against finite difference.","user":"U85JBUGGP","ts":"1616655461.058800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r/fNt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"First do first order AD using Zygote or ReverseDiff and compare against finite difference. Choose the faster. Then use ForwardDiff over whichever you choose to get the Hessian and also verify it against finite difference."}]}]}]},{"client_msg_id":"a037a7db-3ecd-4ded-b01f-4815996145cd","type":"message","text":"if I'm ADing back through a function that uses a for loop to index into an array is it faster to rewrite it as a `mapreduce`?","user":"ULA52A5B5","ts":"1616685915.067000","team":"T68168MUP","edited":{"user":"ULA52A5B5","ts":"1616685939.000000"},"blocks":[{"type":"rich_text","block_id":"=4UXp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if I'm ADing back through a function that uses a for loop to index into an array is it faster to rewrite it as a "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1616685915.067000","reply_count":3,"reply_users_count":2,"latest_reply":"1616689269.068300","reply_users":["ULA52A5B5","U6A936746"],"is_locked":false,"subscribed":false},{"client_msg_id":"9bb3b39f-906a-4cd0-9560-45daaa610907","type":"message","text":"Hi Folks, was wondering if I could pick y'alls brains on how to do autodiff with our code packages for RL and control. Our higher level code is structured similar to a Markov decision process where we have functions like `setstate`, `getobs`, or `step`, which abstracts away the lower level dynamics (i.e. how does the state evolve). Everything works great if we define the dynamics in Julia, but the complication is that for a lot of deepRL for robotics, the lower level dynamics is handled by a physics simulator not implemented in Julia (in our case <http://mujoco.org/|MuJoCo> which is the standard currently). The following is an example of what I used before for a neuralODE project where we learn policy parameters\n\n```function f(u,p,t)\n    # env is a struct, in the following, representing the dynamical environment\n    setstate(env, u[1:end-1])\n    o = getobs(env)\n    a = policy(o, p) # handled by something like flux if using a neural network\n    setaction!(env, a)\n  \n    du = _dustep!(env)\n    cost = -getreward(env)\n\n    vcat(du..., cost)\nend```\nYou can see that if `env` is a julia struct that has vectors to store the state, action, etc., everything is great. However, if `env` contains references to c-structs in an external library such as in the case with MuJoCo, we have a problem. For example, `getobs` might grab some values from the referenced c-structs, but should return a pullback representing `d-obs/d-state` ostensibly. Moving forward, it would be nice to define `rrules` for the above functions (`getobs`etc.) but *one issue* I face is that in code most functions have `env` as an input, but mathematically, we are differentiating w.r.t. state/actions that are not fields in `env` due to state/action being in the c-library -- even if we did make them fields, we would need to know how the simulator changes the fields, so that's a no-go, unless I can prompt autodiff to specify the function's inputs and outputs differently. MuJoCo was designed for finite-differencing, so we can efficiently differentiate forward and inverse dynamics, (as well as observations, rewards, etc.) so there's no problem there (this also has to be done manually since there's quaternions to deal with).\n\nThe way I got around this before was to define an adjoint for the whole function `f` and that was fine, but lacked re-use and flexibility. That let me write the adjoint for `f(u,p,t)`  inputs directly, but I'd like to give folks more options in the future. Any advice would be appreciated!","user":"U9NH09E58","ts":"1616699578.087300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cqP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi Folks, was wondering if I could pick y'alls brains on how to do autodiff with our code packages for RL and control. Our higher level code is structured similar to a Markov decision process where we have functions like "},{"type":"text","text":"setstate","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":", or "},{"type":"text","text":"step","style":{"code":true}},{"type":"text","text":", which abstracts away the lower level dynamics (i.e. how does the state evolve). Everything works great if we define the dynamics in Julia, but the complication is that for a lot of deepRL for robotics, the lower level dynamics is handled by a physics simulator not implemented in Julia (in our case "},{"type":"link","url":"http://mujoco.org/","text":"MuJoCo"},{"type":"text","text":" which is the standard currently). The following is an example of what I used before for a neuralODE project where we learn policy parameters\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f(u,p,t)\n    # env is a struct, in the following, representing the dynamical environment\n    setstate(env, u[1:end-1])\n    o = getobs(env)\n    a = policy(o, p) # handled by something like flux if using a neural network\n    setaction!(env, a)\n  \n    du = _dustep!(env)\n    cost = -getreward(env)\n\n    vcat(du..., cost)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"You can see that if "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" is a julia struct that has vectors to store the state, action, etc., everything is great. However, if "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" contains references to c-structs in an external library such as in the case with MuJoCo, we have a problem. For example, "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":" might grab some values from the referenced c-structs, but should return a pullback representing "},{"type":"text","text":"d-obs/d-state","style":{"code":true}},{"type":"text","text":" ostensibly. Moving forward, it would be nice to define "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for the above functions ("},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":"etc.) but "},{"type":"text","text":"one issue","style":{"bold":true}},{"type":"text","text":" I face is that in code most functions have "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" as an input, but mathematically, we are differentiating w.r.t. state/actions that are not fields in "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" due to state/action being in the c-library -- even if we did make them fields, we would need to know how the simulator changes the fields, so that's a no-go, unless I can prompt autodiff to specify the function's inputs and outputs differently. MuJoCo was designed for finite-differencing, so we can efficiently differentiate forward and inverse dynamics, (as well as observations, rewards, etc.) so there's no problem there (this also has to be done manually since there's quaternions to deal with).\n\nThe way I got around this before was to define an adjoint for the whole function "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" and that was fine, but lacked re-use and flexibility. That let me write the adjoint for "},{"type":"text","text":"f(u,p,t)","style":{"code":true}},{"type":"text","text":"  inputs directly, but I'd like to give folks more options in the future. Any advice would be appreciated!"}]}]}],"thread_ts":"1616699578.087300","reply_count":2,"reply_users_count":1,"latest_reply":"1616700422.087700","reply_users":["U6A936746"],"is_locked":false,"subscribed":false},{"client_msg_id":"de9f9a01-75ad-4a13-9240-ff0ba37be208","type":"message","text":"Say I have a sequence of numbers (x_1, ... x_7) and I want to form the polynomial (x_7 t + (x_6 x_1 + x_5 x_2 + x_4 x_3) t^2 + (x_1 x_2 x_4) t^3) (i.e. all the coefficients sum to 7 and it the power of the polynomial tells you how many you have). What's the algebraic name for that. I know I've seen the construction before, but my memory is failing me. It's probably some sort of exterior algebra inner product.","user":"U674T3KB3","ts":"1616723346.091500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"weM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Say I have a sequence of numbers (x_1, ... x_7) and I want to form the polynomial (x_7 t + (x_6 x_1 + x_5 x_2 + x_4 x_3) t^2 + (x_1 x_2 x_4) t^3) (i.e. all the coefficients sum to 7 and it the power of the polynomial tells you how many you have). What's the algebraic name for that. I know I've seen the construction before, but my memory is failing me. It's probably some sort of exterior algebra inner product."}]}]}]},{"client_msg_id":"bfac4bbe-8df4-4225-b7c2-794de6769be6","type":"message","text":"Ask <@U6EA05EA3> directly?","user":"U67461GUB","ts":"1616723562.091800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ayHG+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ask "},{"type":"user","user_id":"U6EA05EA3"},{"type":"text","text":" directly?"}]}]}]},{"client_msg_id":"19d7ed0b-7508-4b86-8f68-d43411a79e8e","type":"message","text":"yeah, will do. Was hoping somebody could just tell me flat out","user":"U674T3KB3","ts":"1616723743.092200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HwQHY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, will do. Was hoping somebody could just tell me flat out"}]}]}]},{"client_msg_id":"64062237-6786-41db-872a-32dbeaf9c259","type":"message","text":"Hm, it's not clear to me that there's an exterior structure here","user":"U8D9768Q6","ts":"1616724331.092700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pvtz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hm, it's not clear to me that there's an exterior structure here"}]}]}]},{"client_msg_id":"75c91c8f-fb39-4a80-8495-1b738812ffa4","type":"message","text":"However, I think if you look at this `x_i` as carrying units of `[t]^-i` then this is a homogeneous polynomial","user":"U8D9768Q6","ts":"1616724399.093900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xAr1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"However, I think if you look at this "},{"type":"text","text":"x_i","style":{"code":true}},{"type":"text","text":" as carrying units of "},{"type":"text","text":"[t]^-i","style":{"code":true}},{"type":"text","text":" then this is a homogeneous polynomial"}]}]}]},{"client_msg_id":"eafb63c2-fb6f-47dd-9237-852633e608bd","type":"message","text":"I get what you're going for, but in that construction aren't each of the terms homogeneous, but the overall polynomial is not?","user":"U674T3KB3","ts":"1616724827.094400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kamCL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I get what you're going for, but in that construction aren't each of the terms homogeneous, but the overall polynomial is not?"}]}]}]},{"client_msg_id":"d2d4451d-bdc3-4623-819f-a01a637910df","type":"message","text":"It's some sort of diagonal operation on a grading. i.e. x_{1..7} -&gt; (x_1 t, x_2 t, x_1 x_2 t^2 + x_3t, ...) and the 7th component thereof","user":"U674T3KB3","ts":"1616724983.097100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F0GV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's some sort of diagonal operation on a grading. i.e. x_{1..7} -> (x_1 t, x_2 t, x_1 x_2 t^2 + x_3t, ...) and the 7th component thereof"}]}]}]},{"client_msg_id":"a181d595-0c42-461b-9b54-8a853e39fdd5","type":"message","text":"Oh right, yes. So maybe this can be viewed as a construction where you take the 7 independent  homogeneous polynomials and then form a polynomial out of that? Except here the coeffis of the sub-polyonomials are 1. :thinking_face:","user":"U8D9768Q6","ts":"1616724991.097300","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1616725028.000000"},"blocks":[{"type":"rich_text","block_id":"aPwU/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh right, yes. So maybe this can be viewed as a construction where you take the 7 independent  homogeneous polynomials and then form a polynomial out of that? Except here the coeffis of the sub-polyonomials are 1. "},{"type":"emoji","name":"thinking_face"}]}]}]},{"client_msg_id":"ffe3f93b-a50f-48ee-bee5-407c9e58810f","type":"message","text":"I'm sure I've seen the construction before","user":"U674T3KB3","ts":"1616724992.097500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+=sh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm sure I've seen the construction before"}]}]}]},{"client_msg_id":"9c8ac2ca-31bb-4a80-9e11-6d0cb64cfeb8","type":"message","text":"I feel like this is somehow connected to <https://en.wikipedia.org/wiki/Vandermonde_matrix> It's like the trace of a slightly different structure","user":"U8D9768Q6","ts":"1616725150.097900","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1616725187.000000"},"blocks":[{"type":"rich_text","block_id":"fNs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I feel like this is somehow connected to "},{"type":"link","url":"https://en.wikipedia.org/wiki/Vandermonde_matrix"},{"type":"text","text":" It's like the trace of a slightly different structure"}]}]}]},{"client_msg_id":"f23b265a-0dc9-4482-b8fb-62dbe9c9cbd4","type":"message","text":"Can I trust `@code_warntype` when using Zygote code ? My results are full of `Any` and `Union{Nothing, Tuple}`\n\nAnd if it's accurate, how do I prevent return types of Any","user":"UKJSNT1QR","ts":"1616753033.099200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sBFV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can I trust "},{"type":"text","text":"@code_warntype","style":{"code":true}},{"type":"text","text":" when using Zygote code ? My results are full of "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Union{Nothing, Tuple}","style":{"code":true}},{"type":"text","text":"\n\nAnd if it's accurate, how do I prevent return types of Any"}]}]}]}]}