{"cursor": 0, "messages": [{"type":"message","subtype":"channel_join","ts":"1609249273.000200","user":"U67BJLYCS","text":"<@U67BJLYCS> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609249323.000400","user":"UN3KKRCRJ","text":"<@UN3KKRCRJ> has joined the channel","inviter":"U67BJLYCS"},{"type":"message","subtype":"channel_join","ts":"1609249333.000600","user":"UKA81L34J","text":"<@UKA81L34J> has joined the channel","inviter":"U67BJLYCS","reactions":[{"name":"heart","users":["UKA81L34J"],"count":1}]},{"type":"message","subtype":"channel_join","ts":"1609249463.000800","user":"UQWRPDJ68","text":"<@UQWRPDJ68> has joined the channel"},{"client_msg_id":"c6ebe306-1357-4d50-90e1-f4fe027d2165","type":"message","text":"Great ! Well can I ask non julia specific enzyme questions here too ?","user":"UQWRPDJ68","ts":"1609249492.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/ci","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Great ! Well can I ask non julia specific enzyme questions here too ?"}]}]}]},{"client_msg_id":"1bb786ba-05a9-4085-b170-6c659a016b31","type":"message","text":"Yes please do :)","user":"U67BJLYCS","ts":"1609249512.001900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6Etn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes please do :)"}]}]}]},{"client_msg_id":"fd0eb774-55be-4a4a-8d1e-63214255a0c5","type":"message","text":"There is also an enzyme mailing list","user":"U67BJLYCS","ts":"1609249523.002600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ecx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is also an enzyme mailing list"}]}]}]},{"client_msg_id":"f5495ad1-08d5-4f3b-b155-d98291d94009","type":"message","text":"I'm a bit of a noob in how the internals of C , compiled libraries abi etc work , but I was wondering if I could get the functions in math.h differentiated by enzyme\nNow I suppose the linker links in statically compiled code and enzyme can't AD already compiled code","user":"UQWRPDJ68","ts":"1609249736.006600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lVQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm a bit of a noob in how the internals of C , compiled libraries abi etc work , but I was wondering if I could get the functions in math.h differentiated by enzyme\nNow I suppose the linker links in statically compiled code and enzyme can't AD already compiled code"}]}]}]},{"client_msg_id":"11911EE8-DC55-4112-B28E-8EB29EA090CA","type":"message","text":"I think unfortunately you have to annotate your code with the special call, then run it through LLVM bitcodegen and opt. If it’s already compiled to a shared or static lib it’s too late ?","user":"UKA81L34J","ts":"1609250083.013200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZNtQP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think unfortunately you have to annotate your code with the special call, then run it through LLVM bitcodegen and opt. If it’s already compiled to a shared or static lib it’s too late ?"}]}]}]},{"client_msg_id":"8D477D30-6678-471C-ABF5-4E2EA564B676","type":"message","text":"I don’t see why you couldn’t re-compile the standard lib (libc) with clang though and get derivatives out.","user":"UKA81L34J","ts":"1609250198.014100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"is0w","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t see why you couldn’t re-compile the standard lib (libc) with clang though and get derivatives out."}]}]}]},{"client_msg_id":"b634f7f1-ba56-4d89-a729-0b40bbdf38fc","type":"message","text":"Okay , yes I guess  it's too late once already compiled , I'll need the source for cmath and generate IR ;\nI saw some discussion about ADing legacy weather model code in the mailing list and was curious about how to AD the standard libs","user":"UQWRPDJ68","ts":"1609250694.014200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KWCDJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Okay , yes I guess  it's too late once already compiled , I'll need the source for cmath and generate IR ;\nI saw some discussion about ADing legacy weather model code in the mailing list and was curious about how to AD the standard libs"}]}]}]},{"client_msg_id":"e38ee81d-83b4-4aab-86fd-3b14939f93f3","type":"message","text":"in that case I think they have access to source and compilation pipeline.","user":"UKA81L34J","ts":"1609252044.000500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IhlW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"in that case I think they have access to source and compilation pipeline."}]}]}]},{"client_msg_id":"f8a13af2-2877-4fe0-b421-ffdea91ae5d3","type":"message","text":"Yeah, normally we just define the adjoint for the standard math functions","user":"U67BJLYCS","ts":"1609253030.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ip5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, normally we just define the adjoint for the standard math functions"}]}]}]},{"client_msg_id":"ef39b309-4d8b-4bfe-996b-3c402cee7159","type":"message","text":"<@UN3KKRCRJ>","user":"U67BJLYCS","ts":"1609253038.001900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sQ+p","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UN3KKRCRJ"}]}]}]},{"client_msg_id":"29263B4F-D90A-4AAE-AF83-3F9F169D8814","type":"message","text":"So you should never need to compile libc or define a custom adjoint for as we handle all the standard math llvm intrinsics","user":"UN3KKRCRJ","ts":"1609253494.002900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o6sK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So you should never need to compile libc or define a custom adjoint for as we handle all the standard math llvm intrinsics"}]}]}]},{"client_msg_id":"0D0570B6-53AD-4A49-902D-B1B994C7EEA2","type":"message","text":"If you see the need to AD an undefined math function you probably need to add ffast-math to make sure they get lowered","user":"UN3KKRCRJ","ts":"1609253523.003900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VOo76","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you see the need to AD an undefined math function you probably need to add ffast-math to make sure they get lowered"}]}]}]},{"client_msg_id":"5B6FFC5E-906D-4E15-9B16-5DB7D0B1545A","type":"message","text":"We should probably both document this and just automatically do this translation","user":"UN3KKRCRJ","ts":"1609253537.004400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tr/2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We should probably both document this and just automatically do this translation"}]}]}]},{"client_msg_id":"018bf0d3-5d7a-4256-a587-75044836b4d0","type":"message","text":"Oh alright  , \ncmath standalone isn't a good example then , perhaps something like GSL ,\nGSL would have calls to cmath in multiple places throughout the source right ? Or any other library calling cmath for that matter would still require cmath to be Differentiated right?","user":"UQWRPDJ68","ts":"1609253957.008400","team":"T68168MUP","edited":{"user":"UQWRPDJ68","ts":"1609253980.000000"},"blocks":[{"type":"rich_text","block_id":"hdkC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh alright  , \ncmath standalone isn't a good example then , perhaps something like GSL ,\nGSL would have calls to cmath in multiple places throughout the source right ? Or any other library calling cmath for that matter would still require cmath to be Differentiated right?"}]}]}]},{"client_msg_id":"8C1325D9-E8ED-4FC2-8E3A-18F7E5CA781C","type":"message","text":"So Enzyme predefines derivatives for llvm functions and specific common functions, if you compile something that just uses those instructions you’re immediately good to go, if you call a library you’d want to make sure that the IR of that library is available for Enzyme to AD through (by say enabling embedded big code or LTO), any code called by that library would have to follow the same rules (either just be standard instructions or have code it’s called be available)","user":"UN3KKRCRJ","ts":"1609254514.012600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"otUB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So Enzyme predefines derivatives for llvm functions and specific common functions, if you compile something that just uses those instructions you’re immediately good to go, if you call a library you’d want to make sure that the IR of that library is available for Enzyme to AD through (by say enabling embedded big code or LTO), any code called by that library would have to follow the same rules (either just be standard instructions or have code it’s called be available)"}]}]}]},{"type":"message","subtype":"channel_join","ts":"1609261288.013000","user":"U6A936746","text":"<@U6A936746> has joined the channel"},{"type":"message","subtype":"channel_purpose","ts":"1609261306.013100","user":"U6A936746","text":"<@U6A936746> set the channel purpose: see also <#C6G240ENA|autodiff>","purpose":"see also <#C6G240ENA|autodiff>"},{"type":"message","subtype":"channel_purpose","ts":"1609261345.013200","user":"U6A936746","text":"<@U6A936746> set the channel purpose: see also <#C6G240ENA|autodiff> for AD more generally","purpose":"see also <#C6G240ENA|autodiff> for AD more generally"},{"client_msg_id":"31c65850-6051-49fe-aed8-f9e91a418a78","type":"message","text":":oxinabox:","user":"UKA81L34J","ts":"1609261466.013400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k4Aea","elements":[{"type":"rich_text_section","elements":[{"type":"emoji","name":"oxinabox"}]}]}],"reactions":[{"name":"jarrett","users":["UKA81L34J"],"count":1}]},{"type":"message","subtype":"channel_join","ts":"1609261583.013700","user":"U69BL50BF","text":"<@U69BL50BF> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609261616.013900","user":"UM8JUNJG7","text":"<@UM8JUNJG7> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609261786.014100","user":"UDXST8ARK","text":"<@UDXST8ARK> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609262218.014300","user":"U693UD6V7","text":"<@U693UD6V7> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609262938.014500","user":"UC6SUUPRC","text":"<@UC6SUUPRC> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609264926.014700","user":"UJ7DVTVQ8","text":"<@UJ7DVTVQ8> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609266738.017000","user":"U8D9768Q6","text":"<@U8D9768Q6> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609269483.017200","user":"UEN48T0BT","text":"<@UEN48T0BT> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609269599.017400","user":"U82RE6STE","text":"<@U82RE6STE> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609269980.017600","user":"UHDQQ4GN6","text":"<@UHDQQ4GN6> has joined the channel"},{"client_msg_id":"02ED3E69-1031-4E09-B272-708D408499A0","type":"message","text":"I was chatting with <@U674T0Y9Z> about this last night - but why not provide two levels of AD to Julia ? \n\nThe lowest level is something like Enzyme (e.g. a really robust scalar AD which can handle mostly everything) and then a mid level AD which operates at the IRCode or MLIR (e.g. Brutus) but can faithfully represent high-level mathematical features of code (like BLAS adjoints or something)","user":"UKA81L34J","ts":"1609273282.020700","team":"T68168MUP","edited":{"user":"UKA81L34J","ts":"1609273300.000000"},"blocks":[{"type":"rich_text","block_id":"22FPL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was chatting with "},{"type":"user","user_id":"U674T0Y9Z"},{"type":"text","text":" about this last night - but why not provide two levels of AD to Julia ? \n\nThe lowest level is something like Enzyme (e.g. a really robust scalar AD which can handle mostly everything) and then a mid level AD which operates at the IRCode or MLIR (e.g. Brutus) but can faithfully represent high-level mathematical features of code (like BLAS adjoints or something)"}]}]}]},{"type":"message","subtype":"channel_join","ts":"1609273286.020900","user":"U674T0Y9Z","text":"<@U674T0Y9Z> has joined the channel","inviter":"UKA81L34J","reactions":[{"name":"wave","users":["U674T0Y9Z","U6A936746"],"count":2}]},{"client_msg_id":"0640D2B2-69F0-4653-86C9-82CB191405DA","type":"message","text":"Or perhaps that is how Diffractor and Enzyme will combine","user":"UKA81L34J","ts":"1609273313.021500","team":"T68168MUP","edited":{"user":"UKA81L34J","ts":"1609273319.000000"},"blocks":[{"type":"rich_text","block_id":"rs6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or perhaps that is how Diffractor and Enzyme will combine"}]}]}]},{"client_msg_id":"43689510-a14d-4874-88f3-549cd8b938fe","type":"message","text":"Yeah that is basically how Billy and I think about Enzyme in Julia","user":"U67BJLYCS","ts":"1609273420.022500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ush","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah that is basically how Billy and I think about Enzyme in Julia"}]}]}]},{"client_msg_id":"D4CBBCCF-D747-44B7-BE87-898BE44D72F1","type":"message","text":"Wonderful - how you make the levels opaque to the user :p","user":"UKA81L34J","ts":"1609273479.023700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R7UMN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Wonderful - how you make the levels opaque to the user :p"}]}]}]},{"client_msg_id":"a7f976ec-5514-4772-86fe-cc3bd3131b39","type":"message","text":"There is in principle a Zygote integration already","user":"U67BJLYCS","ts":"1609273481.023900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"u7DB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is in principle a Zygote integration already"}]}]}]},{"client_msg_id":"160A33E4-A1A2-4827-B9A1-1AD517BBC437","type":"message","text":"Right","user":"UKA81L34J","ts":"1609273487.024100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ehE6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Right"}]}]}]},{"client_msg_id":"1ec4bcec-57c0-4479-b112-eb78426cd89b","type":"message","text":"Right the issue is the level of choice","user":"U67BJLYCS","ts":"1609273497.024500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GKikh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Right the issue is the level of choice"}]}]}]},{"client_msg_id":"2bc516f1-410d-440b-bb86-5ac243e9887f","type":"message","text":"And I know to little about the diverse AD infrastructure and people plans with it","user":"U67BJLYCS","ts":"1609273525.025300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oS4Rc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And I know to little about the diverse AD infrastructure and people plans with it"}]}]}]},{"client_msg_id":"7146b52b-74af-47f8-bb27-60f98fa8991b","type":"message","text":"I am not the person who will do a great unification ;)","user":"U67BJLYCS","ts":"1609273539.025900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B3la","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am not the person who will do a great unification ;)"}]}]}]},{"client_msg_id":"66B860D5-47A6-4BE7-A474-D444B8091167","type":"message","text":"Neither am I - but this is really cool. It seems like the time is fast approaching for really state of the art AD (like, better than anything else) for most Julia code","user":"UKA81L34J","ts":"1609273585.027000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sGO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Neither am I - but this is really cool. It seems like the time is fast approaching for really state of the art AD (like, better than anything else) for most Julia code"}]}]}]},{"client_msg_id":"f7086c62-c4a3-4896-9812-5e7757307449","type":"message","text":"The things I want to explore next is AD for GPU kernels (aka for KernelAbstractions)","user":"U67BJLYCS","ts":"1609273696.028100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8Nlj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The things I want to explore next is AD for GPU kernels (aka for KernelAbstractions)"}]}]}]},{"client_msg_id":"2829f70d-763a-4515-aea5-c364ba2aef94","type":"message","text":"And doing AD for dynamic code by calling back into Julia","user":"U67BJLYCS","ts":"1609273728.029000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pGHx9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And doing AD for dynamic code by calling back into Julia"}]}]}]},{"client_msg_id":"6fdf2ce1-2df4-4859-bf95-29bbcc49d482","type":"message","text":"But it would be cool if we could teach Enzyme about ChainRules","user":"U67BJLYCS","ts":"1609273798.029800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LeE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it would be cool if we could teach Enzyme about ChainRules"}]}]}],"reactions":[{"name":"chainrules","users":["U6A936746","UHDQQ4GN6"],"count":2}]},{"client_msg_id":"318ce5aa-86a4-4cb0-8ee5-0feca6b24c60","type":"message","text":"Oh and of course to provide more easily AD for foreign code","user":"U67BJLYCS","ts":"1609273849.030400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KnE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh and of course to provide more easily AD for foreign code"}]}]}]},{"client_msg_id":"5F48263F-6817-4E55-9735-4250D7891D46","type":"message","text":"Enzyme using chain rules would be amazing ","user":"U8D9768Q6","ts":"1609274301.030800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uuxT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Enzyme using chain rules would be amazing "}]}]}]},{"client_msg_id":"fd1cccbd-4d0a-4f5a-9342-16169beede4a","type":"message","text":"Alas I don't know how yet ;)","user":"U67BJLYCS","ts":"1609274545.031100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0Ea","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Alas I don't know how yet ;)"}]}]}]},{"type":"message","subtype":"channel_join","ts":"1609277722.031300","user":"UFMH09DAR","text":"<@UFMH09DAR> has joined the channel"},{"client_msg_id":"A1F7F142-B8F4-465A-8FCB-8201555939DB","type":"message","text":"<@UN3KKRCRJ> is the C API stabilized or undergoing changes for <https://github.com/wsmoses/Enzyme.jl/issues/26|https://github.com/wsmoses/Enzyme.jl/issues/26> ? Also are there usage examples of the C API ?","user":"UKA81L34J","ts":"1609304644.033600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C7Mdu","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UN3KKRCRJ"},{"type":"text","text":" is the C API stabilized or undergoing changes for "},{"type":"link","url":"https://github.com/wsmoses/Enzyme.jl/issues/26","text":"https://github.com/wsmoses/Enzyme.jl/issues/26"},{"type":"text","text":" ? Also are there usage examples of the C API ?"}]}]}]},{"type":"message","subtype":"channel_join","ts":"1609309174.033800","user":"UE6BDNM9B","text":"<@UE6BDNM9B> has joined the channel"},{"type":"message","subtype":"channel_join","ts":"1609327698.034100","user":"U01A08JMUKT","text":"<@U01A08JMUKT> has joined the channel"},{"client_msg_id":"4c915d9d-f589-43c7-ac03-5aa501a2e38f","type":"message","text":"so i was tryign to get some GSL functions AD'd\ni downloaded the GSL source and made sure to compile it with clang from Enzymes llvm\niv'e passed the embed bit code option.\n`make CFLAGS=-fembed-bitcode`\nis that sufficient ? can any code using this GSL now have AD on GSL functions ?\ni had a small trial , i wrote some code to differentiate the bessel function\n, clang is able to compile it to `.ll` however running opt on the `.ll` file gives me an error which im not able to understand or google ,\ncould i get some input on what i should be looking up or what im doing wrong ?.\n```opt input.ll -load=/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so -enzyme -o output.ll -S\nopt: /home/antineutrino/Enzyme/llvm/include/llvm/ADT/ilist_iterator.h:140: llvm::ilist_iterator::reference llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock, true, false, void&gt;, false, false&gt;::operator*() const [OptionsT = llvm::ilist_detail::node_options&lt;llvm::BasicBlock, true, false, void&gt;, IsReverse = false, IsConst = false]: Assertion `!NodePtr-&gt;isKnownSentinel()' failed.\nStack dump:\n0.\tProgram arguments: opt input.ll -load=/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so -enzyme -o output.ll -S \n1.\tRunning pass 'Enzyme Pass' on module 'input.ll'.\nLLVMSymbolizer: error reading file: No such file or directory\n#0 0x00000000014a8c64 (opt+0x14a8c64)\n#1 0x00000000014a69be (opt+0x14a69be)\n#2 0x00000000014a8e22 (opt+0x14a8e22)\n#3 0x00007f8af7c7a980 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x12980)\n#4 0x00007f8af6723fb7 gsignal /build/glibc-S9d2JN/glibc-2.27/signal/../sysdeps/unix/sysv/linux/raise.c:51:0\n#5 0x00007f8af6725921 abort /build/glibc-S9d2JN/glibc-2.27/stdlib/abort.c:81:0\n#6 0x00007f8af671548a __assert_fail_base /build/glibc-S9d2JN/glibc-2.27/assert/assert.c:89:0\n#7 0x00007f8af6715502 (/lib/x86_64-linux-gnu/libc.so.6+0x30502)\n#8 0x0000000000eb0c19 (opt+0xeb0c19)\n#9 0x00007f8af6317b98 llvm::DominatorTree::DominatorTree(llvm::Function&amp;) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x3cab98)\n#10 0x00007f8af63a5c96 TypeAnalyzer::TypeAnalyzer(FnTypeInfo const&amp;, TypeAnalysis&amp;, unsigned char) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x458c96)\n#11 0x00007f8af63cd353 TypeAnalysis::analyzeFunction(FnTypeInfo const&amp;) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x480353)\n#12 0x00007f8af625d890 HandleAutoDiff(llvm::CallInst*, llvm::TargetLibraryInfo&amp;, llvm::AAResults&amp;, bool) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x310890)\n#13 0x00007f8af625ffa7 lowerEnzymeCalls(llvm::Function&amp;, llvm::TargetLibraryInfo&amp;, llvm::AAResults&amp;, bool, bool&amp;) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x312fa7)\n#14 0x00007f8af625ece6 (anonymous namespace)::Enzyme::runOnModule(llvm::Module&amp;) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x311ce6)\n#15 0x0000000000f16623 (opt+0xf16623)\n#16 0x000000000063a2f1 (opt+0x63a2f1)\n#17 0x00007f8af6706bf7 __libc_start_main /build/glibc-S9d2JN/glibc-2.27/csu/../csu/libc-start.c:344:0\n#18 0x0000000000621daa (opt+0x621daa)\nAborted (core dumped) ```\n","user":"UQWRPDJ68","ts":"1609332553.043700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F=x+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so i was tryign to get some GSL functions AD'd\ni downloaded the GSL source and made sure to compile it with clang from Enzymes llvm\niv'e passed the embed bit code option.\n"},{"type":"text","text":"make CFLAGS=-fembed-bitcode","style":{"code":true}},{"type":"text","text":"\nis that sufficient ? can any code using this GSL now have AD on GSL functions ?\ni had a small trial , i wrote some code to differentiate the bessel function\n, clang is able to compile it to "},{"type":"text","text":".ll","style":{"code":true}},{"type":"text","text":" however running opt on the "},{"type":"text","text":".ll","style":{"code":true}},{"type":"text","text":" file gives me an error which im not able to understand or google ,\ncould i get some input on what i should be looking up or what im doing wrong ?.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"opt input.ll -load=/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so -enzyme -o output.ll -S\nopt: /home/antineutrino/Enzyme/llvm/include/llvm/ADT/ilist_iterator.h:140: llvm::ilist_iterator::reference llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::BasicBlock, true, false, void>, false, false>::operator*() const [OptionsT = llvm::ilist_detail::node_options<llvm::BasicBlock, true, false, void>, IsReverse = false, IsConst = false]: Assertion `!NodePtr->isKnownSentinel()' failed.\nStack dump:\n0.\tProgram arguments: opt input.ll -load=/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so -enzyme -o output.ll -S \n1.\tRunning pass 'Enzyme Pass' on module 'input.ll'.\nLLVMSymbolizer: error reading file: No such file or directory\n#0 0x00000000014a8c64 (opt+0x14a8c64)\n#1 0x00000000014a69be (opt+0x14a69be)\n#2 0x00000000014a8e22 (opt+0x14a8e22)\n#3 0x00007f8af7c7a980 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x12980)\n#4 0x00007f8af6723fb7 gsignal /build/glibc-S9d2JN/glibc-2.27/signal/../sysdeps/unix/sysv/linux/raise.c:51:0\n#5 0x00007f8af6725921 abort /build/glibc-S9d2JN/glibc-2.27/stdlib/abort.c:81:0\n#6 0x00007f8af671548a __assert_fail_base /build/glibc-S9d2JN/glibc-2.27/assert/assert.c:89:0\n#7 0x00007f8af6715502 (/lib/x86_64-linux-gnu/libc.so.6+0x30502)\n#8 0x0000000000eb0c19 (opt+0xeb0c19)\n#9 0x00007f8af6317b98 llvm::DominatorTree::DominatorTree(llvm::Function&) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x3cab98)\n#10 0x00007f8af63a5c96 TypeAnalyzer::TypeAnalyzer(FnTypeInfo const&, TypeAnalysis&, unsigned char) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x458c96)\n#11 0x00007f8af63cd353 TypeAnalysis::analyzeFunction(FnTypeInfo const&) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x480353)\n#12 0x00007f8af625d890 HandleAutoDiff(llvm::CallInst*, llvm::TargetLibraryInfo&, llvm::AAResults&, bool) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x310890)\n#13 0x00007f8af625ffa7 lowerEnzymeCalls(llvm::Function&, llvm::TargetLibraryInfo&, llvm::AAResults&, bool, bool&) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x312fa7)\n#14 0x00007f8af625ece6 (anonymous namespace)::Enzyme::runOnModule(llvm::Module&) (/home/antineutrino/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-7.so+0x311ce6)\n#15 0x0000000000f16623 (opt+0xf16623)\n#16 0x000000000063a2f1 (opt+0x63a2f1)\n#17 0x00007f8af6706bf7 __libc_start_main /build/glibc-S9d2JN/glibc-2.27/csu/../csu/libc-start.c:344:0\n#18 0x0000000000621daa (opt+0x621daa)\nAborted (core dumped) "}]},{"type":"rich_text_section","elements":[]}]}]},{"client_msg_id":"195C176E-0093-4D39-BC36-59687BE0798F","type":"message","text":"Make sure opt is also from the Enzyme LLVM ?","user":"UKA81L34J","ts":"1609335621.045400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8Ik","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Make sure opt is also from the Enzyme LLVM ?"}]}]}]},{"client_msg_id":"6213D9F5-91ED-4347-BAE2-3590E8457C34","type":"message","text":"That may or may not be the issue.","user":"UKA81L34J","ts":"1609335630.045800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"p8vP7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That may or may not be the issue."}]}]}]},{"client_msg_id":"83C90DCB-E10B-4E88-960F-A69045C3D446","type":"message","text":"No that’s not it","user":"UKA81L34J","ts":"1609335807.046000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aIc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No that’s not it"}]}]}]},{"client_msg_id":"0d03b6c5-302f-4c0b-ab5b-f05e5f5e73dd","type":"message","text":"how do i check if the .so has llvm bitcode appended to it","user":"UQWRPDJ68","ts":"1609338995.046400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"05Wv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"how do i check if the .so has llvm bitcode appended to it"}]}]}]},{"client_msg_id":"118f8eed-4b19-4586-8e7e-d8bb77114ea1","type":"message","text":"i dont have a mac machine , so i cant use otool","user":"UQWRPDJ68","ts":"1609339059.046900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9pZ3m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"i dont have a mac machine , so i cant use otool"}]}]}]},{"client_msg_id":"0fb099bf-7cbc-400c-998a-b1a05d1b284a","type":"message","text":"okay , i think it might be something to do with the fact that when making the shared library after the compilation the final `libgsl.so` file does not seem to have the bitcode","user":"UQWRPDJ68","ts":"1609339383.048400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LlwHL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"okay , i think it might be something to do with the fact that when making the shared library after the compilation the final "},{"type":"text","text":"libgsl.so","style":{"code":true}},{"type":"text","text":" file does not seem to have the bitcode"}]}]}]},{"client_msg_id":"68c44144-7bbd-43bd-bb2c-adf9bac68544","type":"message","text":"oh no nvm ..","user":"UQWRPDJ68","ts":"1609339462.048800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EVL81","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh no nvm .."}]}]}]},{"client_msg_id":"15e55b96-8a73-4a8a-8b2a-0c4d6bf8436a","type":"message","text":"```antineutrino@turingmachine:~/gsllib/lib$ objdump -x libgsl.so.0 | grep llvm\n 13 .llvmbc       004e0980  00000000001d0070  00000000001d0070  001d0070  2**4\n 14 .llvmcmd      0003b87d  00000000006b09f0  00000000006b09f0  006b09f0  2**4\n00000000001d0070 l    d  .llvmbc\t0000000000000000              .llvmbc\n00000000006b09f0 l    d  .llvmcmd\t0000000000000000              .llvmcmd```","user":"UQWRPDJ68","ts":"1609339485.049100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OybB","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"antineutrino@turingmachine:~/gsllib/lib$ objdump -x libgsl.so.0 | grep llvm\n 13 .llvmbc       004e0980  00000000001d0070  00000000001d0070  001d0070  2**4\n 14 .llvmcmd      0003b87d  00000000006b09f0  00000000006b09f0  006b09f0  2**4\n00000000001d0070 l    d  .llvmbc\t0000000000000000              .llvmbc\n00000000006b09f0 l    d  .llvmcmd\t0000000000000000              .llvmcmd"}]}]}]},{"client_msg_id":"9d50e2a7-71d5-468d-b9de-9f534d9e0ceb","type":"message","text":"I’m going to let the masters take this one :slightly_smiling_face: lol","user":"UKA81L34J","ts":"1609339989.049500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sCGz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m going to let the masters take this one "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":" lol"}]}]}]},{"client_msg_id":"aecde0f0-cfe3-410b-a6ed-eeb8726cec1e","type":"message","text":"from the paper on arxiv ...\n\"o use Enzyme on multi-source codebases, enable LTO and run Enzyme on the merged IRfor all the sources. Static libraries can be handled by compiling them with the-fembed-bitcodecommand that ensures that bitcode is included in the library as well. This allows one to perform ADon a program linking against a static library, *by extracting the bitcode in the static library*, and thenrunning Enzyme on the original program with the IR of the static library\"\nis this extraction done manually ? or does clang add in the bitcode from the shared library when i compile my program ?","user":"UQWRPDJ68","ts":"1609346438.051000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l/J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"from the paper on arxiv ...\n\"o use Enzyme on multi-source codebases, enable LTO and run Enzyme on the merged IRfor all the sources. Static libraries can be handled by compiling them with the-fembed-bitcodecommand that ensures that bitcode is included in the library as well. This allows one to perform ADon a program linking against a static library, "},{"type":"text","text":"by extracting the bitcode in the static library","style":{"bold":true}},{"type":"text","text":", and thenrunning Enzyme on the original program with the IR of the static library\"\nis this extraction done manually ? or does clang add in the bitcode from the shared library when i compile my program ?"}]}]}]},{"client_msg_id":"a9ca695d-b810-469d-921c-82918937b781","type":"message","text":"I suspect it should add in the bitcode automatically. Seems tedious to require someone to do it manually. I think this process makes sense - Enzyme must be aware of the static library code to differentiate through it, so you have to associate bitcode with ABI calls.","user":"UKA81L34J","ts":"1609346555.051900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jc4O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I suspect it should add in the bitcode automatically. Seems tedious to require someone to do it manually. I think this process makes sense - Enzyme must be aware of the static library code to differentiate through it, so you have to associate bitcode with ABI calls."}]}]}]},{"client_msg_id":"f9cb53cf-bb4b-487d-8b56-8d935f94ed61","type":"message","text":"However, I don’t know the specifics of how this works <@UN3KKRCRJ>. I suspect it will be rather quiet today (given holidays)","user":"UKA81L34J","ts":"1609346587.052600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5cpCs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"However, I don’t know the specifics of how this works "},{"type":"user","user_id":"UN3KKRCRJ"},{"type":"text","text":". I suspect it will be rather quiet today (given holidays)"}]}]}]},{"client_msg_id":"b9d09c76-056f-4a19-b973-9d3056a31daa","type":"message","text":"alright , ill just put it here so that they can reply when they are free\nanway i looked at the `input.ll` file and i see my `@grad_bessel` in there , inside which `@gsl_sf_bessel_J0`  is being called , but i dont see a definition for  `@gsl_sf_bessl_J0`   as such anywhere , ofcourse its bitcode resides in `libgsl.so` , however i dont see anything referring to the .so file  in `input.ll`  so how would `opt` and `enzyme` know where to look for its bitcode .  Is there some path to pass or env variable to set for  `opt` perhaps ?\n(i do have the right C_INCLUDE_PATH and LIBRARY_PATH set while im running all this)","user":"UQWRPDJ68","ts":"1609347311.060100","team":"T68168MUP","edited":{"user":"UQWRPDJ68","ts":"1609348328.000000"},"blocks":[{"type":"rich_text","block_id":"=Le","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"alright , ill just put it here so that they can reply when they are free\nanway i looked at the "},{"type":"text","text":"input.ll","style":{"code":true}},{"type":"text","text":" file and i see my "},{"type":"text","text":"@grad_bessel","style":{"code":true}},{"type":"text","text":" in there , inside which "},{"type":"text","text":"@gsl_sf_bessel_J0 ","style":{"code":true}},{"type":"text","text":" is being called , but i dont see a definition for  "},{"type":"text","text":"@gsl_sf_bessl_J0 ","style":{"code":true}},{"type":"text","text":"  as such anywhere , ofcourse its bitcode resides in "},{"type":"text","text":"libgsl.so","style":{"code":true}},{"type":"text","text":" , however i dont see anything referring to the .so file  in "},{"type":"text","text":"input.ll","style":{"code":true}},{"type":"text","text":"  so how would "},{"type":"text","text":"opt","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"enzyme","style":{"code":true}},{"type":"text","text":" know where to look for its bitcode .  Is there some path to pass or env variable to set for  "},{"type":"text","text":"opt","style":{"code":true}},{"type":"text","text":" perhaps ?\n(i do have the right C_INCLUDE_PATH and LIBRARY_PATH set while im running all this)"}]}]}]},{"type":"message","text":"","files":[{"id":"F01JH2NMT0Q","created":1609347340,"timestamp":1609347340,"name":"input.ll","title":"input.ll","mimetype":"text/plain","filetype":"text","pretty_type":"Plain Text","user":"UQWRPDJ68","editable":true,"size":3046,"mode":"snippet","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01JH2NMT0Q/input.ll","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01JH2NMT0Q/download/input.ll","permalink":"https://julialang.slack.com/files/UQWRPDJ68/F01JH2NMT0Q/input.ll","permalink_public":"https://slack-files.com/T68168MUP-F01JH2NMT0Q-780a0d8de4","edit_link":"https://julialang.slack.com/files/UQWRPDJ68/F01JH2NMT0Q/input.ll/edit","preview":"; ModuleID = 'grad.c'\nsource_filename = \"grad.c\"\ntarget datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-unknown-linux-gnu\"\n","preview_highlight":"<div class=\"CodeMirror cm-s-default CodeMirrorServer\" oncopy=\"if(event.clipboardData){event.clipboardData.setData('text/plain',window.getSelection().toString().replace(/\\u200b/g,''));event.preventDefault();event.stopPropagation();}\">\n<div class=\"CodeMirror-code\">\n<div><pre>; ModuleID = 'grad.c'</pre></div>\n<div><pre>source_filename = &quot;grad.c&quot;</pre></div>\n<div><pre>target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</pre></div>\n<div><pre>target triple = &quot;x86_64-unknown-linux-gnu&quot;</pre></div>\n<div><pre></pre></div>\n</div>\n</div>\n","lines":62,"lines_more":57,"preview_is_truncated":true,"is_starred":false,"has_rich_preview":false}],"upload":false,"user":"UQWRPDJ68","display_as_bot":false,"ts":"1609347345.060200"},{"type":"message","subtype":"channel_join","ts":"1609351606.060700","user":"UM6JW2SF9","text":"<@UM6JW2SF9> has joined the channel"},{"client_msg_id":"8D9D1183-2172-4426-A0B9-3143BB05B77E","type":"message","text":"<@UCNCMAZ6E> ","user":"UKA81L34J","ts":"1609380881.061100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W4FN","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UCNCMAZ6E"},{"type":"text","text":" "}]}]}]},{"type":"message","subtype":"channel_join","ts":"1609380884.061300","user":"UCNCMAZ6E","text":"<@UCNCMAZ6E> has joined the channel","inviter":"UKA81L34J"},{"client_msg_id":"33b106f5-e1da-4b71-8aff-d05124626b2c","type":"message","text":"<@UKA81L34J> the C API should now be stablized and integrated into Enzyme.jl, there’s still some Enzyme.jl (no longer Enzmye proper) dev work for passing through the custom gradient info","user":"UN3KKRCRJ","ts":"1609384541.062300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"a/W","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UKA81L34J"},{"type":"text","text":" the C API should now be stablized and integrated into Enzyme.jl, there’s still some Enzyme.jl (no longer Enzmye proper) dev work for passing through the custom gradient info"}]}]}]},{"client_msg_id":"b9af7ffb-2a2b-4f1f-aa58-0c6c79265a65","type":"message","text":"<@UQWRPDJ68> a couple of comments:\n1. Yeah the library code via embedded bitcode isn’t quite “plug and play” level at the moment. Using either LTO of embedded bitcode makes sure that the LLVM is available, but you’ll currently need to take some extra steps (e.g. extract the bitcode, llvm-link it into the module being AD’d).\n2. I’ve recently been playing around with using LTO as an initial means of dramatically simplifying this. In essence LTO leaves everything (object files, libraries, etc) as (potentially containers) of bitcode. When running the “full LTO step” everything gets cat’d together and (so long as you’re okay with Full LTO), you should be able to modify the linker command to run Enzyme at that phase. In theory [untested] it should only require adding “-flto” as a flag to clang and “-load=/path/to/ClangEnzyme-11.so” to lld [you need a relatively new version of LLD that supports plugins; ClangEnzyme.so as opposed to LLVMEnzyme.so forcibly runs the Enzyme pass].\n3. Super minor (in hopefully with LTO or the manual process of extracting bitcode shouldn’t matter assuming the lib is well behaved), but given the .so I’m guessing that’s a shared not static library.\n4. Is GSL referring to <https://www.gnu.org/software/gsl/>? More than happy to help test out/debug (though may not have much time til after the new year — my mom’s birthday is tomorrow).","user":"UN3KKRCRJ","ts":"1609385449.068700","team":"T68168MUP","edited":{"user":"UN3KKRCRJ","ts":"1609385557.000000"},"blocks":[{"type":"rich_text","block_id":"pqb","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UQWRPDJ68"},{"type":"text","text":" a couple of comments:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah the library code via embedded bitcode isn’t quite “plug and play” level at the moment. Using either LTO of embedded bitcode makes sure that the LLVM is available, but you’ll currently need to take some extra steps (e.g. extract the bitcode, llvm-link it into the module being AD’d)."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I’ve recently been playing around with using LTO as an initial means of dramatically simplifying this. In essence LTO leaves everything (object files, libraries, etc) as (potentially containers) of bitcode. When running the “full LTO step” everything gets cat’d together and (so long as you’re okay with Full LTO), you should be able to modify the linker command to run Enzyme at that phase. In theory [untested] it should only require adding “-flto” as a flag to clang and “-load=/path/to/ClangEnzyme-11.so” to lld [you need a relatively new version of LLD that supports plugins; ClangEnzyme.so as opposed to LLVMEnzyme.so forcibly runs the Enzyme pass]."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Super minor (in hopefully with LTO or the manual process of extracting bitcode shouldn’t matter assuming the lib is well behaved), but given the .so I’m guessing that’s a shared not static library."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is GSL referring to "},{"type":"link","url":"https://www.gnu.org/software/gsl/"},{"type":"text","text":"? More than happy to help test out/debug (though may not have much time til after the new year — my mom’s birthday is tomorrow)."}]}],"style":"ordered","indent":0}]}]},{"client_msg_id":"ef795f64-3b6e-47e5-a1ce-75d419af7edb","type":"message","text":"Ok, update it did work on GSL! Here’s the instructions (and you’ll want to use my dev branch since it has a fix you’ll need regardless: <https://github.com/wsmoses/Enzyme/pull/100>)","user":"UN3KKRCRJ","ts":"1609393180.069500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WM/Vs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, update it did work on GSL! Here’s the instructions (and you’ll want to use my dev branch since it has a fix you’ll need regardless: "},{"type":"link","url":"https://github.com/wsmoses/Enzyme/pull/100"},{"type":"text","text":")"}]}]}]},{"client_msg_id":"54a2c4cf-4dab-4f55-95f0-19d4158710f1","type":"message","text":"1, build GSL with LTO (my setup was funny so I had some extra things)\n```tar -zxvf gsl-latest.tar.gz\ncd gsl-2.6\nexport CC=\"/mnt/pci4/wmdata/llvm11/build/bin/clang -fuse-ld=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\"\nexport CXX=\"/mnt/pci4/wmdata/llvm11/build/bin/clang++ -fuse-ld=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\"\nexport CFLAGS=\"-flto -O2 -ffast-math\"\nexport CPPFLAGS=\"-flto -O2 -ffast-math\"\nexport LD=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\nexport LINKER=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\nalias ld=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\n./configure\nmake -j12\ncd ..```\n2, compile with LTO (and also an extra -enzyme-globals-default-inactive flag since there is an internal constant global used — will make more aggressive activity analysis later)\n```/mnt/pci4/wmdata/llvm12/build/bin/clang -O2 -fuse-ld=/mnt/pci4/wmdata/llvm12/build/bin/ld.lld -flto test.c -I ./gsl-2.6 -L ./gsl-2.6/.libs -Wl,-mllvm=-load=$HOME/git/Enzyme/enzyme/build12/Enzyme/ClangEnzyme-12.so -Wl,-mllvm=-enzyme-globals-default-inactive -Wl,-Bstatic -lgsl -Wl,-Bdynamic -lm```","user":"UN3KKRCRJ","ts":"1609393263.070900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HxEF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"1, build GSL with LTO (my setup was funny so I had some extra things)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"tar -zxvf gsl-latest.tar.gz\ncd gsl-2.6\nexport CC=\"/mnt/pci4/wmdata/llvm11/build/bin/clang -fuse-ld=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\"\nexport CXX=\"/mnt/pci4/wmdata/llvm11/build/bin/clang++ -fuse-ld=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\"\nexport CFLAGS=\"-flto -O2 -ffast-math\"\nexport CPPFLAGS=\"-flto -O2 -ffast-math\"\nexport LD=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\nexport LINKER=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\nalias ld=/mnt/pci4/wmdata/llvm11/build/bin/ld.lld\n./configure\nmake -j12\ncd .."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"2, compile with LTO (and also an extra -enzyme-globals-default-inactive flag since there is an internal constant global used — will make more aggressive activity analysis later)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"/mnt/pci4/wmdata/llvm12/build/bin/clang -O2 -fuse-ld=/mnt/pci4/wmdata/llvm12/build/bin/ld.lld -flto test.c -I ./gsl-2.6 -L ./gsl-2.6/.libs -Wl,-mllvm=-load=$HOME/git/Enzyme/enzyme/build12/Enzyme/ClangEnzyme-12.so -Wl,-mllvm=-enzyme-globals-default-inactive -Wl,-Bstatic -lgsl -Wl,-Bdynamic -lm"}]}]}]},{"client_msg_id":"08eb5c85-a327-439e-94c3-e16c15c0636e","type":"message","text":"Testing on the following test.c gets the correct result:\n```#include &lt;stdio.h&gt;\n#include &lt;gsl/gsl_sf_bessel.h&gt;\n\ndouble __enzyme_autodiff(void*, double);\n\ndouble dbessel(double x) {\n    return __enzyme_autodiff(gsl_sf_bessel_J0, x);\n}\nint\nmain (void)\n{\n  double x = 5.0;\n  double y = gsl_sf_bessel_J0 (x);\n  double dy = dbessel (x);\n  printf (\"J0(%g) = %.18e\\n\", x, y);\n  printf (\"dJ0(%g) = %.18e\\n\", x, dy);\n  return 0;\n}```\nRun:\n```$ ./a.out \nJ0(5) = -1.775967713143382920e-01\ndJ0(5) = 3.275791375914652859e-01```\n","user":"UN3KKRCRJ","ts":"1609393308.071500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VZV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Testing on the following test.c gets the correct result:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"#include <stdio.h>\n#include <gsl/gsl_sf_bessel.h>\n\ndouble __enzyme_autodiff(void*, double);\n\ndouble dbessel(double x) {\n    return __enzyme_autodiff(gsl_sf_bessel_J0, x);\n}\nint\nmain (void)\n{\n  double x = 5.0;\n  double y = gsl_sf_bessel_J0 (x);\n  double dy = dbessel (x);\n  printf (\"J0(%g) = %.18e\\n\", x, y);\n  printf (\"dJ0(%g) = %.18e\\n\", x, dy);\n  return 0;\n}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Run:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"$ ./a.out \nJ0(5) = -1.775967713143382920e-01\ndJ0(5) = 3.275791375914652859e-01"}]},{"type":"rich_text_section","elements":[]}]}]},{"type":"message","subtype":"channel_join","ts":"1609394452.071700","user":"U010P7VB1J4","text":"<@U010P7VB1J4> has joined the channel","inviter":"UN3KKRCRJ"},{"client_msg_id":"73B5CB4D-6CBC-491B-98E4-379E36C4A8FF","type":"message","text":"<@UQWRPDJ68> note that the above setup has some differences between the ideal configuration (namely it runs enzyme at an unknown point in the passes as opposed to a good middle point). This means that the performance may not be optimal (seemingly could be remedied by a subsequent opt?)","user":"UN3KKRCRJ","ts":"1609437995.074700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VjUyL","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UQWRPDJ68"},{"type":"text","text":" note that the above setup has some differences between the ideal configuration (namely it runs enzyme at an unknown point in the passes as opposed to a good middle point). This means that the performance may not be optimal (seemingly could be remedied by a subsequent opt?)"}]}]}]},{"client_msg_id":"f9a58041-d091-433b-8914-d346fed36bcc","type":"message","text":"<@UN3KKRCRJ> is lllvm 11 also a necesary part of your the fix in your dev branch ?","user":"UQWRPDJ68","ts":"1609516938.075300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NLI","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UN3KKRCRJ"},{"type":"text","text":" is lllvm 11 also a necesary part of your the fix in your dev branch ?"}]}]}]},{"client_msg_id":"F0577A3F-F239-451E-BFC0-37A4DE07F0CE","type":"message","text":"The use of a newer llvm is to make sure that lld has the ability to use plugins (<https://reviews.llvm.org/D75879|https://reviews.llvm.org/D75879>) during LTO.","user":"UN3KKRCRJ","ts":"1609530286.076600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lfW4y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The use of a newer llvm is to make sure that lld has the ability to use plugins ("},{"type":"link","url":"https://reviews.llvm.org/D75879","text":"https://reviews.llvm.org/D75879"},{"type":"text","text":") during LTO."}]}]}]},{"client_msg_id":"9848D313-15FD-4625-89F6-D245A2C8642E","type":"message","text":"So long as that patch exists on the lld you use (by manually applying to an earlier version, using one where already applied, etc) you should be able to use any llvm","user":"UN3KKRCRJ","ts":"1609530376.077900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9S3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So long as that patch exists on the lld you use (by manually applying to an earlier version, using one where already applied, etc) you should be able to use any llvm"}]}]}]},{"client_msg_id":"a7e54456-7c71-4113-bc3d-3146c870a28c","type":"message","text":"<@UN3KKRCRJ> i ran into some trouble building gsl with llvm 11 ;  i guess the default instructions on Enzyme's website  builds only some parts (clang) , i got an error that ld.lld couldnt be found in my llvm/build/bin ;\nive passed \"clang;lld\" in the ENABLE_PROJECTS flag of cmake  and its compiling llvm now ; ill try again when its done ;\nMaybe the installation tutorials mention passing this flag too ?","user":"UQWRPDJ68","ts":"1609605427.082000","team":"T68168MUP","edited":{"user":"UQWRPDJ68","ts":"1609605516.000000"},"blocks":[{"type":"rich_text","block_id":"lD25","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UN3KKRCRJ"},{"type":"text","text":" i ran into some trouble building gsl with llvm 11 ;  i guess the default instructions on Enzyme's website  builds only some parts (clang) , i got an error that ld.lld couldnt be found in my llvm/build/bin ;\nive passed \"clang;lld\" in the ENABLE_PROJECTS flag of cmake  and its compiling llvm now ; ill try again when its done ;\nMaybe the installation tutorials mention passing this flag too ?"}]}]}]},{"client_msg_id":"2ffc7ade-0b33-4169-903f-dc0e3ce0c330","type":"message","text":"is llvm-12 necessary as you have used ?\n```/home/antineutrino/llvm-project/build/bin/clang -O2 -fuse-ld=/home/antineutrino/llvm-project/build/bin/ld.lld -flto grad.c -I /home/antineutrino/sources/gsl-2.6 -L /home/antineutrino/sources/gsl-2.6/.libs -Wl,-mllvm=-load=$HOME/Enzyme/enzyme/build/Enzyme/ClangEnzyme-11.so -Wl,-mllvm=-enzyme-globals-default-inactive -Wl,-Bstatic -lgsl -Wl,-Bdynamic -lm\nError opening '/home/antineutrino/Enzyme/enzyme/build/Enzyme/ClangEnzyme-11.so': /home/antineutrino/Enzyme/enzyme/build/Enzyme/ClangEnzyme-11.so: undefined symbol: _ZTVN4llvm13RGPassManagerE\n  -load request ignored.\nld.lld: error: --mllvm: ld.lld: Unknown command line argument '-enzyme-globals-default-inactive'.  Try: '/home/antineutrino/llvm-project/build/bin/ld.lld --help'\nld.lld: Did you mean '--enable-loop-distribute'?\nclang-11: error: linker command failed with exit code 1 (use -v to see invocation)```\n","user":"UQWRPDJ68","ts":"1609608578.082500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T3=K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is llvm-12 necessary as you have used ?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"/home/antineutrino/llvm-project/build/bin/clang -O2 -fuse-ld=/home/antineutrino/llvm-project/build/bin/ld.lld -flto grad.c -I /home/antineutrino/sources/gsl-2.6 -L /home/antineutrino/sources/gsl-2.6/.libs -Wl,-mllvm=-load=$HOME/Enzyme/enzyme/build/Enzyme/ClangEnzyme-11.so -Wl,-mllvm=-enzyme-globals-default-inactive -Wl,-Bstatic -lgsl -Wl,-Bdynamic -lm\nError opening '/home/antineutrino/Enzyme/enzyme/build/Enzyme/ClangEnzyme-11.so': /home/antineutrino/Enzyme/enzyme/build/Enzyme/ClangEnzyme-11.so: undefined symbol: _ZTVN4llvm13RGPassManagerE\n  -load request ignored.\nld.lld: error: --mllvm: ld.lld: Unknown command line argument '-enzyme-globals-default-inactive'.  Try: '/home/antineutrino/llvm-project/build/bin/ld.lld --help'\nld.lld: Did you mean '--enable-loop-distribute'?\nclang-11: error: linker command failed with exit code 1 (use -v to see invocation)"}]},{"type":"rich_text_section","elements":[]}]}]},{"client_msg_id":"dfd4d45a-1ce5-465f-85cd-5aba36ba5ea5","type":"message","text":"or is this because i havent enabled the neccesary projects (ive enabled clang and lld) when compiling llvm ? , ill compile llvm fully and try","user":"UQWRPDJ68","ts":"1609609397.083600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CiNzC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or is this because i havent enabled the neccesary projects (ive enabled clang and lld) when compiling llvm ? , ill compile llvm fully and try"}]}]}]},{"client_msg_id":"49a9ed21-b366-4a92-8b32-b5dafeca3d4f","type":"message","text":"Yeah you’re going to need to add lld to the build flags (or alternatively enable the gold linker plugin which is a pain to set up). I actually got the same undefined symbol error earlier when linking with LLVM 11 (which is weird because I had it working on LLVM 11 earlier for <https://internals.rust-lang.org/t/automatic-differentiation-differential-programming-via-llvm/13188/7?u=wsmoses|Rust>). Personally I’d just suggest compiling LLVM master (==12) with -DLLVM_ENABLE_PROJECTS=“clang;lld” [and thanks again for helping beta test LTO-based external library support]","user":"UN3KKRCRJ","ts":"1609615390.086600","team":"T68168MUP","attachments":[{"service_name":"Rust Internals","title":"Automatic Differentiation/Differential Programming via LLVM","title_link":"https://internals.rust-lang.org/t/automatic-differentiation-differential-programming-via-llvm/13188/7?u=wsmoses","text":"Not that this is how this should be used -- but as a cute test I told rustc to run Enzyme AD successfully via the linker. In this way no compiler modification is necessary. // <http://test.rs|test.rs> extern { fn __enzyme_autodiff(_: usize, ...) -&gt; f64; } fn square(x : f64) -&gt; f64 { return x * x; } fn main() { unsafe { println!(\"Hello, world {} {}!\", square(3.0), __enzyme_autodiff(square as usize, 3.0)); } } $ rustc -Clinker=clang -Clink-arg=-fuse-ld=lld-11 <http://test.rs|test.rs> -C link-args=\"-Wl,-mllvm=-l...","fallback":"Rust Internals: Automatic Differentiation/Differential Programming via LLVM","thumb_url":"https://aws1.discourse-cdn.com/business6/uploads/rustlang/original/2X/b/b71959a2097ce0b5c3a193ce0a6466a42d4c4952.png","ts":1602907288,"from_url":"https://internals.rust-lang.org/t/automatic-differentiation-differential-programming-via-llvm/13188/7?u=wsmoses","thumb_width":512,"thumb_height":512,"service_icon":"https://aws1.discourse-cdn.com/business6/uploads/rustlang/optimized/1X/e260a60b8dca4dae6ce7db98c45bb5008e6fdc62_2_180x180.png","id":1,"original_url":"https://internals.rust-lang.org/t/automatic-differentiation-differential-programming-via-llvm/13188/7?u=wsmoses"}],"blocks":[{"type":"rich_text","block_id":"C/P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah you’re going to need to add lld to the build flags (or alternatively enable the gold linker plugin which is a pain to set up). I actually got the same undefined symbol error earlier when linking with LLVM 11 (which is weird because I had it working on LLVM 11 earlier for "},{"type":"link","url":"https://internals.rust-lang.org/t/automatic-differentiation-differential-programming-via-llvm/13188/7?u=wsmoses","text":"Rust"},{"type":"text","text":"). Personally I’d just suggest compiling LLVM master (==12) with -DLLVM_ENABLE_PROJECTS=“clang;lld” [and thanks again for helping beta test LTO-based external library support]"}]}]}]},{"client_msg_id":"5a1d45c9-4401-4eeb-8536-288e9e4646ea","type":"message","text":"[My guess as to the issues surrounding LLVM 11 plugin support is that there’s some llvm enable plugin type flags that need to be passed to the build, which I’ll investigate this week as I write up documentation on LTO-based libraries]","user":"UN3KKRCRJ","ts":"1609615598.088100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ow0IR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"[My guess as to the issues surrounding LLVM 11 plugin support is that there’s some llvm enable plugin type flags that need to be passed to the build, which I’ll investigate this week as I write up documentation on LTO-based libraries]"}]}]}]},{"client_msg_id":"f50a5fd9-a135-4ef3-8fe1-71979c3a0e1b","type":"message","text":"hey .. hmm so with LLVM master , Enzyme doesnt seem to compile at all ;\n```5 In file included from ../Enzyme/SCEV/ScalarEvolutionExpander.cpp:30:\n  6 ../Enzyme/SCEV/ScalarEvolutionExpander12.cpp:2248:71: error: cannot initialize a parameter of type 'CmpInst::Predicate' with an lvalue of type 'TargetTransformInfo::TargetCostKind'\n  7                                   CmpInst::makeCmpResultType(OpType), CostKind);\n  8\n\n\n38 /home/antineutrino/llvm-project/llvm/include/llvm/Support/Compiler.h:319:23: note: expanded from macro 'LLVM_ATTRIBUTE_DEPRECATED'\n 39   decl __attribute__((deprecated(message)))\n 40                       ^\n 41 ../Enzyme/ActivityAnalysis.cpp:831:54: error: no member named 'unknown' in 'llvm::LocationSize'\n 42             &amp;I, MemoryLocation(memval, LocationSize::unknown()));\n 43                                        ~~~~~~~~~~~~~~^\n 44 2 warnings and 1 error generated.                                                                       ^~~~~~~~```\n","user":"UQWRPDJ68","ts":"1609709811.089700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gl7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hey .. hmm so with LLVM master , Enzyme doesnt seem to compile at all ;\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"5 In file included from ../Enzyme/SCEV/ScalarEvolutionExpander.cpp:30:\n  6 ../Enzyme/SCEV/ScalarEvolutionExpander12.cpp:2248:71: error: cannot initialize a parameter of type 'CmpInst::Predicate' with an lvalue of type 'TargetTransformInfo::TargetCostKind'\n  7                                   CmpInst::makeCmpResultType(OpType), CostKind);\n  8\n\n\n38 /home/antineutrino/llvm-project/llvm/include/llvm/Support/Compiler.h:319:23: note: expanded from macro 'LLVM_ATTRIBUTE_DEPRECATED'\n 39   decl __attribute__((deprecated(message)))\n 40                       ^\n 41 ../Enzyme/ActivityAnalysis.cpp:831:54: error: no member named 'unknown' in 'llvm::LocationSize'\n 42             &I, MemoryLocation(memval, LocationSize::unknown()));\n 43                                        ~~~~~~~~~~~~~~^\n 44 2 warnings and 1 error generated.                                                                       ^~~~~~~~"}]},{"type":"rich_text_section","elements":[]}]}]},{"client_msg_id":"1046b5cd-5dd5-4249-b75a-0abfeec22afe","type":"message","text":"couple of more errors ;","user":"UQWRPDJ68","ts":"1609709836.090000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OP878","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"couple of more errors ;"}]}]}]},{"type":"message","text":"","files":[{"id":"F01HG8XBPRD","created":1609709872,"timestamp":1609709872,"name":"out.txt","title":"out.txt","mimetype":"text/plain","filetype":"text","pretty_type":"Plain Text","user":"UQWRPDJ68","editable":true,"size":39841,"mode":"snippet","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01HG8XBPRD/out.txt","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01HG8XBPRD/download/out.txt","permalink":"https://julialang.slack.com/files/UQWRPDJ68/F01HG8XBPRD/out.txt","permalink_public":"https://slack-files.com/T68168MUP-F01HG8XBPRD-6a795d8768","edit_link":"https://julialang.slack.com/files/UQWRPDJ68/F01HG8XBPRD/out.txt/edit","preview":"[1/35] Building CXX object Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o\nFAILED: Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o \n/home/antineutrino/llvm-project/build/bin/clang++  -fuse-ld=/home/antineutrino/llvm-project/build/bin/ld.lld -DGTEST_HAS_RTTI=0 -I/home/antineutrino/llvm-project/llvm/include -I/home/antineutrino/llvm-project/build/include -Iinclude -Wall -fPIC -fno-rtti -fPIC   -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS  -fno-exceptions -fno-rtti -std=gnu++17 -MD -MT Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o -MF Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o.d -o Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o -c ../Enzyme/SCEV/ScalarEvolutionExpander.cpp\nclang-12: warning: argument unused during compilation: '-fuse-ld=/home/antineutrino/llvm-project/build/bin/ld.lld' [-Wunused-command-line-argument]\nIn file included from...","preview_highlight":"<div class=\"CodeMirror cm-s-default CodeMirrorServer\" oncopy=\"if(event.clipboardData){event.clipboardData.setData('text/plain',window.getSelection().toString().replace(/\\u200b/g,''));event.preventDefault();event.stopPropagation();}\">\n<div class=\"CodeMirror-code\">\n<div><pre>[1/35] Building CXX object Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o</pre></div>\n<div><pre>FAILED: Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o </pre></div>\n<div><pre>/home/antineutrino/llvm-project/build/bin/clang++  -fuse-ld=/home/antineutrino/llvm-project/build/bin/ld.lld -DGTEST_HAS_RTTI=0 -I/home/antineutrino/llvm-project/llvm/include -I/home/antineutrino/llvm-project/build/include -Iinclude -Wall -fPIC -fno-rtti -fPIC   -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS  -fno-exceptions -fno-rtti -std=gnu++17 -MD -MT Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o -MF Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o.d -o Enzyme/CMakeFiles/ClangEnzyme-12.dir/SCEV/ScalarEvolutionExpander.cpp.o -c ../Enzyme/SCEV/ScalarEvolutionExpander.cpp</pre></div>\n<div><pre>clang-12: warning: argument unused during compilation: '-fuse-ld=/home/antineutrino/llvm-project/build/bin/ld.lld' [-Wunused-command-line-argument]</pre></div>\n<div><pre>In file included from...</pre></div>\n</div>\n</div>\n","lines":492,"lines_more":487,"preview_is_truncated":true,"is_starred":false,"has_rich_preview":false}],"upload":false,"user":"UQWRPDJ68","display_as_bot":false,"ts":"1609709874.090100"},{"client_msg_id":"0bffc08e-d25e-4657-bcfc-348b9757763a","type":"message","text":"what exactly did you mean by LLVM  master == 12 ? :sweat_smile:\nthe branch llvmorg-12.0.0 or the master branch\nthe above errors are on the master branch","user":"UQWRPDJ68","ts":"1609710558.091300","team":"T68168MUP","edited":{"user":"UQWRPDJ68","ts":"1609711790.000000"},"blocks":[{"type":"rich_text","block_id":"Uq9K5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what exactly did you mean by LLVM  master == 12 ? "},{"type":"emoji","name":"sweat_smile"},{"type":"text","text":"\nthe branch llvmorg-12.0.0 or the master branch\nthe above errors are on the master branch"}]}]}]},{"client_msg_id":"d8a2f2ad-3c73-4e33-b8bf-2fece4ca8c8c","type":"message","text":"[moving to DM, in essence LLVM master renamed experimental_vector_reduce_v2_fadd to vector_reduce_fadd in the past month]","user":"UN3KKRCRJ","ts":"1609741160.092000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1233","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"[moving to DM, in essence LLVM master renamed experimental_vector_reduce_v2_fadd to vector_reduce_fadd in the past month]"}]}]}]}]}