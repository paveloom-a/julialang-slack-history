{"cursor": 1, "messages": [{"client_msg_id":"516ba512-94f8-4395-8dab-eaf0acdf3130","type":"message","text":"(Over an infinite domain)","user":"U7YD3DKL2","ts":"1613072737.115100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6Nl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(Over an infinite domain)"}]}]}]},{"client_msg_id":"f1553654-b7c3-40e7-a887-0b876afc148a","type":"message","text":"Are there any maintainers of <https://github.com/nolta/Elliptic.jl> here?","user":"UEP056STX","ts":"1613139802.116700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yWI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Are there any maintainers of "},{"type":"link","url":"https://github.com/nolta/Elliptic.jl"},{"type":"text","text":" here?"}]}]}]},{"client_msg_id":"c3352d9f-3fa3-46f3-ac9b-f2b29cb2a644","type":"message","text":"Is there any package that calculates the modified Bessel's functions in arbitrary precision? It looks like SpecialFunctions.jl has support for BigFloat types for besselj and bessely but not for besseli and besselk...","user":"U01FSUY7YES","ts":"1613149633.118400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6YUuI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there any package that calculates the modified Bessel's functions in arbitrary precision? It looks like SpecialFunctions.jl has support for BigFloat types for besselj and bessely but not for besseli and besselk..."}]}]}],"thread_ts":"1613149633.118400","reply_count":2,"reply_users_count":1,"latest_reply":"1613150276.118700","reply_users":["U01FSUY7YES"],"subscribed":false},{"client_msg_id":"27f135fe-43e8-4543-a4c5-0f5fef71d379","type":"message","text":"I am trying to formalize my understanding of mathematical completeness. Do you think the following definition I have been working on suffices:\n\n_Completeness: an axiom system where each axiom is sufficient for deriving every true statement in that language._","user":"US64J0NPQ","ts":"1613341600.120800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mXN=t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am trying to formalize my understanding of mathematical completeness. Do you think the following definition I have been working on suffices:\n\n"},{"type":"text","text":"Completeness: an axiom system where each axiom is sufficient for deriving every true statement in that language.","style":{"italic":true}}]}]}]},{"client_msg_id":"6f369519-b2fc-4558-823e-5056cac64e76","type":"message","text":"I'm still hunting an Heisenbug from few weeks ago. Is there a know strong difference for dense vectors `x, v` between\n`@. x += scalar * (x - v)`\nand the non-broadcast version\n`x += scalar * (x - v)` ?","user":"U82RE6STE","ts":"1614118125.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NGO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm still hunting an Heisenbug from few weeks ago. Is there a know strong difference for dense vectors `x, v` between\n"},{"type":"text","text":"@. x += scalar * (x - v)","style":{"code":true}},{"type":"text","text":"\nand the non-broadcast version\n"},{"type":"text","text":"x += scalar * (x - v)","style":{"code":true}},{"type":"text","text":" ?"}]}]}]},{"client_msg_id":"48efbc14-d869-43f4-a94f-6a6c0fdcbc6e","type":"message","text":"(in terms of precision, floating point error compensation)","user":"U82RE6STE","ts":"1614119879.002200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"a34gk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(in terms of precision, floating point error compensation)"}]}]}]},{"client_msg_id":"61335a18-5c64-4f12-a9bf-bcdbfd24791f","type":"message","text":"That is probably because the broadcast version may be able to use `fma` instructions. However, I have not been able to reproduce the difference with the code above.","user":"UV3KT0AP5","ts":"1614120891.003300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mxXBL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is probably because the broadcast version may be able to use "},{"type":"text","text":"fma","style":{"code":true}},{"type":"text","text":" instructions. However, I have not been able to reproduce the difference with the code above."}]}]}],"thread_ts":"1614120891.003300","reply_count":1,"reply_users_count":1,"latest_reply":"1614121634.003400","reply_users":["U82RE6STE"],"subscribed":false},{"client_msg_id":"8b1a536f-8728-431b-85b9-48856470abcf","type":"message","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?","user":"UDSG73JTH","ts":"1614437236.006800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KxVV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?"}]}]}]},{"client_msg_id":"79a14b83-46e5-4b17-aafb-437b5b817c93","type":"message","text":"You can do the same thing with chunk size = 3 dual numbers in ForwardDiff.","user":"U69BL50BF","ts":"1614442743.007200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SsrNv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can do the same thing with chunk size = 3 dual numbers in ForwardDiff."}]}]}]},{"type":"message","subtype":"thread_broadcast","text":"As far as I understand, complex step differentiation is a \"hacky\" way to achieve automatic differentiation. I don't see a need for it if forward-mode automatic differentiation (e.g. using Dual numbers) is available.","user":"U72B7LTMX","ts":"1614885165.012000","thread_ts":"1614437236.006800","root":{"client_msg_id":"8b1a536f-8728-431b-85b9-48856470abcf","type":"message","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?","user":"UDSG73JTH","ts":"1614437236.006800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KxVV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?"}]}]}],"thread_ts":"1614437236.006800","reply_count":16,"reply_users_count":4,"latest_reply":"1614885165.012000","reply_users":["U67G3QRJM","UGHS7LC64","UDSG73JTH","U72B7LTMX"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"jYuly","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As far as I understand, complex step differentiation is a \"hacky\" way to achieve automatic differentiation. I don't see a need for it if forward-mode automatic differentiation (e.g. using Dual numbers) is available."}]}]}],"client_msg_id":"29eab17e-ea1e-41ed-be9a-50d4b6fac960"},{"client_msg_id":"6d39a338-ea8e-4d2f-855a-17401a2dcdf5","type":"message","text":"This will be a stupid question - but you all know me by now... Is there a kind of theory that relates to functions which give \"easy to deal with\" numbers? IE whole numbers are easy. Decimals which result from small whole number fractions are also \"easy\".","user":"UPUBAM63X","ts":"1614993741.018900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pQOf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This will be a stupid question - but you all know me by now... Is there a kind of theory that relates to functions which give \"easy to deal with\" numbers? IE whole numbers are easy. Decimals which result from small whole number fractions are also \"easy\"."}]}]}]},{"client_msg_id":"35886f1e-9846-47aa-96e3-4be7d08ab4ce","type":"message","text":"In some weird, but practical cases, \"easy\" numbers beat out optimal solutions.","user":"UPUBAM63X","ts":"1614993845.019600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JN36/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In some weird, but practical cases, \"easy\" numbers beat out optimal solutions."}]}]}]},{"client_msg_id":"d685098d-7645-4f72-9ff2-b3d068f5ced8","type":"message","text":"I'm not sure: is it decidable whether a set of linear inequalities is feasible?","user":"U01MG0TN079","ts":"1615127955.022800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YlHoa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure: is it decidable whether a set of linear inequalities is feasible?"}]}]}]},{"client_msg_id":"d18feb4a-10bf-4efe-a127-19290faeceeb","type":"message","text":"I think yes, but can't find a source","user":"U01MG0TN079","ts":"1615127968.023100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SXolf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think yes, but can't find a source"}]}]}]},{"client_msg_id":"a9bda020-1852-482b-9172-fef9b5265c0d","type":"message","text":"<@U01MG0TN079>: Yes it is. <https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination|https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination>","user":"U67G3QRJM","ts":"1615131920.023700","team":"T68168MUP","attachments":[{"title":"Fourier–Motzkin elimination","title_link":"https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination","from_url":"https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"Fourier–Motzkin elimination, also known as the FME method, is a mathematical algorithm for eliminating variables from a system of linear inequalities. It can output real solutions.\nThe algorithm is named after Joseph Fourier and Theodore Motzkin who independently discovered the method in 1827 and in 1936, respectively.","fallback":"wikipedia: Fourier–Motzkin elimination","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination"}],"blocks":[{"type":"rich_text","block_id":"zjbiu","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01MG0TN079"},{"type":"text","text":": Yes it is. "},{"type":"link","url":"https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination","text":"https://en.m.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination"}]}]}]},{"client_msg_id":"9ab4bf60-7246-46f3-b206-56f9542aadbb","type":"message","text":"but when reading about LP, I see polynomial time mentions, and here the algo is said to be superexponential. Are the variables for complexity distinct, or what am I missing?","user":"U01MG0TN079","ts":"1615132095.025000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+RK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but when reading about LP, I see polynomial time mentions, and here the algo is said to be superexponential. Are the variables for complexity distinct, or what am I missing?"}]}]}]},{"client_msg_id":"fb9807d3-dad3-4950-b1ce-48904b91f780","type":"message","text":"The theorem is <https://en.m.wikipedia.org/wiki/Farkas%27_lemma|https://en.m.wikipedia.org/wiki/Farkas%27_lemma>","user":"U67G3QRJM","ts":"1615132096.025200","team":"T68168MUP","attachments":[{"title":"Farkas' lemma","title_link":"https://en.m.wikipedia.org/wiki/Farkas%27_lemma","from_url":"https://en.m.wikipedia.org/wiki/Farkas%27_lemma","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"Farkas' lemma is a solvability theorem for a finite system of linear inequalities in mathematics. It was originally proven by the Hungarian mathematician Gyula Farkas.\nFarkas' lemma is the key result underpinning the linear programming duality and has played a central role in the development of mathematical optimization (alternatively, mathematical programming). It is used amongst other things in the proof of the Karush–Kuhn–Tucker theorem in nonlinear programming.\nRemarkably, in the area of the foundations of quantum theory, the lemma also underlies the complete set of Bell inequalities in the form of necessary and sufficient conditions for the existence of a local hidden-variable theory, given data from any specific set of measurements.Generalizations of the Farkas' lemma are about the solvability theorem for convex inequalities, i.e., infinite system of linear inequalities. Farkas' lemma belongs to a class of statements called \"theorems of the alternative\": a theorem stating that exactly one of two systems has a solution.","fallback":"wikipedia: Farkas' lemma","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.m.wikipedia.org/wiki/Farkas%27_lemma"}],"blocks":[{"type":"rich_text","block_id":"9GG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The theorem is "},{"type":"link","url":"https://en.m.wikipedia.org/wiki/Farkas%27_lemma","text":"https://en.m.wikipedia.org/wiki/Farkas%27_lemma"}]}]}]},{"client_msg_id":"da23fd0c-044e-4b59-ba7c-e44b86af6df7","type":"message","text":"What do you mean by feasible?","user":"U67G3QRJM","ts":"1615132120.025700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fYW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do you mean by feasible?"}]}]}]},{"client_msg_id":"0a3c9205-8626-43a3-9ed0-558b4dcb8bfb","type":"message","text":"Well, I have a set of linear inequalities, and I want to know whether they define the empty set or not","user":"U01MG0TN079","ts":"1615132153.026300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dm1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well, I have a set of linear inequalities, and I want to know whether they define the empty set or not"}]}]}]},{"client_msg_id":"b6bf9a84-6c4b-4878-a9d9-9ace4a383ae6","type":"message","text":"Does Fourier-Motzkin care for strict inequalities?","user":"U01MG0TN079","ts":"1615132270.028400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0bhmH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does Fourier-Motzkin care for strict inequalities?"}]}]}]},{"client_msg_id":"77c12aa0-d5b6-408f-8e21-d2b4f73d2a1c","type":"message","text":"The above links tell you that it's possible to answer that question.","user":"U67G3QRJM","ts":"1615132278.028600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BDQy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The above links tell you that it's possible to answer that question."}]}]}]},{"client_msg_id":"45595acd-f6d1-495a-9ed0-beb159360ded","type":"message","text":"I don't know about complexity","user":"U67G3QRJM","ts":"1615132312.029700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bEX7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't know about complexity"}]}]}]},{"client_msg_id":"73bdee2a-01de-44f8-8dd1-884cccfd92f5","type":"message","text":"Hmm not sure about strict","user":"U67G3QRJM","ts":"1615132322.030200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YelUb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm not sure about strict"}]}]}]},{"client_msg_id":"ce507183-1186-43c9-8577-76dc7445ffe0","type":"message","text":"And in practice, the best way to do this is to use `Convex.jl` or a similar library?","user":"U01MG0TN079","ts":"1615132332.030700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LZY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And in practice, the best way to do this is to use "},{"type":"text","text":"Convex.jl","style":{"code":true}},{"type":"text","text":" or a similar library?"}]}]}]},{"client_msg_id":"052e052d-cba4-48bf-8741-efcbc49e80c9","type":"message","text":"But also there's the question of floating point","user":"U67G3QRJM","ts":"1615132344.031400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=XwyR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But also there's the question of floating point"}]}]}]},{"client_msg_id":"793c9cd7-e41f-4799-81e4-e369441ac79a","type":"message","text":"Tulip.jl is a pure Julia LP solver","user":"U67G3QRJM","ts":"1615132381.032700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qmope","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tulip.jl is a pure Julia LP solver"}]}]}]},{"client_msg_id":"0d553ac9-75d6-4ae0-8b11-c948234aae8b","type":"message","text":"Though it uses interior point methods (not simplex)","user":"U67G3QRJM","ts":"1615132399.033500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6iEp7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Though it uses interior point methods (not simplex)"}]}]}]},{"client_msg_id":"e586cfb6-bba9-4678-934c-da7e5bcca0b5","type":"message","text":"what's the diff with cosmo?","user":"U01MG0TN079","ts":"1615132402.033600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HeN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what's the diff with cosmo?"}]}]}],"thread_ts":"1615132402.033600","reply_count":1,"reply_users_count":1,"latest_reply":"1615133804.054700","reply_users":["UCZ7VBGUD"],"subscribed":false},{"client_msg_id":"d09c515d-c6cd-4533-8b12-50fcda48a33b","type":"message","text":"I mean, how do they compare?","user":"U01MG0TN079","ts":"1615132415.034200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zHi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, how do they compare?"}]}]}]},{"client_msg_id":"73e7c901-f79b-4430-84b9-29af33487a39","type":"message","text":"Neumaier-Scherbina showed how to make the result of an LP calculation rigorous using (I believe) interval arithmetic","user":"U67G3QRJM","ts":"1615132434.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cgfj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Neumaier-Scherbina showed how to make the result of an LP calculation rigorous using (I believe) interval arithmetic"}]}]}]},{"client_msg_id":"2302c0d5-4f32-4f7a-be80-b963d4c74db1","type":"message","text":"Don't know about cosmo","user":"U67G3QRJM","ts":"1615132475.035500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RhMd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Don't know about cosmo"}]}]}]},{"client_msg_id":"c50e9407-b0fb-4753-b411-e74928456ef4","type":"message","text":"Also, can I get a certificate for infeasibility?","user":"U01MG0TN079","ts":"1615132481.035800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ReS6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, can I get a certificate for infeasibility?"}]}]}]},{"client_msg_id":"07035f92-dcd0-4082-b195-c76a08aae1a4","type":"message","text":"If you want a rigorous certificate I think you need Neumaier Scherbina. I know somebody has implemented that but I don't think it's public yet","user":"U67G3QRJM","ts":"1615132524.037200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bfNs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you want a rigorous certificate I think you need Neumaier Scherbina. I know somebody has implemented that but I don't think it's public yet"}]}]}]},{"client_msg_id":"0940b751-f4bd-4ff4-90d8-29a9f35e5c03","type":"message","text":"But I believe normal LP solvers will give you a feasibility certificate up to floating point roundoff error","user":"U67G3QRJM","ts":"1615132551.038100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AmH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I believe normal LP solvers will give you a feasibility certificate up to floating point roundoff error"}]}]}]},{"client_msg_id":"c189691c-35d2-4bc6-9350-2ad07d1f0cf4","type":"message","text":"How many inequalities do you have?","user":"U67G3QRJM","ts":"1615132591.038800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NEs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How many inequalities do you have?"}]}]}]},{"client_msg_id":"eacd4dc0-f533-4fe4-bc35-410b6d216d00","type":"message","text":"up to 20 if I'm not mistaken","user":"U01MG0TN079","ts":"1615132652.039800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I5L+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"up to 20 if I'm not mistaken"}]}]}]},{"client_msg_id":"c04b6c4d-12f1-4041-a446-6a7c92745646","type":"message","text":"The thing is, in theory, my constraints have coefficients in some number field: my plan was to approximate these with enough precision, get a certificate of either feasibility or infeasibility, plug this certificate in my number field to ensure that it's an \"exact\" certificate, and if it isn't, redo the process using finer approximations","user":"U01MG0TN079","ts":"1615132747.041500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Hii","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The thing is, in theory, my constraints have coefficients in some number field: my plan was to approximate these with enough precision, get a certificate of either feasibility or infeasibility, plug this certificate in my number field to ensure that it's an \"exact\" certificate, and if it isn't, redo the process using finer approximations"}]}]}]},{"client_msg_id":"d6eaa40c-aa3d-420f-b42b-8fb0d6f6276b","type":"message","text":"this looks doable for feasibility, but if I cannot get a certificate for infeasibility, then it's problematic","user":"U01MG0TN079","ts":"1615132785.042100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z70","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"this looks doable for feasibility, but if I cannot get a certificate for infeasibility, then it's problematic"}]}]}]},{"client_msg_id":"28e64143-3666-4db7-9af8-b85efc2e1ea0","type":"message","text":"OR, I could implement Fourier-Motzkin on the number field itself?","user":"U01MG0TN079","ts":"1615132820.042500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zSeS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OR, I could implement Fourier-Motzkin on the number field itself?"}]}]}]},{"client_msg_id":"e2e9d50b-ed51-46fa-9458-c7e886b1565e","type":"message","text":"but I'd bet the optimizations behind \"industry\" solvers will beat any hand-written code easily","user":"U01MG0TN079","ts":"1615132891.043100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z5a22","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but I'd bet the optimizations behind \"industry\" solvers will beat any hand-written code easily"}]}]}]},{"client_msg_id":"0a2f2b33-73a2-4c44-96c3-dfceb8aec081","type":"message","text":"This could well already be implemented in one of the algebra packages like Nemo or Oscar","user":"U67G3QRJM","ts":"1615133205.046300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PZF0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This could well already be implemented in one of the algebra packages like Nemo or Oscar"}]}]}],"thread_ts":"1615133205.046300","reply_count":1,"reply_users_count":1,"latest_reply":"1615133439.049200","reply_users":["U01MG0TN079"],"subscribed":false},{"client_msg_id":"05c7a3ba-31fa-485e-acf5-a09ef4de5006","type":"message","text":"Or Sagemath (Python)","user":"U67G3QRJM","ts":"1615133213.046700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"avQEi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or Sagemath (Python)"}]}]}]},{"client_msg_id":"f9318d2e-2f16-46ea-8b29-2c08428db9a8","type":"message","text":"It's like that: I have a set of, say, a thousand hyperplanes containing zero (in RR^20) and I want to find a \"cell\", which is to say, a connected component of RR^20 - {all hyperplanes}. So, I enumerate all halfspaces defined by the hyperplanes, and keep a list of halfspaces defining a superset of my cell: now, at any new halfspace, I check that intersecting with the new halfspace doesn't kill of my cell, and (if it doesn't) add the halfspace, and remove all unnecessary halfspaces from my new list.","user":"U01MG0TN079","ts":"1615133379.049100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iE5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's like that: I have a set of, say, a thousand hyperplanes containing zero (in RR^20) and I want to find a \"cell\", which is to say, a connected component of RR^20 - {all hyperplanes}. So, I enumerate all halfspaces defined by the hyperplanes, and keep a list of halfspaces defining a superset of my cell: now, at any new halfspace, I check that intersecting with the new halfspace doesn't kill of my cell, and (if it doesn't) add the halfspace, and remove all unnecessary halfspaces from my new list."}]}]}]},{"client_msg_id":"a90527c5-0c2a-44aa-a2f3-03bcd38bb40d","type":"message","text":"(by \"killing off\", I mean that the intersection becomes degenerate)","user":"U01MG0TN079","ts":"1615133501.049900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4wMiq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(by \"killing off\", I mean that the intersection becomes degenerate)"}]}]}]},{"client_msg_id":"e907f07b-cca2-48b6-965d-454c28c2ae35","type":"message","text":"and to remove superfluous halfspaces and check that I don't \"kill off\", I use in both case linear programming to test feasibility","user":"U01MG0TN079","ts":"1615133566.050600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Iiu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and to remove superfluous halfspaces and check that I don't \"kill off\", I use in both case linear programming to test feasibility"}]}]}]},{"client_msg_id":"042b8f74-9669-4c4b-851a-05b86130cc68","type":"message","text":"but now I'm thinking maybe there is some pre-baked library that would do that for me already","user":"U01MG0TN079","ts":"1615133602.051200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Bxu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but now I'm thinking maybe there is some pre-baked library that would do that for me already"}]}]}]},{"client_msg_id":"4c9ee558-b0c0-4666-b282-85291d739b9a","type":"message","text":"<@U01MG0TN079> There are bindings for polymake in Polymake.jl","user":"U85R3JJ8L","ts":"1615133748.052600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rXJ3","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01MG0TN079"},{"type":"text","text":" There are bindings for polymake in Polymake.jl"}]}]}],"reactions":[{"name":"thumbsup_all","users":["U01MG0TN079"],"count":1}]},{"client_msg_id":"ba7e321b-8ffd-47dd-b84f-15351e4068d6","type":"message","text":"(Not sure if polymake has this functionality though)","user":"U85R3JJ8L","ts":"1615133792.054100","team":"T68168MUP","edited":{"user":"U85R3JJ8L","ts":"1615133807.000000"},"blocks":[{"type":"rich_text","block_id":"Jh6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(Not sure if polymake has this functionality though)"}]}]}]},{"client_msg_id":"3cab21b2-fbfa-4c85-a824-b17e24b566cb","type":"message","text":"I tried with `Polyhedra.jl` , but it seemed not woth the hassle (strange errors) and looked at polymake actually; maybe I should look again","user":"U01MG0TN079","ts":"1615133836.055500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"otNCI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I tried with "},{"type":"text","text":"Polyhedra.jl","style":{"code":true}},{"type":"text","text":" , but it seemed not woth the hassle (strange errors) and looked at polymake actually; maybe I should look again"}]}]}]},{"client_msg_id":"1c91d4f2-abd3-4975-aa90-595ad98534d3","type":"message","text":"<@U7KA5J01Y> do you know if polymake/Polymake.jl can do this?","user":"U85R3JJ8L","ts":"1615134038.056500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zV0t","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U7KA5J01Y"},{"type":"text","text":" do you know if polymake/Polymake.jl can do this?"}]}]}]},{"client_msg_id":"3a19196a-2697-448a-a01e-acf927adfe19","type":"message","text":"If you're working over a number field, the extrema points of the convex set should be numbers with coefficients in the number field.","user":"UDD5Z7FLZ","ts":"1615138574.057600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HfH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you're working over a number field, the extrema points of the convex set should be numbers with coefficients in the number field."}]}]}]},{"client_msg_id":"095cc27e-edc6-4627-9667-aa8c040cd749","type":"message","text":"unrelated to Julia - but is there a name for a matrix whose eigenvalues have non-negative real parts? I’ve heard a “stable matrix” refer to matrices whose eigenvalues have positive real parts, but I’m not sure if there’s a distinct name for the non-negative case.","user":"U011LUQ182G","ts":"1615140401.058900","team":"T68168MUP","edited":{"user":"U011LUQ182G","ts":"1615140670.000000"},"blocks":[{"type":"rich_text","block_id":"Mhj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"unrelated to Julia - but is there a name for a matrix whose eigenvalues have non-negative real parts? I’ve heard a “stable matrix” refer to matrices whose eigenvalues have positive real parts, but I’m not sure if there’s a distinct name for the non-negative case."}]}]}],"thread_ts":"1615140401.058900","reply_count":9,"reply_users_count":3,"latest_reply":"1615140962.061200","reply_users":["UJ7DVTVQ8","U8HHPBKQR","U011LUQ182G"],"subscribed":false},{"client_msg_id":"25774e93-f0b4-4c36-902b-840b529816e0","type":"message","text":"Hi <@U01MG0TN079>, LazySets maintainer here. I think you're looking for the function <https://juliareach.github.io/LazySets.jl/dev/lib/sets/HPolyhedron/#Base.isempty-Union{Tuple{Union{HPolyhedron{N,VN}%20where%20VN%3C:AbstractArray{N,1},%20HPolytope{N,VN}%20where%20VN%3C:AbstractArray{N,1}}},%20Tuple{N},%20Tuple{Union{HPolyhedron{N,VN}%20where%20VN%3C:AbstractArray{N,1},%20HPolytope{N,VN}%20where%20VN%3C:AbstractArray{N,1}},Bool}}%20where%20N|isempty> for an HPolyhedron. Try with the CDDLib solver, which also admits to work with exact arithmetic if you prefer.","user":"U9Z3H4H5F","ts":"1615217749.070100","team":"T68168MUP","edited":{"user":"U9Z3H4H5F","ts":"1615217862.000000"},"blocks":[{"type":"rich_text","block_id":"s19g","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi "},{"type":"user","user_id":"U01MG0TN079"},{"type":"text","text":", LazySets maintainer here. I think you're looking for the function "},{"type":"link","url":"https://juliareach.github.io/LazySets.jl/dev/lib/sets/HPolyhedron/#Base.isempty-Union{Tuple{Union{HPolyhedron{N,VN}%20where%20VN%3C:AbstractArray{N,1},%20HPolytope{N,VN}%20where%20VN%3C:AbstractArray{N,1}}},%20Tuple{N},%20Tuple{Union{HPolyhedron{N,VN}%20where%20VN%3C:AbstractArray{N,1},%20HPolytope{N,VN}%20where%20VN%3C:AbstractArray{N,1}},Bool}}%20where%20N","text":"isempty"},{"type":"text","text":" for an HPolyhedron. Try with the CDDLib solver, which also admits to work with exact arithmetic if you prefer."}]}]}]},{"client_msg_id":"2b5e8dd6-ddcf-4b34-9b41-28c139abdaca","type":"message","text":"There is also a function `remove_redundant_constraints` which does something similar as what you described above.","user":"U9Z3H4H5F","ts":"1615218353.072200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LrghO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is also a function "},{"type":"text","text":"remove_redundant_constraints","style":{"code":true}},{"type":"text","text":" which does something similar as what you described above."}]}]}]},{"client_msg_id":"e5e10cb1-0fcd-46f1-8b47-24bd2f15f219","type":"message","text":"Really neat free resource: <https://optimaltransport.github.io/>","user":"UPUBAM63X","ts":"1615668594.075900","team":"T68168MUP","edited":{"user":"UPUBAM63X","ts":"1615668644.000000"},"blocks":[{"type":"rich_text","block_id":"UV2jB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Really neat free resource: "},{"type":"link","url":"https://optimaltransport.github.io/"}]}]}],"thread_ts":"1615668594.075900","reply_count":4,"reply_users_count":3,"latest_reply":"1615669429.076900","reply_users":["UM8JUNJG7","UPUBAM63X","UMDEUKM29"],"subscribed":false},{"client_msg_id":"19278c88-fdfc-4565-86a8-666433b924fd","type":"message","text":"How do people handle infinite's in the wild? Like one infinite can be smaller than another, or whatever, but it's still infinite. Does it only matter if you like go on to do cesaro summations or do these kinds of problems \"commonly\" arise in applied fields too? Seems like they would...","user":"UPUBAM63X","ts":"1615745341.080500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r2pO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How do people handle infinite's in the wild? Like one infinite can be smaller than another, or whatever, but it's still infinite. Does it only matter if you like go on to do cesaro summations or do these kinds of problems \"commonly\" arise in applied fields too? Seems like they would..."}]}]}]},{"client_msg_id":"af1ba220-b9c8-4001-88f9-5053929afad4","type":"message","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form `[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]` where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first `length(a)` elements of the result (or in \"batched\" mode, `CartesianIndices(a)`)*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of `ifft(fft(a_padded) .* fft(b_padded))` stays real and not complex. It works and is fairly fast (at least compared to a naive `mapreduce` impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the `DSP.conv` but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the `NNlib.conv` doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size).","user":"UHDNY2YMA","ts":"1615759299.083400","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615759799.000000"},"blocks":[{"type":"rich_text","block_id":"wSgu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form "},{"type":"text","text":"[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]","style":{"code":true}},{"type":"text","text":" where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first "},{"type":"text","text":"length(a)","style":{"code":true}},{"type":"text","text":" elements of the result (or in \"batched\" mode, "},{"type":"text","text":"CartesianIndices(a)","style":{"code":true}},{"type":"text","text":")*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of "},{"type":"text","text":"ifft(fft(a_padded) .* fft(b_padded))","style":{"code":true}},{"type":"text","text":" stays real and not complex. It works and is fairly fast (at least compared to a naive "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":" impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the "},{"type":"text","text":"DSP.conv","style":{"code":true}},{"type":"text","text":" but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the "},{"type":"text","text":"NNlib.conv","style":{"code":true}},{"type":"text","text":" doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size)."}]}]}],"thread_ts":"1615759299.083400","reply_count":1,"reply_users_count":1,"latest_reply":"1615760201.083600","reply_users":["UM30MT6RF"],"subscribed":false}]}