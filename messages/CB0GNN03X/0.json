{"cursor": 0, "messages": [{"type":"message","text":"","user":"U011V2YN59N","ts":"1617892612.000300","team":"T68168MUP","attachments":[{"fallback":"[April 8th, 2021 10:33 AM] pjentsch: Taking the name of this channel literally, are there any vectorized RNGs in Julia? <https://github.com/lemire/SIMDxorshift|Here> in one in C. I find that often operations that might be vectorized are bottlenecked by the serial nature of RNGs, producing just a stream of random floats.","ts":"1617892396.178800","author_id":"U011V2YN59N","author_subname":"Peter J","channel_id":"C680MM7D4","channel_name":"random","is_msg_unfurl":true,"is_thread_root_unfurl":true,"text":"Taking the name of this channel literally, are there any vectorized RNGs in Julia? <https://github.com/lemire/SIMDxorshift|Here> in one in C. I find that often operations that might be vectorized are bottlenecked by the serial nature of RNGs, producing just a stream of random floats.","author_name":"Peter J","author_link":"https://julialang.slack.com/team/U011V2YN59N","author_icon":"https://avatars.slack-edge.com/2020-04-22/1103390456848_2f885299664a3012f2e3_48.jpg","mrkdwn_in":["text"],"color":"D0D0D0","from_url":"https://julialang.slack.com/archives/C680MM7D4/p1617892396178800?thread_ts=1617892396178800&cid=C680MM7D4","is_share":true,"footer":"Thread in #random"}]},{"client_msg_id":"bd3f97a6-e0be-46a6-9edd-6a3d2d36aee6","type":"message","text":"Yep, <https://github.com/JuliaSIMD/VectorizedRNG.jl>.\nThere is also this old PR (<https://github.com/JuliaLang/julia/pull/34852>), which is about making the default Julia RNG vectorized (and task-local)","user":"U7HAYKY9X","ts":"1617895473.001100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iNr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yep, "},{"type":"link","url":"https://github.com/JuliaSIMD/VectorizedRNG.jl"},{"type":"text","text":".\nThere is also this old PR ("},{"type":"link","url":"https://github.com/JuliaLang/julia/pull/34852"},{"type":"text","text":"), which is about making the default Julia RNG vectorized (and task-local)"}]}]}]},{"client_msg_id":"290963f7-de3e-4c97-9000-1bb984e38991","type":"message","text":"cool yeah, <@UJ7DVTVQ8> also mentioned this in the other thread. That package does not appear to define vectorized distribution sampling, is there a separate place for that, or are they yet to be implemented?","user":"U011V2YN59N","ts":"1617895634.002200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MAGSS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"cool yeah, "},{"type":"user","user_id":"UJ7DVTVQ8"},{"type":"text","text":" also mentioned this in the other thread. That package does not appear to define vectorized distribution sampling, is there a separate place for that, or are they yet to be implemented?"}]}]}]},{"type":"message","subtype":"channel_join","ts":"1617895674.002400","user":"UJ7DVTVQ8","text":"<@UJ7DVTVQ8> has joined the channel","inviter":"U011V2YN59N"},{"client_msg_id":"1b71c573-1cf0-4988-9a9e-665134529c12","type":"message","text":"I don't know of any such thing. Since it's only possible to SIMD'ify simple arrays, I would imagine the only way would be if the package that defines distribution sampling implements such a thing. A simple way would be to initialize an array of random values using `Base.rand!` , then use those values to create the distribution samples","user":"U7HAYKY9X","ts":"1617896211.004500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mSxJV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't know of any such thing. Since it's only possible to SIMD'ify simple arrays, I would imagine the only way would be if the package that defines distribution sampling implements such a thing. A simple way would be to initialize an array of random values using "},{"type":"text","text":"Base.rand!","style":{"code":true}},{"type":"text","text":" , then use those values to create the distribution samples"}]}]}]},{"client_msg_id":"87529118-194e-4809-a0e0-24c264d3a000","type":"message","text":"hm, yeah I will have to look up parallel samplers. It's an interesting problem.","user":"U011V2YN59N","ts":"1617896719.005700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ijd0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hm, yeah I will have to look up parallel samplers. It's an interesting problem."}]}]}]},{"client_msg_id":"57c8fe86-a0e1-4ccc-b762-e9f616b50eb8","type":"message","text":"&gt; A simple way would be to initialize an array of random values using Base.rand! , then use those values to create the distribution samples\nIt's exactly the trick used in the array version of `randn` !","user":"U6QPTG69E","ts":"1617896799.006400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KzdNE","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"A simple way would be to initialize an array of random values using Base.rand! , then use those values to create the distribution samples"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It's exactly the trick used in the array version of "},{"type":"text","text":"randn","style":{"code":true}},{"type":"text","text":" !"}]}]}]},{"client_msg_id":"bd4dbead-e018-43d2-8350-c6a7dee500a2","type":"message","text":"Yeah I think the problem is that a lot of samplers do not statically know the number of samples they need. They just sample from the stream until a condition is satisfied. It is fine to take a few extra samples of course, but optimizing that tradeoff is probably hard.","user":"U011V2YN59N","ts":"1617897310.007900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7L5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah I think the problem is that a lot of samplers do not statically know the number of samples they need. They just sample from the stream until a condition is satisfied. It is fine to take a few extra samples of course, but optimizing that tradeoff is probably hard."}]}]}]},{"client_msg_id":"e876d0e5-4dde-4c8f-9566-fcfb181d3ef0","type":"message","text":"<@U6QPTG69E> is this trick used in other random samplers? particularly I am interesting in sampling short vectors of geometric random variates.","user":"U011V2YN59N","ts":"1617897606.008800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w=J3","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6QPTG69E"},{"type":"text","text":" is this trick used in other random samplers? particularly I am interesting in sampling short vectors of geometric random variates."}]}]}]},{"client_msg_id":"7c2258cc-e3dd-4f98-b5c5-187b20ddcbf7","type":"message","text":"I think it does so also for `randexp`, but I'm not aware of others","user":"U6QPTG69E","ts":"1617898278.009400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Gvw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it does so also for "},{"type":"text","text":"randexp","style":{"code":true}},{"type":"text","text":", but I'm not aware of others"}]}]}],"reactions":[{"name":"+1","users":["U011V2YN59N"],"count":1}]}]}