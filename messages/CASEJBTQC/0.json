{"cursor": 0, "messages": [{"client_msg_id":"f45dc03e-27d0-4713-a184-eeb9b0aa0967","type":"message","text":"Hi there. I have a very basic question about macros. I am trying to define a macro that generate the second method based on the first one. (something does something based on x, not only x[i])\n```f(i::Int, x::Vector) = something(x[i],x)\nf(x::Vector) = map(i -&gt; f(i, x), 1:length(x))```\nAny idea?","user":"U01FR2HFJ7M","ts":"1608622994.068400","team":"T68168MUP","edited":{"user":"U01FR2HFJ7M","ts":"1608623257.000000"},"blocks":[{"type":"rich_text","block_id":"iPO2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi there. I have a very basic question about macros. I am trying to define a macro that generate the second method based on the first one. (something does something based on x, not only x[i])\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"f(i::Int, x::Vector) = something(x[i],x)\nf(x::Vector) = map(i -> f(i, x), 1:length(x))"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Any idea?"}]}]}]},{"client_msg_id":"7a3004cf-0b61-459f-8bc3-26dc66c0aada","type":"message","text":"<@U01FR2HFJ7M> What do you need to do that needs a macro?","user":"U6QGE7S86","ts":"1608668741.069500","team":"T68168MUP","edited":{"user":"U6QGE7S86","ts":"1608668754.000000"},"blocks":[{"type":"rich_text","block_id":"8r=Vj","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01FR2HFJ7M"},{"type":"text","text":" What do you need to do that needs a macro?"}]}]}]},{"client_msg_id":"927aa77e-70c1-4f3e-ae3f-784faf2b519c","type":"message","text":"You might be able to do the same by making an array / dict of functions and then looking it up, then calling it.","user":"U6QGE7S86","ts":"1608668777.070100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fZn4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might be able to do the same by making an array / dict of functions and then looking it up, then calling it."}]}]}]},{"client_msg_id":"15b3b9dd-0374-41ee-9841-e81d305715c2","type":"message","text":"One reason is that I'm lazy and I have a lot of those function. Also, users of my package can add some function on the fly that would need that the second method to be generated. But I can probably try to do something with a dict. Thanks for the help <@U6QGE7S86>","user":"U01FR2HFJ7M","ts":"1608676895.075200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tlc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One reason is that I'm lazy and I have a lot of those function. Also, users of my package can add some function on the fly that would need that the second method to be generated. But I can probably try to do something with a dict. Thanks for the help "},{"type":"user","user_id":"U6QGE7S86"}]}]}]},{"client_msg_id":"27e986e7-22c3-4785-8bf8-5aa55c00967b","type":"message","text":"```julia&gt; f(x) = 2x\nf (generic function with 1 method)\n\njulia&gt; h(x) = 3x\nh (generic function with 1 method)\n\njulia&gt; z(x) = 4x\nz (generic function with 1 method)\n\njulia&gt; funcs = (f,z,h)\n(f, z, h)\n\njulia&gt; funcs[2](3)\n12```","user":"U6QGE7S86","ts":"1608680352.076100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"V5M","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> f(x) = 2x\nf (generic function with 1 method)\n\njulia> h(x) = 3x\nh (generic function with 1 method)\n\njulia> z(x) = 4x\nz (generic function with 1 method)\n\njulia> funcs = (f,z,h)\n(f, z, h)\n\njulia> funcs[2](3)\n12"}]}]}]},{"client_msg_id":"d34d77b8-9346-4913-a7ad-6f425e079225","type":"message","text":"<@U01FR2HFJ7M> can you identify all the possible funcitons that you need to generate without input data?","user":"U6QGE7S86","ts":"1608680386.076700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"24bC","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01FR2HFJ7M"},{"type":"text","text":" can you identify all the possible funcitons that you need to generate without input data?"}]}]}]},{"client_msg_id":"5e3982f8-de81-4983-9169-7c666b0e7344","type":"message","text":"(i.e, at compile time?)","user":"U6QGE7S86","ts":"1608680624.077000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Msa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(i.e, at compile time?)"}]}]}]},{"client_msg_id":"67ab13bb-ac61-44eb-b538-58f59fe011e9","type":"message","text":"For most yes, but not all of them (as the user is likely to input some of its own).\nMore than using a macro, I wanted something as easy to use as the `@lazy` macro  of Lazy.jl.\nWell, I will go with handcoded ones for a start and think carefully for the user input ones later","user":"U01FR2HFJ7M","ts":"1608682705.081200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6zr34","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For most yes, but not all of them (as the user is likely to input some of its own).\nMore than using a macro, I wanted something as easy to use as the "},{"type":"text","text":"@lazy","style":{"code":true}},{"type":"text","text":" macro  of Lazy.jl.\nWell, I will go with handcoded ones for a start and think carefully for the user input ones later"}]}]}]},{"client_msg_id":"E3FE7BD7-F81A-4E15-BC04-9607420F85B1","type":"message","text":"So I’m not 100% sure of this, but I think that Julia is a lisp that uses M expressions. Is that written down somewhere that I could cite in a blog post? ","user":"U69L6CPJN","ts":"1609887218.084000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pnUB9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I’m not 100% sure of this, but I think that Julia is a lisp that uses M expressions. Is that written down somewhere that I could cite in a blog post? "}]}]}]},{"client_msg_id":"CEBEC1AC-0D34-472F-A103-22137A09C94B","type":"message","text":"As I think about it, I’m not sure I know what “is a lisp” or “uses M expressions” really mean in a precise sense. ","user":"U69L6CPJN","ts":"1609887264.084700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k=H","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As I think about it, I’m not sure I know what “is a lisp” or “uses M expressions” really mean in a precise sense. "}]}]}]},{"client_msg_id":"be058a3c-1292-454c-910f-e1d9e160c283","type":"message","text":"I think the general response is 'meh, what does it really mean to be a lisp anyways?'","user":"U8D9768Q6","ts":"1609890553.085400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=oKc8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the general response is 'meh, what does it really mean to be a lisp anyways?'"}]}]}]},{"client_msg_id":"7cfd85e4-f15f-4d1b-984d-e1cecd1b7e32","type":"message","text":"It's generally not worth claiming to be a lisp, just like it was not worth claiming to have dependent types.","user":"U8D9768Q6","ts":"1609890590.086100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"izI2+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's generally not worth claiming to be a lisp, just like it was not worth claiming to have dependent types."}]}]}]},{"client_msg_id":"d4dd636b-aa5a-4b40-9b32-1bf56f19bda5","type":"message","text":"Many people in the lisp community don't consider Clojure to be a lisp. It would not be productive to have this conversation with those people","user":"U8D9768Q6","ts":"1609890630.086900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2sDT8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Many people in the lisp community don't consider Clojure to be a lisp. It would not be productive to have this conversation with those people"}]}]}]},{"client_msg_id":"b519ca74-2c1d-4d93-87a7-e8a2f17c03c0","type":"message","text":"but we do have dependent types!","user":"U69L6CPJN","ts":"1609899521.087200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yVL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but we do have dependent types!"}]}]}]},{"client_msg_id":"bd4877da-6a55-47e3-856a-1ab605ad3a7f","type":"message","text":"On a complete aside, in my opinion, being a lisp is moreso a philosophy then a set of features a language has.","user":"UDD5Z7FLZ","ts":"1609901453.087700","team":"T68168MUP","edited":{"user":"UDD5Z7FLZ","ts":"1609901463.000000"},"blocks":[{"type":"rich_text","block_id":"5wV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On a complete aside, in my opinion, being a lisp is moreso a philosophy then a set of features a language has."}]}]}]},{"type":"message","subtype":"thread_broadcast","text":"Yes, but we no longer claim to have them because it upsets PL wheenies too much.","user":"U8D9768Q6","ts":"1609901727.087900","thread_ts":"1609899521.087200","root":{"client_msg_id":"b519ca74-2c1d-4d93-87a7-e8a2f17c03c0","type":"message","text":"but we do have dependent types!","user":"U69L6CPJN","ts":"1609899521.087200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yVL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but we do have dependent types!"}]}]}],"thread_ts":"1609899521.087200","reply_count":3,"reply_users_count":2,"latest_reply":"1609901954.089200","reply_users":["U8D9768Q6","U69L6CPJN"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"ZBv6r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, but we no longer claim to have them because it upsets PL wheenies too much."}]}]}],"client_msg_id":"ed9aa3b7-b71e-45cc-8c11-a17a5ca9aded"},{"client_msg_id":"a48800f8-bb64-4190-a2db-9263028dedb6","type":"message","text":"I'd say lisp is a language family that Julia is closely related to, but not really a member of.","user":"U8D9768Q6","ts":"1609901774.088800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XYLAB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd say lisp is a language family that Julia is closely related to, but not really a member of."}]}]}]},{"client_msg_id":"4ed986c5-668c-4685-8b38-5e50fd5a3899","type":"message","text":"Wikipedia says:\n&gt;  There are several new dialects of Lisp: <https://en.wikipedia.org/wiki/Arc_(programming_language)|Arc>, <https://en.wikipedia.org/wiki/Hy|Hy>, <https://en.wikipedia.org/wiki/Nu_(programming_language)|Nu>, <https://en.wikipedia.org/w/index.php?title=Liskell&amp;action=edit&amp;redlink=1|Liskell>, and <https://en.wikipedia.org/wiki/LFE_(programming_language)|LFE> (Lisp Flavored Erlang). The parser for <https://en.wikipedia.org/wiki/Julia_(programming_language)|Julia> is implemented in Femtolisp, a dialect of <https://en.wikipedia.org/wiki/Scheme_(programming_language)|Scheme> (Julia is inspired by Scheme, which in turn is a Lisp dialect).","user":"U69L6CPJN","ts":"1609902067.089600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WkC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Wikipedia says:\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":" There are several new dialects of Lisp: "},{"type":"link","url":"https://en.wikipedia.org/wiki/Arc_(programming_language)","text":"Arc"},{"type":"text","text":", "},{"type":"link","url":"https://en.wikipedia.org/wiki/Hy","text":"Hy"},{"type":"text","text":", "},{"type":"link","url":"https://en.wikipedia.org/wiki/Nu_(programming_language)","text":"Nu"},{"type":"text","text":", "},{"type":"link","url":"https://en.wikipedia.org/w/index.php?title=Liskell&action=edit&redlink=1","text":"Liskell"},{"type":"text","text":", and "},{"type":"link","url":"https://en.wikipedia.org/wiki/LFE_(programming_language)","text":"LFE"},{"type":"text","text":" (Lisp Flavored Erlang). The parser for "},{"type":"link","url":"https://en.wikipedia.org/wiki/Julia_(programming_language)","text":"Julia"},{"type":"text","text":" is implemented in Femtolisp, a dialect of "},{"type":"link","url":"https://en.wikipedia.org/wiki/Scheme_(programming_language)","text":"Scheme"},{"type":"text","text":" (Julia is inspired by Scheme, which in turn is a Lisp dialect)."}]}]}]},{"client_msg_id":"b850f916-9dc0-4301-b48c-1fb2c9ec80d8","type":"message","text":"Seems like all you need to be a lisp is homoiconicity, macros, and S-Expressions as a core data structure and lambdas (functions as data)","user":"U69L6CPJN","ts":"1609902171.090300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZRk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Seems like all you need to be a lisp is homoiconicity, macros, and S-Expressions as a core data structure and lambdas (functions as data)"}]}]}]},{"client_msg_id":"f010a305-146c-4a88-ac4f-32f08cec0623","type":"message","text":"based on the wiki page","user":"U69L6CPJN","ts":"1609902179.090500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kauv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"based on the wiki page"}]}]}]},{"client_msg_id":"24502E9F-2516-4142-A7D8-27B8DFCFF505","type":"message","text":"<@U8D9768Q6> thats the cringiest thread I’ve ever read","user":"UKA81L34J","ts":"1609903403.091200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iSE+","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8D9768Q6"},{"type":"text","text":" thats the cringiest thread I’ve ever read"}]}]}]},{"client_msg_id":"B30BECC6-CB72-4D74-AD68-1647C2B12800","type":"message","text":"You win","user":"UKA81L34J","ts":"1609903413.091400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Nf9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You win"}]}]}]},{"client_msg_id":"BACAAF91-0C20-4453-8D8B-6EC2D70C3C62","type":"message","text":"Sooo bad","user":"U8D9768Q6","ts":"1609903915.091800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WaFty","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sooo bad"}]}]}]},{"client_msg_id":"F27767D8-2DE0-47BD-B611-5971DD0C4254","type":"message","text":"What about when I dispatch on generated functions with isbits values ? Am I doing dependent types ?","user":"UKA81L34J","ts":"1609904464.092800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7DXAq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What about when I dispatch on generated functions with isbits values ? Am I doing dependent types ?"}]}]}]},{"client_msg_id":"2D01DFFC-67EE-4A36-9C05-9D3A950C54A2","type":"message","text":"Does Zig have dependent types with comptime ?","user":"UKA81L34J","ts":"1609904492.093300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Aosy6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does Zig have dependent types with comptime ?"}]}]}]},{"client_msg_id":"891DA576-0608-41FC-BD05-0F195801D0F4","type":"message","text":"I have so many questions","user":"UKA81L34J","ts":"1609904497.093500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ph/p4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have so many questions"}]}]}]},{"client_msg_id":"b3371d9f-7733-4f55-8a7b-e055816435e7","type":"message","text":"The example everyone uses is Vector where the length of the vector is in the type. StaticArrays does that :julia:  julia has dependent types.","user":"U69L6CPJN","ts":"1609907027.094500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"btDsU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The example everyone uses is Vector where the length of the vector is in the type. StaticArrays does that "},{"type":"emoji","name":"julia"},{"type":"text","text":"  julia has dependent types."}]}]}]},{"client_msg_id":"2bc8c197-44c1-49f7-a991-97f33a8cda54","type":"message","text":"It doesn't have a static type checker that can prove stuff using those types, but :shrug:","user":"U69L6CPJN","ts":"1609907062.095000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"p0J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It doesn't have a static type checker that can prove stuff using those types, but "},{"type":"emoji","name":"shrug"}]}]}]},{"client_msg_id":"6b595cbd-4a74-4c76-b260-b5d59ee1f765","type":"message","text":"But if Haskell runs with ... :expressionless:","user":"U69BL50BF","ts":"1609907363.095400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2aH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But if Haskell runs with ... "},{"type":"emoji","name":"expressionless"}]}]}]},{"client_msg_id":"3e46d9d7-3e03-4cf2-a69a-23730c6dffbc","type":"message","text":"Is it possible to wrap an instance of a composite type as an `Expr`?\n\nHere is the context: Initially, I have an empty array of expressions `Expr[]` that later gets populated. However, on some occasions, I want to evaluate a given expression and then push the result to that array. The result after evaluating the expression is an instance of a composite type. I tried enclosing it with `:()` but it has no effect. Is there a way to accomplish this?","user":"UEA5FBCRH","ts":"1609925672.105500","team":"T68168MUP","edited":{"user":"UEA5FBCRH","ts":"1609925692.000000"},"blocks":[{"type":"rich_text","block_id":"aLS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it possible to wrap an instance of a composite type as an "},{"type":"text","text":"Expr","style":{"code":true}},{"type":"text","text":"?\n\nHere is the context: Initially, I have an empty array of expressions "},{"type":"text","text":"Expr[]","style":{"code":true}},{"type":"text","text":" that later gets populated. However, on some occasions, I want to evaluate a given expression and then push the result to that array. The result after evaluating the expression is an instance of a composite type. I tried enclosing it with "},{"type":"text","text":":()","style":{"code":true}},{"type":"text","text":" but it has no effect. Is there a way to accomplish this?"}]}]}]}]}