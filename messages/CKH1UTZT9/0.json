{"cursor": 0, "messages": [{"client_msg_id":"24188e99-519d-49cc-bc2c-9f04be822617","type":"message","text":"New breaking release of ControlSystems.jl brings a lot of new improvements\n<https://github.com/JuliaControl/ControlSystems.jl/releases/tag/v0.9.0>\nbreaking changes are listed [here](<https://github.com/JuliaControl/ControlSystems.jl#2021-01>)","user":"UJ7DVTVQ8","ts":"1612008751.000600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"y+srL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"New breaking release of ControlSystems.jl brings a lot of new improvements\n"},{"type":"link","url":"https://github.com/JuliaControl/ControlSystems.jl/releases/tag/v0.9.0"},{"type":"text","text":"\nbreaking changes are listed [here]("},{"type":"link","url":"https://github.com/JuliaControl/ControlSystems.jl#2021-01"},{"type":"text","text":")"}]}]}],"reactions":[{"name":"thumbsup_all","users":["U01BX0V74Q2"],"count":1},{"name":"+1","users":["UM8JUNJG7"],"count":1}]},{"client_msg_id":"035f13e1-32f4-4335-be02-618f043b87aa","type":"message","text":"For anyone interested in nonlinear optimal control, there's a stub tutorial showing what can be done in ModelingToolkit right now: <https://mtk.sciml.ai/dev/tutorials/nonlinear_optimal_control/>. You can see where we are going if you look at the acausal modeling tutorial: <https://mtk.sciml.ai/dev/tutorials/acausal_components/> . We plan to get similar interfaces together to make it easy to specify the variables and get the solutions as time series, along with symbolic simplification of the generated optimization problems. But it should be pretty clear what the near future looks like!","user":"U69BL50BF","ts":"1614515537.001800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eVg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For anyone interested in nonlinear optimal control, there's a stub tutorial showing what can be done in ModelingToolkit right now: "},{"type":"link","url":"https://mtk.sciml.ai/dev/tutorials/nonlinear_optimal_control/"},{"type":"text","text":". You can see where we are going if you look at the acausal modeling tutorial: "},{"type":"link","url":"https://mtk.sciml.ai/dev/tutorials/acausal_components/"},{"type":"text","text":" . We plan to get similar interfaces together to make it easy to specify the variables and get the solutions as time series, along with symbolic simplification of the generated optimization problems. But it should be pretty clear what the near future looks like!"}]}]}],"thread_ts":"1614515537.001800","reply_count":4,"reply_users_count":2,"latest_reply":"1614516855.002500","reply_users":["U011NEW8A2E","U69BL50BF"],"subscribed":false},{"type":"message","text":"I've had a look at ControlSystems internals and i've noticed that the implementations could allow for more thoughput.\nThe package doesn't use Static Arrays where it could, it doesn't create a block diagonal for the A of the sum of two state space systems.\n\nHas anyone encountered performance problems with ControlSystems?","user":"U9MD78Z9N","ts":"1615389362.000500","team":"T68168MUP"},{"client_msg_id":"c93014d9-88cb-4512-8845-2491dcb01c5b","type":"message","text":"We have the type `HeteroStateSpace` that accepts arbitrary matrix types, I use this with static arrays","user":"UJ7DVTVQ8","ts":"1615389410.001000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rYI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We have the type "},{"type":"text","text":"HeteroStateSpace","style":{"code":true}},{"type":"text","text":" that accepts arbitrary matrix types, I use this with static arrays"}]}]}]},{"type":"message","text":"I see.","user":"U9MD78Z9N","ts":"1615389513.001100","team":"T68168MUP"},{"type":"message","text":"Has anyone ever worked with large enough systems that ControlSystems became a serious bottleneck of the workflow?","user":"U9MD78Z9N","ts":"1615389633.001200","team":"T68168MUP"},{"client_msg_id":"da30c511-b5a4-4b15-94b6-9df046afe436","type":"message","text":"Sure, it becomes the bottleneck already for small systems if you close an optimization loop around, e.g., freqresp or lsim etc.","user":"UJ7DVTVQ8","ts":"1615389773.003000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Zme5z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sure, it becomes the bottleneck already for small systems if you close an optimization loop around, e.g., freqresp or lsim etc."}]}]}]},{"client_msg_id":"808b75ff-c978-44ad-9649-d942fe92ae70","type":"message","text":"there's lots of room for performance improvement for `freqresp` in particular","user":"UJ7DVTVQ8","ts":"1615389806.003500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"21KVP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there's lots of room for performance improvement for "},{"type":"text","text":"freqresp","style":{"code":true}},{"type":"text","text":" in particular"}]}]}]},{"client_msg_id":"fbe7d32d-20ba-42d4-8a23-6bd6e2afe1e8","type":"message","text":"I have never worked with very large systems with, e.g., sparse matrices, but I can imagine that there are some fixes to apply before everything works perfectly for those","user":"UJ7DVTVQ8","ts":"1615389870.004500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Urzm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have never worked with very large systems with, e.g., sparse matrices, but I can imagine that there are some fixes to apply before everything works perfectly for those"}]}]}]},{"client_msg_id":"51b39f73-451e-43c8-91d0-9d3f81ae7391","type":"message","text":"I haven't necessarily seen bottlenecks, but I have an example system I can use that is 50x50 with only 400 non-zero entries in the state transition matrix - so I like using sparse matrices for that.","user":"UPTBGS6CC","ts":"1615393357.005400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1MED","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I haven't necessarily seen bottlenecks, but I have an example system I can use that is 50x50 with only 400 non-zero entries in the state transition matrix - so I like using sparse matrices for that."}]}]}]},{"client_msg_id":"1539a7e4-c5c1-459e-a48b-552bf99039f9","type":"message","text":"<https://github.com/imciner2/ControlBenchmarks.jl/blob/master/src/benchmarks/ifac/prob9006-airplaneFlutter.jl>","user":"UPTBGS6CC","ts":"1615393375.005600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QzS","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/imciner2/ControlBenchmarks.jl/blob/master/src/benchmarks/ifac/prob9006-airplaneFlutter.jl"}]}]}]},{"client_msg_id":"97390883-70c0-450a-852d-b5d0eb7f4b8f","type":"message","text":"I haven't updated this to work with the changes in 0.8 yet though, so I can't guarantee that will actually work :laughing:","user":"UPTBGS6CC","ts":"1615393400.006100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bkvA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I haven't updated this to work with the changes in 0.8 yet though, so I can't guarantee that will actually work "},{"type":"emoji","name":"laughing"}]}]}]},{"client_msg_id":"ab739c3c-a114-4d3e-b3e3-135e1709e58e","type":"message","text":"The main part that I care about with sparse capabilities is that we can represent the system in it, since when I work with MPC for a system like that I would like to keep the sparsity information when I form my optimization problem and not end up with a large dense problem with a lot of zeros.","user":"UPTBGS6CC","ts":"1615393553.007200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MRf0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The main part that I care about with sparse capabilities is that we can represent the system in it, since when I work with MPC for a system like that I would like to keep the sparsity information when I form my optimization problem and not end up with a large dense problem with a lot of zeros."}]}]}]},{"client_msg_id":"db00a4b0-68a0-4bcf-bbde-94ac5530cff9","type":"message","text":"The HeteroStateSpace is intended to work with sparse matrixes. I am not sure how many of the functions are generic enough to handle it well, but please tell us if you run into any problems. A few versions ago we decided to simplify the standard StateSpace type and create the even more general HeteroStateSpace type instead","user":"U011NEW8A2E","ts":"1615393797.011700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nfp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The HeteroStateSpace is intended to work with sparse matrixes. I am not sure how many of the functions are generic enough to handle it well, but please tell us if you run into any problems. A few versions ago we decided to simplify the standard StateSpace type and create the even more general HeteroStateSpace type instead"}]}]}]},{"client_msg_id":"23d5e942-a28a-4da4-82a3-06beb6d2181b","type":"message","text":"Hey Control folks, I just had a question. I am still relatively new to control theory--coming from statistics. But I was wondering what the current thinking/methods are as a control system becomes more and more complex. Even having a few additional joints in some simple pendulum or spring mass system will generate a number of additional equations, etc. I would imagine that the challenges of maintaining and validating all of the equations and forces quickly becomes too much for individuals to follows. Is the current thinking to simply rely on say more modular designs where subsystems are nested into the main system, and each piece only has to worry about a limited set of physics. Or is the idea to move towards more systems-identification approaches which are less model-intensive if not model-free? I imagine neural networks enter the question here as well. Any insights from your experience would be appreciated.","user":"UDDSTBX19","ts":"1615904336.005200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XjcVK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey Control folks, I just had a question. I am still relatively new to control theory--coming from statistics. But I was wondering what the current thinking/methods are as a control system becomes more and more complex. Even having a few additional joints in some simple pendulum or spring mass system will generate a number of additional equations, etc. I would imagine that the challenges of maintaining and validating all of the equations and forces quickly becomes too much for individuals to follows. Is the current thinking to simply rely on say more modular designs where subsystems are nested into the main system, and each piece only has to worry about a limited set of physics. Or is the idea to move towards more systems-identification approaches which are less model-intensive if not model-free? I imagine neural networks enter the question here as well. Any insights from your experience would be appreciated."}]}]}]},{"client_msg_id":"5c673ea2-10c9-46ac-a59c-c99fdd4f731d","type":"message","text":"I would say that it very much depends on context. The classical thinking in control is similar to engineering in general, to isolate subsystems and make sure they behave well (well controlled) in isolation, after which they can be approximated by much simpler dynamics. If you take the complicated pendulum dynamics and are only interested in its behavior around an operating point, you design a controller that maintains that operating point and after that the complicated pendulum behaves more or less like a linear system. This also means that the model of the pendulum really only has to be good around this operating point since you will not deviate from this anyway.\nIf you are interested in optimally moving the pendulum around complicated trajectories, you instead design a controller around a trajectory that makes sure that you follow the trajectory even in the presence of model errors etc. This of course requires you to leave room for this controller to operate when you solve the optimal control problem.\n\nModels can get vastly omre complicated than a pendulum with several joints though, the trick then is to make use of modeling tools, ModelingToolkit being one such tool, that allows you to compose simple and well-tested building blocks together to form a bigger and more complicated model. This is how complex systems like cars/ robots etc. are modeled.\n\nEven if you make use of deep learning for the system-identification part, the same principles can be applied in order to make sure the system behaves in a robust way using feedback. Of course, it becomes more complicated if the system can not be approximately linearized by simple feedback.","user":"UJ7DVTVQ8","ts":"1615904965.013000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4/8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would say that it very much depends on context. The classical thinking in control is similar to engineering in general, to isolate subsystems and make sure they behave well (well controlled) in isolation, after which they can be approximated by much simpler dynamics. If you take the complicated pendulum dynamics and are only interested in its behavior around an operating point, you design a controller that maintains that operating point and after that the complicated pendulum behaves more or less like a linear system. This also means that the model of the pendulum really only has to be good around this operating point since you will not deviate from this anyway.\nIf you are interested in optimally moving the pendulum around complicated trajectories, you instead design a controller around a trajectory that makes sure that you follow the trajectory even in the presence of model errors etc. This of course requires you to leave room for this controller to operate when you solve the optimal control problem.\n\nModels can get vastly omre complicated than a pendulum with several joints though, the trick then is to make use of modeling tools, ModelingToolkit being one such tool, that allows you to compose simple and well-tested building blocks together to form a bigger and more complicated model. This is how complex systems like cars/ robots etc. are modeled.\n\nEven if you make use of deep learning for the system-identification part, the same principles can be applied in order to make sure the system behaves in a robust way using feedback. Of course, it becomes more complicated if the system can not be approximately linearized by simple feedback."}]}]}],"reactions":[{"name":"today-i-learned","users":["U0138UTB7A4","UDDSTBX19"],"count":2}]},{"client_msg_id":"fc560096-a8c9-496e-8faf-417f072bd535","type":"message","text":"<@UJ7DVTVQ8> oh thanks so much for that clarification. This makes a lot more sense. I have been looking at some texts on control theory lately, and it is interesting to see how simple systems can rapidly grow in complexity through the addition of extra elements. But this idea of subsystems makes a lot more sense now, as well as having a specified set of operating points and trajectories. That fills in the gap. Thanks again Fredrik :slightly_smiling_face:.","user":"UDDSTBX19","ts":"1615905501.016100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PsD","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UJ7DVTVQ8"},{"type":"text","text":" oh thanks so much for that clarification. This makes a lot more sense. I have been looking at some texts on control theory lately, and it is interesting to see how simple systems can rapidly grow in complexity through the addition of extra elements. But this idea of subsystems makes a lot more sense now, as well as having a specified set of operating points and trajectories. That fills in the gap. Thanks again Fredrik "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":"."}]}]}],"reactions":[{"name":"slightly_smiling_face","users":["UJ7DVTVQ8"],"count":1}]}]}