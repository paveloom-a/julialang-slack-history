{"cursor": 0, "messages": [{"client_msg_id":"87a61e02-62df-4386-a74d-75d537a97a5b","type":"message","text":"I am wondering  about a `provide` method, a way for types' instances to provide their values into expressions. Like an inversion of dispatch forwarding .. rather than write code that redispatches through to the value of a struct comcretion,, write a [few] `provide` method[s] that is available to be called and will be autodialed where a value of that type is expressed without an overriding specialization.  For example, where Base.(+)(a::AProvidableType, b::TypeTwo) is defined, that handles the process of addition. otherwise `a + b` becomes `provide(a) + b` which becomes _.  With binary operators of mixed type, it would be similar to having `op(a, b)`  first selfdo `op(provide(a), b)` into `op(a_provided, b).` To asses type compatibility or determine multityped dispatch, an available-to-internals method that \"provides the type for a providable value\" `providetype`  completes this note.","user":"U68QW0PUZ","ts":"1612561799.032600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gmBZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am wondering  about a "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" method, a way for types' instances to provide their values into expressions. Like an inversion of dispatch forwarding .. rather than write code that redispatches through to the value of a struct comcretion,, write a [few] "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" method[s] that is available to be called and will be autodialed where a value of that type is expressed without an overriding specialization.  For example, where Base.(+)(a::AProvidableType, b::TypeTwo) is defined, that handles the process of addition. otherwise "},{"type":"text","text":"a + b","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"provide(a) + b","style":{"code":true}},{"type":"text","text":" which becomes _.  With binary operators of mixed type, it would be similar to having "},{"type":"text","text":"op(a, b)","style":{"code":true}},{"type":"text","text":"  first selfdo "},{"type":"text","text":"op(provide(a), b)","style":{"code":true}},{"type":"text","text":" into "},{"type":"text","text":"op(a_provided, b).","style":{"code":true}},{"type":"text","text":" To asses type compatibility or determine multityped dispatch, an available-to-internals method that \"provides the type for a providable value\" "},{"type":"text","text":"providetype","style":{"code":true}},{"type":"text","text":"  completes this note."}]}]}]},{"client_msg_id":"6B8FDE75-A5E1-4BB1-8E5D-69103CA1C2A9","type":"message","text":"It’s not clear to me what you mean by this. Why would you need a function to get the value of a type? It’s already there...","user":"U8D9768Q6","ts":"1612562858.033600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HAZfA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s not clear to me what you mean by this. Why would you need a function to get the value of a type? It’s already there..."}]}]}]},{"client_msg_id":"cae4e1d4-d75f-4470-a6dd-07bd7a2e29c0","type":"message","text":"I do not need a function to get the value of an instance of a type of mine.  You may.\n\nValue is carried as/with/within an instantiate constructed of/by/with a type of mine.\nThat you have a value does not assure you have the intended content appropriately provided.\n\nSo `yourfunc(myvalue)`  works correctly only if `yourfunc(myvalue) == yourfunc(mycontentmadeavailable)`\n`yourfunc(unnestedtuple) = _`   to work correctly without my explicit attention to your design\nI would `provide` unnestability through Julia's more generic support for `provide` , augmenting as mytype may require\n\n `yourfunc(mynestedvector)`  =&gt; Julia: `providetype(mynestedvector) informs the provision`\n`tuplify(unnest(mynestedvector))` and you compute `yourfunc(mycontentmadeavailble)`\n\nJulia would have one or a few generalized unnests. In the event that mytype is nested through slots (fieldsI in a manner\nthat Julia's unnests would not properly process, I write a simple dispatchable `provider` that Julia's unnest would use\nonly when obtaining the next nested item, as a navigation aid,; or I could specialize the method for mytype.\n\n                                      &gt;&gt; provide &lt;&lt;    yourfunc(provide(myvalue)) == yourfunc(myintendedcontent)\n                            mostly, `provide` would not appear in your source code.\nJulia would ascertain the provisioning that obtains an informed value, and could do so because \"It's already there\"","user":"U68QW0PUZ","ts":"1612590533.108000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C2n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do not need a function to get the value of an instance of a type of mine.  You may.\n\nValue is carried as/with/within an instantiate constructed of/by/with a type of mine.\nThat you have a value does not assure you have the intended content appropriately provided.\n\nSo "},{"type":"text","text":"yourfunc(myvalue)","style":{"code":true}},{"type":"text","text":"  works correctly only if "},{"type":"text","text":"yourfunc(myvalue) == yourfunc(mycontentmadeavailable)","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"yourfunc(unnestedtuple) = _  ","style":{"code":true}},{"type":"text","text":" to work correctly without my explicit attention to your design\nI would "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" unnestability through Julia's more generic support for "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" , augmenting as mytype may require\n\n "},{"type":"text","text":"yourfunc(mynestedvector)","style":{"code":true}},{"type":"text","text":"  => Julia: "},{"type":"text","text":"providetype(mynestedvector) informs the provision","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"tuplify(unnest(mynestedvector))","style":{"code":true}},{"type":"text","text":" and you compute "},{"type":"text","text":"yourfunc(mycontentmadeavailble)","style":{"code":true}},{"type":"text","text":"\n\nJulia would have one or a few generalized unnests. In the event that mytype is nested through slots (fieldsI in a manner\nthat Julia's unnests would not properly process, I write a simple dispatchable `provider` that Julia's unnest would use\nonly when obtaining the next nested item, as a navigation aid,; or I could specialize the method for mytype.\n\n                                      >> provide <<    yourfunc(provide(myvalue)) == yourfunc(myintendedcontent)\n                            mostly, `provide` would not appear in your source code.\nJulia would ascertain the provisioning that obtains an informed value, and could do so because \"It's already there\""}]}]}]}]}