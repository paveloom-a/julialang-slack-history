{"cursor": 0, "messages": [{"client_msg_id":"87a61e02-62df-4386-a74d-75d537a97a5b","type":"message","text":"I am wondering  about a `provide` method, a way for types' instances to provide their values into expressions. Like an inversion of dispatch forwarding .. rather than write code that redispatches through to the value of a struct comcretion,, write a [few] `provide` method[s] that is available to be called and will be autodialed where a value of that type is expressed without an overriding specialization.  For example, where Base.(+)(a::AProvidableType, b::TypeTwo) is defined, that handles the process of addition. otherwise `a + b` becomes `provide(a) + b` which becomes _.  With binary operators of mixed type, it would be similar to having `op(a, b)`  first selfdo `op(provide(a), b)` into `op(a_provided, b).` To asses type compatibility or determine multityped dispatch, an available-to-internals method that \"provides the type for a providable value\" `providetype`  completes this note.","user":"U68QW0PUZ","ts":"1612561799.032600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gmBZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am wondering  about a "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" method, a way for types' instances to provide their values into expressions. Like an inversion of dispatch forwarding .. rather than write code that redispatches through to the value of a struct comcretion,, write a [few] "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" method[s] that is available to be called and will be autodialed where a value of that type is expressed without an overriding specialization.  For example, where Base.(+)(a::AProvidableType, b::TypeTwo) is defined, that handles the process of addition. otherwise "},{"type":"text","text":"a + b","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"provide(a) + b","style":{"code":true}},{"type":"text","text":" which becomes _.  With binary operators of mixed type, it would be similar to having "},{"type":"text","text":"op(a, b)","style":{"code":true}},{"type":"text","text":"  first selfdo "},{"type":"text","text":"op(provide(a), b)","style":{"code":true}},{"type":"text","text":" into "},{"type":"text","text":"op(a_provided, b).","style":{"code":true}},{"type":"text","text":" To asses type compatibility or determine multityped dispatch, an available-to-internals method that \"provides the type for a providable value\" "},{"type":"text","text":"providetype","style":{"code":true}},{"type":"text","text":"  completes this note."}]}]}]},{"client_msg_id":"6B8FDE75-A5E1-4BB1-8E5D-69103CA1C2A9","type":"message","text":"It’s not clear to me what you mean by this. Why would you need a function to get the value of a type? It’s already there...","user":"U8D9768Q6","ts":"1612562858.033600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HAZfA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s not clear to me what you mean by this. Why would you need a function to get the value of a type? It’s already there..."}]}]}]},{"client_msg_id":"cae4e1d4-d75f-4470-a6dd-07bd7a2e29c0","type":"message","text":"I do not need a function to get the value of an instance of a type of mine.  You may.\n\nValue is carried as/with/within an instantiate constructed of/by/with a type of mine.\nThat you have a value does not assure you have the intended content appropriately provided.\n\nSo `yourfunc(myvalue)`  works correctly only if `yourfunc(myvalue) == yourfunc(mycontentmadeavailable)`\n`yourfunc(unnestedtuple) = _`   to work correctly without my explicit attention to your design\nI would `provide` unnestability through Julia's more generic support for `provide` , augmenting as mytype may require\n\n `yourfunc(mynestedvector)`  =&gt; Julia: `providetype(mynestedvector) informs the provision`\n`tuplify(unnest(mynestedvector))` and you compute `yourfunc(mycontentmadeavailble)`\n\nJulia would have one or a few generalized unnests. In the event that mytype is nested through slots (fieldsI in a manner\nthat Julia's unnests would not properly process, I write a simple dispatchable `provider` that Julia's unnest would use\nonly when obtaining the next nested item, as a navigation aid,; or I could specialize the method for mytype.\n\n                                      &gt;&gt; provide &lt;&lt;    yourfunc(provide(myvalue)) == yourfunc(myintendedcontent)\n                            mostly, `provide` would not appear in your source code.\nJulia would ascertain the provisioning that obtains an informed value, and could do so because \"It's already there\"","user":"U68QW0PUZ","ts":"1612590533.108000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C2n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do not need a function to get the value of an instance of a type of mine.  You may.\n\nValue is carried as/with/within an instantiate constructed of/by/with a type of mine.\nThat you have a value does not assure you have the intended content appropriately provided.\n\nSo "},{"type":"text","text":"yourfunc(myvalue)","style":{"code":true}},{"type":"text","text":"  works correctly only if "},{"type":"text","text":"yourfunc(myvalue) == yourfunc(mycontentmadeavailable)","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"yourfunc(unnestedtuple) = _  ","style":{"code":true}},{"type":"text","text":" to work correctly without my explicit attention to your design\nI would "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" unnestability through Julia's more generic support for "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" , augmenting as mytype may require\n\n "},{"type":"text","text":"yourfunc(mynestedvector)","style":{"code":true}},{"type":"text","text":"  => Julia: "},{"type":"text","text":"providetype(mynestedvector) informs the provision","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"tuplify(unnest(mynestedvector))","style":{"code":true}},{"type":"text","text":" and you compute "},{"type":"text","text":"yourfunc(mycontentmadeavailble)","style":{"code":true}},{"type":"text","text":"\n\nJulia would have one or a few generalized unnests. In the event that mytype is nested through slots (fieldsI in a manner\nthat Julia's unnests would not properly process, I write a simple dispatchable `provider` that Julia's unnest would use\nonly when obtaining the next nested item, as a navigation aid,; or I could specialize the method for mytype.\n\n                                      >> provide <<    yourfunc(provide(myvalue)) == yourfunc(myintendedcontent)\n                            mostly, `provide` would not appear in your source code.\nJulia would ascertain the provisioning that obtains an informed value, and could do so because \"It's already there\""}]}]}]},{"client_msg_id":"9c8586ba-7f23-4545-a8ee-aaf4d228c93e","type":"message","text":"`merge` is defined for NamedTuples. Is it piracy to define `merge` for NamedTuple types in a manner that follows the current `merge`?","user":"U68QW0PUZ","ts":"1612899345.109600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FAq7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"merge","style":{"code":true}},{"type":"text","text":" is defined for NamedTuples. Is it piracy to define "},{"type":"text","text":"merge","style":{"code":true}},{"type":"text","text":" for NamedTuple types in a manner that follows the current "},{"type":"text","text":"merge","style":{"code":true}},{"type":"text","text":"?"}]}]}]},{"client_msg_id":"77985628-665b-458b-b506-feb29123a629","type":"message","text":"If you don't own the element types of the named tuple in question, yes.","user":"U8D9768Q6","ts":"1612900126.110200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sBeG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you don't own the element types of the named tuple in question, yes."}]}]}],"reactions":[{"name":"ok","users":["U68QW0PUZ"],"count":1}]},{"client_msg_id":"b214518e-c6a4-4003-a13d-adb02b3b517a","type":"message","text":"Type piracy is about the base type (in most cases), not the elements","user":"U67BXBF99","ts":"1612900713.110700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=SrB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Type piracy is about the base type (in most cases), not the elements"}]}]}]},{"client_msg_id":"7988f628-4888-4b60-af83-6e78fb2c0f63","type":"message","text":"If the element types are in the type signature, it should be kosher though, right?\n\nLike, I've never heard it said that defining a method for\n```Base.:+(::Vector{MyType})```\nwas piracy.","user":"U8D9768Q6","ts":"1612901020.113200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ITDe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If the element types are in the type signature, it should be kosher though, right?\n\nLike, I've never heard it said that defining a method for\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Base.:+(::Vector{MyType})"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"was piracy."}]}]}]},{"client_msg_id":"1bc2eb49-68e6-4c74-b36b-2e852ee99af7","type":"message","text":"`Base.show(::IO, ::BaseContainer{MyType})` has been described as \"type treason\"","user":"U680THK2S","ts":"1612901096.113800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rLVKu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Base.show(::IO, ::BaseContainer{MyType})","style":{"code":true}},{"type":"text","text":" has been described as \"type treason\""}]}]}],"reactions":[{"name":"joy","users":["U8D9768Q6"],"count":1}]},{"client_msg_id":"fb5067a8-dd88-4560-b291-8dc37f3a3d11","type":"message","text":"Yeah, I can definitely imagine how it can cause problems.","user":"U8D9768Q6","ts":"1612901224.114800","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1612901327.000000"},"blocks":[{"type":"rich_text","block_id":"2MR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I can definitely imagine how it can cause problems."}]}]}]},{"client_msg_id":"841014d3-ce25-40a0-aa14-1ef7051949d6","type":"message","text":"My question was for `Base.merge(::Type{NamedTuple{N1,T1}}, ::Type{NamedTuple{N2,T2}}) where {N1,T1,N2,T2}`","user":"U68QW0PUZ","ts":"1612901655.116600","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1612901756.000000"},"blocks":[{"type":"rich_text","block_id":"2ntl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My question was for "},{"type":"text","text":"Base.merge(::Type{NamedTuple{N1,T1}}, ::Type{NamedTuple{N2,T2}}) where {N1,T1,N2,T2}","style":{"code":true}}]}]}]},{"client_msg_id":"be6bac9a-1a7a-4748-9a9b-cb8d9ff80eb1","type":"message","text":"Both are typically deemed privateering","user":"U67BXBF99","ts":"1612901720.116900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MltZ1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Both are typically deemed privateering"}]}]}],"reactions":[{"name":"heavy_check_mark","users":["U68QW0PUZ"],"count":1}]},{"client_msg_id":"f72e6897-cc47-47b8-9909-c7bd9289b6ad","type":"message","text":"once this it was considered reasonable to define\n  `Base.convert(::Type{T1}, x::T2)` where `T1` `T2` are not my types and the conversion is not defined\nhas this become piracy too?","user":"U68QW0PUZ","ts":"1612958998.122900","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1612959548.000000"},"blocks":[{"type":"rich_text","block_id":"sD6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"once this it was considered reasonable to define\n  "},{"type":"text","text":"Base.convert(::Type{T1}, x::T2)","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":"T1","style":{"code":true}},{"type":"text","text":" "},{"type":"text","text":"T2","style":{"code":true}},{"type":"text","text":" are not my types and the conversion is not defined\nhas this become piracy too?"}]}]}]},{"client_msg_id":"3f6422cd-d49c-4281-b76f-77be7e458747","type":"message","text":"e.g. `Base.convert(::Type{Vector{Pair}}, x::NamedTuple) = ...`\n       `Base.convert(::Type{NamedTuple}, x::OrderedDict{Symbol,Any})  = ...`","user":"U68QW0PUZ","ts":"1612959076.123900","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1612959682.000000"},"blocks":[{"type":"rich_text","block_id":"7G2mZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"e.g. "},{"type":"text","text":"Base.convert(::Type{Vector{Pair}}, x::NamedTuple) = ...","style":{"code":true}},{"type":"text","text":"\n       "},{"type":"text","text":"Base.convert(::Type{NamedTuple}, x::OrderedDict{Symbol,Any})  = ...","style":{"code":true}}]}]}]},{"client_msg_id":"799db434-4c43-40f9-b18d-3c2345be482e","type":"message","text":"I think I gained my understanding of type piracy by osmosis but I definitely thought that if you owned a type `T`, then you also owned `Vector{T}` until this week.","user":"U69L6CPJN","ts":"1613147205.126500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1qyd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think I gained my understanding of type piracy by osmosis but I definitely thought that if you owned a type "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":", then you also owned "},{"type":"text","text":"Vector{T}","style":{"code":true}},{"type":"text","text":" until this week."}]}]}]},{"client_msg_id":"5629db54-4ca2-467c-8a4f-b7fa45149d55","type":"message","text":"Easy to avoid - create a `VectorFoo` type, instead of `Vector{Foo}`","user":"UB7JS9CHF","ts":"1613157541.127300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F0xPQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Easy to avoid - create a "},{"type":"text","text":"VectorFoo","style":{"code":true}},{"type":"text","text":" type, instead of "},{"type":"text","text":"Vector{Foo}","style":{"code":true}}]}]}]},{"type":"message","text":"Is this a bug in `isa`?\nHow can it be false, while letting me store this in a typed field?","files":[{"id":"F01NQ11BZBQ","created":1614004468,"timestamp":1614004468,"name":"Untitled","title":"Untitled","mimetype":"text/plain","filetype":"julia","pretty_type":"Julia","user":"U6A936746","editable":true,"size":328,"mode":"snippet","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01NQ11BZBQ/untitled","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01NQ11BZBQ/download/untitled","permalink":"https://julialang.slack.com/files/U6A936746/F01NQ11BZBQ/untitled","permalink_public":"https://slack-files.com/T68168MUP-F01NQ11BZBQ-541ab6dccb","edit_link":"https://julialang.slack.com/files/U6A936746/F01NQ11BZBQ/untitled/edit","preview":"julia> abstract type VeryAbstractBar end\n\njulia> abstract type AbstractBar <: VeryAbstractBar end\n\njulia> AbstractBar isa Type{<:VeryAbstractBar}","preview_highlight":"<div class=\"CodeMirror cm-s-default CodeMirrorServer\" oncopy=\"if(event.clipboardData){event.clipboardData.setData('text/plain',window.getSelection().toString().replace(/\\u200b/g,''));event.preventDefault();event.stopPropagation();}\">\n<div class=\"CodeMirror-code\">\n<div><pre><span class=\"cm-variable\">julia</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-keyword\">abstract</span> <span class=\"cm-keyword\">type</span> <span class=\"cm-def\">VeryAbstractBar</span> <span class=\"cm-keyword\">end</span></pre></div>\n<div><pre>&#8203;</pre></div>\n<div><pre><span class=\"cm-variable\">julia</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-keyword\">abstract</span> <span class=\"cm-keyword\">type</span> <span class=\"cm-def\">AbstractBar</span> <span class=\"cm-operator\">&lt;:</span> <span class=\"cm-variable\">VeryAbstractBar</span> <span class=\"cm-keyword\">end</span></pre></div>\n<div><pre>&#8203;</pre></div>\n<div><pre><span class=\"cm-variable\">julia</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-variable\">AbstractBar</span> <span class=\"cm-operator\">isa</span> <span class=\"cm-variable\">Type</span>{<span class=\"cm-operator\">&lt;:</span><span class=\"cm-variable\">VeryAbstractBar</span>}</pre></div>\n</div>\n</div>\n","lines":14,"lines_more":9,"preview_is_truncated":false,"is_starred":false,"has_rich_preview":false}],"upload":true,"blocks":[{"type":"rich_text","block_id":"Jcp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is this a bug in "},{"type":"text","text":"isa","style":{"code":true}},{"type":"text","text":"?\nHow can it be false, while letting me store this in a typed field?"}]}]}],"user":"U6A936746","display_as_bot":false,"ts":"1614004470.000400","edited":{"user":"U6A936746","ts":"1614004519.000000"},"client_msg_id":"aaa64671-95b3-4d4f-90a0-e4c692a8c0cc","thread_ts":"1614004470.000400","reply_count":2,"reply_users_count":2,"latest_reply":"1614005511.001800","reply_users":["U6A936746","U7HAYKY9X"],"subscribed":false},{"type":"message","subtype":"channel_join","ts":"1614004496.001000","user":"U0160CXEY3Z","text":"<@U0160CXEY3Z> has joined the channel","inviter":"U6A936746"},{"type":"message","subtype":"channel_join","ts":"1614004496.001200","user":"UBHFY1H4Z","text":"<@UBHFY1H4Z> has joined the channel","inviter":"U6A936746"},{"client_msg_id":"d8ba4749-0426-4c93-99fd-0aed5bbed4d8","type":"message","text":"Often I want to essentially dispatch a function on whether its defined a method.  It seems both forbidden but also within reach.  Is there anyway to achieve the following without (naughty abuse of) generated functions and in a way which type-infers?\n\n```using Test\nstruct MyTypeA end\n\nstruct Has end\nstruct NotHas end\n\ndispatchfunc(f) = hasmethod(f, Tuple{MyTypeA}) ? Has() : NotHas()\n\na(x::MyTypeA) = 1\nb(x::Int) = 1\n\n@test dispatchfunc(a) == Has()\n@test dispatchfunc(b) == NotHas()```","user":"U66G4838Q","ts":"1614868300.004600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SSNgX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Often I want to essentially dispatch a function on whether its defined a method.  It seems both forbidden but also within reach.  Is there anyway to achieve the following without (naughty abuse of) generated functions and in a way which type-infers?\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Test\nstruct MyTypeA end\n\nstruct Has end\nstruct NotHas end\n\ndispatchfunc(f) = hasmethod(f, Tuple{MyTypeA}) ? Has() : NotHas()\n\na(x::MyTypeA) = 1\nb(x::Int) = 1\n\n@test dispatchfunc(a) == Has()\n@test dispatchfunc(b) == NotHas()"}]}]}],"thread_ts":"1614868300.004600","reply_count":2,"reply_users_count":2,"latest_reply":"1614870574.004900","reply_users":["UDGT4PM41","U6A936746"],"subscribed":false}]}