{"cursor": 0, "messages": [{"client_msg_id":"87a61e02-62df-4386-a74d-75d537a97a5b","type":"message","text":"I am wondering  about a `provide` method, a way for types' instances to provide their values into expressions. Like an inversion of dispatch forwarding .. rather than write code that redispatches through to the value of a struct comcretion,, write a [few] `provide` method[s] that is available to be called and will be autodialed where a value of that type is expressed without an overriding specialization.  For example, where Base.(+)(a::AProvidableType, b::TypeTwo) is defined, that handles the process of addition. otherwise `a + b` becomes `provide(a) + b` which becomes _.  With binary operators of mixed type, it would be similar to having `op(a, b)`  first selfdo `op(provide(a), b)` into `op(a_provided, b).` To asses type compatibility or determine multityped dispatch, an available-to-internals method that \"provides the type for a providable value\" `providetype`  completes this note.","user":"U68QW0PUZ","ts":"1612561799.032600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gmBZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am wondering  about a "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" method, a way for types' instances to provide their values into expressions. Like an inversion of dispatch forwarding .. rather than write code that redispatches through to the value of a struct comcretion,, write a [few] "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" method[s] that is available to be called and will be autodialed where a value of that type is expressed without an overriding specialization.  For example, where Base.(+)(a::AProvidableType, b::TypeTwo) is defined, that handles the process of addition. otherwise "},{"type":"text","text":"a + b","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"provide(a) + b","style":{"code":true}},{"type":"text","text":" which becomes _.  With binary operators of mixed type, it would be similar to having "},{"type":"text","text":"op(a, b)","style":{"code":true}},{"type":"text","text":"  first selfdo "},{"type":"text","text":"op(provide(a), b)","style":{"code":true}},{"type":"text","text":" into "},{"type":"text","text":"op(a_provided, b).","style":{"code":true}},{"type":"text","text":" To asses type compatibility or determine multityped dispatch, an available-to-internals method that \"provides the type for a providable value\" "},{"type":"text","text":"providetype","style":{"code":true}},{"type":"text","text":"  completes this note."}]}]}]},{"client_msg_id":"6B8FDE75-A5E1-4BB1-8E5D-69103CA1C2A9","type":"message","text":"It’s not clear to me what you mean by this. Why would you need a function to get the value of a type? It’s already there...","user":"U8D9768Q6","ts":"1612562858.033600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HAZfA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s not clear to me what you mean by this. Why would you need a function to get the value of a type? It’s already there..."}]}]}]},{"client_msg_id":"cae4e1d4-d75f-4470-a6dd-07bd7a2e29c0","type":"message","text":"I do not need a function to get the value of an instance of a type of mine.  You may.\n\nValue is carried as/with/within an instantiate constructed of/by/with a type of mine.\nThat you have a value does not assure you have the intended content appropriately provided.\n\nSo `yourfunc(myvalue)`  works correctly only if `yourfunc(myvalue) == yourfunc(mycontentmadeavailable)`\n`yourfunc(unnestedtuple) = _`   to work correctly without my explicit attention to your design\nI would `provide` unnestability through Julia's more generic support for `provide` , augmenting as mytype may require\n\n `yourfunc(mynestedvector)`  =&gt; Julia: `providetype(mynestedvector) informs the provision`\n`tuplify(unnest(mynestedvector))` and you compute `yourfunc(mycontentmadeavailble)`\n\nJulia would have one or a few generalized unnests. In the event that mytype is nested through slots (fieldsI in a manner\nthat Julia's unnests would not properly process, I write a simple dispatchable `provider` that Julia's unnest would use\nonly when obtaining the next nested item, as a navigation aid,; or I could specialize the method for mytype.\n\n                                      &gt;&gt; provide &lt;&lt;    yourfunc(provide(myvalue)) == yourfunc(myintendedcontent)\n                            mostly, `provide` would not appear in your source code.\nJulia would ascertain the provisioning that obtains an informed value, and could do so because \"It's already there\"","user":"U68QW0PUZ","ts":"1612590533.108000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C2n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do not need a function to get the value of an instance of a type of mine.  You may.\n\nValue is carried as/with/within an instantiate constructed of/by/with a type of mine.\nThat you have a value does not assure you have the intended content appropriately provided.\n\nSo "},{"type":"text","text":"yourfunc(myvalue)","style":{"code":true}},{"type":"text","text":"  works correctly only if "},{"type":"text","text":"yourfunc(myvalue) == yourfunc(mycontentmadeavailable)","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"yourfunc(unnestedtuple) = _  ","style":{"code":true}},{"type":"text","text":" to work correctly without my explicit attention to your design\nI would "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" unnestability through Julia's more generic support for "},{"type":"text","text":"provide","style":{"code":true}},{"type":"text","text":" , augmenting as mytype may require\n\n "},{"type":"text","text":"yourfunc(mynestedvector)","style":{"code":true}},{"type":"text","text":"  => Julia: "},{"type":"text","text":"providetype(mynestedvector) informs the provision","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"tuplify(unnest(mynestedvector))","style":{"code":true}},{"type":"text","text":" and you compute "},{"type":"text","text":"yourfunc(mycontentmadeavailble)","style":{"code":true}},{"type":"text","text":"\n\nJulia would have one or a few generalized unnests. In the event that mytype is nested through slots (fieldsI in a manner\nthat Julia's unnests would not properly process, I write a simple dispatchable `provider` that Julia's unnest would use\nonly when obtaining the next nested item, as a navigation aid,; or I could specialize the method for mytype.\n\n                                      >> provide <<    yourfunc(provide(myvalue)) == yourfunc(myintendedcontent)\n                            mostly, `provide` would not appear in your source code.\nJulia would ascertain the provisioning that obtains an informed value, and could do so because \"It's already there\""}]}]}]},{"client_msg_id":"9c8586ba-7f23-4545-a8ee-aaf4d228c93e","type":"message","text":"`merge` is defined for NamedTuples. Is it piracy to define `merge` for NamedTuple types in a manner that follows the current `merge`?","user":"U68QW0PUZ","ts":"1612899345.109600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FAq7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"merge","style":{"code":true}},{"type":"text","text":" is defined for NamedTuples. Is it piracy to define "},{"type":"text","text":"merge","style":{"code":true}},{"type":"text","text":" for NamedTuple types in a manner that follows the current "},{"type":"text","text":"merge","style":{"code":true}},{"type":"text","text":"?"}]}]}]},{"client_msg_id":"77985628-665b-458b-b506-feb29123a629","type":"message","text":"If you don't own the element types of the named tuple in question, yes.","user":"U8D9768Q6","ts":"1612900126.110200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sBeG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you don't own the element types of the named tuple in question, yes."}]}]}],"reactions":[{"name":"ok","users":["U68QW0PUZ"],"count":1}]},{"client_msg_id":"b214518e-c6a4-4003-a13d-adb02b3b517a","type":"message","text":"Type piracy is about the base type (in most cases), not the elements","user":"U67BXBF99","ts":"1612900713.110700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=SrB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Type piracy is about the base type (in most cases), not the elements"}]}]}]},{"client_msg_id":"7988f628-4888-4b60-af83-6e78fb2c0f63","type":"message","text":"If the element types are in the type signature, it should be kosher though, right?\n\nLike, I've never heard it said that defining a method for\n```Base.:+(::Vector{MyType})```\nwas piracy.","user":"U8D9768Q6","ts":"1612901020.113200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ITDe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If the element types are in the type signature, it should be kosher though, right?\n\nLike, I've never heard it said that defining a method for\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Base.:+(::Vector{MyType})"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"was piracy."}]}]}]},{"client_msg_id":"1bc2eb49-68e6-4c74-b36b-2e852ee99af7","type":"message","text":"`Base.show(::IO, ::BaseContainer{MyType})` has been described as \"type treason\"","user":"U680THK2S","ts":"1612901096.113800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rLVKu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Base.show(::IO, ::BaseContainer{MyType})","style":{"code":true}},{"type":"text","text":" has been described as \"type treason\""}]}]}],"reactions":[{"name":"joy","users":["U8D9768Q6"],"count":1}]},{"client_msg_id":"fb5067a8-dd88-4560-b291-8dc37f3a3d11","type":"message","text":"Yeah, I can definitely imagine how it can cause problems.","user":"U8D9768Q6","ts":"1612901224.114800","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1612901327.000000"},"blocks":[{"type":"rich_text","block_id":"2MR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I can definitely imagine how it can cause problems."}]}]}]},{"client_msg_id":"841014d3-ce25-40a0-aa14-1ef7051949d6","type":"message","text":"My question was for `Base.merge(::Type{NamedTuple{N1,T1}}, ::Type{NamedTuple{N2,T2}}) where {N1,T1,N2,T2}`","user":"U68QW0PUZ","ts":"1612901655.116600","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1612901756.000000"},"blocks":[{"type":"rich_text","block_id":"2ntl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My question was for "},{"type":"text","text":"Base.merge(::Type{NamedTuple{N1,T1}}, ::Type{NamedTuple{N2,T2}}) where {N1,T1,N2,T2}","style":{"code":true}}]}]}]},{"client_msg_id":"be6bac9a-1a7a-4748-9a9b-cb8d9ff80eb1","type":"message","text":"Both are typically deemed privateering","user":"U67BXBF99","ts":"1612901720.116900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MltZ1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Both are typically deemed privateering"}]}]}],"reactions":[{"name":"heavy_check_mark","users":["U68QW0PUZ"],"count":1}]}]}