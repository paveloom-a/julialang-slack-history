{"cursor":0,"messages":[{"type":"message","text":"Getting a compilation error with trying to use AlgebraicPetri from Git master branch:\n```using AlgebraicPetri\n[ Info: Precompiling AlgebraicPetri [4f99eebe-17bf-4e98-b6a1-2c4f205a959b]\nERROR: LoadError: LoadError: MethodError: Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::NamedTuple{(:T, :S, :I, :O),Tuple{TypedTables.Table{NamedTuple{(:tname,),Tuple{Symbol}},1,NamedTuple{(:tname,),Tuple{Array{Symbol,1}}}},TypedTables.Table{NamedTuple{(:sname,),Tuple{Symbol}},1,NamedTuple{(:sname,),Tuple{Array{Symbol,1}}}},TypedTables.Table{NamedTuple{(:it, :is),Tuple{Int64,Int64}},1,NamedTuple{(:it, :is),Tuple{Array{Int64,1},Array{Int64,1}}}},TypedTables.Table{NamedTuple{(:ot, :os),Tuple{Int64,Int64}},1,NamedTuple{(:ot, :os),Tuple{Array{Int64,1},Array{Int64,1}}}}}}, ::NamedTuple{(:is, :it, :os, :ot),NTuple{4,Array{Array{Int64,1},1}}}) is ambiguous. Candidates:\n  (::Type{Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple})(n, ts...) in AlgebraicPetri at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:171\n  (::Type{Catlab.CSetDataStructures.AttributedCSet{CD,AD,Ts,Idxed,UniqueIdxed,Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple})(tables::Tables, indices::Indices) where {CD&lt;:Catlab.Theories.CatDesc, AD&lt;:(Catlab.Theories.AttrDesc{CD,Data,Attr,ADom,ACodom} where ACodom where ADom where Attr where Data), Ts&lt;:Tuple, Idxed, UniqueIdxed, Tables&lt;:NamedTuple, Indices&lt;:NamedTuple} in Catlab.CSetDataStructures at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:58\nPossible fix, define\n  Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::Tables, ::Indices) where {Tables&lt;:NamedTuple, Indices&lt;:NamedTuple}\nStacktrace:\n [1] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(; table_type::Type{T} where T) at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:70\n [2] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple() at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:68","user":"UJEQCEAKF","ts":"1608723283.014600","team":"T68168MUP"},{"type":"message","text":" [3] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::Array{Symbol,1}, ::Pair{Symbol,Pair{Tuple{Symbol,Symbol},Tuple{Symbol,Symbol}}}) at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:172\n [4] exposure_petri(::Symbol, ::Symbol, ::Symbol, ::Symbol) at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/Epidemiology.jl:12\n [5] top-level scope at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/Epidemiology.jl:15\n [6] include at ./Base.jl:368 [inlined]\n [7] include(::String) at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:3\n [8] top-level scope at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:301\n [9] top-level scope at none:2\n [10] eval at ./boot.jl:331 [inlined]\nin expression starting at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/Epidemiology.jl:15\nin expression starting at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:301\nERROR: Failed to precompile AlgebraicPetri [4f99eebe-17bf-4e98-b6a1-2c4f205a959b] to /home/ntm/.julia/compiled/v1.5/AlgebraicPetri/7bhUx_WhfCm.ji.\nStacktrace:\n [1] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305\n [2] _require(::Base.PkgId) at ./loading.jl:1030\n [3] require(::Base.PkgId) at ./loading.jl:928\n [4] require(::Module, ::Symbol) at ./loading.jl:923\n [5] run_repl(::REPL.AbstractREPL, ::Any) at /build/julia/src/julia-1.5.3/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288\n```","user":"UJEQCEAKF","ts":"1608723283.014700","team":"T68168MUP"},{"type":"message","text":"julia&gt; using AlgebraicPetri\n[ Info: Precompiling AlgebraicPetri [4f99eebe-17bf-4e98-b6a1-2c4f205a959b]\nERROR: LoadError: LoadError: MethodError: Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::NamedTuple{(:T, :S, :I, :O),Tuple{TypedTables.Table{NamedTuple{(:tname,),Tuple{Symbol}},1,NamedTuple{(:tname,),Tuple{Array{Symbol,1}}}},TypedTables.Table{NamedTuple{(:sname,),Tuple{Symbol}},1,NamedTuple{(:sname,),Tuple{Array{Symbol,1}}}},TypedTables.Table{NamedTuple{(:it, :is),Tuple{Int64,Int64}},1,NamedTuple{(:it, :is),Tuple{Array{Int64,1},Array{Int64,1}}}},TypedTables.Table{NamedTuple{(:ot, :os),Tuple{Int64,Int64}},1,NamedTuple{(:ot, :os),Tuple{Array{Int64,1},Array{Int64,1}}}}}}, ::NamedTuple{(:is, :it, :os, :ot),NTuple{4,Array{Array{Int64,1},1}}}) is ambiguous. Candidates:\n  (::Type{Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple})(n, ts...) in AlgebraicPetri at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:171\n  (::Type{Catlab.CSetDataStructures.AttributedCSet{CD,AD,Ts,Idxed,UniqueIdxed,Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple})(tables::Tables, indices::Indices) where {CD&lt;:Catlab.Theories.CatDesc, AD&lt;:(Catlab.Theories.AttrDesc{CD,Data,Attr,ADom,ACodom} where ACodom where ADom where Attr where Data), Ts&lt;:Tuple, Idxed, UniqueIdxed, Tables&lt;:NamedTuple, Indices&lt;:NamedTuple} in Catlab.CSetDataStructures at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:58\nPossible fix, define\n  Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::Tables, ::Indices) where {Tables&lt;:NamedTuple, Indices&lt;:NamedTuple}\nStacktrace:\n [1] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(; table_type::Type{T} where T) at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:70\n [2] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple() at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:68","user":"UJEQCEAKF","ts":"1608723362.014800","team":"T68168MUP"},{"type":"message","text":"julia&gt; using AlgebraicPetri\n[ Info: Precompiling AlgebraicPetri [4f99eebe-17bf-4e98-b6a1-2c4f205a959b]\nERROR: LoadError: LoadError: MethodError: Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::NamedTuple{(:T, :S, :I, :O),Tuple{TypedTables.Table{NamedTuple{(:tname,),Tuple{Symbol}},1,NamedTuple{(:tname,),Tuple{Array{Symbol,1}}}},TypedTables.Table{NamedTuple{(:sname,),Tuple{Symbol}},1,NamedTuple{(:sname,),Tuple{Array{Symbol,1}}}},TypedTables.Table{NamedTuple{(:it, :is),Tuple{Int64,Int64}},1,NamedTuple{(:it, :is),Tuple{Array{Int64,1},Array{Int64,1}}}},TypedTables.Table{NamedTuple{(:ot, :os),Tuple{Int64,Int64}},1,NamedTuple{(:ot, :os),Tuple{Array{Int64,1},Array{Int64,1}}}}}}, ::NamedTuple{(:is, :it, :os, :ot),NTuple{4,Array{Array{Int64,1},1}}}) is ambiguous. Candidates:\n  (::Type{Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple})(n, ts...) in AlgebraicPetri at /home/ntm/.julia/packages/AlgebraicPetri/CjaEI/src/AlgebraicPetri.jl:171\n  (::Type{Catlab.CSetDataStructures.AttributedCSet{CD,AD,Ts,Idxed,UniqueIdxed,Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple})(tables::Tables, indices::Indices) where {CD&lt;:Catlab.Theories.CatDesc, AD&lt;:(Catlab.Theories.AttrDesc{CD,Data,Attr,ADom,ACodom} where ACodom where ADom where Attr where Data), Ts&lt;:Tuple, Idxed, UniqueIdxed, Tables&lt;:NamedTuple, Indices&lt;:NamedTuple} in Catlab.CSetDataStructures at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:58\nPossible fix, define\n  Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(::Tables, ::Indices) where {Tables&lt;:NamedTuple, Indices&lt;:NamedTuple}\nStacktrace:\n [1] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple(; table_type::Type{T} where T) at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:70\n [2] Catlab.CSetDataStructures.AttributedCSet{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},Catlab.Theories.AttrDesc{Catlab.Theories.CatDesc{(:T, :S, :I, :O),(:it, :is, :ot, :os),(3, 3, 4, 4),(1, 2, 1, 2)},(:Name,),(:tname, :sname),(1, 2),(1, 1)},Tuple{Symbol},(:is, :it, :os, :ot),(),Tables,Indices} where Indices&lt;:NamedTuple where Tables&lt;:NamedTuple() at /home/ntm/.julia/packages/Catlab/suTk7/src/categorical_algebra/CSetDataStructures.jl:68","user":"UJEQCEAKF","ts":"1608723405.015100","team":"T68168MUP"},{"type":"message","text":"^ got this error trying to compile from git master branch","user":"UJEQCEAKF","ts":"1608723434.015200","team":"T68168MUP"},{"client_msg_id":"C891535A-8B48-4324-AACE-D556543D4262","type":"message","text":"I think there is a new PR that might address this","user":"U69L6CPJN","ts":"1608739222.016000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uHY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think there is a new PR that might address this"}]}]}]},{"type":"message","text":"thx, I'll use that","user":"UJEQCEAKF","ts":"1608741155.016100","team":"T68168MUP"},{"type":"message","text":"it works now, but I think all the macro magic gets weird with Pluto (which puts every code cell in its own module)","user":"UJEQCEAKF","ts":"1608741392.016200","team":"T68168MUP"},{"type":"message","text":"nevermind, still had some code from the old docs, new code from the new docs works","user":"UJEQCEAKF","ts":"1608741618.016300","team":"T68168MUP"},{"type":"message","text":"I'm interested in seeing if I can implement a timed petri net with discrete tokens/transitions instead of a continuous reaction network.","user":"UJEQCEAKF","ts":"1608745014.016400","team":"T68168MUP"},{"client_msg_id":"AFF95619-0FEF-4081-8DC9-5CD6BD933C03","type":"message","text":"That would be an awesome addition to the library ","user":"U69L6CPJN","ts":"1608745862.017000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"st+v","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would be an awesome addition to the library "}]}]}]},{"type":"message","text":"I'm still pretty new to all this, so the first thing to figure out is where to begin","user":"UJEQCEAKF","ts":"1608746386.017100","team":"T68168MUP"},{"client_msg_id":"5B042CB2-0BEA-417E-BA05-B70E2127E6F9","type":"message","text":"Well you can make a Petri net using a fairly traditional interface of enumerating the transitions and states, or using the ACT interface of undirected wiring diagrams. Then you can write your Petri net simulator that takes an initial configuration of tokens and produces and new configuration of tokens. You will have to decide whether to randomly sample a new configuration (stochastic) or enumerate all possible new configurations (deterministic, but high complexity)","user":"U69L6CPJN","ts":"1608746579.019900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Iio","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well you can make a Petri net using a fairly traditional interface of enumerating the transitions and states, or using the ACT interface of undirected wiring diagrams. Then you can write your Petri net simulator that takes an initial configuration of tokens and produces and new configuration of tokens. You will have to decide whether to randomly sample a new configuration (stochastic) or enumerate all possible new configurations (deterministic, but high complexity)"}]}]}]},{"type":"message","text":"I intend to reuse as much as possible from what we have. I picture eager deterministic evaluation semantics.","user":"UJEQCEAKF","ts":"1608749884.020000","team":"T68168MUP"},{"client_msg_id":"946c882a-b243-4aaf-b149-e94156286f2c","type":"message","text":"Petri.jl has support for discrete tokens instead of continuous using DiffEqJump.jl which can be easily used by converting AlgebraicPetri to a Petri.Model","user":"UQ51REEL8","ts":"1608756844.021900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WEW/0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Petri.jl has support for discrete tokens instead of continuous using DiffEqJump.jl which can be easily used by converting AlgebraicPetri to a Petri.Model"}]}]}]},{"client_msg_id":"36a29f09-36a1-481e-b477-6d405a81ec26","type":"message","text":"I also have been needing to transfer this functionality to the new package and can go ahead and do this! Sorry it's not all migrated yet :joy:","user":"UQ51REEL8","ts":"1608756866.022700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Iqau","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I also have been needing to transfer this functionality to the new package and can go ahead and do this! Sorry it's not all migrated yet "},{"type":"emoji","name":"joy"}]}]}]},{"client_msg_id":"657e5858-882d-465d-9fa6-d482da9f2b94","type":"message","text":"Also I just merged the new PR to fix compatibility with the latest Catlab and have tagged a new release v0.6.1","user":"UQ51REEL8","ts":"1608756910.023600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ReYt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also I just merged the new PR to fix compatibility with the latest Catlab and have tagged a new release v0.6.1"}]}]}]},{"client_msg_id":"9d6f1a9d-6c3c-434c-966f-ad2efbaf2dc5","type":"message","text":"Also if you are interested in using the discrete functionality in Petri.jl with AlgebraicPetri.jl The relevant code can be found here:\n\nThese lines in AlgebraicPetri.jl provide interoperability with Petri.jl (<https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/c344248bf21bccfbd7ff022b49207395a045c59d/src/AlgebraicPetri.jl#L260>)\n\nallows you to do something like this\n\n```using AlgebraicPetri\nusing Petri\n\nsir_algpetri = PetriNet(3, (1,2)-&gt;(2,2), 2-&gt;3)\nsir_petri = Petri.Model(sir_algpetri)```\n","user":"UQ51REEL8","ts":"1608757170.025900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ve3ZW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also if you are interested in using the discrete functionality in Petri.jl with AlgebraicPetri.jl The relevant code can be found here:\n\nThese lines in AlgebraicPetri.jl provide interoperability with Petri.jl ("},{"type":"link","url":"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/c344248bf21bccfbd7ff022b49207395a045c59d/src/AlgebraicPetri.jl#L260"},{"type":"text","text":")\n\nallows you to do something like this\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using AlgebraicPetri\nusing Petri\n\nsir_algpetri = PetriNet(3, (1,2)->(2,2), 2->3)\nsir_petri = Petri.Model(sir_algpetri)"}]},{"type":"rich_text_section","elements":[]}]}]},{"client_msg_id":"cc001e97-1e77-4ce4-a59c-d34a8d2592ca","type":"message","text":"And then these lines provide the discrete solver functionality in Petri.jl (<https://github.com/mehalter/Petri.jl/blob/a3b2c79029c9f6966ef4264d5b148055840b2332/src/solvers.jl#L114>)\n\nwhich allows you to do something like this\n\n```using AlgebraicPetri\nusing Petri\nusing DiffEqJump\nusing Plots\n\nsir_algpetri = PetriNet(3, (1,2)-&gt;(2,2), 2-&gt;3)\nsir_petri = Petri.Model(sir_algpetri)\n\nu0 = [990.0, 10.0, 0.0]\np = [0.5/sum(u0), 0.25]\ntspan = (0.0, 40.0)\nprob = JumpProblem(sir_petri, u0, tspan, p)\nsol = DiffEqJump.solve(prob,SSAStepper())\n\nplot(sol)```\n","user":"UQ51REEL8","ts":"1608757375.028300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Af","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And then these lines provide the discrete solver functionality in Petri.jl ("},{"type":"link","url":"https://github.com/mehalter/Petri.jl/blob/a3b2c79029c9f6966ef4264d5b148055840b2332/src/solvers.jl#L114"},{"type":"text","text":")\n\nwhich allows you to do something like this\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using AlgebraicPetri\nusing Petri\nusing DiffEqJump\nusing Plots\n\nsir_algpetri = PetriNet(3, (1,2)->(2,2), 2->3)\nsir_petri = Petri.Model(sir_algpetri)\n\nu0 = [990.0, 10.0, 0.0]\np = [0.5/sum(u0), 0.25]\ntspan = (0.0, 40.0)\nprob = JumpProblem(sir_petri, u0, tspan, p)\nsol = DiffEqJump.solve(prob,SSAStepper())\n\nplot(sol)"}]},{"type":"rich_text_section","elements":[]}]}]},{"client_msg_id":"be253124-0706-464d-b7f8-1d04a495efa3","type":"message","text":"examples of all of the different solvers can be found on this example in the documentation for Petri.jl: <https://mehalter.github.io/Petri.jl/stable/examples/epidemiology/>","user":"UQ51REEL8","ts":"1608757393.028700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XY5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"examples of all of the different solvers can be found on this example in the documentation for Petri.jl: "},{"type":"link","url":"https://mehalter.github.io/Petri.jl/stable/examples/epidemiology/"}]}]}]}]}