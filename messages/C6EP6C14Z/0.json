{"cursor": 0, "messages": [{"client_msg_id":"aae5a0da-d461-4e65-bbdd-0968a9707fbd","type":"message","text":"Does anyone have an opinion if Julia's `range` ends up taking a distinct path from Python's `range`?\n\nPython current a has `range` defined as either `range(stop)` or `range(start, stop, [step])` where `stop` is not included in the resulting sequence. All arguments have to be integers in Python.\n\n```In [26]: [i for i in range(5)]\nOut[26]: [0, 1, 2, 3, 4]\n\nIn [27]: [i for i in range(1,5)]\nOut[27]: [1, 2, 3, 4]\n\nIn [28]: [i for i in range(1,5,3)]\nOut[28]: [1, 4]\n\nIn [29]: [i for i in range(1,5,4)]\nOut[29]: [1]\n\nIn [30]: [i for i in range(1,5,2)]\nOut[30]: [1, 3]```\nJulia's range current requires keywords to explicitly indicate, `stop`, `length` , or `step`. A proposed change is to adopt a 3-positional argument version of `range(start, stop, length)` which is inclusive of `stop`. These arguments can be any real value.\n\nWith some extrapolation:\n```julia&gt; range(stop) = 1:stop\nrange (generic function with 2 methods)\n\njulia&gt; range(start, stop) = start:stop\nrange (generic function with 2 methods)\n\njulia&gt; range(start, stop, length) = range(start, stop, length = length)\nrange (generic function with 3 methods)\n\njulia&gt; [i for i in range(5)]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia&gt; [i for i in range(1,5)]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia&gt; [i for i in range(1,5,3)]\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 5.0\n\njulia&gt; [i for i in range(1,5,4)]\n4-element Array{Float64,1}:\n 1.0\n 2.3333333333333335\n 3.6666666666666665\n 5.0\n\njulia&gt; [i for i in range(1,5,2)]\n2-element Array{Float64,1}:\n 1.0\n 5.0```\n<https://github.com/JuliaLang/julia/issues/38750>","user":"USU9FRPEU","ts":"1608599871.032100","team":"T68168MUP","edited":{"user":"USU9FRPEU","ts":"1608600380.000000"},"blocks":[{"type":"rich_text","block_id":"G9qe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone have an opinion if Julia's `range` ends up taking a distinct path from Python's "},{"type":"text","text":"range","style":{"code":true}},{"type":"text","text":"?\n\nPython current a has `range` defined as either `range(stop)` or `range(start, stop, [step])` where `stop` is not included in the resulting sequence. All arguments have to be integers in Python.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"In [26]: [i for i in range(5)]\nOut[26]: [0, 1, 2, 3, 4]\n\nIn [27]: [i for i in range(1,5)]\nOut[27]: [1, 2, 3, 4]\n\nIn [28]: [i for i in range(1,5,3)]\nOut[28]: [1, 4]\n\nIn [29]: [i for i in range(1,5,4)]\nOut[29]: [1]\n\nIn [30]: [i for i in range(1,5,2)]\nOut[30]: [1, 3]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nJulia's range current requires keywords to explicitly indicate, "},{"type":"text","text":"stop","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"length","style":{"code":true}},{"type":"text","text":" , or "},{"type":"text","text":"step","style":{"code":true}},{"type":"text","text":". A proposed change is to adopt a 3-positional argument version of `range(start, stop, length)` which is inclusive of "},{"type":"text","text":"stop","style":{"code":true}},{"type":"text","text":". These arguments can be any real value.\n\nWith some extrapolation:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> range(stop) = 1:stop\nrange (generic function with 2 methods)\n\njulia> range(start, stop) = start:stop\nrange (generic function with 2 methods)\n\njulia> range(start, stop, length) = range(start, stop, length = length)\nrange (generic function with 3 methods)\n\njulia> [i for i in range(5)]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> [i for i in range(1,5)]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> [i for i in range(1,5,3)]\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 5.0\n\njulia> [i for i in range(1,5,4)]\n4-element Array{Float64,1}:\n 1.0\n 2.3333333333333335\n 3.6666666666666665\n 5.0\n\njulia> [i for i in range(1,5,2)]\n2-element Array{Float64,1}:\n 1.0\n 5.0"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n"},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/38750"}]}]}]},{"client_msg_id":"8A0EC82B-9A6C-4B79-8B4E-439E4AE29DA0","type":"message","text":"Might be better to ask in <#CQG6KQMR7|expytriates> ","user":"U6795JH6H","ts":"1608648810.032700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xKo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Might be better to ask in "},{"type":"channel","channel_id":"CQG6KQMR7"},{"type":"text","text":" "}]}]}]},{"client_msg_id":"EB751F0A-538D-4524-A1C2-8FEEA9A90A36","type":"message","text":"I think this channel is specifically for the Python package that allows calling Julia","user":"U6795JH6H","ts":"1608648829.033400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ceebb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this channel is specifically for the Python package that allows calling Julia"}]}]}]},{"client_msg_id":"6e4792c9-127a-47f4-b173-49415ec49331","type":"message","text":"Hi pyjulia friends! PyPlot can’t be used in Pluto because of <https://github.com/JuliaPy/PyPlot.jl/issues/512> — I can write a workaround on the Pluto side, should I do that, or wait for this to be fixed?","user":"UUTL3EKN3","ts":"1609666071.035500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1X6R","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi pyjulia friends! PyPlot can’t be used in Pluto because of "},{"type":"link","url":"https://github.com/JuliaPy/PyPlot.jl/issues/512"},{"type":"text","text":" — I can write a workaround on the Pluto side, should I do that, or wait for this to be fixed?"}]}]}]},{"client_msg_id":"2de4eba5-215c-4749-a6a3-f3cf9fd98620","type":"message","text":"Can someone please tag a new PyCall release?","user":"UHDQQ4GN6","ts":"1613971644.000300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9exLd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can someone please tag a new PyCall release?"}]}]}]},{"client_msg_id":"c07a4cb2-ef51-426f-9ebb-128624f42774","type":"message","text":"when using PyCall and a pip package installed locally with `pip install -e`, is there a way to automatically keep up to date with changes in the pip package (like Revise.jl does with Julia packages)?","user":"U017PV1H2LV","ts":"1615506868.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5Q0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"when using PyCall and a pip package installed locally with "},{"type":"text","text":"pip install -e","style":{"code":true}},{"type":"text","text":", is there a way to automatically keep up to date with changes in the pip package (like Revise.jl does with Julia packages)?"}]}]}]}]}