{"cursor": 0, "messages": [{"client_msg_id":"8f207220-096b-4dc3-b6e4-bb82c673eaa5","type":"message","text":"So does irtools define its own IR? Does that mean someone can do the same thing with a domain specific IR?","user":"UDGT4PM41","ts":"1610047739.103400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oMtK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So does irtools define its own IR? Does that mean someone can do the same thing with a domain specific IR?"}]}]}]},{"client_msg_id":"c6d6b540-892c-4330-9a20-91baed778594","type":"message","text":"How does that work with Julia's codeinfo and internal representation","user":"UDGT4PM41","ts":"1610047778.104200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QEcEB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How does that work with Julia's codeinfo and internal representation"}]}]}]},{"client_msg_id":"68828e52-8701-4513-a6b2-dc7173a80a09","type":"message","text":"I'm looking through the source now","user":"UDGT4PM41","ts":"1610047794.104600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dIhiE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm looking through the source now"}]}]}]},{"client_msg_id":"47307b89-5433-43f2-bf1d-874b5b8e7039","type":"message","text":"IRTools defines basically a simpler version of CodeInfo that's easier to work with","user":"U8D9768Q6","ts":"1610047801.104800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LD2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"IRTools defines basically a simpler version of CodeInfo that's easier to work with"}]}]}]},{"client_msg_id":"19676320-4021-4c53-a7f4-e39ed44fab54","type":"message","text":"You can translate more CodeInfo to <http://IRTools.IR|IRTools.IR> and vice versa.","user":"U8D9768Q6","ts":"1610047855.105400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"luWe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can translate more CodeInfo to IRTools.IR and vice versa."}]}]}]},{"client_msg_id":"4968363a-bd38-4369-8459-fd60497660ea","type":"message","text":"I see","user":"UDGT4PM41","ts":"1610047876.105600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k+xh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see"}]}]}]},{"client_msg_id":"092c7763-f09d-40d6-a674-b842c2eefdae","type":"message","text":"There’s three structures which you need to be aware of","user":"UKA81L34J","ts":"1610047996.107000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ay7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There’s three structures which you need to be aware of"}]}]}]},{"client_msg_id":"69f93932-c415-49d7-b3b2-6f3dd7c1d4bc","type":"message","text":"`CodeInfo`, `<http://IRTools.IR|IRTools.IR>`, and `Core.Compiler.IRCode`","user":"UKA81L34J","ts":"1610048008.107400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1BdU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"CodeInfo","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"IRTools.IR","style":{"code":true}},{"type":"text","text":", and "},{"type":"text","text":"Core.Compiler.IRCode","style":{"code":true}}]}]}]},{"client_msg_id":"e4ed4e87-44cc-40bd-9a13-df977b8544de","type":"message","text":"do we know how this will look when rebased on AbstractInterpreter or I assume that's an open design question","user":"UDGT4PM41","ts":"1610048093.108500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Ep","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"do we know how this will look when rebased on AbstractInterpreter or I assume that's an open design question"}]}]}]},{"client_msg_id":"89916713-07d8-4480-bc38-c5e875d6643e","type":"message","text":"The ways things get converted between is outlined in <https://github.com/FluxML/IRTools.jl/blob/47f5627e480e81a3855e213730e1c030b0ee86e1/src/ir/wrap.jl>","user":"UKA81L34J","ts":"1610048105.109000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iuN04","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The ways things get converted between is outlined in "},{"type":"link","url":"https://github.com/FluxML/IRTools.jl/blob/47f5627e480e81a3855e213730e1c030b0ee86e1/src/ir/wrap.jl"}]}]}],"reactions":[{"name":"+1","users":["UDGT4PM41"],"count":1}]},{"client_msg_id":"aeea5806-28ff-4521-b6d4-a4cb5e729207","type":"message","text":"partially there, also partially in","user":"UKA81L34J","ts":"1610048119.109400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qeVe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"partially there, also partially in"}]}]}]},{"client_msg_id":"4f4e1aca-07a9-49fb-94b9-7cf3859b40ba","type":"message","text":"Like you can't have your own representation and still work with Julia's opt passes I take it","user":"UDGT4PM41","ts":"1610048134.109600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"be=R","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like you can't have your own representation and still work with Julia's opt passes I take it"}]}]}]},{"client_msg_id":"0b2c2210-ee53-46e9-a6f0-8dcdc5fda6e2","type":"message","text":"Thanks <@UKA81L34J>","user":"UDGT4PM41","ts":"1610048177.110500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"g3316","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks "},{"type":"user","user_id":"UKA81L34J"}]}]}]},{"client_msg_id":"7ea756fd-5aa1-436a-ac1e-5a95737c3d9e","type":"message","text":"The thing with julia’s IR is that is it painful to work with.\nBecause of things like you need to renumber all the SSA values if you insert or delete a line.\nThere are tools in `Core.Compiler`  for doing this.\nand Cassette’s `insert_statements` uses them.\nbut IRTools avoids needing to do them because it’s data structures are a bit higher level","user":"U6A936746","ts":"1610048270.112400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qgTs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The thing with julia’s IR is that is it painful to work with.\nBecause of things like you need to renumber all the SSA values if you insert or delete a line.\nThere are tools in "},{"type":"text","text":"Core.Compiler","style":{"code":true}},{"type":"text","text":"  for doing this.\nand Cassette’s "},{"type":"text","text":"insert_statements","style":{"code":true}},{"type":"text","text":" uses them.\nbut IRTools avoids needing to do them because it’s data structures are a bit higher level"}]}]}]},{"client_msg_id":"f0997fd4-5753-4a5f-9df2-f413c0e83e1c","type":"message","text":"I mean, I think the rebase will look different ? `AbstractInterpreter` works a bit differently.\n\nWith `IRTools` - you can manipulate the `<http://IRTools.IR|IRTools.IR>` directly with the APIs and you mostly have a guarantee it will convert to valid `IRCode` - however there’s no guarantee that you won’t segfault with a dumb mistake if you manipulate the `IR` and emit out of a `dynamo`  (`CodeInfo` gets updated with new `IRCode` after dynamo).","user":"UKA81L34J","ts":"1610048444.116700","team":"T68168MUP","edited":{"user":"UKA81L34J","ts":"1610048479.000000"},"blocks":[{"type":"rich_text","block_id":"M+X2a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, I think the rebase will look different ? "},{"type":"text","text":"AbstractInterpreter","style":{"code":true}},{"type":"text","text":" works a bit differently.\n\nWith "},{"type":"text","text":"IRTools","style":{"code":true}},{"type":"text","text":" - you can manipulate the "},{"type":"text","text":"IRTools.IR","style":{"code":true}},{"type":"text","text":" directly with the APIs and you mostly have a guarantee it will convert to valid "},{"type":"text","text":"IRCode","style":{"code":true}},{"type":"text","text":" - however there’s no guarantee that you won’t segfault with a dumb mistake if you manipulate the "},{"type":"text","text":"IR","style":{"code":true}},{"type":"text","text":" and emit out of a "},{"type":"text","text":"dynamo","style":{"code":true}},{"type":"text","text":"  ("},{"type":"text","text":"CodeInfo","style":{"code":true}},{"type":"text","text":" gets updated with new "},{"type":"text","text":"IRCode","style":{"code":true}},{"type":"text","text":" after dynamo)."}]}]}]},{"client_msg_id":"a2ca617e-b07e-4bfb-b5b4-31d7588283b3","type":"message","text":"What does `rebase`  mean?","user":"U6A936746","ts":"1610048484.117500","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1610048494.000000"},"blocks":[{"type":"rich_text","block_id":"/0S46","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What does "},{"type":"text","text":"rebase","style":{"code":true}},{"type":"text","text":"  mean?"}]}]}]},{"client_msg_id":"95de513a-cf45-48d2-be17-04c18abac714","type":"message","text":"<@U6A936746> I think Ari is asking what a new version of `IRTools` would look like with `AbstractInterpreter`","user":"UKA81L34J","ts":"1610048506.118300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/z2","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6A936746"},{"type":"text","text":" I think Ari is asking what a new version of "},{"type":"text","text":"IRTools","style":{"code":true}},{"type":"text","text":" would look like with "},{"type":"text","text":"AbstractInterpreter","style":{"code":true}}]}]}]},{"client_msg_id":"8d675431-d71a-43e6-8645-2a2d4896e832","type":"message","text":"Ah i see","user":"U6A936746","ts":"1610048513.118800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M+b9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah i see"}]}]}]},{"client_msg_id":"dc56b5d3-a229-4365-83e3-99580f211877","type":"message","text":"I don’t know what you can do with AA - like can you do method overlay with AA on type inferred code ? You now have a good amount of control but I don’t know what the art of the possible is.","user":"UKA81L34J","ts":"1610048554.120100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JOkd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know what you can do with AA - like can you do method overlay with AA on type inferred code ? You now have a good amount of control but I don’t know what the art of the possible is."}]}]}]},{"client_msg_id":"92c2e1f5-59b1-469e-a7e5-8ee60a955563","type":"message","text":"Valentin made his own JIT, one sec","user":"UKA81L34J","ts":"1610048563.120400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wDC7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Valentin made his own JIT, one sec"}]}]}]},{"client_msg_id":"d9cf3442-c2b6-4dfe-bd82-fc2630d8a3c1","type":"message","text":"(or in process)","user":"UKA81L34J","ts":"1610048569.120700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k5L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(or in process)"}]}]}]},{"client_msg_id":"87a1edbf-03aa-4370-a77b-69268adb1c15","type":"message","text":"Yeah I know nothing of the abstract interprettor stuff","user":"U6A936746","ts":"1610048580.121000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8Qi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah I know nothing of the abstract interprettor stuff"}]}]}]},{"client_msg_id":"f0d8042b-86ba-47ac-bf5d-60432423aa3b","type":"message","text":"<https://github.com/vchuravy/KernelCompiler.jl/blob/main/src/jit.jl>","user":"UKA81L34J","ts":"1610048602.121600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"q+H","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/vchuravy/KernelCompiler.jl/blob/main/src/jit.jl"}]}]}]},{"client_msg_id":"d2df0136-6565-45e5-976e-d0c9b16692a4","type":"message","text":"But this is basically with the `GPUCompiler` infrastructure and `LLVM.jl`","user":"UKA81L34J","ts":"1610048612.122100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Uh6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But this is basically with the "},{"type":"text","text":"GPUCompiler","style":{"code":true}},{"type":"text","text":" infrastructure and "},{"type":"text","text":"LLVM.jl","style":{"code":true}}]}]}]},{"client_msg_id":"0bcfb589-66d7-4c54-b35a-c3843c5d5ab1","type":"message","text":"I’m out of my depth but I think the native pipeline is different than the infra offered by those two packages","user":"UKA81L34J","ts":"1610048635.123100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"owpF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m out of my depth but I think the native pipeline is different than the infra offered by those two packages"}]}]}]},{"client_msg_id":"7f005aa9-2892-4691-a549-c9e9bdd22156","type":"message","text":"Other IRTools things  (none of this is related to anything else though I am just spouting things)\nthe control flow graph and dominance tree (sp?) is really useful,  but julia’s IR doesn’t even have basic blocks.\nJulia does construct the basic blocks and then the control flow graph and then dominance tree(sp) as part of the optimizer\nand you can in-fact call that code yourself on the IR.\nMagneticReadHead does this.\n\nIRTools works at the basic block level already.\nIt also has its own algorithm for constructing the control flow graph and dominance tree.\nIt’s a different algorithm to the one julia itself uses, though both are from the literature.\n\nOne problem just in general with this is it makes your compile time looong, at least that is what i found with MRH.\nbecause you are doing it twice, and it is expensive to begin with.\n\nThe actual place I would like to insert tranforms is after the optimizer has generated this stuff.\nThough would then need to run the optimizer again i guess, at least on that part of the code?\nAlso at that stage just in general the IR is way richer, not only does it have these graphs structure, typing has occurred","user":"U6A936746","ts":"1610048763.125200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PzDz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Other IRTools things  (none of this is related to anything else though I am just spouting things)\nthe control flow graph and dominance tree (sp?) is really useful,  but julia’s IR doesn’t even have basic blocks.\nJulia does construct the basic blocks and then the control flow graph and then dominance tree(sp) as part of the optimizer\nand you can in-fact call that code yourself on the IR.\nMagneticReadHead does this.\n\nIRTools works at the basic block level already.\nIt also has its own algorithm for constructing the control flow graph and dominance tree.\nIt’s a different algorithm to the one julia itself uses, though both are from the literature.\n\nOne problem just in general with this is it makes your compile time looong, at least that is what i found with MRH.\nbecause you are doing it twice, and it is expensive to begin with.\n\nThe actual place I would like to insert tranforms is after the optimizer has generated this stuff.\nThough would then need to run the optimizer again i guess, at least on that part of the code?\nAlso at that stage just in general the IR is way richer, not only does it have these graphs structure, typing has occurred"}]}]}]},{"client_msg_id":"2cfd0d5c-6feb-4586-b8ac-8bb897649e3f","type":"message","text":"what stage does Abstract Interpetter run?","user":"U6A936746","ts":"1610048819.125600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+XqMu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what stage does Abstract Interpetter run?"}]}]}]},{"client_msg_id":"e6ae2970-b3c7-4577-b515-d861019042b3","type":"message","text":"I’m concerned that modifications after type inference would mess things up, and you’d have to be very careful","user":"UKA81L34J","ts":"1610048832.126100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nA0lc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m concerned that modifications after type inference would mess things up, and you’d have to be very careful"}]}]}]},{"client_msg_id":"50558eb3-7307-4b8f-8d48-7fa23d8c9cfe","type":"message","text":"yeah absolutely","user":"U6A936746","ts":"1610048841.126400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uYQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah absolutely"}]}]}]},{"client_msg_id":"8edbecb7-3c58-4b18-ac7c-94d7f011fab5","type":"message","text":"Its already hard enough to not break things by changing right after lowering","user":"U6A936746","ts":"1610048854.126900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1610048861.000000"},"blocks":[{"type":"rich_text","block_id":"7cX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Its already hard enough to not break things by changing right after lowering"}]}]}]},{"client_msg_id":"2cbdb767-81d2-4165-b325-d26f25ad8032","type":"message","text":"I think AA runs at type inference","user":"UKA81L34J","ts":"1610048862.127200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9GpOH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think AA runs at type inference"}]}]}]},{"client_msg_id":"7a57c10c-ca98-4293-9723-7a02979adb6a","type":"message","text":"what is AA?","user":"U6A936746","ts":"1610048874.127600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NVhms","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what is AA?"}]}]}]},{"client_msg_id":"273e1ec4-1ad3-4752-a647-02e82055289c","type":"message","text":"lol why do I keep saying that","user":"UKA81L34J","ts":"1610048881.127900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8+r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"lol why do I keep saying that"}]}]}]},{"client_msg_id":"f1263269-5118-44d2-b083-70ca25e40e51","type":"message","text":"sorry","user":"UKA81L34J","ts":"1610048882.128200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"82Kd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sorry"}]}]}]},{"client_msg_id":"13f3c681-8dd2-4f31-898a-8f6166fea1df","type":"message","text":"AbstractInterpreter = AI","user":"UKA81L34J","ts":"1610048886.128600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8tuxL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"AbstractInterpreter = AI"}]}]}]},{"client_msg_id":"7facf805-3e1f-40c0-8109-6d25015024e4","type":"message","text":"doink","user":"UKA81L34J","ts":"1610048887.128800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0eJ9c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"doink"}]}]}]},{"client_msg_id":"3e89b383-7622-4031-af7b-b743041e4b84","type":"message","text":"prob because AI is something else","user":"U6A936746","ts":"1610048891.129000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HhM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"prob because AI is something else"}]}]}]},{"client_msg_id":"60b77ce0-d3dd-49f6-8c68-448a56681059","type":"message","text":"I thought AI was linear regression?","user":"UDGT4PM41","ts":"1610048896.129200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i+OR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I thought AI was linear regression?"}]}]}],"reactions":[{"name":"correct_answer","users":["U6A936746"],"count":1}]},{"client_msg_id":"a790ab4b-463e-4903-9d32-bfcb3841aad5","type":"message","text":"AbInt","user":"U6A936746","ts":"1610048896.129300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RXG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"AbInt"}]}]}]},{"client_msg_id":"59fc1a92-0768-44fc-848e-2da935abf255","type":"message","text":"Here’s an example: <https://github.com/vchuravy/KernelCompiler.jl/blob/main/src/codegen.jl>","user":"UKA81L34J","ts":"1610049006.129600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IA8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here’s an example: "},{"type":"link","url":"https://github.com/vchuravy/KernelCompiler.jl/blob/main/src/codegen.jl"}]}]}]},{"client_msg_id":"e88eb987-0f1f-4716-9acc-afa4dcb4b260","type":"message","text":"oh sorry, I don’t think Valentin is doing inference with his custom AbsInt yet","user":"UKA81L34J","ts":"1610049148.130000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bA0E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh sorry, I don’t think Valentin is doing inference with his custom AbsInt yet"}]}]}]},{"client_msg_id":"a57e8da1-fa35-4f20-be5b-1ce8613dfc65","type":"message","text":"forget what I said","user":"UKA81L34J","ts":"1610049156.130300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pOvI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"forget what I said"}]}]}]},{"client_msg_id":"b2bad6df-59d7-420f-9658-c3515a51888a","type":"message","text":"My understanding is that the abstract interpreter is a whole pipeline and you can plug in at many points","user":"U8D9768Q6","ts":"1610049189.131100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"63N+c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My understanding is that the abstract interpreter is a whole pipeline and you can plug in at many points"}]}]}]},{"client_msg_id":"8e94cbbd-629c-449e-b41a-5d7688649ec7","type":"message","text":"But can it do dependent typing ?","user":"UKA81L34J","ts":"1610049208.131600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+cqp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But can it do dependent typing ?"}]}]}],"reactions":[{"name":"joy","users":["UDGT4PM41"],"count":1}]},{"client_msg_id":"5e6ea533-075a-4426-a078-08fe3eec31da","type":"message","text":"That is the real question here.","user":"UKA81L34J","ts":"1610049227.132100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hO=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is the real question here."}]}]}]},{"client_msg_id":"f94fc673-bd10-4d56-89e4-861f458102d0","type":"message","text":"That is, you can work at the untyped IR level, you can work on typed IR, you can choose when and which optimization passes run, etc","user":"U8D9768Q6","ts":"1610049251.132500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sOq3Q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is, you can work at the untyped IR level, you can work on typed IR, you can choose when and which optimization passes run, etc"}]}]}]},{"client_msg_id":"533ae59d-b07f-4823-89c3-3fda4530cffb","type":"message","text":"I thought it was, is Julia a lisp?","user":"UDGT4PM41","ts":"1610049252.132600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hgGxe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I thought it was, is Julia a lisp?"}]}]}]},{"client_msg_id":"09864066-2b1b-40e5-9183-a5a3b2b30f1f","type":"message","text":"<@UDGT4PM41> I think a good package to follow is `JET` now","user":"UKA81L34J","ts":"1610049264.133100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZN8o","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDGT4PM41"},{"type":"text","text":" I think a good package to follow is "},{"type":"text","text":"JET","style":{"code":true}},{"type":"text","text":" now"}]}]}]},{"client_msg_id":"8933b4e2-6b29-489b-ab3b-5beedaa0dd72","type":"message","text":"<https://github.com/aviatesk/JET.jl/blob/master/src/abstractinterpreterinterface.jl>","user":"UKA81L34J","ts":"1610049268.133400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XrsO8","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/aviatesk/JET.jl/blob/master/src/abstractinterpreterinterface.jl"}]}]}]},{"client_msg_id":"42ab8ebe-faca-43e1-9d40-d903fe8a6dd1","type":"message","text":"This seems to be a bit more fleshed out","user":"UKA81L34J","ts":"1610049273.133700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z=9/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This seems to be a bit more fleshed out"}]}]}]},{"client_msg_id":"f67da299-6c7d-46ab-85af-728fd68b8c22","type":"message","text":"ah yea, that's a meaty example","user":"UDGT4PM41","ts":"1610049317.134700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1FKhX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah yea, that's a meaty example"}]}]}]},{"client_msg_id":"3a87454d-f57d-427e-a7b4-4a6457b34d2e","type":"message","text":"I can’t claim to understand it, but it looks like Shuhei is actually using it for something","user":"UKA81L34J","ts":"1610049320.134900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P=1P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I can’t claim to understand it, but it looks like Shuhei is actually using it for something"}]}]}]},{"client_msg_id":"970d40e2-887c-4ba1-acbe-8557efff5cdd","type":"message","text":"And perhaps most importantly, you can have the compilation pipeline be recurrent. You could run the optimization passes, then modify things, then run them again for instance. That's supposedly why Diffractor works well for higher order derivatives because the code graph gets pruned instead of exploding","user":"U8D9768Q6","ts":"1610049364.135800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YkF=V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And perhaps most importantly, you can have the compilation pipeline be recurrent. You could run the optimization passes, then modify things, then run them again for instance. That's supposedly why Diffractor works well for higher order derivatives because the code graph gets pruned instead of exploding"}]}]}]},{"client_msg_id":"f8b03e42-c90d-4d8c-91b8-dbddd2799ae1","type":"message","text":"This sort of stuff gets me fired up, it’s too interesting","user":"UKA81L34J","ts":"1610049521.136500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WwZ72","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This sort of stuff gets me fired up, it’s too interesting"}]}]}]},{"client_msg_id":"c867faa6-e423-4a2b-9f28-c602f06866ae","type":"message","text":"Anyways I have to get back to my actual job","user":"UKA81L34J","ts":"1610049526.136700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3Vs9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyways I have to get back to my actual job"}]}]}]},{"client_msg_id":"751d1888-e231-4cc3-8a07-68b3a477badb","type":"message","text":"<@UDGT4PM41> last note - here’s the toplevel for `JET`","user":"UKA81L34J","ts":"1610050151.137000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kkuUT","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDGT4PM41"},{"type":"text","text":" last note - here’s the toplevel for "},{"type":"text","text":"JET","style":{"code":true}}]}]}]},{"client_msg_id":"d105d214-2687-47e1-901f-9cabe59230a1","type":"message","text":"<https://github.com/aviatesk/JET.jl/blob/master/src/virtualprocess.jl>","user":"UKA81L34J","ts":"1610050152.137200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j0F","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/aviatesk/JET.jl/blob/master/src/virtualprocess.jl"}]}]}]},{"client_msg_id":"432a997d-43c3-4fc6-9689-bd28e66909e6","type":"message","text":"AbsInt is a parameterized inference pipeline with custom caching that is also capable with enough trickery to do pre-inference passes aka Cassette/IRTools and mid-optimization passes","user":"U67BJLYCS","ts":"1610051147.138500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5zgK0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"AbsInt is a parameterized inference pipeline with custom caching that is also capable with enough trickery to do pre-inference passes aka Cassette/IRTools and mid-optimization passes"}]}]}]},{"client_msg_id":"3d4667b0-81c9-4536-b71e-9b2ddb790852","type":"message","text":"Yao.jl uses it quite extensively already","user":"U67BJLYCS","ts":"1610051166.138900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FRyu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yao.jl uses it quite extensively already"}]}]}]},{"client_msg_id":"a78c78b3-2ee1-4b3e-ad61-5765a2de4a4a","type":"message","text":"I think Valentin is referring to <https://github.com/QuantumBFS/YaoLang.jl> YaoLang part of Yao just FYI.","user":"UKA81L34J","ts":"1610051904.139500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3rW+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think Valentin is referring to "},{"type":"link","url":"https://github.com/QuantumBFS/YaoLang.jl"},{"type":"text","text":" YaoLang part of Yao just FYI."}]}]}]},{"client_msg_id":"824804f4-3134-4926-bf39-9a8a6d193f52","type":"message","text":"err, sorry - <https://github.com/QuantumBFS/YaoCompiler.jl>","user":"UKA81L34J","ts":"1610051957.139800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VuF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"err, sorry - "},{"type":"link","url":"https://github.com/QuantumBFS/YaoCompiler.jl"}]}]}]},{"client_msg_id":"0b5866e8-55c2-4b3a-b125-8d8bab642c8e","type":"message","text":"yeah YaoCompiler","user":"U67BJLYCS","ts":"1610052062.140000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A1lhd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah YaoCompiler"}]}]}]},{"client_msg_id":"0f73ed85-c3e3-4c49-a61a-07131f088501","type":"message","text":"did you figure out execution yet ?","user":"UKA81L34J","ts":"1610052080.140200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"h6rT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"did you figure out execution yet ?"}]}]}],"thread_ts":"1610052080.140200","reply_count":1,"reply_users_count":1,"latest_reply":"1610052665.141400","reply_users":["U67BJLYCS"],"subscribed":false},{"client_msg_id":"814d26a8-42ed-469c-820a-280e6501f7c7","type":"message","text":"<@U67BJLYCS> is there a place/way for custom IR dialects (like MLIR) but defined in Julia,  to plug into the pipeline?","user":"UDGT4PM41","ts":"1610052621.141100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ux2","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67BJLYCS"},{"type":"text","text":" is there a place/way for custom IR dialects (like MLIR) but defined in Julia,  to plug into the pipeline?"}]}]}]},{"client_msg_id":"ad526eae-b582-4482-8720-1c42667ceeca","type":"message","text":"or wrapping MLIR","user":"UDGT4PM41","ts":"1610052643.141300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KuG1o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or wrapping MLIR"}]}]}]},{"client_msg_id":"f92f8808-4e7a-4812-a526-18bb39322bee","type":"message","text":"I plan to protoype the bridge between KernelCompiler.jl and brutus soonish","user":"U67BJLYCS","ts":"1610052695.142000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1XJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I plan to protoype the bridge between KernelCompiler.jl and brutus soonish"}]}]}]},{"client_msg_id":"d86941a9-80ae-459b-8b49-ccfafe68f2d0","type":"message","text":"I mean if I want to define my own dialect of Julia's IR","user":"UDGT4PM41","ts":"1610052740.142500","team":"T68168MUP","edited":{"user":"UDGT4PM41","ts":"1610052748.000000"},"blocks":[{"type":"rich_text","block_id":"iMU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean if I want to define my own dialect of Julia's IR"}]}]}]},{"client_msg_id":"420ba132-e149-4bda-ba19-f839ab3bb740","type":"message","text":"In the same sense of MLIR having dialects","user":"UDGT4PM41","ts":"1610052756.143000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZgT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In the same sense of MLIR having dialects"}]}]}]},{"client_msg_id":"e4e1ac4d-3da4-4e7f-a149-e9cc5678eb73","type":"message","text":"What does that mean?","user":"U67BJLYCS","ts":"1610052756.143100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tpms","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What does that mean?"}]}]}]},{"client_msg_id":"57136416-d8e3-47d1-8e5d-45dd94685734","type":"message","text":"What semantics does a (or more specifically yours) custom dialect need","user":"U67BJLYCS","ts":"1610052801.143800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8qX0H","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What semantics does a (or more specifically yours) custom dialect need"}]}]}]},{"client_msg_id":"08dfd726-7e4b-4d19-acb8-600fe402d7db","type":"message","text":"you can implement custom intrinsics","user":"U67BJLYCS","ts":"1610052807.144100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jPB1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you can implement custom intrinsics"}]}]}]},{"client_msg_id":"d1a04353-5797-4faa-8c6c-bc81ba1bb73c","type":"message","text":"I don't have something specific in mind, but <@UKA81L34J>’s comment here got me curious <https://llvm.discourse.group/t/julia-c-api-bindings-simple-op-dump-segfault/2459/9>\n\n\"There exist mechanisms to manipulate the Julia IR from stable non-compiler dev user land, but they are not fully exposed out of the compiler yet. In addition, the Julia IR is not designed to be extensible or to model semantics which are not intended by the compiler team.\"","user":"UDGT4PM41","ts":"1610052939.144800","team":"T68168MUP","attachments":[{"service_name":"LLVM Discussion Forums","title":"Julia C API bindings - simple op dump segfault","title_link":"https://llvm.discourse.group/t/julia-c-api-bindings-simple-op-dump-segfault/2459/9","text":"Thanks for comments here - will create an issue to track the correct usage of verify on the bindings repo. @joker-eph I can also describe a bit more some of Julian motivations for playing with MLIR: one high level motivation for exploring these bindings: there are a number of researchers in the Julia community who are engaging in “soft” compiler research design (e.g. high level AD or probabilistic programming IR design) but want a little more space to move than what is provided by the standard...","fallback":"LLVM Discussion Forums: Julia C API bindings - simple op dump segfault","thumb_url":"https://aws1.discourse-cdn.com/free1/uploads/llvm/optimized/1X/1188a6351afc596a02412b6d5b0a1a557b4770ff_2_1023x633.png","ts":1609307860,"from_url":"https://llvm.discourse.group/t/julia-c-api-bindings-simple-op-dump-segfault/2459/9","thumb_width":1023,"thumb_height":633,"service_icon":"https://aws1.discourse-cdn.com/free1/uploads/llvm/optimized/1X/6ac54669f4b30cb07094375cbd65d24163b5b6e0_2_180x180.jpeg","id":1,"original_url":"https://llvm.discourse.group/t/julia-c-api-bindings-simple-op-dump-segfault/2459/9"}],"blocks":[{"type":"rich_text","block_id":"MXQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't have something specific in mind, but "},{"type":"user","user_id":"UKA81L34J"},{"type":"text","text":"’s comment here got me curious "},{"type":"link","url":"https://llvm.discourse.group/t/julia-c-api-bindings-simple-op-dump-segfault/2459/9"},{"type":"text","text":"\n\n\"There exist mechanisms to manipulate the Julia IR from stable non-compiler dev user land, but they are not fully exposed out of the compiler yet. In addition, the Julia IR is not designed to be extensible or to model semantics which are not intended by the compiler team.\""}]}]}]},{"client_msg_id":"7f9019d7-29e5-4d5e-b8f5-70cf5d336c03","type":"message","text":"I’m a probabilistic programming researcher - a number of my recent experiments have centered around constructing abstract interpretations to statically verify properties of models and inference algorithms. I’ve found that it’s difficult to express or verify the correctness of the transformations I write on Julia’s SSA form IR and would prefer to express a domain-specific IR which faithfully models the primitives of my languages","user":"UDGT4PM41","ts":"1610052961.145100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cqjm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m a probabilistic programming researcher - a number of my recent experiments have centered around constructing abstract interpretations to statically verify properties of models and inference algorithms. I’ve found that it’s difficult to express or verify the correctness of the transformations I write on Julia’s SSA form IR and would prefer to express a domain-specific IR which faithfully models the primitives of my languages"}]}]}]},{"client_msg_id":"36569ef6-c78a-45c2-82da-e2cbd3f7a926","type":"message","text":"Yeah, that’s me","user":"UKA81L34J","ts":"1610053002.145300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HQy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, that’s me"}]}]}]},{"client_msg_id":"f1d079c3-aac0-4248-8e50-6a458b9680b7","type":"message","text":":stuck_out_tongue:","user":"UKA81L34J","ts":"1610053032.145600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IVXT","elements":[{"type":"rich_text_section","elements":[{"type":"emoji","name":"stuck_out_tongue"}]}]}]},{"client_msg_id":"68662424-5499-4bd9-ae74-474f95743596","type":"message","text":"I'm interested in Prob Programming and don't want to have to learn Cpp...","user":"UDGT4PM41","ts":"1610053038.145800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9PPt3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm interested in Prob Programming and don't want to have to learn Cpp..."}]}]}]},{"client_msg_id":"85c8844b-bafe-4e34-a250-2065a70d4bcd","type":"message","text":"I don’t thing any of these things would be exposed to a user","user":"UKA81L34J","ts":"1610053184.146700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m8/x","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t thing any of these things would be exposed to a user"}]}]}]},{"client_msg_id":"f0bc4959-de8a-4d38-8a43-bf18db8593b4","type":"message","text":"I'd like to hack on it though","user":"UDGT4PM41","ts":"1610053206.147300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lu9y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd like to hack on it though"}]}]}]},{"client_msg_id":"ff820f94-b19e-45fc-9157-bde2d6f79e22","type":"message","text":"E.g. a dialect expressed through a combination of C++/C would be targeted by following the brutus recipe","user":"UKA81L34J","ts":"1610053220.147800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xkMU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"E.g. a dialect expressed through a combination of C++/C would be targeted by following the brutus recipe"}]}]}]},{"client_msg_id":"b5aa9c1a-052f-4bb8-ba55-92d0947a4f94","type":"message","text":"so the passes can be in julia","user":"UDGT4PM41","ts":"1610053242.148000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ShlvW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so the passes can be in julia"}]}]}]},{"client_msg_id":"8aa782f1-4350-474e-a266-f06ca42324d0","type":"message","text":"?","user":"UDGT4PM41","ts":"1610053287.148600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6SR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"?"}]}]}]},{"client_msg_id":"256a02bf-978a-46cd-9595-617474062be1","type":"message","text":"well, it’s complicated a bit","user":"UKA81L34J","ts":"1610053311.148800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7W=9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"well, it’s complicated a bit"}]}]}]},{"client_msg_id":"0b9ea477-d433-4e9c-ba88-734f7270ff5c","type":"message","text":"ie Gen is open to DSLs","user":"UDGT4PM41","ts":"1610053318.149200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NwjD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ie Gen is open to DSLs"}]}]}]},{"client_msg_id":"b71583b8-2095-4ebb-a8a3-401bfdf874bc","type":"message","text":"some things have to be in C++ basically because stuff is not exposed through the C API","user":"UKA81L34J","ts":"1610053345.150200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9DHIx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"some things have to be in C++ basically because stuff is not exposed through the C API"}]}]}]},{"client_msg_id":"5a5820d6-4cbc-45c8-9714-81a20c110fd9","type":"message","text":"it's all Julia so the bar is lower for people to make new ones","user":"UDGT4PM41","ts":"1610053350.150400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ViBB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it's all Julia so the bar is lower for people to make new ones"}]}]}]},{"client_msg_id":"2ec1c37b-782e-4b2a-a4e6-1506e7b66031","type":"message","text":"Yeah right - I know what you mean. But it’s hard because some of these issues are outside of the design boundaries for Julia","user":"UKA81L34J","ts":"1610053381.151000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DOtxg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah right - I know what you mean. But it’s hard because some of these issues are outside of the design boundaries for Julia"}]}]}]},{"client_msg_id":"ce01fd37-fe20-48ef-811d-005cdfadc844","type":"message","text":"e.g. we can expose C APIs for MLIR and LLVM, but the developers of MLIR and LLVM are ultimately responsible for what they expose through the C API","user":"UKA81L34J","ts":"1610053401.151700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qDm8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"e.g. we can expose C APIs for MLIR and LLVM, but the developers of MLIR and LLVM are ultimately responsible for what they expose through the C API"}]}]}]},{"client_msg_id":"e9c66ec3-cc4b-474f-a1b3-e1c92e554c31","type":"message","text":"that's why I'm asking the dialect question","user":"UDGT4PM41","ts":"1610053402.151800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pFP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that's why I'm asking the dialect question"}]}]}]},{"client_msg_id":"d307ac65-3aed-47ba-b64a-abf4252a8de8","type":"message","text":"maybe the boundaries are broader but it's hard to know since I don't really understand the AI use cases yet","user":"UDGT4PM41","ts":"1610053427.152800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pya+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"maybe the boundaries are broader but it's hard to know since I don't really understand the AI use cases yet"}]}]}]},{"client_msg_id":"ae5090e2-0488-49a5-9e31-f6dc24c7d64d","type":"message","text":"So if you look at that thread, they’ve actually answered some of the pass/conversion questions. Some of that is off-limits for the C API (in their mind).","user":"UKA81L34J","ts":"1610053438.153200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L0Nf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So if you look at that thread, they’ve actually answered some of the pass/conversion questions. Some of that is off-limits for the C API (in their mind)."}]}]}]},{"client_msg_id":"8728c60b-fc09-44c3-92dc-1322af5cddca","type":"message","text":"yea i saw that","user":"UDGT4PM41","ts":"1610053451.153400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"N1n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yea i saw that"}]}]}]},{"client_msg_id":"56ff23b3-e54a-48af-8817-e705924150fb","type":"message","text":"I just feel like we're reinventing a new dialect of the two language problem. anyway, this isn't really IR tools related anymore so I'll PM you if I have any other questions","user":"UDGT4PM41","ts":"1610053532.154700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DD9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just feel like we're reinventing a new dialect of the two language problem. anyway, this isn't really IR tools related anymore so I'll PM you if I have any other questions"}]}]}]},{"client_msg_id":"75f053f0-4b68-462d-9a49-d6ec1ed0cefa","type":"message","text":"It’s a bit different now","user":"UKA81L34J","ts":"1610053553.154900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K/TRo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s a bit different now"}]}]}]},{"client_msg_id":"0cbd4ec6-4b58-41fe-a326-34ea469dee5e","type":"message","text":"I don’t think it’s really the same. Also keep in mind that a lot of the MLIR experimentation (on the LLVM side) is to make high-level IR optimizations easier and re-usable. E.g. they basically saw the need for infrastructure which is re-usable since so many languages/compilers were implementing mid-level IRs","user":"UKA81L34J","ts":"1610053712.156800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZeO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t think it’s really the same. Also keep in mind that a lot of the MLIR experimentation (on the LLVM side) is to make high-level IR optimizations easier and re-usable. E.g. they basically saw the need for infrastructure which is re-usable since so many languages/compilers were implementing mid-level IRs"}]}]}]},{"client_msg_id":"34723531-ddcd-4a8a-8e09-0497d8bb627c","type":"message","text":"On another note, the point of an MLIR-specific thing would be to facilitate codegen to other devices.","user":"UKA81L34J","ts":"1610053774.157300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vV/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On another note, the point of an MLIR-specific thing would be to facilitate codegen to other devices."}]}]}]},{"client_msg_id":"0b9b0746-339a-4f2d-9adb-4c5ef294c19c","type":"message","text":"LLVM is super duper for CPUs - but it’s not necessarily the right thing for your custom quantum architecture (or your custom inference accelerator)","user":"UKA81L34J","ts":"1610053795.157800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"G2z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"LLVM is super duper for CPUs - but it’s not necessarily the right thing for your custom quantum architecture (or your custom inference accelerator)"}]}]}]},{"client_msg_id":"852cff4c-ff51-4520-a68c-472564ed0e83","type":"message","text":"Also, on another note - if the level required to get involved is getting you down, just remember Proebsting’s Law","user":"UKA81L34J","ts":"1610053852.158400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nvIea","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, on another note - if the level required to get involved is getting you down, just remember Proebsting’s Law"}]}]}]},{"client_msg_id":"c572f06f-7082-4802-be9f-cd2f0bde32cd","type":"message","text":"<http://proebsting.cs.arizona.edu/law.html>","user":"UKA81L34J","ts":"1610053853.158600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Zd9O","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"http://proebsting.cs.arizona.edu/law.html"}]}]}]},{"client_msg_id":"7ddefcf8-3bcb-483f-a1c0-8757c129132a","type":"message","text":"(of course, Proebsting’s Law assumes that target architectures are held constant :stuck_out_tongue: )","user":"UKA81L34J","ts":"1610053880.159000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0avNn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(of course, Proebsting’s Law assumes that target architectures are held constant "},{"type":"emoji","name":"stuck_out_tongue"},{"type":"text","text":" )"}]}]}]},{"type":"message","subtype":"thread_broadcast","text":"there are actually a bunch of helper functions inside Julia compiler, e.g `renumber_ssa!` etc. I started writing YaoLang/YaoCompiler project with IRTools, but then later removed it since I don’t want to introduce too much levels of similar IRs in the compiler. But I agree, we don’t have much tools exposed for manipulating Julia’s IR. I think perhaps should move some of the tools in YaoCompiler for `CodeInfo` to a package and develop a light weight package for directly manipulating `CodeInfo` would be helpful","user":"UC6SUUPRC","ts":"1610060738.159100","thread_ts":"1610048270.112400","root":{"client_msg_id":"7ea756fd-5aa1-436a-ac1e-5a95737c3d9e","type":"message","text":"The thing with julia’s IR is that is it painful to work with.\nBecause of things like you need to renumber all the SSA values if you insert or delete a line.\nThere are tools in `Core.Compiler`  for doing this.\nand Cassette’s `insert_statements` uses them.\nbut IRTools avoids needing to do them because it’s data structures are a bit higher level","user":"U6A936746","ts":"1610048270.112400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qgTs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The thing with julia’s IR is that is it painful to work with.\nBecause of things like you need to renumber all the SSA values if you insert or delete a line.\nThere are tools in "},{"type":"text","text":"Core.Compiler","style":{"code":true}},{"type":"text","text":"  for doing this.\nand Cassette’s "},{"type":"text","text":"insert_statements","style":{"code":true}},{"type":"text","text":" uses them.\nbut IRTools avoids needing to do them because it’s data structures are a bit higher level"}]}]}],"thread_ts":"1610048270.112400","reply_count":5,"reply_users_count":2,"latest_reply":"1610060964.160400","reply_users":["UC6SUUPRC","U6A936746"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"0A6as","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there are actually a bunch of helper functions inside Julia compiler, e.g "},{"type":"text","text":"renumber_ssa!","style":{"code":true}},{"type":"text","text":" etc. I started writing YaoLang/YaoCompiler project with IRTools, but then later removed it since I don’t want to introduce too much levels of similar IRs in the compiler. But I agree, we don’t have much tools exposed for manipulating Julia’s IR. I think perhaps should move some of the tools in YaoCompiler for "},{"type":"text","text":"CodeInfo","style":{"code":true}},{"type":"text","text":" to a package and develop a light weight package for directly manipulating "},{"type":"text","text":"CodeInfo","style":{"code":true}},{"type":"text","text":" would be helpful"}]}]}],"client_msg_id":"6c4f709e-b9d9-4863-b9d5-ce3a3c087b8e"},{"client_msg_id":"73291a8e-9c7d-482c-aadd-ca21d0dac64f","type":"message","text":"guys, can I generate the same code from expressions like:\n`xcall(:(+), 0, 1)`\nto be the same as:\n`:(0 + 1)`\nI mean xcall basically returns `:(0 + 1)` but they are not identical.","user":"U016RL8KEHX","ts":"1611488958.000700","team":"T68168MUP","edited":{"user":"U016RL8KEHX","ts":"1611489025.000000"},"blocks":[{"type":"rich_text","block_id":"WCeE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"guys, can I generate the same code from expressions like:\n"},{"type":"text","text":"xcall(:(+), 0, 1)","style":{"code":true}},{"type":"text","text":"\nto be the same as:\n"},{"type":"text","text":":(0 + 1)","style":{"code":true}},{"type":"text","text":"\nI mean xcall basically returns "},{"type":"text","text":":(0 + 1)","style":{"code":true}},{"type":"text","text":" but they are not identical."}]}]}]},{"client_msg_id":"d86f00e2-c297-448e-95ef-a5a4d811e7e6","type":"message","text":"xcall and the :(0 + 1) both return an expression, but the second expression I can't push into an IRTools `IR` for example:\n`ir = @code_ir somefunc(), push!(ir, :(0 + 1))`","user":"U016RL8KEHX","ts":"1611494980.005000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FwfA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"xcall and the :(0 + 1) both return an expression, but the second expression I can't push into an IRTools "},{"type":"text","text":"IR","style":{"code":true}},{"type":"text","text":" for example:\n"},{"type":"text","text":"ir = @code_ir somefunc(), push!(ir, :(0 + 1))","style":{"code":true}}]}]}]},{"client_msg_id":"b5c25644-5e49-4bf8-9773-3ea5301d1fa5","type":"message","text":"It sounds reasonable, but can it be done in such a simple form, there must be a simple way to do this. :slightly_smiling_face:","user":"U016RL8KEHX","ts":"1611495014.005600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/0sLF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It sounds reasonable, but can it be done in such a simple form, there must be a simple way to do this. "},{"type":"emoji","name":"slightly_smiling_face"}]}]}]},{"client_msg_id":"33661174-1920-4ea3-bd40-419c6c655310","type":"message","text":"Naturally this would work: `push!(ir, xcall(:(+), 0, 1))`\nEven tho `xcall(:(+), 0, 1)` returns `:(0 + 1)` .\nWhat I see as a difference is that :(+) is a Symbol in `:(0 + 1)`, but it is Base.:+ in the `xcall(:(+), 0, 1)`  format, so what interest me is a simple way to move from exressions to IR code?","user":"U016RL8KEHX","ts":"1611495228.008500","team":"T68168MUP","edited":{"user":"U016RL8KEHX","ts":"1611495260.000000"},"blocks":[{"type":"rich_text","block_id":"F3qz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Naturally this would work: "},{"type":"text","text":"push!(ir, xcall(:(+), 0, 1))","style":{"code":true}},{"type":"text","text":"\nEven tho "},{"type":"text","text":"xcall(:(+), 0, 1)","style":{"code":true}},{"type":"text","text":" returns "},{"type":"text","text":":(0 + 1)","style":{"code":true}},{"type":"text","text":" .\nWhat I see as a difference is that :(+) is a Symbol in "},{"type":"text","text":":(0 + 1)","style":{"code":true}},{"type":"text","text":", but it is Base.:+ in the "},{"type":"text","text":"xcall(:(+), 0, 1)","style":{"code":true}},{"type":"text","text":"  format, so what interest me is a simple way to move from exressions to IR code?"}]}]}]},{"client_msg_id":"D2998796-8328-4099-9752-F04CCEC30A3E","type":"message","text":"You can’t always be sure that you are referring to the generic function that is exported into Main even in just normal Julia AST so you just need to write a Global reference ","user":"UC6SUUPRC","ts":"1611504961.010100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z8p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can’t always be sure that you are referring to the generic function that is exported into Main even in just normal Julia AST so you just need to write a Global reference "}]}]}]},{"client_msg_id":"ecdeb44e-8e27-42f1-a221-6590e5fd9e64","type":"message","text":"I see I need to address what function I refer to. So then the question is, how can i convert `:(1 + 2)` to a representation where \"+\" is a Global reference and not just a Symbol?","user":"U016RL8KEHX","ts":"1611507778.011700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O+F2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see I need to address what function I refer to. So then the question is, how can i convert "},{"type":"text","text":":(1 + 2)","style":{"code":true}},{"type":"text","text":" to a representation where \"+\" is a Global reference and not just a Symbol?"}]}]}]},{"client_msg_id":"ba8db0e2-adc1-4d40-9948-f535d2ba10f2","type":"message","text":"Hm as I am asking this question, I see that :(1+2) needs a context where it is ran, so the \"+\" symbol can become a reference to a function, right?","user":"U016RL8KEHX","ts":"1611507867.012800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Sjn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hm as I am asking this question, I see that :(1+2) needs a context where it is ran, so the \"+\" symbol can become a reference to a function, right?"}]}]}]},{"client_msg_id":"1a3d0ddd-5b59-4109-b728-63436bcab124","type":"message","text":"<@U016RL8KEHX>\n```Expr(:call, GlobalRef(Base, :(+)), args...)```","user":"UKA81L34J","ts":"1611514631.013300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BtX","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U016RL8KEHX"},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Expr(:call, GlobalRef(Base, :(+)), args...)"}]}]}],"reactions":[{"name":"+1","users":["U016RL8KEHX"],"count":1}]},{"client_msg_id":"41ffd079-b64c-47e6-9601-28f2318fc226","type":"message","text":"```julia&gt; Expr(:call, GlobalRef(Base, :(+)), 1, 2)\n:(1 + 2)```\n","user":"UKA81L34J","ts":"1611514755.014100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AU9","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Expr(:call, GlobalRef(Base, :(+)), 1, 2)\n:(1 + 2)"}]},{"type":"rich_text_section","elements":[]}]}]},{"client_msg_id":"11031201-d98c-45ee-ba32-319c9e91b167","type":"message","text":"This means that we use Base as a context to infer the function what \"+\" refers to right? :slightly_smiling_face:","user":"U016RL8KEHX","ts":"1611515029.014700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C=7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This means that we use Base as a context to infer the function what \"+\" refers to right? "},{"type":"emoji","name":"slightly_smiling_face"}]}]}]},{"client_msg_id":"17d634da-9568-433f-9158-9b46a7d0bf2e","type":"message","text":"Yeah - take a look at: <https://docs.julialang.org/en/v1/devdocs/ast/#Lowered-form>","user":"UKA81L34J","ts":"1611515069.014900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9F80=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah - take a look at: "},{"type":"link","url":"https://docs.julialang.org/en/v1/devdocs/ast/#Lowered-form"}]}]}]},{"client_msg_id":"134789fe-c2de-4503-84eb-3d9ebc19f6a3","type":"message","text":"`GlobalRef` refers to a `name` in module `mod` basically in the lowered IR.","user":"UKA81L34J","ts":"1611515096.015500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eJv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"GlobalRef","style":{"code":true}},{"type":"text","text":" refers to a "},{"type":"text","text":"name","style":{"code":true}},{"type":"text","text":" in module "},{"type":"text","text":"mod","style":{"code":true}},{"type":"text","text":" basically in the lowered IR."}]}]}]},{"client_msg_id":"5e7f0c51-cf35-4475-87a9-5e3d23449fe5","type":"message","text":"Note that IRTools IR _is different_ than this lowered IR but re-uses some of the structures (like `Expr` as a subfield inside of `IRTools` `Statement`)","user":"UKA81L34J","ts":"1611515138.016400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uJmi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Note that IRTools IR "},{"type":"text","text":"is different","style":{"italic":true}},{"type":"text","text":" than this lowered IR but re-uses some of the structures (like "},{"type":"text","text":"Expr","style":{"code":true}},{"type":"text","text":" as a subfield inside of "},{"type":"text","text":"IRTools","style":{"code":true}},{"type":"text","text":" "},{"type":"text","text":"Statement","style":{"code":true}},{"type":"text","text":")"}]}]}]},{"client_msg_id":"68e398cc-733d-4fa1-b5aa-00117bdcc636","type":"message","text":"if you want to refer to the current scope you should use `__module__`  if it’s inside a macro, or if it’s inside `@generated` you should always specified the actual module you are referring to","user":"UC6SUUPRC","ts":"1611601706.017700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l3A4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you want to refer to the current scope you should use "},{"type":"text","text":"__module__","style":{"code":true}},{"type":"text","text":"  if it’s inside a macro, or if it’s inside "},{"type":"text","text":"@generated","style":{"code":true}},{"type":"text","text":" you should always specified the actual module you are referring to"}]}]}],"reactions":[{"name":"heart","users":["U016RL8KEHX"],"count":1}]},{"client_msg_id":"cdbfcab5-1671-4eb6-9ae4-c637fb092cf2","type":"message","text":"I have some questions about how `func` works. Looking at the body of the function\n```@eval @generated function $(gensym())($([Symbol(:arg, i) for i = 1:length(arguments(ir))]...))\n    return build_codeinfo($ir)\n  end```\nit seems `@generated` returns the function it defines, which is why we can call `f` after `f = func(ir)`. In addition, `@generated` somehow replaces the formal parameters of `ir` with those of the generated function, even though within the body of the generated function formal parameters hold types not values of actual arguments. This is implicit in Julia documentation involving ASTs, but in IRs this is less visual. Is my understanding correct?","user":"UMS8C22UA","ts":"1612026830.025500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FK1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have some questions about how "},{"type":"text","text":"func","style":{"code":true}},{"type":"text","text":" works. Looking at the body of the function\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@eval @generated function $(gensym())($([Symbol(:arg, i) for i = 1:length(arguments(ir))]...))\n    return build_codeinfo($ir)\n  end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"it seems "},{"type":"text","text":"@generated","style":{"code":true}},{"type":"text","text":" returns the function it defines, which is why we can call "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" after "},{"type":"text","text":"f = func(ir)","style":{"code":true}},{"type":"text","text":". In addition, "},{"type":"text","text":"@generated","style":{"code":true}},{"type":"text","text":" somehow replaces the formal parameters of "},{"type":"text","text":"ir","style":{"code":true}},{"type":"text","text":" with those of the generated function, even though within the body of the generated function formal parameters hold types not values of actual arguments. This is implicit in Julia documentation involving ASTs, but in IRs this is less visual. Is my understanding correct?"}]}]}]},{"client_msg_id":"A4004DFE-5ADA-4748-AF3D-56CA22768C47","type":"message","text":"<@UMS8C22UA> When returning a piece of CodeInfo out of a generated function, the number of arguments must match the number of arguments of the generated function. Because when you return a piece of CodeInfo, you’re saying “for this generated function with these argument types, this is the body”\n\nI’m not sure what you mean by:\n\n&gt; within the body of the generated function formal parameters hold types not values of actual arguments.\n\nDo you mean the arguments are symbolic or ? They are formals.","user":"UKA81L34J","ts":"1612033244.028700","team":"T68168MUP","edited":{"user":"UKA81L34J","ts":"1612033259.000000"},"blocks":[{"type":"rich_text","block_id":"2jlz","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UMS8C22UA"},{"type":"text","text":" When returning a piece of CodeInfo out of a generated function, the number of arguments must match the number of arguments of the generated function. Because when you return a piece of CodeInfo, you’re saying “for this generated function with these argument types, this is the body”\n\nI’m not sure what you mean by:\n\n> within the body of the generated function formal parameters hold types not values of actual arguments.\n\nDo you mean the arguments are symbolic or ? They are formals."}]}]}]},{"client_msg_id":"ed413a6d-7abc-41ea-b268-b9935c74c432","type":"message","text":"Thanks, <@UKA81L34J>. That makes sense.\nBy \"within the body of the generated function formal parameters hold types not values of actual arguments,\" I was thinking about\n``` @generated function foo(x)\n           Core.println(x)\n           return :(x * x)\n       end```\nfrom Julia documentation. Here `x` inside the `Core.println` is a type, while inside `:(x * x)` a value, the actual argument, will be substituted. Above implies that symbol lookup is done like regular functions, via symbol talbes. However, inside `build_codeinfo` all arguments are set to empty strings -- via pushing into `slotname` , which leads me to think parameters are looked up by position. Is the difference that one returns AST and the other returns IRs?\n\"Formal parameter\" and \"actual argument\" are terminology I picked up from my compiler course a while ago, which I am using here to emphasize their distinction; they mean just parameter and argument. Sorry that they are confusing.","user":"UMS8C22UA","ts":"1612044280.038100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GFpV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, "},{"type":"user","user_id":"UKA81L34J"},{"type":"text","text":". That makes sense.\nBy \"within the body of the generated function formal parameters hold types not values of actual arguments,\" I was thinking about\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":" @generated function foo(x)\n           Core.println(x)\n           return :(x * x)\n       end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"from Julia documentation. Here "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" inside the "},{"type":"text","text":"Core.println","style":{"code":true}},{"type":"text","text":" is a type, while inside "},{"type":"text","text":":(x * x)","style":{"code":true}},{"type":"text","text":" a value, the actual argument, will be substituted. Above implies that symbol lookup is done like regular functions, via symbol talbes. However, inside "},{"type":"text","text":"build_codeinfo","style":{"code":true}},{"type":"text","text":" all arguments are set to empty strings -- via pushing into "},{"type":"text","text":"slotname","style":{"code":true}},{"type":"text","text":" , which leads me to think parameters are looked up by position. Is the difference that one returns AST and the other returns IRs?\n\"Formal parameter\" and \"actual argument\" are terminology I picked up from my compiler course a while ago, which I am using here to emphasize their distinction; they mean just parameter and argument. Sorry that they are confusing."}]}]}]},{"client_msg_id":"57e58495-fdc4-4ad6-9115-9bb38dedd615","type":"message","text":"I'm new to IRTools and Julia IR so I'm not sure whether my question makes sense.\nIs there a way to immediately return the result of a particular function that is called somewhere while recursing through a main function.\ne.g. return the result of the first matmul in a neural network, regardless of what would happen next.","user":"UBGC95BDJ","ts":"1612213452.041700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MoW6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm new to IRTools and Julia IR so I'm not sure whether my question makes sense.\nIs there a way to immediately return the result of a particular function that is called somewhere while recursing through a main function.\ne.g. return the result of the first matmul in a neural network, regardless of what would happen next."}]}]}]},{"client_msg_id":"c91c5f8a-8037-4bde-85da-aafbac20f5c8","type":"message","text":"sounds like you can just use Cassette, e.g create a context with a flag and when you hit `matmul` then set the flag to `false` so nothing will happens afterwards","user":"UC6SUUPRC","ts":"1612215550.042800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WDE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sounds like you can just use Cassette, e.g create a context with a flag and when you hit "},{"type":"text","text":"matmul","style":{"code":true}},{"type":"text","text":" then set the flag to "},{"type":"text","text":"false","style":{"code":true}},{"type":"text","text":" so nothing will happens afterwards"}]}]}],"thread_ts":"1612215550.042800","reply_count":1,"reply_users_count":1,"latest_reply":"1612217826.043000","reply_users":["UBGC95BDJ"],"subscribed":false,"reactions":[{"name":"+1","users":["U8D9768Q6"],"count":1},{"name":"thankyou","users":["UBGC95BDJ"],"count":1}]},{"client_msg_id":"056623b4-81bc-4fa5-945b-c57c1aff0f53","type":"message","text":"<@UBGC95BDJ>\n```function main(args...)\n    try\n       Cassette.overdub(YourContext(), run_network, args...)\n    catch e\n       println(e)\n    end\nend```\nthen, in your `overdub` for matmul, just throw?","user":"UKA81L34J","ts":"1612220352.044700","team":"T68168MUP","edited":{"user":"UKA81L34J","ts":"1612220363.000000"},"blocks":[{"type":"rich_text","block_id":"aXq","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UBGC95BDJ"},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function main(args...)\n    try\n       Cassette.overdub(YourContext(), run_network, args...)\n    catch e\n       println(e)\n    end\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"then, in your "},{"type":"text","text":"overdub","style":{"code":true}},{"type":"text","text":" for matmul, just throw?"}]}]}]},{"client_msg_id":"7f4b3dc4-39e6-493d-8c8a-6641e2d786c7","type":"message","text":"You can also structure `e` to contain the return value.","user":"UKA81L34J","ts":"1612220399.045100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QeOJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can also structure "},{"type":"text","text":"e","style":{"code":true}},{"type":"text","text":" to contain the return value."}]}]}]},{"client_msg_id":"5323bf59-a6fc-4e52-a899-85f03844d0bc","type":"message","text":"I think you can throw arrays. (Or any other value)\nSo you don't been need to declare an exception type or anything","user":"U6A936746","ts":"1612223911.046800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Wyi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think you can throw arrays. (Or any other value)\nSo you don't been need to declare an exception type or anything"}]}]}]},{"client_msg_id":"9c996f53-dd35-45bb-af25-17f65bdd91e8","type":"message","text":"Thanks! That works like a charm!","user":"UBGC95BDJ","ts":"1612265076.047200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uua","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks! That works like a charm!"}]}]}]},{"client_msg_id":"8b6ae4fb-8a49-490e-8085-dd75aebe46cf","type":"message","text":"Is there a straightforward way to substitute variables in the IR with IRTools, i.e. I want to replace all occurances of `IRTools.var(3)` with `IRTools.var(4)`?","user":"UM30MT6RF","ts":"1614085430.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hFfE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a straightforward way to substitute variables in the IR with IRTools, i.e. I want to replace all occurances of "},{"type":"text","text":"IRTools.var(3)","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"IRTools.var(4)","style":{"code":true}},{"type":"text","text":"?"}]}]}]},{"client_msg_id":"064caab0-86a5-450c-a8f0-3420a0a3acce","type":"message","text":"I think that's exactly what IRTools tries to avoid having to do...? Without further context I can just say: none that I know of; I usually did those things by turning\n```%3 = f(...)\n...\n%10 = g(%3)```\ninto\n```%100 = f(...)\n%3 = my_new_stuff(%100, ...)\n...\n%10 = g(%3)```\nBut again, depends on what you want to do.","user":"UN45LV5K6","ts":"1614086185.004700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PPB7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think that's exactly what IRTools tries to avoid having to do...? Without further context I can just say: none that I know of; I usually did those things by turning\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"%3 = f(...)\n...\n%10 = g(%3)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"into\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"%100 = f(...)\n%3 = my_new_stuff(%100, ...)\n...\n%10 = g(%3)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"But again, depends on what you want to do."}]}]}]},{"client_msg_id":"e96ce1f4-201f-47c8-b33c-6516c14e69d5","type":"message","text":"If it get's harder, try to rebuild the whole thing, maybe with a `Pipe`.","user":"UN45LV5K6","ts":"1614086247.005800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"98D","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If it get's harder, try to rebuild the whole thing, maybe with a "},{"type":"text","text":"Pipe","style":{"code":true}},{"type":"text","text":"."}]}]}]},{"client_msg_id":"db267fba-37e0-4d3c-920d-301db4dc750e","type":"message","text":"The problem in my case is that I want to replace a function argument with a different variable","user":"UM30MT6RF","ts":"1614086266.006000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PYKC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The problem in my case is that I want to replace a function argument with a different variable"}]}]}]},{"client_msg_id":"3c129254-38b7-40ab-940b-1a110da55135","type":"message","text":"I guess I could probably abuse inline for this","user":"UM30MT6RF","ts":"1614086446.006400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VIL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess I could probably abuse inline for this"}]}]}]},{"client_msg_id":"246aac6f-dd00-4373-8242-4564db60dcc0","type":"message","text":"You could try a variant of the approach above and replace the function argument (delete and add a new one), and then push a new statement to the top with defines the old variable instead, with some hack perhaps to manually set the name.\n\nOr if you go the rebuild route: pipes [have some substituition mechanism](<https://github.com/FluxML/IRTools.jl/blob/master/src/ir/ir.jl#L852>), which I never fully understood, though.","user":"UN45LV5K6","ts":"1614086873.009000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rG4mm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could try a variant of the approach above and replace the function argument (delete and add a new one), and then push a new statement to the top with defines the old variable instead, with some hack perhaps to manually set the name.\n\nOr if you go the rebuild route: pipes [have some substituition mechanism]("},{"type":"link","url":"https://github.com/FluxML/IRTools.jl/blob/master/src/ir/ir.jl#L852"},{"type":"text","text":"), which I never fully understood, though."}]}]}]},{"client_msg_id":"281c94b5-4d9f-49be-b494-d28428cd745a","type":"message","text":"```1: (%1, %100)\n  %2 = your_new_stuff(%100)\n  ...\n  %5 = old_function(%2)```","user":"UN45LV5K6","ts":"1614086950.009800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o2aGe","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"1: (%1, %100)\n  %2 = your_new_stuff(%100)\n  ...\n  %5 = old_function(%2)"}]}]}]},{"client_msg_id":"d1eb1cb7-c1db-4fb9-9631-13d8f5faa153","type":"message","text":"where `%100` is a fresh name.","user":"UN45LV5K6","ts":"1614086995.010100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s=l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"where "},{"type":"text","text":"%100","style":{"code":true}},{"type":"text","text":" is a fresh name."}]}]}]},{"client_msg_id":"cc12e136-69e6-4349-93f0-63b4cb352e4b","type":"message","text":"Yeah, I tried this, but it didn't really work like I expected","user":"UM30MT6RF","ts":"1614087052.010500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DMl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I tried this, but it didn't really work like I expected"}]}]}]},{"client_msg_id":"1ffc3dee-bf67-4d71-b840-cc99b3d11384","type":"message","text":"Did you rebuild the metadata of the resulting function?","user":"UN45LV5K6","ts":"1614087163.010900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cR3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Did you rebuild the metadata of the resulting function?"}]}]}]},{"client_msg_id":"a827ab86-33fa-4791-91f7-68a0e5d6c2da","type":"message","text":"A dynamo might not like this kind of things (but I'm not sure). That's how I did it once: <https://github.com/TuringLang/IRTracker.jl/blob/master/src/tracker.jl#L27>","user":"UN45LV5K6","ts":"1614087344.011500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FG4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A dynamo might not like this kind of things (but I'm not sure). That's how I did it once: "},{"type":"link","url":"https://github.com/TuringLang/IRTracker.jl/blob/master/src/tracker.jl#L27"}]}]}]},{"client_msg_id":"5329dae0-adec-48c2-aebb-57412ecc6c7a","type":"message","text":"I don't think I did. I think I might just go with `inlining` the IR into a copy of itself, which seems to work.","user":"UM30MT6RF","ts":"1614088023.012300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"duu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think I did. I think I might just go with "},{"type":"text","text":"inlining","style":{"code":true}},{"type":"text","text":" the IR into a copy of itself, which seems to work."}]}]}]},{"client_msg_id":"c11cbf69-e9dd-4899-9199-24cc2cfc8101","type":"message","text":"Ah, yeah. The faster equivalent of rebuilding the whole thing :slightly_smiling_face:","user":"UN45LV5K6","ts":"1614088158.012800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cza2/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, yeah. The faster equivalent of rebuilding the whole thing "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"reactions":[{"name":"laughing","users":["UM30MT6RF"],"count":1}]},{"client_msg_id":"029ea6a3-19ad-4fb3-8039-ac421a7087cf","type":"message","text":"Does anybody know how to use `IRTools.func()`  in a precompiled module? I'm trying to manually construct a function from IR and put it into my module, but during testing it fails with:\n\n&gt;  Evaluation into the closed module `Inner` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Inner` with `eval` during precompilation - don't do this.\nPutting it into a submodule with `__precompile__(false)`  fixes the issue, but as far as I understand it prevents prcompilation of the parent module too.","user":"U72B014PN","ts":"1616922754.003300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ljY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anybody know how to use "},{"type":"text","text":"IRTools.func()","style":{"code":true}},{"type":"text","text":"  in a precompiled module? I'm trying to manually construct a function from IR and put it into my module, but during testing it fails with:\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":" Evaluation into the closed module "},{"type":"text","text":"Inner","style":{"code":true}},{"type":"text","text":" breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating "},{"type":"text","text":"Inner","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"eval","style":{"code":true}},{"type":"text","text":" during precompilation - don't do this."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nPutting it into a submodule with "},{"type":"text","text":"__precompile__(false)","style":{"code":true}},{"type":"text","text":"  fixes the issue, but as far as I understand it prevents prcompilation of the parent module too."}]}]}],"thread_ts":"1616922754.003300","reply_count":1,"reply_users_count":1,"latest_reply":"1616922921.003400","reply_users":["U72B014PN"],"is_locked":false,"subscribed":false},{"client_msg_id":"BE49FC7C-E363-4E51-9E86-B5C625623988","type":"message","text":"You could eval the func definition inside `__init__()`","user":"U8D9768Q6","ts":"1616946848.005000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Voc56","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could eval the func definition inside "},{"type":"text","text":"__init__()","style":{"code":true}}]}]}]},{"client_msg_id":"313EB46D-97CF-4936-8C5A-1CC2EEBCEED5","type":"message","text":"`func` uses eval anyways","user":"U8D9768Q6","ts":"1616946877.005900","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1616946894.000000"},"blocks":[{"type":"rich_text","block_id":"yINN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"func","style":{"code":true}},{"type":"text","text":" uses eval anyways"}]}]}]},{"client_msg_id":"c496269a-200f-423e-97bf-b1f4c14e7eb2","type":"message","text":"Yeah, I thought about it, but `__init__()`  works during package initialization while I'm trying to create and use a function during package precompilation.\n\nBut I found out that `IRTools.func()`  supports an additional argument - a module to evaluate function in. I tried `func(@__MODULE__, ir)`  and it worked fine in my case.\n\n(Well, to be precise, it worked after I fixed the definition locally, so right now I'm preparing the PR. A good test for this use case turns to be much harder task than the fix itself :D)","user":"U72B014PN","ts":"1616948102.009900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+eZb/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I thought about it, but "},{"type":"text","text":"__init__()","style":{"code":true}},{"type":"text","text":"  works during package initialization while I'm trying to create and use a function during package precompilation.\n\nBut I found out that "},{"type":"text","text":"IRTools.func()","style":{"code":true}},{"type":"text","text":"  supports an additional argument - a module to evaluate function in. I tried "},{"type":"text","text":"func(@__MODULE__, ir)","style":{"code":true}},{"type":"text","text":"  and it worked fine in my case.\n\n(Well, to be precise, it worked after I fixed the definition locally, so right now I'm preparing the PR. A good test for this use case turns to be much harder task than the fix itself :D)"}]}]}]},{"client_msg_id":"ff573063-feaa-40a1-be3a-8010cdc777f6","type":"message","text":"I would try to avoid `IRTools.func` altogether and use a dynamo instead","user":"UM30MT6RF","ts":"1616948271.010000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ger","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would try to avoid "},{"type":"text","text":"IRTools.func","style":{"code":true}},{"type":"text","text":" altogether and use a dynamo instead"}]}]}]},{"client_msg_id":"100765e8-fbdf-458f-be39-f29815e40074","type":"message","text":"Ha, I didn't think about dynamos in this context, but now when you said it indeed looks like the easiest solution","user":"U72B014PN","ts":"1616948979.011100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0aQ8Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ha, I didn't think about dynamos in this context, but now when you said it indeed looks like the easiest solution"}]}]}]},{"client_msg_id":"19194730-77f1-4f9e-a477-fb0e7254bd65","type":"message","text":"In dynamos, when constructing IR from scratch (i.e. `IR()`, not `IR(f, args...)` ), how do we construct an argument list? I tried this:\n\n```@dynamo function __splatnew__(a...)\n    ir = IR()\n    vT = argument!(ir)      # argument for a type to be constructed\n    vargs = argument!(ir)   # argument for its field values\n    vres = push!(ir, Expr(:splatnew, vT, vargs))\n    return!(ir, vres)\n    return ir\nend```\nbut it results in an undefined variable\n```struct Point x; y end\n\n@code_ir __splatnew__(Point, (1, 2))```\nresult:\n```1: (%1, %2)\n  %3 = %splatnew(%2, IRTools.Inner.Undefined())\n  return %3```\nany examples of building functions from the grounds up?","user":"U72B014PN","ts":"1616973951.017500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"moh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In dynamos, when constructing IR from scratch (i.e. "},{"type":"text","text":"IR()","style":{"code":true}},{"type":"text","text":", not "},{"type":"text","text":"IR(f, args...)","style":{"code":true}},{"type":"text","text":" ), how do we construct an argument list? I tried this:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@dynamo function __splatnew__(a...)\n    ir = IR()\n    vT = argument!(ir)      # argument for a type to be constructed\n    vargs = argument!(ir)   # argument for its field values\n    vres = push!(ir, Expr(:splatnew, vT, vargs))\n    return!(ir, vres)\n    return ir\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nbut it results in an undefined variable\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Point x; y end\n\n@code_ir __splatnew__(Point, (1, 2))"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"result:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"1: (%1, %2)\n  %3 = %splatnew(%2, IRTools.Inner.Undefined())\n  return %3"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"any examples of building functions from the grounds up?"}]}]}],"thread_ts":"1616973951.017500","reply_count":1,"reply_users_count":1,"latest_reply":"1616975166.017700","reply_users":["UM30MT6RF"],"is_locked":false,"subscribed":false}]}