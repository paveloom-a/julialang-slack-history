{"cursor": 0, "messages": [{"client_msg_id":"4808b27b-22dd-40cd-ab0e-1e9ab8cb5c44","type":"message","text":"Right now `mapreduce(*, +, fill(3, 2,2), fill(5, 2,2), dims=1)` just applies map &amp; then reduces. Is there an issue about not doing that, i.e. not allocating a matrix before reducing?","user":"UD0NS8PDF","ts":"1608733152.049900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7Pa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Right now "},{"type":"text","text":"mapreduce(*, +, fill(3, 2,2), fill(5, 2,2), dims=1)","style":{"code":true}},{"type":"text","text":" just applies map & then reduces. Is there an issue about not doing that, i.e. not allocating a matrix before reducing?"}]}]}]},{"client_msg_id":"23e3992f-020b-489d-af20-d3d03931e7e1","type":"message","text":"I seem to remember someone mentioning a package that let you have some dimensions being static, and some being not.","user":"U68P09RFZ","ts":"1608751868.050500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ze0B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I seem to remember someone mentioning a package that let you have some dimensions being static, and some being not."}]}]}]},{"client_msg_id":"0477af0d-2783-4ea0-b839-1d5c583c085d","type":"message","text":"does anyone remember what it was?","user":"U68P09RFZ","ts":"1608751875.050700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XbcJA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"does anyone remember what it was?"}]}]}]},{"client_msg_id":"e84b5123-17db-40a4-9166-947a6baa1f8b","type":"message","text":"ah found it <https://github.com/mateuszbaran/HybridArrays.jl>","user":"U68P09RFZ","ts":"1608751964.051000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A7H","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah found it "},{"type":"link","url":"https://github.com/mateuszbaran/HybridArrays.jl"}]}]}],"reactions":[{"name":"+1","users":["UCZ7VBGUD","U8D9768Q6"],"count":2},{"name":"sonic","users":["UCZ7VBGUD"],"count":1}]},{"client_msg_id":"90D76606-B6FE-46AC-84CF-7E798907A45D","type":"message","text":"<https://github.com/mateuszbaran/HybridArrays.jl|https://github.com/mateuszbaran/HybridArrays.jl>","user":"UCZ7VBGUD","ts":"1608751964.051100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"umE","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/mateuszbaran/HybridArrays.jl","text":"https://github.com/mateuszbaran/HybridArrays.jl"}]}]}],"reactions":[{"name":"+1","users":["U68P09RFZ"],"count":1}]},{"client_msg_id":"48e2ca51-0a46-4b9c-bf73-9452e969e468","type":"message","text":"&gt; I seem to remember someone mentioning a package that let you have some dimensions being static, and some being not.\nArraysOfArrays can also do this\n\n```using ArraysOfArrays, StaticArrays\nA = rand(3, 1000)\nVofSV = nestedview(A, SVector{3})\nVofSV isa AbstractVector{&lt;:SVector{3}}```\nThe result is actually not a type defined in ArraysOfArrays, it just does a `reshape(reinterpret(...), ...)`. Works pretty well, though.","user":"U756M0EB0","ts":"1609005892.054200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uY4hZ","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"I seem to remember someone mentioning a package that let you have some dimensions being static, and some being not."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nArraysOfArrays can also do this\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using ArraysOfArrays, StaticArrays\nA = rand(3, 1000)\nVofSV = nestedview(A, SVector{3})\nVofSV isa AbstractVector{<:SVector{3}}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The result is actually not a type defined in ArraysOfArrays, it just does a "},{"type":"text","text":"reshape(reinterpret(...), ...)","style":{"code":true}},{"type":"text","text":". Works pretty well, though."}]}]}]},{"client_msg_id":"2ee9007b-2d97-456f-9e22-0296251fad68","type":"message","text":"That you can just do with Base though, like `reinterpret(typeof(SA[1,2,3]), rand(1:99, 3, 10)) |&gt; vec`?","user":"UD0NS8PDF","ts":"1609006646.054800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8tQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That you can just do with Base though, like "},{"type":"text","text":"reinterpret(typeof(SA[1,2,3]), rand(1:99, 3, 10)) |> vec","style":{"code":true}},{"type":"text","text":"?"}]}]}]},{"client_msg_id":"7ba88025-aeb3-48cf-bf35-94aad5a1e5fc","type":"message","text":"Re having some axes static, should this perhaps return `(SOneTo(3), OneTo(8))`?\n```julia&gt; reinterpret(reshape, Int, [SA[1,2,n] for n in 3:10])\n3×8 reinterpret(reshape, Int64, ::Vector{SVector{3, Int64}}) with eltype Int64:\n 1  1  1  1  1  1  1   1\n 2  2  2  2  2  2  2   2\n 3  4  5  6  7  8  9  10\n\njulia&gt; axes(ans)\n(Base.OneTo(3), Base.OneTo(8))```","user":"UD0NS8PDF","ts":"1609006704.055500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CU1b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Re having some axes static, should this perhaps return "},{"type":"text","text":"(SOneTo(3), OneTo(8))","style":{"code":true}},{"type":"text","text":"?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> reinterpret(reshape, Int, [SA[1,2,n] for n in 3:10])\n3×8 reinterpret(reshape, Int64, ::Vector{SVector{3, Int64}}) with eltype Int64:\n 1  1  1  1  1  1  1   1\n 2  2  2  2  2  2  2   2\n 3  4  5  6  7  8  9  10\n\njulia> axes(ans)\n(Base.OneTo(3), Base.OneTo(8))"}]}]}]},{"client_msg_id":"ce256225-6395-4138-998e-605b1959fb27","type":"message","text":"Not sure about other approaches, but HybridArrays returns a statically sized array in practically any indexing situation where it can be done, and has statically sized views","user":"U9AHT3YM7","ts":"1609013085.056500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Wve","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not sure about other approaches, but HybridArrays returns a statically sized array in practically any indexing situation where it can be done, and has statically sized views"}]}]}]},{"client_msg_id":"a7fa882d-2206-49d4-aeb8-51a6d6006d34","type":"message","text":"and, at least for me, it's much more convenient to be able to mutate a hybrid array in any way I want, not just in SArray chunks","user":"U9AHT3YM7","ts":"1609013277.057400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Rp7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and, at least for me, it's much more convenient to be able to mutate a hybrid array in any way I want, not just in SArray chunks"}]}]}]},{"client_msg_id":"d13195fe-6cdc-475c-bb72-a310cfa78583","type":"message","text":"point 1 from here: <https://discourse.julialang.org/t/recent-developments-in-staticarrays-jl-land/47778> describes it in some detail","user":"U9AHT3YM7","ts":"1609013666.058300","team":"T68168MUP","attachments":[{"service_name":"JuliaLang","title":"Recent developments in StaticArrays.jl land","title_link":"https://discourse.julialang.org/t/recent-developments-in-staticarrays-jl-land/47778","text":"StaticArrays.jl has received a few cool new features since its 0.12.4 release that are now fast thanks to the memory layout changes in Julia 1.5. These changes are commonly known as non-allocating views but as I show here it’s just the tip of the iceberg :slightly_smiling_face:. Here is the outline to make this post a bit more digestible: A cool application. Sized abstract arrays. Faster matrix multiplication. Loading time reduction. These things may not be easy to find so I decided to write about it...","fallback":"JuliaLang: Recent developments in StaticArrays.jl land","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","fields":[{"title":"Reading time","value":"3 mins :clock2:","short":true},{"title":"Likes","value":"75 :heart:","short":true}],"ts":1601896071,"from_url":"https://discourse.julialang.org/t/recent-developments-in-staticarrays-jl-land/47778","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/recent-developments-in-staticarrays-jl-land/47778"}],"blocks":[{"type":"rich_text","block_id":"iA8f/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"point 1 from here: "},{"type":"link","url":"https://discourse.julialang.org/t/recent-developments-in-staticarrays-jl-land/47778"},{"type":"text","text":" describes it in some detail"}]}]}]},{"client_msg_id":"622ea302-f130-4f08-8344-79a2af311fb1","type":"message","text":"Agree this is the full-feature solution. I just suddenly wondered whether Base’s reinterpret ought to have a little more of its flavour. You can mutate the matrix from my msg. as `R[1,2] = 99` etc. And its type does contain the size, but `size` doesn’t use this.","user":"UD0NS8PDF","ts":"1609014312.060300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KXP+n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Agree this is the full-feature solution. I just suddenly wondered whether Base’s reinterpret ought to have a little more of its flavour. You can mutate the matrix from my msg. as "},{"type":"text","text":"R[1,2] = 99","style":{"code":true}},{"type":"text","text":" etc. And its type does contain the size, but "},{"type":"text","text":"size","style":{"code":true}},{"type":"text","text":" doesn’t use this."}]}]}]},{"client_msg_id":"f64b7c33-6dc7-4351-905d-445915e8b7d5","type":"message","text":"That's a good point, it may be something worth looking into.","user":"U9AHT3YM7","ts":"1609146739.060800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MbIaj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's a good point, it may be something worth looking into."}]}]}]},{"client_msg_id":"10362ee4-706f-4d87-8d04-bc199e2430f1","type":"message","text":"Good evening all! Was wondering about review for my PRs for multidimensional array concatenation syntax (<https://github.com/JuliaLang/julia/pull/33697>) and the precursor deprecation warning (<https://github.com/JuliaLang/julia/pull/37168>). I know bandwidth is limited for the array specialists here, just curious what the queue looks like. :slightly_smiling_face:","user":"U01HD5VFXJM","ts":"1609900527.066000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/nOv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Good evening all! Was wondering about review for my PRs for multidimensional array concatenation syntax ("},{"type":"link","url":"https://github.com/JuliaLang/julia/pull/33697"},{"type":"text","text":") and the precursor deprecation warning ("},{"type":"link","url":"https://github.com/JuliaLang/julia/pull/37168"},{"type":"text","text":"). I know bandwidth is limited for the array specialists here, just curious what the queue looks like. "},{"type":"emoji","name":"slightly_smiling_face"}]}]}]},{"client_msg_id":"f400c229-b287-4665-82dc-ed420d9051e1","type":"message","text":"Is ReadOnlyArrays.jl still the recommended way of creating a immutable/readonly/frozen array?","user":"U695B1S2X","ts":"1610388218.066900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f+aB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is ReadOnlyArrays.jl still the recommended way of creating a immutable/readonly/frozen array?"}]}]}],"thread_ts":"1610388218.066900","reply_count":1,"reply_users_count":1,"latest_reply":"1610388347.067000","reply_users":["U6A936746"],"subscribed":false},{"client_msg_id":"3921eb22-fde0-4690-ae03-f24148879865","type":"message","text":"Does Juila have built-in support for <https://en.wikipedia.org/wiki/Pointwise_product|Pointwise product> operations between multidimensional arrays? or is there a package I could use to compute these efficiently?","user":"UEA5FBCRH","ts":"1610718993.001000","team":"T68168MUP","edited":{"user":"UEA5FBCRH","ts":"1610719064.000000"},"attachments":[{"title":"Pointwise product","title_link":"https://en.wikipedia.org/wiki/Pointwise_product","from_url":"https://en.wikipedia.org/wiki/Pointwise_product","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"In mathematics, the pointwise product of two functions is another function, obtained by multiplying the image of the two functions at each value in the domain. If f and g are both functions with domain X and codomain Y, and elements of Y can be multiplied (for instance, Y could be some set of numbers), then the pointwise product of f and g is another function from X to Y which maps x in X to f(x)g(x) in Y.","fallback":"wikipedia: Pointwise product","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/Pointwise_product"}],"blocks":[{"type":"rich_text","block_id":"rqcb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does Juila have built-in support for "},{"type":"link","url":"https://en.wikipedia.org/wiki/Pointwise_product","text":"Pointwise product"},{"type":"text","text":" operations between multidimensional arrays? or is there a package I could use to compute these efficiently?"}]}]}],"thread_ts":"1610718993.001000","reply_count":2,"reply_users_count":2,"latest_reply":"1610720624.001900","reply_users":["UEA5FBCRH","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"370b418e-172b-47f1-83d6-ae389d8f1580","type":"message","text":"I just discovered that `copyto!` silently skips undefined entries. So something like `copyto!(Vector{Any}(undef, 3), 1, Vector{Any}(undef, 3), 1, 3)` works. In Julia 1.0 it throwed an error. Should this be documented?","user":"U67431ELR","ts":"1611224956.000900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=u7i","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just discovered that "},{"type":"text","text":"copyto!","style":{"code":true}},{"type":"text","text":" silently skips undefined entries. So something like "},{"type":"text","text":"copyto!(Vector{Any}(undef, 3), 1, Vector{Any}(undef, 3), 1, 3)","style":{"code":true}},{"type":"text","text":" works. In Julia 1.0 it throwed an error. Should this be documented?"}]}]}],"thread_ts":"1611224956.000900","reply_count":3,"reply_users_count":2,"latest_reply":"1611244764.005300","reply_users":["U681ELA87","U6740K1SP"],"subscribed":false},{"client_msg_id":"b7de6b9a-7e6e-4d5f-ac08-8db923df2927","type":"message","text":"I was about to open an issue in *NamedDims.jl* pointing out how `dropdims,` when used with a `NamedDimsArray,` does incur in some penalty (time and memory) compared to when it is used with a plain `Array`. I noticed however that an issue has already been opened: <https://github.com/invenia/NamedDims.jl/issues/85>. I was wondering if any work has been done on this and if there is any way that I could help.","user":"UEA5FBCRH","ts":"1611258940.011200","team":"T68168MUP","edited":{"user":"UEA5FBCRH","ts":"1611258965.000000"},"blocks":[{"type":"rich_text","block_id":"=t=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was about to open an issue in "},{"type":"text","text":"NamedDims.jl","style":{"bold":true}},{"type":"text","text":" pointing out how "},{"type":"text","text":"dropdims,","style":{"code":true}},{"type":"text","text":" when used with a "},{"type":"text","text":"NamedDimsArray,","style":{"code":true}},{"type":"text","text":" does incur in some penalty (time and memory) compared to when it is used with a plain "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":". I noticed however that an issue has already been opened: "},{"type":"link","url":"https://github.com/invenia/NamedDims.jl/issues/85"},{"type":"text","text":". I was wondering if any work has been done on this and if there is any way that I could help."}]}]}],"thread_ts":"1611258940.011200","reply_count":2,"reply_users_count":2,"latest_reply":"1611261576.011800","reply_users":["UDXST8ARK","UD0NS8PDF"],"subscribed":false,"reactions":[{"name":"+1","users":["U6A936746"],"count":1}]},{"client_msg_id":"506e1ca5-bf4f-4222-9dd3-2cfcb396e9e9","type":"message","text":"is there a package for contiguous “zipped” representations of same-sized arrays of arrays? e.g., if `u,v` are arrays of the same size, a way to represent them as `[u_1,u_2,...,u_i,v_i,...]` ?","user":"U011LUQ182G","ts":"1611369402.014400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Rdll","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is there a package for contiguous “zipped” representations of same-sized arrays of arrays? e.g., if "},{"type":"text","text":"u,v","style":{"code":true}},{"type":"text","text":" are arrays of the same size, a way to represent them as "},{"type":"text","text":"[u_1,u_2,...,u_i,v_i,...]","style":{"code":true}},{"type":"text","text":" ?"}]}]}]},{"client_msg_id":"8457D5CD-D5EE-49B7-8E36-6EA238C68E83","type":"message","text":"<https://github.com/jonniedie/ComponentArrays.jl|https://github.com/jonniedie/ComponentArrays.jl>","user":"U8D9768Q6","ts":"1611370533.014600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZO8Hd","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/jonniedie/ComponentArrays.jl","text":"https://github.com/jonniedie/ComponentArrays.jl"}]}]}],"thread_ts":"1611370533.014600","reply_count":5,"reply_users_count":2,"latest_reply":"1611382828.016000","reply_users":["U011LUQ182G","UD0NS8PDF"],"subscribed":false},{"type":"message","subtype":"channel_join","ts":"1611437029.016300","user":"UQE0NBSS1","text":"<@UQE0NBSS1> has joined the channel","inviter":"U68QW0PUZ"},{"client_msg_id":"00040516-c281-4046-969e-63e37661c1a0","type":"message","text":"I've started working on the final milestone issue for the next release of StructArrays, but I'm not completely sure whether the change is valid and worth the breakage. It is an attempt to make the interface more consistent. I'm adding a link to the PR here in case anybody wants to give feedback <https://github.com/JuliaArrays/StructArrays.jl/pull/167>","user":"U6BJ9E351","ts":"1611920196.018700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r7s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've started working on the final milestone issue for the next release of StructArrays, but I'm not completely sure whether the change is valid and worth the breakage. It is an attempt to make the interface more consistent. I'm adding a link to the PR here in case anybody wants to give feedback "},{"type":"link","url":"https://github.com/JuliaArrays/StructArrays.jl/pull/167"}]}]}],"reactions":[{"name":"+1","users":["U66QZ3QF3"],"count":1}]},{"client_msg_id":"df4b4f68-a5d4-48b7-a773-d93080cbf323","type":"message","text":"<@UD0NS8PDF> does AxisKeys work with Factorizations?","user":"U6A936746","ts":"1612441297.019600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"24pKi","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" does AxisKeys work with Factorizations?"}]}]}],"thread_ts":"1612441297.019600","reply_count":1,"reply_users_count":1,"latest_reply":"1612442280.020700","reply_users":["UD0NS8PDF"],"subscribed":false},{"client_msg_id":"274c8d02-22d5-4906-a1fe-e21070fea4a9","type":"message","text":"<@UD0NS8PDF>  have a case for a named KeyedArray of JuMP affine expressions\nwhere calling `sum` on the keyed array mutates the content of the array.\ncalling `sum` on the NamedArray inside it, or the `Array` inside that doesn’t have this effect.","user":"U6A936746","ts":"1613567158.024200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/WG","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":"  have a case for a named KeyedArray of JuMP affine expressions\nwhere calling "},{"type":"text","text":"sum","style":{"code":true}},{"type":"text","text":" on the keyed array mutates the content of the array.\ncalling "},{"type":"text","text":"sum","style":{"code":true}},{"type":"text","text":" on the NamedArray inside it, or the "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":" inside that doesn’t have this effect."}]}]}]},{"client_msg_id":"19cef7ec-aaf5-4d13-9515-ee8d89b8d38a","type":"message","text":"This is more of a curiosity, but I was wondering, how can Tullio.jl handle raise conditions when the LHS uses a nontrivial function of the indices? For example, I've noticed that one can do things like\n```@tullio C[i ÷ 2, k] += A[i, j] * B[j, k]```\nDoes Tullio have some smart way to multithread this, or does it just fall back to a sequential approach?","user":"U6BJ9E351","ts":"1613657824.027300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YOK1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is more of a curiosity, but I was wondering, how can Tullio.jl handle raise conditions when the LHS uses a nontrivial function of the indices? For example, I've noticed that one can do things like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@tullio C[i ÷ 2, k] += A[i, j] * B[j, k]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Does Tullio have some smart way to multithread this, or does it just fall back to a sequential approach?"}]}]}],"thread_ts":"1613657824.027300","reply_count":3,"reply_users_count":2,"latest_reply":"1613660141.027800","reply_users":["U6BJ9E351","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"363d15cd-5259-427e-b43d-26850a9c793e","type":"message","text":"I have the following minimal working example:\n```using BenchmarkTools\n\nstruct MyFactor{vars, card, T}\n  vals::T\nend\n\na_vals = rand(2,3,1)\nb_vals = rand(2,1,2)\n\nc_vars = (2,3,4)\nc_card = (2,3,2)\n\n@btime a_vals.* b_vals\n@btime MyFactor{c_vars, c_card, Array{Float64, length(c_vars)}}(a_vals .* b_vals)```\nwhich ouputs:\n```julia&gt; include_string(Main, clipboard())\n  536.910 ns (3 allocations: 240 bytes)\n  1.273 μs (4 allocations: 256 bytes)\nMain.MyModule```\nIs this loss of performance by a factor of 2 when storing the broadcast result in my composite type something that should be expected? Or is there a way I can avoid it or at least improve it?\n\n(I'm running Julia 1.6)","user":"UEA5FBCRH","ts":"1613742408.035200","team":"T68168MUP","edited":{"user":"UEA5FBCRH","ts":"1613742659.000000"},"blocks":[{"type":"rich_text","block_id":"m+W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have the following minimal working example:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using BenchmarkTools\n\nstruct MyFactor{vars, card, T}\n  vals::T\nend\n\na_vals = rand(2,3,1)\nb_vals = rand(2,1,2)\n\nc_vars = (2,3,4)\nc_card = (2,3,2)\n\n@btime a_vals.* b_vals\n@btime MyFactor{c_vars, c_card, Array{Float64, length(c_vars)}}(a_vals .* b_vals)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which ouputs:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> include_string(Main, clipboard())\n  536.910 ns (3 allocations: 240 bytes)\n  1.273 μs (4 allocations: 256 bytes)\nMain.MyModule"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nIs this loss of performance by a factor of 2 when storing the broadcast result in my composite type something that should be expected? Or is there a way I can avoid it or at least improve it?\n\n(I'm running Julia 1.6)"}]}]}]},{"client_msg_id":"7d5b0dd2-9ce9-47bc-b4d6-10b36edfa0eb","type":"message","text":"It's a benchmark artifacts from that the global variables are not `const`","user":"U67D54KS8","ts":"1613743147.035900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"86rfj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's a benchmark artifacts from that the global variables are not "},{"type":"text","text":"const","style":{"code":true}}]}]}]},{"client_msg_id":"e68247ca-c83a-432a-aa7a-47217d7b48fa","type":"message","text":"Benchmark a function, make the `const` or interpolate them into `@btime` wiht `$` to see that you get the same performance","user":"U67D54KS8","ts":"1613743181.036600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5s9c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Benchmark a function, make the "},{"type":"text","text":"const","style":{"code":true}},{"type":"text","text":" or interpolate them into "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" wiht "},{"type":"text","text":"$","style":{"code":true}},{"type":"text","text":" to see that you get the same performance"}]}]}]},{"client_msg_id":"4d311823-9819-4f28-8955-2275b05eddfc","type":"message","text":"Thanks for the answer! Hmm I actually had read that before. I tested both approaches, and got the follwing results:\n```julia&gt; include_string(Main, clipboard())\nWARNING: replacing module MyModule.\n  107.976 ns (1 allocation: 176 bytes)\n  107.511 ns (1 allocation: 176 bytes)\nMain.MyModule```\n```julia&gt; include_string(Main, clipboard())\n  106.980 ns (1 allocation: 176 bytes)\n  439.202 ns (4 allocations: 256 bytes)\nMain.MyOtherModule```\nCould you explain the difference?","user":"UEA5FBCRH","ts":"1613743499.037500","team":"T68168MUP","edited":{"user":"UEA5FBCRH","ts":"1613743604.000000"},"blocks":[{"type":"rich_text","block_id":"GmFx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the answer! Hmm I actually had read that before. I tested both approaches, and got the follwing results:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> include_string(Main, clipboard())\nWARNING: replacing module MyModule.\n  107.976 ns (1 allocation: 176 bytes)\n  107.511 ns (1 allocation: 176 bytes)\nMain.MyModule"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> include_string(Main, clipboard())\n  106.980 ns (1 allocation: 176 bytes)\n  439.202 ns (4 allocations: 256 bytes)\nMain.MyOtherModule"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nCould you explain the difference?"}]}]}]},{"client_msg_id":"6fbfddf3-8a6b-4195-8a5c-8f0882d65b79","type":"message","text":"Interpolating the global vars with `$` still produces a larger ellapsed time for the last statement.\n```@btime MyFactor{$c_vars, $c_card, Array{Float64, length($c_vars)}}($a_vals .* $b_vals)```\nor I'm I still doing something wrong?","user":"UEA5FBCRH","ts":"1613743676.038900","team":"T68168MUP","edited":{"user":"UEA5FBCRH","ts":"1613743782.000000"},"blocks":[{"type":"rich_text","block_id":"GHq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Interpolating the global vars with "},{"type":"text","text":"$","style":{"code":true}},{"type":"text","text":" still produces a larger ellapsed time for the last statement.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@btime MyFactor{$c_vars, $c_card, Array{Float64, length($c_vars)}}($a_vals .* $b_vals)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"or I'm I still doing something wrong?"}]}]}]}]}