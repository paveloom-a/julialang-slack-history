[{"client_msg_id":"2FCCB376-F590-4298-98E3-7F39462A4291","type":"message","text":"Hi, all. As I build the plot recipe for Chain, I have two questions, if I may. \n\n1) Given a layer of the Chain, is there a method, independent of the type of layer, that sets all the parameters of that layer to random numbers? I would like to see each neurons on the next layer are affected by each layer in current layer. I will do by applying the layer to the basis in the input space (for a pool of random parameters) and see which neurons on the next layer are different from zero, so I need to avoid getting zeros by chance. \n\n2) if I have a function `f(x, a)` and I want to use `x-&gt; f(x, a)` in a certain layer and set `a` as a train able parameter, is that possible? How?","user":"U01CR62LAAD","ts":"1615676180.045500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4oHV4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi, all. As I build the plot recipe for Chain, I have two questions, if I may. \n\n"},{"type":"text","text":"1) Given a layer of the Chain, is there a method, independent of the type of layer, that sets all the parameters of that layer to random numbers? I would like to see each neurons on the next layer are affected by each layer in current layer. I will do by applying the layer to the basis in the input space (for a pool of random parameters) and see which neurons on the next layer are different from zero, so I need to avoid getting zeros by chance. \n\n2) if I have a function "},{"type":"text","text":"f(x, a)","style":{"code":true}},{"type":"text","text":" and I want to use "},{"type":"text","text":"x-> f(x, a)","style":{"code":true}},{"type":"text","text":" in a certain layer and set "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" as a train able parameter, is that possible? How?"}]}]}],"thread_ts":"1615676180.045500","reply_count":8,"reply_users_count":3,"latest_reply":"1615708373.051400","reply_users":["UH9KWTTD3","U01CR62LAAD","UC4QQPG4A"],"is_locked":false,"subscribed":false},{"client_msg_id":"1d7c24af-15ed-427a-a575-ee188c96d208","type":"message","text":"1. You can use `fmap` from Functors.jl. For example, if `mchain` is your `Chain`, you can do `fmap(x -&gt; rand(eltype(x), size(x)), mchain)`. This will “map” the function you pass into down to each leaf node in the model, then reconstruct the model back up with the new leaf nodes.\n2. Technically, there is a way since all anonymous functions in Julia are structs, but if you want a trainable layer, then the best way is to define a new struct and use `@functor` (see here: <https://fluxml.ai/Flux.jl/stable/models/basics/#Building-Layers-1>).","user":"UH9KWTTD3","ts":"1615677288.045600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OhP4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"1. You can use "},{"type":"text","text":"fmap","style":{"code":true}},{"type":"text","text":" from Functors.jl. For example, if "},{"type":"text","text":"mchain","style":{"code":true}},{"type":"text","text":" is your "},{"type":"text","text":"Chain","style":{"code":true}},{"type":"text","text":", you can do "},{"type":"text","text":"fmap(x -> rand(eltype(x), size(x)), mchain)","style":{"code":true}},{"type":"text","text":". This will “map” the function you pass into down to each leaf node in the model, then reconstruct the model back up with the new leaf nodes.\n2. Technically, there is a way since all anonymous functions in Julia are structs, but if you want a trainable layer, then the best way is to define a new struct and use "},{"type":"text","text":"@functor","style":{"code":true}},{"type":"text","text":" (see here: "},{"type":"link","url":"https://fluxml.ai/Flux.jl/stable/models/basics/#Building-Layers-1"},{"type":"text","text":")."}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD","reactions":[{"name":"heart","users":["U90JR0C80"],"count":1}]},{"client_msg_id":"8c6626f8-fb68-41aa-8164-692578df4486","type":"message","text":"For (2) it is also possible to just use your function as is, then add `a` manually to the parameters you train with. First, do `ps = params(m)` where `m` is your model. This will not include `a`. Then do `push!(ps, a)`. Now `ps[a]` will return the value of `a`, and you can use `ps` like you would any other set of parameters.","user":"UH9KWTTD3","ts":"1615677420.045800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YZf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For (2) it is also possible to just use your function as is, then add "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" manually to the parameters you train with. First, do "},{"type":"text","text":"ps = params(m)","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":" is your model. This will not include "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":". Then do "},{"type":"text","text":"push!(ps, a)","style":{"code":true}},{"type":"text","text":". Now "},{"type":"text","text":"ps[a]","style":{"code":true}},{"type":"text","text":" will return the value of "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":", and you can use "},{"type":"text","text":"ps","style":{"code":true}},{"type":"text","text":" like you would any other set of parameters."}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"},{"client_msg_id":"41883d59-39b6-4c0e-98e7-eb84d328652c","type":"message","text":"Note that `a` must be an array","user":"UH9KWTTD3","ts":"1615677437.046000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2m2fn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Note that "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" must be an array"}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"},{"client_msg_id":"592C8254-4F76-4594-AB67-059ADF0E520E","type":"message","text":"Oh, thanks! Yeah, `eltype`! Will that also work in ramdomizing `a` as done in either of the two ways you mentioned?","user":"U01CR62LAAD","ts":"1615677728.048900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Uojx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, thanks! Yeah, "},{"type":"text","text":"eltype","style":{"code":true}},{"type":"text","text":"! Will that also work in ramdomizing "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" as done in either of the two ways you mentioned?"}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"},{"client_msg_id":"5977B41A-2066-4BA9-AE3B-59B764AE649B","type":"message","text":"If you make a new struct like in the link, then yes `a` will also get randomized. But if you use the second option of manually pushing into the parameters, then it will not be randomized.","user":"UH9KWTTD3","ts":"1615691154.050800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/dEt1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you make a new struct like in the link, then yes "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" will also get randomized. But if you use the second option of manually pushing into the parameters, then it will not be randomized."}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"},{"client_msg_id":"812bd948-be83-44be-8fee-518d9a5bb1d1","type":"message","text":"We have initialisation functions for every layer that the constructors accept, so setting them to rand or something should work just the same, and in principle already work","user":"UC4QQPG4A","ts":"1615708210.051000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RiuF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We have initialisation functions for every layer that the constructors accept, so setting them to rand or something should work just the same, and in principle already work"}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"},{"client_msg_id":"54b01827-6e85-4102-af7c-6100fbc49e78","type":"message","text":"I don't recommend pushing into the params manually, that may be error prone.","user":"UC4QQPG4A","ts":"1615708267.051200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GgW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't recommend pushing into the params manually, that may be error prone."}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"},{"client_msg_id":"cce999f5-126c-42f7-a2e3-1bb5d4aaa8a1","type":"message","text":"Also, simply using the initialisation functions should get you very far. If not, then maybe fmap, but that isn't guaranteed to work as users can now simply ignore some structures from ever making it into the functored struct.","user":"UC4QQPG4A","ts":"1615708373.051400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vn=x","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, simply using the initialisation functions should get you very far. If not, then maybe fmap, but that isn't guaranteed to work as users can now simply ignore some structures from ever making it into the functored struct."}]}]}],"thread_ts":"1615676180.045500","parent_user_id":"U01CR62LAAD"}]