[{"client_msg_id":"e4f80e73-68dc-4b87-aade-44a67beacb0a","type":"message","text":"I have new appreciation for how easy Blosc.jl is to use.\n\nToday someone asked me for help with python-blosc. For `a` a NumPy array, the most efficient compression call apparently looks like this:\n```blosc.compress_ptr(a.__array_interface__['data'][0], a.size, a.dtype.itemsize, 9,cname= 'lz4')```\nI think numcodecs is probably easier to use, but this was a bit shocking.","user":"USU9FRPEU","ts":"1616201430.050700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=LX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have new appreciation for how easy Blosc.jl is to use.\n\nToday someone asked me for help with python-blosc. For "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" a NumPy array, the most efficient compression call apparently looks like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"blosc.compress_ptr(a.__array_interface__['data'][0], a.size, a.dtype.itemsize, 9,cname= 'lz4')"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I think numcodecs is probably easier to use, but this was a bit shocking."}]}]}],"thread_ts":"1616201430.050700","reply_count":11,"reply_users_count":4,"latest_reply":"1616252766.053500","reply_users":["U6QGE7S86","USU9FRPEU","U0179G7FG4F","U72B7LTMX"],"is_locked":false,"subscribed":false},{"client_msg_id":"b489a22d-b0d2-4089-a8aa-83b94bae9c7a","type":"message","text":"And for Julia?","user":"U6QGE7S86","ts":"1616201458.050800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=zcdJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And for Julia?"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"68212802-5640-4026-b111-8651c92dff36","type":"message","text":"Absolutely.","user":"USU9FRPEU","ts":"1616201501.051000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b+/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Absolutely."}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"98e680e8-9045-4fae-b75b-eaeaa7446c70","type":"message","text":"What's the equivalent julia code?","user":"U0179G7FG4F","ts":"1616201609.051200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"csuxE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What's the equivalent julia code?"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"c1212ab4-db58-4f24-87bb-1e910484d094","type":"message","text":"```julia&gt; Blosc.set_compressor(\"lz4\")\n1\n\njulia&gt; Blosc.compress(A; level = 9);```","user":"USU9FRPEU","ts":"1616201779.051400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vTR","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Blosc.set_compressor(\"lz4\")\n1\n\njulia> Blosc.compress(A; level = 9);"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU","reactions":[{"name":"julia","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"e122caaf-9b46-4015-a27a-99d9b83bb4dd","type":"message","text":"The problem is that python-blosc doesn't interact directly with Numpy so it has go through pickle:\n\n<http://python-blosc.blosc.org/tutorial.html#packaging-numpy-arrays>","user":"USU9FRPEU","ts":"1616201976.051700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jqjr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The problem is that python-blosc doesn't interact directly with Numpy so it has go through pickle:\n\n"},{"type":"link","url":"http://python-blosc.blosc.org/tutorial.html#packaging-numpy-arrays"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"4550c3c0-936d-4fd6-a05b-53b2a4c63afa","type":"message","text":"The easier way is go through numcodecs:\n<https://numcodecs.readthedocs.io/en/stable/blosc.html>\n```from numcodecs import Blosc\ncompressor = Blosc(cname = \"lz4\", clevel = 1, shuffle = 1, blocksize = 0)\ncompressor.encode(a)```","user":"USU9FRPEU","ts":"1616202075.051900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Voy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The easier way is go through numcodecs:\n"},{"type":"link","url":"https://numcodecs.readthedocs.io/en/stable/blosc.html"},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"from numcodecs import Blosc\ncompressor = Blosc(cname = \"lz4\", clevel = 1, shuffle = 1, blocksize = 0)\ncompressor.encode(a)"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"697abc57-90d4-40dc-a83c-2f0322795bd4","type":"message","text":"In retrospect, this is probably not too bad:\n```blosc.compress(a, typesize=a.dtype.itemsize, cname='lz4')```\nThe main issue is that Python doesn't really have a way of communicating type information.","user":"USU9FRPEU","ts":"1616222790.052400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9wMJ1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In retrospect, this is probably not too bad:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"blosc.compress(a, typesize=a.dtype.itemsize, cname='lz4')"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The main issue is that Python doesn't really have a way of communicating type information."}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"fa0d3f56-cb42-496c-b939-0f59da75b40d","type":"message","text":"It stood out to me that the Julia interface is stateful and the python one is not. (Do you find that you ever use different compressors in the same script? )","user":"U72B7LTMX","ts":"1616231135.052800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d3VC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It stood out to me that the Julia interface is stateful and the python one is not. (Do you find that you ever use different compressors in the same script? )"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"a9e0a4e6-365c-4a5d-9ba8-1a11f3b1ee55","type":"message","text":"Underneath the hood everything is using the same C API in c-blosc. <https://github.com/JuliaIO/Blosc.jl/blob/master/src/Blosc.jl#L26-L29>","user":"USU9FRPEU","ts":"1616252537.053100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R+Vx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Underneath the hood everything is using the same C API in c-blosc. "},{"type":"link","url":"https://github.com/JuliaIO/Blosc.jl/blob/master/src/Blosc.jl#L26-L29"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"adea50f7-262b-4674-bd31-91f49f84484d","type":"message","text":"Julia's advantage is multiple dispatch. It knows how to take specific kinds arrays and turn it into a pointer and figure out the size of the data type.","user":"USU9FRPEU","ts":"1616252705.053300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Mo6ZJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Julia's advantage is multiple dispatch. It knows how to take specific kinds arrays and turn it into a pointer and figure out the size of the data type."}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"},{"client_msg_id":"f1b411a2-0d7b-4595-95c4-ce45eb166a4d","type":"message","text":"We could and probably should build a stateful API via <https://github.com/JuliaIO/TranscodingStreams.jl>","user":"USU9FRPEU","ts":"1616252766.053500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ENGx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We could and probably should build a stateful API via "},{"type":"link","url":"https://github.com/JuliaIO/TranscodingStreams.jl"}]}]}],"thread_ts":"1616201430.050700","parent_user_id":"USU9FRPEU"}]