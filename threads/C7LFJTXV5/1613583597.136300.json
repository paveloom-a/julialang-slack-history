[{"client_msg_id":"051378ad-ae68-42c8-a9fe-a4b7a3819db0","type":"message","text":"Why does `destructure` not work on `NamedTuple` instances?","user":"UKA81L34J","ts":"1613583597.136300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F=h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why does "},{"type":"text","text":"destructure","style":{"code":true}},{"type":"text","text":" not work on "},{"type":"text","text":"NamedTuple","style":{"code":true}},{"type":"text","text":" instances?"}]}]}],"thread_ts":"1613583597.136300","reply_count":10,"reply_users_count":2,"latest_reply":"1613602984.151800","reply_users":["UH9KWTTD3","UKA81L34J"],"subscribed":false},{"client_msg_id":"4e1bc1d4-83a6-47e5-aae4-9403e5a57cc9","type":"message","text":"I believe cause Functors.jl treats `NamedTuple`s and `Tuple`s as leaf nodes in a structure","user":"UH9KWTTD3","ts":"1613584428.140000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sHc3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I believe cause Functors.jl treats `NamedTuple`s and `Tuple`s as leaf nodes in a structure"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"1e1535e5-794b-4c51-8ba5-26b569b4c96a","type":"message","text":"Or maybe you mean why does `destructure` not include `NamedTuple`s in the returned parameter vector?","user":"UH9KWTTD3","ts":"1613584582.140200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fZg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or maybe you mean why does "},{"type":"text","text":"destructure","style":{"code":true}},{"type":"text","text":" not include `NamedTuple`s in the returned parameter vector?"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"aec5405e-6b2d-4d97-8b92-ddce45edf1c0","type":"message","text":"no, the first comment","user":"UKA81L34J","ts":"1613584593.140400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HVY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no, the first comment"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"72a9542b-8842-4db8-a044-9c654ba527a6","type":"message","text":"I want to treat primitive number types as leaves. Maybe I’ll overload this and see what happens.","user":"UKA81L34J","ts":"1613584612.140600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RZ/k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want to treat primitive number types as leaves. Maybe I’ll overload this and see what happens."}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"cc23a418-d5ae-40b0-8877-fa48846a8e70","type":"message","text":"Yeah that seems like the right thing then","user":"UH9KWTTD3","ts":"1613584648.140800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BaoJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah that seems like the right thing then"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"e239e1b0-6247-460e-860f-eb0cb722531f","type":"message","text":"Though it still might not work for your example since Flux also does a check for `AbstractArray`: <https://github.com/FluxML/Flux.jl/blob/15a0ebfbf8446e913efdd0ce3fa2be26fbaaa080/src/utils.jl#L560>","user":"UH9KWTTD3","ts":"1613584691.141000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XZl2T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Though it still might not work for your example since Flux also does a check for "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":": "},{"type":"link","url":"https://github.com/FluxML/Flux.jl/blob/15a0ebfbf8446e913efdd0ce3fa2be26fbaaa080/src/utils.jl#L560"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"7fafc4be-df15-4e79-b967-2cab850644ca","type":"message","text":"How does that work when `m` is a `struct` ?","user":"UKA81L34J","ts":"1613584972.141400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3ri","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How does that work when "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":" is a "},{"type":"text","text":"struct","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"72b62d91-c279-4046-b33d-dbfba727ddde","type":"message","text":"It doesn’t hit that either right?","user":"UKA81L34J","ts":"1613584976.141600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"x3I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It doesn’t hit that either right?"}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"4F5EA8EA-FE14-4E84-8942-E038F200AD27","type":"message","text":"When `m` is a struct, it goes through each field in the struct and if that field is an `AbstractArray` then it stores it in the parameter vector. All fields that are not leaf nodes are further deconstructed.","user":"UH9KWTTD3","ts":"1613602593.151400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vMY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":" is a struct, it goes through each field in the struct and if that field is an "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" then it stores it in the parameter vector. All fields that are not leaf nodes are further deconstructed."}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"},{"client_msg_id":"b7e93538-7176-482e-8f1a-aeee818dfc44","type":"message","text":"It seems like `destructure` only considers `AbstractArray`s as nodes worth storing in `theta`. So you’d need to 1) make Functors.jl descend into `NamedTuple`s and 2) write your own `destructure` that stores a plain number into `theta` not just `AbstractArray`s.","user":"UH9KWTTD3","ts":"1613602984.151800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nD2i","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems like "},{"type":"text","text":"destructure","style":{"code":true}},{"type":"text","text":" only considers `AbstractArray`s as nodes worth storing in "},{"type":"text","text":"theta","style":{"code":true}},{"type":"text","text":". So you’d need to 1) make Functors.jl descend into `NamedTuple`s and 2) write your own "},{"type":"text","text":"destructure","style":{"code":true}},{"type":"text","text":" that stores a plain number into "},{"type":"text","text":"theta","style":{"code":true}},{"type":"text","text":" not just `AbstractArray`s."}]}]}],"thread_ts":"1613583597.136300","parent_user_id":"UKA81L34J"}]