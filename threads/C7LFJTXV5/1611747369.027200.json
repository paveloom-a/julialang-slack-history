[{"client_msg_id":"c8a62483-1a69-4b1b-9cf8-ec57280bf0c4","type":"message","text":"hi folks, a quick question out of curiosity: what kinds of compiler optimizations happen in flux in regards to the networks that get built? is there any tensor graph optimization happening? we are building a particularly unique general purpose customizable optimization package for Julia and the techniques we implemented fit really well for optimizing signal flow graphs. we are curious about what's already happening in Flux and we'd like to try applying those techniques to flux nets soon\\ :rocket:","user":"U01K2JB9GPJ","ts":"1611747369.027200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"997","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hi folks, a quick question out of curiosity: what kinds of compiler optimizations happen in flux in regards to the networks that get built? is there any tensor graph optimization happening? we are building a particularly unique general purpose customizable optimization package for Julia and the techniques we implemented fit really well for optimizing signal flow graphs. we are curious about what's already happening in Flux and we'd like to try applying those techniques to flux nets soon\\ "},{"type":"emoji","name":"rocket"}]}]}],"thread_ts":"1611747369.027200","reply_count":7,"reply_users_count":3,"latest_reply":"1611863691.030800","reply_users":["UC4QQPG4A","UDGT4PM41","UAUPJLBQX"],"subscribed":false},{"client_msg_id":"5b1988d3-66c3-4048-8280-eb031d69d387","type":"message","text":"Depends on what you're after. Zygote and irtools do some heavy inlining and optimisation around cfg.\n\nDiffractor would allow us to use typed IR so we can reasonably take this and apply more of Julia compiler optimisations directly to transforms. We also plan to do some higher level fusion using vectorisation tools in Julia.","user":"UC4QQPG4A","ts":"1611747804.027400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mhi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Depends on what you're after. Zygote and irtools do some heavy inlining and optimisation around cfg.\n\nDiffractor would allow us to use typed IR so we can reasonably take this and apply more of Julia compiler optimisations directly to transforms. We also plan to do some higher level fusion using vectorisation tools in Julia."}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"eca74341-acd4-4d35-bdf2-ad067c99b627","type":"message","text":"<@UC4QQPG4A> can you expand on the vectorization tools?","user":"UDGT4PM41","ts":"1611765648.027600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KF3","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UC4QQPG4A"},{"type":"text","text":" can you expand on the vectorization tools?"}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"9385edcf-4206-40fa-8c9f-d30da39f6e0a","type":"message","text":"Absolutely! Although I think <@UAUPJLBQX> would be best placed to answer that. We have been pushing for bringing a bunch of optimisations from faster activations and loop reordering etc","user":"UC4QQPG4A","ts":"1611826824.029200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YVp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Absolutely! Although I think "},{"type":"user","user_id":"UAUPJLBQX"},{"type":"text","text":" would be best placed to answer that. We have been pushing for bringing a bunch of optimisations from faster activations and loop reordering etc"}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"b79d55c1-5e26-49d1-afb5-eaf03105a7ef","type":"message","text":"We would be able to bring in much of the changes to vectorisation base inspired by wanting the faster kernels by default, including the changes to things like array layouts","user":"UC4QQPG4A","ts":"1611826896.029400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kln9d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We would be able to bring in much of the changes to vectorisation base inspired by wanting the faster kernels by default, including the changes to things like array layouts"}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"42976c3a-04e9-42e9-a91a-4e4ff5bdfb8e","type":"message","text":"Interesting, thanks. You mean into Julia base? Is this for CPU only ?","user":"UDGT4PM41","ts":"1611844585.029800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"N2N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Interesting, thanks. You mean into Julia base? Is this for CPU only ?"}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"8f2c9ef8-6359-43fe-bdcd-c17de8071cd9","type":"message","text":"<https://github.com/chriselrod/VectorizationBase.jl|VectorizationBase.jl> the library. It provides most of the low level tools <https://github.com/chriselrod/LoopVectorization.jl|LoopVectorization.jl> needs.\nCurrently it makes some very aggressive assumptions about loops, e.g. assuming total freedom to reorder loops even if it's provably invalid (e.g. `x[i] = y[i] + x[i-1]`).\nI'm slowly working on a major overhaul that will (a) fix that, (b) lift the current restriction to rectangular loop nests, (c) support some simple loop fusion, and (d) add the option to automatically use low-overhead threadpools to evaluate the loop nest with multiple threads.\n\nThis work is CPU only, unfortunately.","user":"UAUPJLBQX","ts":"1611856450.030400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AliWE","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/chriselrod/VectorizationBase.jl","text":"VectorizationBase.jl"},{"type":"text","text":" the library. It provides most of the low level tools "},{"type":"link","url":"https://github.com/chriselrod/LoopVectorization.jl","text":"LoopVectorization.jl"},{"type":"text","text":" needs.\nCurrently it makes some very aggressive assumptions about loops, e.g. assuming total freedom to reorder loops even if it's provably invalid (e.g. "},{"type":"text","text":"x[i] = y[i] + x[i-1]","style":{"code":true}},{"type":"text","text":").\nI'm slowly working on a major overhaul that will (a) fix that, (b) lift the current restriction to rectangular loop nests, (c) support some simple loop fusion, and (d) add the option to automatically use low-overhead threadpools to evaluate the loop nest with multiple threads.\n\nThis work is CPU only, unfortunately."}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"5c25bac7-0a6a-4aa2-b33b-75acdf4a72ab","type":"message","text":"gotcha, thanks!","user":"UDGT4PM41","ts":"1611863691.030800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nwv60","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"gotcha, thanks!"}]}]}],"thread_ts":"1611747369.027200","parent_user_id":"U01K2JB9GPJ"}]