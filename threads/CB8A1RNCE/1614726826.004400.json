[{"client_msg_id":"8c89d1f7-be44-4a37-8557-e46d4a235bb5","type":"message","text":"so static compilation either needs to have libjulia bound to it, or it needs to have no dynamic dispatching in order to ensure that it only hits the available methods.","user":"U69BL50BF","ts":"1614726826.004400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P8QMO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so static compilation either needs to have libjulia bound to it, or it needs to have no dynamic dispatching in order to ensure that it only hits the available methods."}]}]}],"thread_ts":"1614726826.004400","reply_count":13,"reply_users_count":2,"latest_reply":"1614788962.018200","reply_users":["U6A0PD8CR","U9MD78Z9N"],"subscribed":false},{"client_msg_id":"e24226fd-0cce-4d4c-8641-4c330e33966c","type":"message","text":"Once we split out the runtime from libjulia, you can still link to libjulia for runtime things like dynamic dispatch and tasks and such","user":"U6A0PD8CR","ts":"1614732343.011200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EzZbz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Once we split out the runtime from libjulia, you can still link to libjulia for runtime things like dynamic dispatch and tasks and such"}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"e75c9273-019b-46ff-b791-7d3da2e0665c","type":"message","text":"No one really wants truly static programs these days, anyway","user":"U6A0PD8CR","ts":"1614732356.011400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gVFz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No one really wants truly static programs these days, anyway"}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"e6415e81-e25f-47ba-a7db-42f0ff8270bc","type":"message","text":"<@U6A0PD8CR> I want truly static program preferably in LLVM IR so i can at some point in future turn high level Julia code into self contained binaries for embedded architectures.","user":"U9MD78Z9N","ts":"1614782193.016000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zfL","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6A0PD8CR"},{"type":"text","text":" I want truly static program preferably in LLVM IR so i can at some point in future turn high level Julia code into self contained binaries for embedded architectures."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"e92d9a6b-d528-4a05-a44a-d2a2ac9b9b97","type":"message","text":"What kind of embedded are you referring to? Note that cross-compilation isn't a thing right now.","user":"U6A0PD8CR","ts":"1614785461.016200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kch","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What kind of embedded are you referring to? Note that cross-compilation isn't a thing right now."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"68d53260-552e-4c86-be43-acd7cf9073dd","type":"message","text":"When I hear \"embedded\", I think microcontrollers, and potentially Linux-capable 32-bit ARM boards","user":"U6A0PD8CR","ts":"1614785489.016400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pvG0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When I hear \"embedded\", I think microcontrollers, and potentially Linux-capable 32-bit ARM boards"}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"2fde2ef0-5ae2-4e79-b85b-b2dd4f9b4f3c","type":"message","text":"Well in the ideal case:\n - There is an package which allows me to run fully static Julia code in which interacts with the emulation of the hardware which might interact with an model of the environment (for example an DiffEq model). (Emulating DAC's etc ...)\n - The code can be compiled for that hardware.\n - The targets would be anything from MMU full Linux ARM to baremetal Qualcomm Hexagon, baremetal AVR or any other architecture supported by LLVM.\n - The experience is similar to the one outlined in the JuliaCon talk some years ago where someone developed flight controller for blood bag delivery in Julia, except never touching C.","user":"U9MD78Z9N","ts":"1614788570.016600","team":"T68168MUP","edited":{"user":"U9MD78Z9N","ts":"1614788651.000000"},"blocks":[{"type":"rich_text","block_id":"Xfc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well in the ideal case:\n - There is an package which allows me to run fully static Julia code in which interacts with the emulation of the hardware which might interact with an model of the environment (for example an DiffEq model). (Emulating DAC's etc ...)\n - The code can be compiled for that hardware.\n - The targets would be anything from MMU full Linux ARM to baremetal Qualcomm Hexagon, baremetal AVR or any other architecture supported by LLVM.\n - The experience is similar to the one outlined in the JuliaCon talk some years ago where someone developed flight controller for blood bag delivery in Julia, except never touching C."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"76a0107f-237b-4cc6-af9b-95931bc04c7b","type":"message","text":"To do that with Julia, you'll probably want to add support for those targets to GPUCompiler","user":"U6A0PD8CR","ts":"1614788648.016900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HlXyF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To do that with Julia, you'll probably want to add support for those targets to GPUCompiler"}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"1f07eb13-f820-4059-bc8b-4f54cfdeb4a7","type":"message","text":"I have access to a variety of AVR and ARM chips, so I would be happy to test it out","user":"U6A0PD8CR","ts":"1614788669.017200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qhXbq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have access to a variety of AVR and ARM chips, so I would be happy to test it out"}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"be6103ad-3ac9-49f2-87a3-89380d95fba7","type":"message","text":"I will need that when i go industry. At my current pace i might need some years before finishing my bachelor's.","user":"U9MD78Z9N","ts":"1614788704.017400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/rrK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I will need that when i go industry. At my current pace i might need some years before finishing my bachelor's."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"1f8d6a3f-860b-4ef7-981e-c12d259eeb2d","type":"message","text":"It would be really good if you could also hook it up a decently cycle accurate simulator, write interrupt catching routines and have all that nicely abstracted behind AbstractCPU and AbstractPIC.","user":"U9MD78Z9N","ts":"1614788797.017600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F5A","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It would be really good if you could also hook it up a decently cycle accurate simulator, write interrupt catching routines and have all that nicely abstracted behind AbstractCPU and AbstractPIC."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"d3bd32ec-8464-481c-8f39-3555adf2b029","type":"message","text":"Probably use QEMU or similar for that","user":"U6A0PD8CR","ts":"1614788859.017800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mPAM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Probably use QEMU or similar for that"}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"fd3fe8d0-32a4-4500-a5ab-b9b23817f158","type":"message","text":"Yeah but it couldn't heard to keep that abstract too.","user":"U9MD78Z9N","ts":"1614788932.018000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qFPC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah but it couldn't heard to keep that abstract too."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"},{"client_msg_id":"13ce88e5-d379-42fd-8f3c-4c9a99162092","type":"message","text":"QEMU is rarely cycle accurate from what i understand.","user":"U9MD78Z9N","ts":"1614788962.018200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NoM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"QEMU is rarely cycle accurate from what i understand."}]}]}],"thread_ts":"1614726826.004400","parent_user_id":"U69BL50BF"}]