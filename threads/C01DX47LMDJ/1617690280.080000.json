[{"client_msg_id":"195d4993-26a6-4a87-9ed1-9fc305c83a9d","type":"message","text":"Coming back to the Rust/Julia error handling design: I've been thinking about it for some time (which I why I made ErrorTypes a few months back). Error handling is a pretty hard, but interesting design nut to crack with lots of options explored in various languages.\nIt seems clear to me that C's ordinary error codes, Go's system of dual return types, and Java's checked results are all bad solutions. That essentially leaves Python's exception/try mechanism, Rust's sum-types (i.e. Enums), and Julia's Union-types (i.e. `Union{Foo, Nothing}` ). They have different strengths:\n• Python's is easiest to deal with in simple circumstances (because you don't have to think about the return type), but try/catch can get very messy very quickly. It's also inefficient computationally. Probably the best design in a slow, expressive language without static checking\n• Rust's mechanism is the most elegant and robust. It's \"safe\", because sum types *must* be handled, but it also allows an escape hatch with `.unwrap()` when you're lazy. It has two drawbacks. First, it's cumbersome to write and constantly deal with unwrapping and wrapping results, it adds a little friction to development that would make it terrible in e.g. Python. Second, the fact that a `Option&lt;Foo&gt;` is *not* a Foo is also a big problem: It means that when an (internal or external) API has settled on returning a `Option&lt;Foo&gt;` , it can never just return a `Foo` , even in circumstances where that would be possible. So a person cannot \"strengthen their promise\" and gurantee a `Foo` , nor can they \"loosen their demands\" by suddenly accepting `Option&lt;Foo&gt;` where they required `Foo` before. Nor can the compiler decide to make that optimization and return a `Foo` when e.g. constant prop means that is possible.\n• Union types are in many cases the sweet spot. They're as easy as exceptions, as efficient as sum types, and allows broadening/narrowing on a special-case basis. The problem is that they aren't as safe as sum types. I think the ideal design would be Union types with opt-in static analysis, which we might get in Julia soon (JET.jl shows promise). Unfortunately, this design *needs* to be backed by a strong culture of handling the unions correctly. Currently in Julia, too much code doesn't handle their Unions, which causes static analysis of any code to be flooded with pointless error messages. I hope that will change, but it will take a coordinated explicit effort of the core designers to point in a direction and say \"this is where we all should be going\".","user":"U7HAYKY9X","ts":"1617690280.080000","team":"T68168MUP","edited":{"user":"U7HAYKY9X","ts":"1617690353.000000"},"blocks":[{"type":"rich_text","block_id":"B4j9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Coming back to the Rust/Julia error handling design: I've been thinking about it for some time (which I why I made ErrorTypes a few months back). Error handling is a pretty hard, but interesting design nut to crack with lots of options explored in various languages.\nIt seems clear to me that C's ordinary error codes, Go's system of dual return types, and Java's checked results are all bad solutions. That essentially leaves Python's exception/try mechanism, Rust's sum-types (i.e. Enums), and Julia's Union-types (i.e. "},{"type":"text","text":"Union{Foo, Nothing}","style":{"code":true}},{"type":"text","text":" ). They have different strengths:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Python's is easiest to deal with in simple circumstances (because you don't have to think about the return type), but try/catch can get very messy very quickly. It's also inefficient computationally. Probably the best design in a slow, expressive language without static checking"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Rust's mechanism is the most elegant and robust. It's \"safe\", because sum types "},{"type":"text","text":"must","style":{"bold":true}},{"type":"text","text":" be handled, but it also allows an escape hatch with "},{"type":"text","text":".unwrap()","style":{"code":true}},{"type":"text","text":" when you're lazy. It has two drawbacks. First, it's cumbersome to write and constantly deal with unwrapping and wrapping results, it adds a little friction to development that would make it terrible in e.g. Python. Second, the fact that a "},{"type":"text","text":"Option<Foo>","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"not","style":{"bold":true}},{"type":"text","text":" a Foo is also a big problem: It means that when an (internal or external) API has settled on returning a "},{"type":"text","text":"Option<Foo>","style":{"code":true}},{"type":"text","text":" , it can never just return a "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" , even in circumstances where that would be possible. So a person cannot \"strengthen their promise\" and gurantee a "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" , nor can they \"loosen their demands\" by suddenly accepting "},{"type":"text","text":"Option<Foo>","style":{"code":true}},{"type":"text","text":" where they required "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" before. Nor can the compiler decide to make that optimization and return a "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" when e.g. constant prop means that is possible."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Union types are in many cases the sweet spot. They're as easy as exceptions, as efficient as sum types, and allows broadening/narrowing on a special-case basis. The problem is that they aren't as safe as sum types. I think the ideal design would be Union types with opt-in static analysis, which we might get in Julia soon (JET.jl shows promise). Unfortunately, this design "},{"type":"text","text":"needs","style":{"bold":true}},{"type":"text","text":" to be backed by a strong culture of handling the unions correctly. Currently in Julia, too much code doesn't handle their Unions, which causes static analysis of any code to be flooded with pointless error messages. I hope that will change, but it will take a coordinated explicit effort of the core designers to point in a direction and say \"this is where we all should be going\"."}]}],"style":"bullet","indent":0}]}],"thread_ts":"1617690280.080000","reply_count":6,"reply_users_count":2,"latest_reply":"1617717622.081800","reply_users":["UPUBAM63X","UDSU53PEG"],"is_locked":false,"subscribed":false,"reactions":[{"name":"100","users":["UPUBAM63X","URVFJB60N","U011V2YN59N"],"count":3}]},{"client_msg_id":"df6e1388-dc46-47ab-a63f-2e02a96fad85","type":"message","text":"Thanks for sharing your overview. I pretty much agree with everything you've said here.  I didn't consider static analysis but now that you mention it - that is kind of where this leads unless theres something else I'm missing. Fun to think about.","user":"UPUBAM63X","ts":"1617709136.080400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kmp1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for sharing your overview. I pretty much agree with everything you've said here.  I didn't consider static analysis but now that you mention it - that is kind of where this leads unless theres something else I'm missing. Fun to think about."}]}]}],"thread_ts":"1617690280.080000","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"075bd7c1-d26f-4dcb-9513-f3777e25f0eb","type":"message","text":"`Option&lt;&amp;Foo&gt;` is for owning an `Option` that references its contents is maybe more clear though then you are responsible for properly handling references","user":"UDSU53PEG","ts":"1617717123.080800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ubLEw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Option<&Foo>","style":{"code":true}},{"type":"text","text":" is for owning an "},{"type":"text","text":"Option","style":{"code":true}},{"type":"text","text":" that references its contents is maybe more clear though then you are responsible for properly handling references"}]}]}],"thread_ts":"1617690280.080000","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"f1b46dd2-fcdb-4db9-885b-f796d54165cf","type":"message","text":"this is helpful in async you are often dealing with traits like`impl FnOnce(Option&lt;&amp;Foo&gt;) -&gt; Bar`","user":"UDSU53PEG","ts":"1617717224.081000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=P0p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"this is helpful in async you are often dealing with traits like"},{"type":"text","text":"impl FnOnce(Option<&Foo>) -> Bar","style":{"code":true}}]}]}],"thread_ts":"1617690280.080000","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"7ae4f818-5b15-4808-832a-ff733d2439cf","type":"message","text":"of course there is the nuclear option with `Option&lt;UnsafeCell&lt;Foo&gt;&gt;`where you can match on it *and* modify the inner `Foo`","user":"UDSU53PEG","ts":"1617717341.081200","team":"T68168MUP","edited":{"user":"UDSU53PEG","ts":"1617717351.000000"},"blocks":[{"type":"rich_text","block_id":"PwCa+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"of course there is the nuclear option with "},{"type":"text","text":"Option<UnsafeCell<Foo>>","style":{"code":true}},{"type":"text","text":"where you can match on it "},{"type":"text","text":"and","style":{"bold":true}},{"type":"text","text":" modify the inner "},{"type":"text","text":"Foo","style":{"code":true}}]}]}],"thread_ts":"1617690280.080000","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"309d31fe-2948-4180-af19-b8e071405608","type":"message","text":"there are more sane approaches: <https://docs.rs/futures/0.3.13/futures/task/enum.Poll.html#impl-2>","user":"UDSU53PEG","ts":"1617717487.081500","team":"T68168MUP","attachments":[{"title":"futures::task::Poll - Rust","title_link":"https://docs.rs/futures/0.3.13/futures/task/enum.Poll.html#impl-2","text":"Indicates whether a value is available or if the current task has been scheduled to receive a wakeup instead.","fallback":"futures::task::Poll - Rust","from_url":"https://docs.rs/futures/0.3.13/futures/task/enum.Poll.html#impl-2","service_name":"docs.rs","id":1,"original_url":"https://docs.rs/futures/0.3.13/futures/task/enum.Poll.html#impl-2"}],"blocks":[{"type":"rich_text","block_id":"X+g9/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there are more sane approaches: "},{"type":"link","url":"https://docs.rs/futures/0.3.13/futures/task/enum.Poll.html#impl-2"}]}]}],"thread_ts":"1617690280.080000","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"51d70119-d3d7-43ca-bde5-0c03926cad9a","type":"message","text":"so there you can work with the `Option` instead of `Poll` using `?`","user":"UDSU53PEG","ts":"1617717622.081800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"krE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so there you can work with the "},{"type":"text","text":"Option","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":"Poll","style":{"code":true}},{"type":"text","text":" using "},{"type":"text","text":"?","style":{"code":true}}]}]}],"thread_ts":"1617690280.080000","parent_user_id":"U7HAYKY9X"}]