[{"client_msg_id":"a97ce403-068d-4858-8843-cadca572fa51","type":"message","text":"Why would below snippet of code spend almost all of its time in GC ?\n`_const_ GJ = GeoJSON`\n`_const_ GI = GeoInterface`\n`@time Threads.@threads _for_ h _in_ highways`\n    `write(open(\"/home/data/osm_split/highways_\" * string(h[1]) * \".geojson\", \"w\"), GJ.write(GI.FeatureCollection(h[2])))`\n_`end`_\n\nTime:\n`8215.429909 seconds (835.49 M allocations: 67.452 GiB, 99.89% gc time)`","user":"U01GZQ6B0JU","ts":"1609265060.156100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Xa2Q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why would below snippet of code spend almost all of its time in GC ?\n"},{"type":"text","text":"const","style":{"italic":true,"code":true}},{"type":"text","text":" GJ = GeoJSON","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"const","style":{"italic":true,"code":true}},{"type":"text","text":" GI = GeoInterface","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"@time Threads.@threads ","style":{"code":true}},{"type":"text","text":"for","style":{"italic":true,"code":true}},{"type":"text","text":" h ","style":{"code":true}},{"type":"text","text":"in","style":{"italic":true,"code":true}},{"type":"text","text":" highways","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"    write(open(\"/home/data/osm_split/highways_\" * string(h[1]) * \".geojson\", \"w\"), GJ.write(GI.FeatureCollection(h[2])))","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"end","style":{"italic":true,"code":true}},{"type":"text","text":"\n\nTime:\n"},{"type":"text","text":"8215.429909 seconds (835.49 M allocations: 67.452 GiB, 99.89% gc time)","style":{"code":true}}]}]}],"thread_ts":"1609265060.156100","reply_count":10,"reply_users_count":2,"latest_reply":"1609361273.163600","reply_users":["U8D0QF5NZ","U01GZQ6B0JU"],"subscribed":false},{"client_msg_id":"b245fed6-5e16-426d-aba4-9671d95b87a5","type":"message","text":"What type is `h` here? It's not quite clear what this is doing, mainly reading and writing many GeoJSON files? That would probably generate quite some garbage already. Besides that neither GeoJSON.jl nor GeoInterface are currently optimized.  GeoInterface should get much better with <https://github.com/JuliaGeo/GeoInterface.jl/pull/33>. And GeoJSON will need some work once that is done anyway. We could take it more in the direction of <https://github.com/visr/GeoJSONTables.jl>. It's unregistered, but you could try it out, it's probably faster here.","user":"U8D0QF5NZ","ts":"1609267048.156200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MCUe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What type is "},{"type":"text","text":"h","style":{"code":true}},{"type":"text","text":" here? It's not quite clear what this is doing, mainly reading and writing many GeoJSON files? That would probably generate quite some garbage already. Besides that neither GeoJSON.jl nor GeoInterface are currently optimized.  GeoInterface should get much better with "},{"type":"link","url":"https://github.com/JuliaGeo/GeoInterface.jl/pull/33"},{"type":"text","text":". And GeoJSON will need some work once that is done anyway. We could take it more in the direction of "},{"type":"link","url":"https://github.com/visr/GeoJSONTables.jl"},{"type":"text","text":". It's unregistered, but you could try it out, it's probably faster here."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"15fd1f3e-0047-4f2c-bb03-4f1af02a460f","type":"message","text":"Besides that the usual put your code in a function, avoid globals advice from <https://docs.julialang.org/en/v1/manual/performance-tips/> may apply here :slightly_smiling_face:","user":"U8D0QF5NZ","ts":"1609267105.156400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cY9l3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Besides that the usual put your code in a function, avoid globals advice from "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/performance-tips/"},{"type":"text","text":" may apply here "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"cb49d2db-828d-4935-9cfd-7fb129a2215c","type":"message","text":"There are a few benchmarks in <https://github.com/JuliaGeo/GeoJSON.jl/pull/23> actually.","user":"U8D0QF5NZ","ts":"1609267477.156600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v+UR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are a few benchmarks in "},{"type":"link","url":"https://github.com/JuliaGeo/GeoJSON.jl/pull/23"},{"type":"text","text":" actually."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"d0589ade-a077-4442-9adc-c35128080cbe","type":"message","text":"h is pair of 2 element, first is the unint64 value, second is the array of GI.Feature,\nThe need is to split the map data (OSM) into small subregions\n\nI will wrap this in a function and see if the allocations reduces. I think I need to get used to wrapping chunks of code in functions. Are there any good tutorial which can help to get to this design thinking quickly ?","user":"U01GZQ6B0JU","ts":"1609310880.156900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Mu/aO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"h is pair of 2 element, first is the unint64 value, second is the array of GI.Feature,\nThe need is to split the map data (OSM) into small subregions\n\nI will wrap this in a function and see if the allocations reduces. I think I need to get used to wrapping chunks of code in functions. Are there any good tutorial which can help to get to this design thinking quickly ?"}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"f561d2ff-c9e1-4452-b161-be2d439188c9","type":"message","text":"Here are some more resources about writing performant Julia code: <http://www.stochasticlifestyle.com/7-julia-gotchas-handle/|http://www.stochasticlifestyle.com/7-julia-gotchas-handle/> and <https://mitmath.github.io/18337/#lecture-and-notes-2|https://mitmath.github.io/18337/#lecture-and-notes-2>","user":"U8D0QF5NZ","ts":"1609316708.157100","team":"T68168MUP","attachments":[{"service_name":"Stochastic Lifestyle","title":"7 Julia Gotchas and How to Handle Them - Stochastic Lifestyle","title_link":"http://www.stochasticlifestyle.com/7-julia-gotchas-handle/","text":"Let me start by saying Julia is a great language. I love the language, it is what I find to be the most powerful and intuitive language that I have ever used. It's undoubtedly my favorite language. That said, there are some \"gotchas\", tricky little things you need to know about. Every language has them, and one of the first things you have to do in order to master a language is to find out what they are and how to avoid them. The point of this blog post is to help accelerate this process for you by exposing some of the most common \"gotchas\" offering alternative programming practices. Julia is a good language for understanding what's going on because there's no magic. The Julia developers like to have clearly defined rules for how things act. This means that all behavior ... READ MORE","fallback":"Stochastic Lifestyle: 7 Julia Gotchas and How to Handle Them - Stochastic Lifestyle","thumb_url":"http://www.stochasticlifestyle.com/wp-content/themes/chrisrack/style/faviPic2.PNG","fields":[{"title":"Written by","value":"Christopher Rackauckas","short":true},{"title":"Est. reading time","value":"12 minutes","short":true}],"ts":1475542256,"from_url":"http://www.stochasticlifestyle.com/7-julia-gotchas-handle/","thumb_width":669,"thumb_height":891,"service_icon":"https://i2.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2016/01/cropped-faviPic.png?fit=180%2C180","id":1,"original_url":"http://www.stochasticlifestyle.com/7-julia-gotchas-handle/"},{"service_name":"18337","title":"18.337J/6.338J: Parallel Computing and Scientific Machine Learning","title_link":"https://mitmath.github.io/18337/#lecture-and-notes-2","text":"18.337 - Parallel Computing and Scientific Machine Learning","fallback":"18337: 18.337J/6.338J: Parallel Computing and Scientific Machine Learning","from_url":"https://mitmath.github.io/18337/#lecture-and-notes-2","id":2,"original_url":"https://mitmath.github.io/18337/#lecture-and-notes-2"}],"blocks":[{"type":"rich_text","block_id":"/qC9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here are some more resources about writing performant Julia code: "},{"type":"link","url":"http://www.stochasticlifestyle.com/7-julia-gotchas-handle/","text":"http://www.stochasticlifestyle.com/7-julia-gotchas-handle/"},{"type":"text","text":" and "},{"type":"link","url":"https://mitmath.github.io/18337/#lecture-and-notes-2","text":"https://mitmath.github.io/18337/#lecture-and-notes-2"}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"0ab2c9a4-dc7e-4554-98da-b12f55b9bcb5","type":"message","text":"<@U8D0QF5NZ> so I wrapped my whole code in `main` function which in turn is calling a set of functions. However the GC doesn’t seem to be dropping, is there a better way to deal with this problem?  I mean can opening up 96threads to parallel read/write cause so much of overhead? Is I/O throttled somewhere? I don’t see IO wait occurring either in the `iostat` , Also the cpu utilisation is also ~100% for each virtual core.\nWith my other code, I started disabling `GC.enable(false)`  and making manual calls to `GC.gc()` to clean up memory.","user":"U01GZQ6B0JU","ts":"1609331289.157400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YBhaz","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8D0QF5NZ"},{"type":"text","text":" so I wrapped my whole code in "},{"type":"text","text":"main","style":{"code":true}},{"type":"text","text":" function which in turn is calling a set of functions. However the GC doesn’t seem to be dropping, is there a better way to deal with this problem?  I mean can opening up 96threads to parallel read/write cause so much of overhead? Is I/O throttled somewhere? I don’t see IO wait occurring either in the "},{"type":"text","text":"iostat","style":{"code":true}},{"type":"text","text":" , Also the cpu utilisation is also ~100% for each virtual core.\nWith my other code, I started disabling "},{"type":"text","text":"GC.enable(false)","style":{"code":true}},{"type":"text","text":"  and making manual calls to "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" to clean up memory."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"cde5e29e-e2ca-4639-9199-a4396a39cdd2","type":"message","text":"Hmm so the GC is only in the case of using (many) threads? How does it perform on a single thread? I'm not very aware of the IO performance situation with many threads, I just found <https://github.com/JuliaLang/julia/issues/17118>. But I'd think this problem might be IO bound anyway, such that adding threading doesn't add much? Or perhaps the GeoJSON code is slow enough and allocates too much to be causing this. Have you tried GeoJSONTables.jl as well? Might be fun to play with if you can share the code snippet and data.","user":"U8D0QF5NZ","ts":"1609332232.157600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"upW8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm so the GC is only in the case of using (many) threads? How does it perform on a single thread? I'm not very aware of the IO performance situation with many threads, I just found "},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/17118"},{"type":"text","text":". But I'd think this problem might be IO bound anyway, such that adding threading doesn't add much? Or perhaps the GeoJSON code is slow enough and allocates too much to be causing this. Have you tried GeoJSONTables.jl as well? Might be fun to play with if you can share the code snippet and data."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"46c143a1-e098-42df-8c46-df116c52d415","type":"message","text":"<@U8D0QF5NZ> Haven’t tried the single thread performance, let me check that in REPL, but would surely like to get an opinion on the code, I have been practicing julia for over a few weeks now. I am messaging you the code as direct message.","user":"U01GZQ6B0JU","ts":"1609333175.157800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B3j/","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8D0QF5NZ"},{"type":"text","text":" Haven’t tried the single thread performance, let me check that in REPL, but would surely like to get an opinion on the code, I have been practicing julia for over a few weeks now. I am messaging you the code as direct message."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"c2e419b0-56d5-4731-b75a-29a410fc016a","type":"message","text":"In the small sample that I tested I inly got about 20% GC time. But I profiled the code and almost all time was spent in `JSON3.write`. `JSON.json` had similar performance. At first I thought all the size 2 Vectors that store points were to blame, so I replaced those by `SVector{2, Float64}` from StaticArrays. But this hardly helped. The problem instead seems to be the many nested dicts with type `Dict{String, Any}`. There are many many features, most are short linestrings. If you look at the example in <https://geojson.org/>, you see each of those features has 2 Dicts like that. Iterating over these Dicts, and not knowing what to expect (Any), seems to be the performance bottleneck.","user":"U8D0QF5NZ","ts":"1609361087.163400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lXK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In the small sample that I tested I inly got about 20% GC time. But I profiled the code and almost all time was spent in "},{"type":"text","text":"JSON3.write","style":{"code":true}},{"type":"text","text":". "},{"type":"text","text":"JSON.json","style":{"code":true}},{"type":"text","text":" had similar performance. At first I thought all the size 2 Vectors that store points were to blame, so I replaced those by "},{"type":"text","text":"SVector{2, Float64}","style":{"code":true}},{"type":"text","text":" from StaticArrays. But this hardly helped. The problem instead seems to be the many nested dicts with type "},{"type":"text","text":"Dict{String, Any}","style":{"code":true}},{"type":"text","text":". There are many many features, most are short linestrings. If you look at the example in "},{"type":"link","url":"https://geojson.org/"},{"type":"text","text":", you see each of those features has 2 Dicts like that. Iterating over these Dicts, and not knowing what to expect (Any), seems to be the performance bottleneck."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"},{"client_msg_id":"2cebcf4a-de67-4910-b9cc-717b55c51cff","type":"message","text":"We should be able to do better, encoding a geometry in a `Dict{String, Any}` is not very efficient. If we would put it in a struct and give JSON3 the information it needs to encode it, it will probably be much faster.","user":"U8D0QF5NZ","ts":"1609361273.163600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xb+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We should be able to do better, encoding a geometry in a "},{"type":"text","text":"Dict{String, Any}","style":{"code":true}},{"type":"text","text":" is not very efficient. If we would put it in a struct and give JSON3 the information it needs to encode it, it will probably be much faster."}]}]}],"thread_ts":"1609265060.156100","parent_user_id":"U01GZQ6B0JU"}]