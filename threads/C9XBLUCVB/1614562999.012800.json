[{"client_msg_id":"00c393c0-eef5-4e1b-b468-d4eff9947727","type":"message","text":"Are there mass-conserving smoothing packages out there? (I thought maybe this is a good question to ask here.)\n\n*More details*: I have a 3D array `s` that represents localized sources of some tracer in the ocean. That is, `s` is mostly zeros, with a only select few indices (locations on the global ocean) for which `s` is non-zero. I would like to smooth `s` in 3D (or just horizontally) in a way that conserves mass. That is, if I have an individual source \"pixel\" or \"grid cell\", surrounded by no other sources, where, e.g., `s == 1 kg  m⁻³ s⁻¹` , I would like to spread it across 1 cell in each direction, similarly to how you would apply a blurrying kernel to an image, but in such a way that after smoothing, the integrated source over these neighboring cells remains the same as for the original `s`. So a sort of mass-preserving blur.\n\nAdditional hurdle, because of the topography, `s` is also full of `NaN`s where there is land. The blur should take these `NaN`s into account, i.e., *not* propagate them, and ensure that if there is a neighboring `NaN` cell of a source cell (index `i`) that gets smoothed, then that `NaN` cell remains a `NaN` and whatever quantity it would have gotten from smoothing is attributed to the other, non-`NaN` nieghboring cells of the `i` cell.","user":"UB197FRCL","ts":"1614562999.012800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vipTR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Are there mass-conserving smoothing packages out there? (I thought maybe this is a good question to ask here.)\n\n"},{"type":"text","text":"More details","style":{"bold":true}},{"type":"text","text":": I have a 3D array "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":" that represents localized sources of some tracer in the ocean. That is, "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":" is mostly zeros, with a only select few indices (locations on the global ocean) for which "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":" is non-zero. I would like to smooth "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":" in 3D (or just horizontally) in a way that conserves mass. That is, if I have an individual source \"pixel\" or \"grid cell\", surrounded by no other sources, where, e.g., "},{"type":"text","text":"s == 1 kg  m⁻³ s⁻¹","style":{"code":true}},{"type":"text","text":" , I would like to spread it across 1 cell in each direction, similarly to how you would apply a blurrying kernel to an image, but in such a way that after smoothing, the integrated source over these neighboring cells remains the same as for the original "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":". So a sort of mass-preserving blur.\n\nAdditional hurdle, because of the topography, "},{"type":"text","text":"s","style":{"code":true}},{"type":"text","text":" is also full of "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":"s where there is land. The blur should take these "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":"s into account, i.e., "},{"type":"text","text":"not","style":{"bold":true}},{"type":"text","text":" propagate them, and ensure that if there is a neighboring "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":" cell of a source cell (index "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":") that gets smoothed, then that "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":" cell remains a "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":" and whatever quantity it would have gotten from smoothing is attributed to the other, non-"},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":" nieghboring cells of the "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":" cell."}]}]}],"thread_ts":"1614562999.012800","reply_count":6,"reply_users_count":2,"latest_reply":"1615209361.019000","reply_users":["UB197FRCL","U88813859"],"subscribed":false},{"client_msg_id":"d19154c5-ef40-48ca-9ed9-22f393cb084b","type":"message","text":"Sorry if unclear BTW, I'd be happy to elaborate/clarify anything :slightly_smiling_face:","user":"UB197FRCL","ts":"1614563021.012900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CPM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry if unclear BTW, I'd be happy to elaborate/clarify anything "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1614562999.012800","parent_user_id":"UB197FRCL"},{"client_msg_id":"d854ea4a-da7d-4beb-afb9-d695db7d08e6","type":"message","text":"My specific problem arises when simulating river sources of tracers to the ocean in one of the AIBECS.jl tutorials, where I get this noisy signal at the outlet of the Amazon river: <https://user-images.githubusercontent.com/4486578/109439430-609a6380-7a82-11eb-8965-e3d6cf8dede7.png> . Values should all be positive, all the red and alterning colors are numerical noises due to the fact that rivers are pointwise sources, and this needs to be corrected, so I'm thinking I'll just smooth the river sources for that, but I still want fine control on the magnitude of these sources, so mass conervation of the blurrying is important IMHO.","user":"UB197FRCL","ts":"1614563226.013100","team":"T68168MUP","attachments":[{"fallback":"1956x1506px image","image_url":"https://user-images.githubusercontent.com/4486578/109439430-609a6380-7a82-11eb-8965-e3d6cf8dede7.png","image_width":1956,"image_height":1506,"image_bytes":1530794,"from_url":"https://user-images.githubusercontent.com/4486578/109439430-609a6380-7a82-11eb-8965-e3d6cf8dede7.png","id":1,"original_url":"https://user-images.githubusercontent.com/4486578/109439430-609a6380-7a82-11eb-8965-e3d6cf8dede7.png"}],"blocks":[{"type":"rich_text","block_id":"HsG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My specific problem arises when simulating river sources of tracers to the ocean in one of the AIBECS.jl tutorials, where I get this noisy signal at the outlet of the Amazon river: "},{"type":"link","url":"https://user-images.githubusercontent.com/4486578/109439430-609a6380-7a82-11eb-8965-e3d6cf8dede7.png"},{"type":"text","text":" . Values should all be positive, all the red and alterning colors are numerical noises due to the fact that rivers are pointwise sources, and this needs to be corrected, so I'm thinking I'll just smooth the river sources for that, but I still want fine control on the magnitude of these sources, so mass conervation of the blurrying is important IMHO."}]}]}],"thread_ts":"1614562999.012800","parent_user_id":"UB197FRCL"},{"client_msg_id":"cba29d2f-31a3-4882-9df2-a56b315b330c","type":"message","text":"FWIW, my (w)hacky solution was to use ImageFiltering's Gaussian blurring kernels weights and then create an operator out of it (a sparse matrix `S` such that `S * x` is the smoothed `x`) and modify its columns to account for the mass lost to `NaN` cells.","user":"UB197FRCL","ts":"1614579003.013400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"c=5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"FWIW, my (w)hacky solution was to use ImageFiltering's Gaussian blurring kernels weights and then create an operator out of it (a sparse matrix "},{"type":"text","text":"S","style":{"code":true}},{"type":"text","text":" such that "},{"type":"text","text":"S * x","style":{"code":true}},{"type":"text","text":" is the smoothed "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":") and modify its columns to account for the mass lost to "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":" cells."}]}]}],"thread_ts":"1614562999.012800","parent_user_id":"UB197FRCL"},{"client_msg_id":"471df9d6-fb03-4306-9c30-c984254f59a2","type":"message","text":"This matrix was evidently called `smooth_operator` :slightly_smiling_face:","user":"UB197FRCL","ts":"1614579112.013600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+2LI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This matrix was evidently called "},{"type":"text","text":"smooth_operator","style":{"code":true}},{"type":"text","text":" "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1614562999.012800","parent_user_id":"UB197FRCL"},{"client_msg_id":"91c23a4f-90ca-461b-a151-adc6b27eaf83","type":"message","text":"I see you submitted your fix to the package itself, something I wanted to ask you after reading this (or at least make an issue for future reference). Kudos! :+1:","user":"U88813859","ts":"1615209247.018800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"V3iOQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see you submitted your fix to the package itself, something I wanted to ask you after reading this (or at least make an issue for future reference). Kudos! "},{"type":"emoji","name":"+1"}]}]}],"thread_ts":"1614562999.012800","parent_user_id":"UB197FRCL"},{"client_msg_id":"506abaa1-896a-4a81-b02e-ba924f4bbbf5","type":"message","text":"And now I also see you're the author of the package :sweat_smile:","user":"U88813859","ts":"1615209361.019000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cam","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And now I also see you're the author of the package "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1614562999.012800","parent_user_id":"UB197FRCL"}]