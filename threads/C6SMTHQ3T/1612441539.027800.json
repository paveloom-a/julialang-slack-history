[{"client_msg_id":"a6658344-fabb-45e9-8bb5-810356c9ef96","type":"message","text":"<@U8JAMQGQY> and I are looking for a solution to make PooledArrays and CategoricalArrays thread-safe, despite their using a `Dict` internally. Let's imagine one thread does only `Dict` lookups, and another one only adds new entries to it (without modifying existing ones). Is that OK, or does the addition of new entries leave the `Dict` in a temporarily invalid state that would make lookups from the other thread be incorrect? (Assuming that the table doesn't need to be resized for now.)","user":"U67431ELR","ts":"1612441539.027800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"53u","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" and I are looking for a solution to make PooledArrays and CategoricalArrays thread-safe, despite their using a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" internally. Let's imagine one thread does only "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" lookups, and another one only adds new entries to it (without modifying existing ones). Is that OK, or does the addition of new entries leave the "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" in a temporarily invalid state that would make lookups from the other thread be incorrect? (Assuming that the table doesn't need to be resized for now.)"}]}]}],"thread_ts":"1612441539.027800","reply_count":3,"reply_users_count":3,"latest_reply":"1612458736.028500","reply_users":["U8JAMQGQY","U681ELA87","U67431ELR"],"subscribed":false},{"client_msg_id":"2e4ec54c-41f8-4936-ae4d-a3dfa8101ab5","type":"message","text":"a broader context. Normally people write e.g.:\n```Threads.@threads for i in 1:length(x)\n    x[i] = i\nend```\nand if `x` is an `AbstractArray` assume that this operation is thread safe. In particular you can have such code in a generic package that does not know the type/soruce of `x`.\n\nFor PooledArrays.jl, as <@U67431ELR> noted the problem is that they internally store some information in a `Dict` that in such a thread can get corrupted. See <https://github.com/JuliaData/PooledArrays.jl/issues/55>","user":"U8JAMQGQY","ts":"1612441801.027900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fXK+8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"a broader context. Normally people write e.g.:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Threads.@threads for i in 1:length(x)\n    x[i] = i\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and if "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is an "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" assume that this operation is thread safe. In particular you can have such code in a generic package that does not know the type/soruce of "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":".\n\nFor PooledArrays.jl, as "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" noted the problem is that they internally store some information in a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" that in such a thread can get corrupted. See "},{"type":"link","url":"https://github.com/JuliaData/PooledArrays.jl/issues/55"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"5c8992f6-b7a1-4de0-b1fd-e878fb3a07df","type":"message","text":"We could add a `lock` field to PooledArray?","user":"U681ELA87","ts":"1612458678.028300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gUizF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We could add a "},{"type":"text","text":"lock","style":{"code":true}},{"type":"text","text":" field to PooledArray?"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"6678396e-28ee-4fa4-b046-75e1b57b3215","type":"message","text":"That would probably be OK to avoid conflicts when adding new values to the pool, but taking the lock each time we access invpool would prevent parallel `setindex!`.","user":"U67431ELR","ts":"1612458736.028500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uFK2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would probably be OK to avoid conflicts when adding new values to the pool, but taking the lock each time we access invpool would prevent parallel "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"}]