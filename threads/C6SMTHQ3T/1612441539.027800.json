[{"client_msg_id":"a6658344-fabb-45e9-8bb5-810356c9ef96","type":"message","text":"<@U8JAMQGQY> and I are looking for a solution to make PooledArrays and CategoricalArrays thread-safe, despite their using a `Dict` internally. Let's imagine one thread does only `Dict` lookups, and another one only adds new entries to it (without modifying existing ones). Is that OK, or does the addition of new entries leave the `Dict` in a temporarily invalid state that would make lookups from the other thread be incorrect? (Assuming that the table doesn't need to be resized for now.)","user":"U67431ELR","ts":"1612441539.027800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"53u","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" and I are looking for a solution to make PooledArrays and CategoricalArrays thread-safe, despite their using a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" internally. Let's imagine one thread does only "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" lookups, and another one only adds new entries to it (without modifying existing ones). Is that OK, or does the addition of new entries leave the "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" in a temporarily invalid state that would make lookups from the other thread be incorrect? (Assuming that the table doesn't need to be resized for now.)"}]}]}],"thread_ts":"1612441539.027800","reply_count":24,"reply_users_count":5,"latest_reply":"1612562466.043900","reply_users":["U8JAMQGQY","U681ELA87","U67431ELR","UP9P4JFNJ","UC7AF7NSU"],"subscribed":false},{"client_msg_id":"2e4ec54c-41f8-4936-ae4d-a3dfa8101ab5","type":"message","text":"a broader context. Normally people write e.g.:\n```Threads.@threads for i in 1:length(x)\n    x[i] = i\nend```\nand if `x` is an `AbstractArray` assume that this operation is thread safe. In particular you can have such code in a generic package that does not know the type/soruce of `x`.\n\nFor PooledArrays.jl, as <@U67431ELR> noted the problem is that they internally store some information in a `Dict` that in such a thread can get corrupted. See <https://github.com/JuliaData/PooledArrays.jl/issues/55>","user":"U8JAMQGQY","ts":"1612441801.027900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fXK+8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"a broader context. Normally people write e.g.:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Threads.@threads for i in 1:length(x)\n    x[i] = i\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and if "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is an "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" assume that this operation is thread safe. In particular you can have such code in a generic package that does not know the type/soruce of "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":".\n\nFor PooledArrays.jl, as "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" noted the problem is that they internally store some information in a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" that in such a thread can get corrupted. See "},{"type":"link","url":"https://github.com/JuliaData/PooledArrays.jl/issues/55"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"5c8992f6-b7a1-4de0-b1fd-e878fb3a07df","type":"message","text":"We could add a `lock` field to PooledArray?","user":"U681ELA87","ts":"1612458678.028300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gUizF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We could add a "},{"type":"text","text":"lock","style":{"code":true}},{"type":"text","text":" field to PooledArray?"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"6678396e-28ee-4fa4-b046-75e1b57b3215","type":"message","text":"That would probably be OK to avoid conflicts when adding new values to the pool, but taking the lock each time we access invpool would prevent parallel `setindex!`.","user":"U67431ELR","ts":"1612458736.028500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uFK2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would probably be OK to avoid conflicts when adding new values to the pool, but taking the lock each time we access invpool would prevent parallel "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"4ca77107-71dd-4c04-9e24-7792fa8d4000","type":"message","text":"You could write a task serving the Dict over a channel. I did a demonstration of that with <https://github.com/JuliaActors/Actors.jl|Actors.jl>, see: <https://juliaactors.github.io/Actors.jl/dev/actors/#dict-server|Dict Server>","user":"UP9P4JFNJ","ts":"1612462963.028700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8jO4d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could write a task serving the Dict over a channel. I did a demonstration of that with "},{"type":"link","url":"https://github.com/JuliaActors/Actors.jl","text":"Actors.jl"},{"type":"text","text":", see: "},{"type":"link","url":"https://juliaactors.github.io/Actors.jl/dev/actors/#dict-server","text":"Dict Server"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"55d12ff4-f357-4e03-9d75-db24024886e8","type":"message","text":"Won't that be quite slow? We need a dict lookup for each `setindex!` call.","user":"U67431ELR","ts":"1612462996.028900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wf/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Won't that be quite slow? We need a dict lookup for each "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" call."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"eb7cffb6-651a-438d-a3be-e643a0cabc8b","type":"message","text":"there is a channel communication back and forth for each Dict access","user":"UP9P4JFNJ","ts":"1612463119.029100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ycXG6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there is a channel communication back and forth for each Dict access"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"65c132db-0483-44a2-91fc-e875ef8aef9b","type":"message","text":"Our use case might be a bit special because the dict lookup is 100% of the work here, contrary to workflows that would perform some computation and store the result in a dict.","user":"U67431ELR","ts":"1612463135.029300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lkQq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Our use case might be a bit special because the dict lookup is 100% of the work here, contrary to workflows that would perform some computation and store the result in a dict."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"4f0fc3c8-1a52-4e0c-9f0a-0893d62007ad","type":"message","text":"I guess with channels it should not be slower than locks, but it is composable (it does not interfere with locks from users)","user":"UP9P4JFNJ","ts":"1612463561.029500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eTm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess with channels it should not be slower than locks, but it is composable (it does not interfere with locks from users)"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"bc985ba0-2cd4-41db-ac17-53437acc6937","type":"message","text":"Ideally we would find a way to avoid locks... In theory that should be possible since we never modify existing entries in the dict, we only add new ones. We could replace the dict atomically with a new one when needed. But I'm not sure that's possible to detect when that's the case with the `Dict` implementation.","user":"U67431ELR","ts":"1612463754.029700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QTmsM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ideally we would find a way to avoid locks... In theory that should be possible since we never modify existing entries in the dict, we only add new ones. We could replace the dict atomically with a new one when needed. But I'm not sure that's possible to detect when that's the case with the "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" implementation."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"dbd8dd9d-087d-4f23-be1b-475717f6ff0a","type":"message","text":"&gt;  We could add a `lock` field to PooledArray?\nLock should be on both `pool` and `invpool` that should be stored in a separate sub-object. (likie in CategoricalArrays.jl there is such object and probably similar thing needs to be done)","user":"U8JAMQGQY","ts":"1612472702.039500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YPWd","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" We could add a "},{"type":"text","text":"lock","style":{"code":true}},{"type":"text","text":" field to PooledArray?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Lock should be on both "},{"type":"text","text":"pool","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"invpool","style":{"code":true}},{"type":"text","text":" that should be stored in a separate sub-object. (likie in CategoricalArrays.jl there is such object and probably similar thing needs to be done)"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"df0fc440-da68-4559-aa7d-cb0bc1475675","type":"message","text":"I think the performance would be out of window if you use a lock. But I think it is a very interesting problem. Throwing two random thoughts...\n\n1. Is packed/dense representation of `.pool` a hard requirement? Can you get away with using a hash function that maps onto `eltype(refs)` with a secondary dictionary for resolving the collision? You can then split the array into chunks sharing `refs` but with independent pool/invpool. I think it might be possible to merge the pools with relatively low cost if the entries are \"sparse\" enough (no collisions, no resize). It'd be then probably possible to give a not-so-horrible interface with Referenceables.jl and FLoops.jl.\n\n2. What are the typical use cases of threaded `setindex!` in the first place? Maybe it's beneficial to come up with better threaded algorithms for them? Is it for constructing PooledArray? If it's just for construction, I'd guess a two-pass approach that construct a `Set` first would be way faster than using a lock.","user":"UC7AF7NSU","ts":"1612507430.041200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7YGZG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the performance would be out of window if you use a lock. But I think it is a very interesting problem. Throwing two random thoughts...\n\n1. Is packed/dense representation of "},{"type":"text","text":".pool","style":{"code":true}},{"type":"text","text":" a hard requirement? Can you get away with using a hash function that maps onto "},{"type":"text","text":"eltype(refs)","style":{"code":true}},{"type":"text","text":" with a secondary dictionary for resolving the collision? You can then split the array into chunks sharing "},{"type":"text","text":"refs","style":{"code":true}},{"type":"text","text":" but with independent pool/invpool. I think it might be possible to merge the pools with relatively low cost if the entries are \"sparse\" enough (no collisions, no resize). It'd be then probably possible to give a not-so-horrible interface with Referenceables.jl and FLoops.jl.\n\n2. What are the typical use cases of threaded "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" in the first place? Maybe it's beneficial to come up with better threaded algorithms for them? Is it for constructing PooledArray? If it's just for construction, I'd guess a two-pass approach that construct a "},{"type":"text","text":"Set","style":{"code":true}},{"type":"text","text":" first would be way faster than using a lock."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"3c620d72-4b99-40d0-9bc3-4ecb191cf909","type":"message","text":"Regarding 1, I'm not sure the dense representation `pool` is really a problem here (which is why I only mentioned `invpool`), since pushing entries to an array doesn't make it invalid at any point AFAIK: you can perfectly access previously valid entries from one threads while pushing from the other. Sometimes the array will have to be reallocated, but even in that case it's fine if one threads doesn't start reading from the new location immediately. (Note that it would be OK for us to take a lock when pushing new entries to the dict to avoid conflicting writes.) So I'm not sure the hash map approach you describe is really needed -- and anyway IIUC it would be quite slower than a simple vector `getindex` operation, and we really want to keep read accesses as fast as possible as they are more common than writes.","user":"U67431ELR","ts":"1612513863.041400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OHG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Regarding 1, I'm not sure the dense representation "},{"type":"text","text":"pool","style":{"code":true}},{"type":"text","text":" is really a problem here (which is why I only mentioned "},{"type":"text","text":"invpool","style":{"code":true}},{"type":"text","text":"), since pushing entries to an array doesn't make it invalid at any point AFAIK: you can perfectly access previously valid entries from one threads while pushing from the other. Sometimes the array will have to be reallocated, but even in that case it's fine if one threads doesn't start reading from the new location immediately. (Note that it would be OK for us to take a lock when pushing new entries to the dict to avoid conflicting writes.) So I'm not sure the hash map approach you describe is really needed -- and anyway IIUC it would be quite slower than a simple vector "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" operation, and we really want to keep read accesses as fast as possible as they are more common than writes."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"d60d4dd9-0476-4434-b56b-c93672c69a85","type":"message","text":"Regarding 2, our goal is not so much to tackle a particular use case, but rather to guarantee thread safety to users. Indeed we wanted to change `pa[indices]` to return a `PooledArray` sharing the pool with `pa` for performance. But in that case it means that if you read from and write to the two arrays from different threads bad things may happen, and that sounds quite dangerous to require users to keep track of which arrays share pools over their whole lifetime.","user":"U67431ELR","ts":"1612514027.041600","team":"T68168MUP","edited":{"user":"U67431ELR","ts":"1612514079.000000"},"blocks":[{"type":"rich_text","block_id":"tDjR0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Regarding 2, our goal is not so much to tackle a particular use case, but rather to guarantee thread safety to users. Indeed we wanted to change "},{"type":"text","text":"pa[indices]","style":{"code":true}},{"type":"text","text":" to return a "},{"type":"text","text":"PooledArray","style":{"code":true}},{"type":"text","text":" sharing the pool with "},{"type":"text","text":"pa","style":{"code":true}},{"type":"text","text":" for performance. But in that case it means that if you read from and write to the two arrays from different threads bad things may happen, and that sounds quite dangerous to require users to keep track of which arrays share pools over their whole lifetime."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"0fd5bdaa-442a-4d27-8d14-5b0f50d8ccda","type":"message","text":"&gt; pushing entries to an array doesn't make it invalid at any point\npush is not really a problem. The problem is that the value of `refs` depends on the history. My perspective is that fast parallel program requires breaking dependencies.\n\n&gt; Sometimes the array will have to be reallocated, but even in that case it's fine if one threads doesn't start reading from the new location immediately.\nI don't think it's true. `push!` in one thread and `getindex` in another is a race. Unless dereferencing head pointer and length are annotated with atomics, the compiler and CPU are technically allowed to reorder the operations. It's also possible for GC to kick in at any point (from Julia program's perspective).\n\n&gt; quite slower than a simple vector getindex operation\nYou are right. It'd be challenging to make it fast.\n\n&gt; our goal is not so much to tackle a particular use case, but rather to guarantee thread safety to users\nI don't think this is possible so I thought it might be better to change the perspective. It is quite normal that you need to rethink API when it comes to support parallelism. Of course, I'd love to be proven wrong.","user":"UC7AF7NSU","ts":"1612542423.041900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+uo","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"pushing entries to an array doesn't make it invalid at any point"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\npush is not really a problem. The problem is that the value of "},{"type":"text","text":"refs","style":{"code":true}},{"type":"text","text":" depends on the history. My perspective is that fast parallel program requires breaking dependencies.\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"Sometimes the array will have to be reallocated, but even in that case it's fine if one threads doesn't start reading from the new location immediately."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI don't think it's true. "},{"type":"text","text":"push!","style":{"code":true}},{"type":"text","text":" in one thread and "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" in another is a race. Unless dereferencing head pointer and length are annotated with atomics, the compiler and CPU are technically allowed to reorder the operations. It's also possible for GC to kick in at any point (from Julia program's perspective).\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"quite slower than a simple vector getindex operation"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nYou are right. It'd be challenging to make it fast.\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"our goal is not so much to tackle a particular use case, but rather to guarantee thread safety to users"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI don't think this is possible so I thought it might be better to change the perspective. It is quite normal that you need to rethink API when it comes to support parallelism. Of course, I'd love to be proven wrong."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"86c605df-8644-46be-8aaf-5b5828e6ba9b","type":"message","text":"&gt;  I don't think it's true. `push!` in one thread and `getindex`\n&gt;  in another is a race. Unless dereferencing head pointer and length are \n&gt; annotated with atomics, the compiler and CPU are technically allowed to \n&gt; reorder the operations. It's also possible for GC to kick in at any \n&gt; point (from Julia program's perspective).\nAs long as the array isn't resized, the head pointer doesn't change, right?","user":"U67431ELR","ts":"1612542715.042100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9FL","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" I don't think it's true. "},{"type":"text","text":"push!","style":{"code":true}},{"type":"text","text":" in one thread and "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":"\n in another is a race. Unless dereferencing head pointer and length are \nannotated with atomics, the compiler and CPU are technically allowed to \nreorder the operations. It's also possible for GC to kick in at any \npoint (from Julia program's perspective)."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"As long as the array isn't resized, the head pointer doesn't change, right?"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"45af9042-3b04-4f33-aaf1-a0561492dbbd","type":"message","text":"Yes, I think so. But it can be resized, right? (Unless you make sure that's not going to happen by `sizehint!`. But it's only a suggestion so that's an implementation-defined behavior.)","user":"UC7AF7NSU","ts":"1612544221.042300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J3t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, I think so. But it can be resized, right? (Unless you make sure that's not going to happen by "},{"type":"text","text":"sizehint!","style":{"code":true}},{"type":"text","text":". But it's only a suggestion so that's an implementation-defined behavior.)"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"f5cdc69c-20d8-4c9e-aa3f-455670a43574","type":"message","text":"Yes but ideally we'd be able to check whether it's going to be resized or not, and maybe replace the array with a larger one instead of pushing to it.","user":"U67431ELR","ts":"1612544351.042500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4on","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes but ideally we'd be able to check whether it's going to be resized or not, and maybe replace the array with a larger one instead of pushing to it."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"bf6fe12a-c512-4de1-979c-30699ab7c696","type":"message","text":"yeah, replacing the array would work, as long as you make sure that setting and _getting_ the array have well defined ordering","user":"UC7AF7NSU","ts":"1612547291.042700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UtR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, replacing the array would work, as long as you make sure that setting and "},{"type":"text","text":"getting","style":{"italic":true}},{"type":"text","text":" the array have well defined ordering"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"e4ad0eaa-a2c7-4abd-9572-a01cb874afc8","type":"message","text":"(which makes vanilla getindex slow)","user":"UC7AF7NSU","ts":"1612547340.042900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kzc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(which makes vanilla getindex slow)"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"60d68573-515e-427c-a992-1688057f3d61","type":"message","text":"Yeah, the tricky part would be to ensure that if the reading thread still sees the old pool, it stills sees the old refs, and that if it seems the new pool it also sees the new refs (changed by another thread). I'm not sure this can be guaranteed.","user":"U67431ELR","ts":"1612547503.043100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nak","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, the tricky part would be to ensure that if the reading thread still sees the old pool, it stills sees the old refs, and that if it seems the new pool it also sees the new refs (changed by another thread). I'm not sure this can be guaranteed."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"0e4beceb-57ee-4587-8479-fb4d72871c21","type":"message","text":"Though that's the strong version of thread safety. A weaker version would be that we assume the reading thread only has refs that existed in the old pool, so it doesn't care if the old or the new one is returned, as long as it's valid.","user":"U67431ELR","ts":"1612547604.043300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0th","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Though that's the strong version of thread safety. A weaker version would be that we assume the reading thread only has refs that existed in the old pool, so it doesn't care if the old or the new one is returned, as long as it's valid."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"e26bf73d-3bd7-4136-b58e-5761d1d8f27f","type":"message","text":"The weak version would at least allow working on separate parts of an array without corrupting it, or sharing the pool between multiple arrays.","user":"U67431ELR","ts":"1612547656.043500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wJNWP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The weak version would at least allow working on separate parts of an array without corrupting it, or sharing the pool between multiple arrays."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"8e5a2d75-4b4b-42ff-a0db-bd1124db0ae3","type":"message","text":"&gt; it stills sees the old refs\nI don't think it's possible since semantically Julia has to go through indirections for each getindex. If you swap some object without lock or atomics, then getting such object through some field of the struct is a race. `julia` might optimize things out but that does not mean the program is correct.\n\nMy general attitude is to *not* make the data structure thread-safe if I want to make it fast in parallel programs.","user":"UC7AF7NSU","ts":"1612551379.043700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CQr=4","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"it stills sees the old refs"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI don't think it's possible since semantically Julia has to go through indirections for each getindex. If you swap some object without lock or atomics, then getting such object through some field of the struct is a race. "},{"type":"text","text":"julia","style":{"code":true}},{"type":"text","text":" might optimize things out but that does not mean the program is correct.\n\nMy general attitude is to "},{"type":"text","text":"not","style":{"bold":true}},{"type":"text","text":" make the data structure thread-safe if I want to make it fast in parallel programs."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"bf00a350-3fb5-431f-8348-ad8ccb3e898b","type":"message","text":"The problem is that this means you can't take an `AbstractArray` object and assume you can split work on separate chunks of indices across threadsif `PooledArray` isn't thread-safe. And users may not even be aware that they got a `PooledArray` column in their data frame, e.g. if they read it using CSV.jl. :-/","user":"U67431ELR","ts":"1612562466.043900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ho/Kh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The problem is that this means you can't take an "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" object and assume you can split work on separate chunks of indices across threadsif "},{"type":"text","text":"PooledArray","style":{"code":true}},{"type":"text","text":" isn't thread-safe. And users may not even be aware that they got a "},{"type":"text","text":"PooledArray","style":{"code":true}},{"type":"text","text":" column in their data frame, e.g. if they read it using CSV.jl. :-/"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"}]