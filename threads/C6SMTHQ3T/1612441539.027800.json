[{"client_msg_id":"a6658344-fabb-45e9-8bb5-810356c9ef96","type":"message","text":"<@U8JAMQGQY> and I are looking for a solution to make PooledArrays and CategoricalArrays thread-safe, despite their using a `Dict` internally. Let's imagine one thread does only `Dict` lookups, and another one only adds new entries to it (without modifying existing ones). Is that OK, or does the addition of new entries leave the `Dict` in a temporarily invalid state that would make lookups from the other thread be incorrect? (Assuming that the table doesn't need to be resized for now.)","user":"U67431ELR","ts":"1612441539.027800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"53u","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" and I are looking for a solution to make PooledArrays and CategoricalArrays thread-safe, despite their using a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" internally. Let's imagine one thread does only "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" lookups, and another one only adds new entries to it (without modifying existing ones). Is that OK, or does the addition of new entries leave the "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" in a temporarily invalid state that would make lookups from the other thread be incorrect? (Assuming that the table doesn't need to be resized for now.)"}]}]}],"thread_ts":"1612441539.027800","reply_count":11,"reply_users_count":5,"latest_reply":"1612507430.041200","reply_users":["U8JAMQGQY","U681ELA87","U67431ELR","UP9P4JFNJ","UC7AF7NSU"],"subscribed":false},{"client_msg_id":"2e4ec54c-41f8-4936-ae4d-a3dfa8101ab5","type":"message","text":"a broader context. Normally people write e.g.:\n```Threads.@threads for i in 1:length(x)\n    x[i] = i\nend```\nand if `x` is an `AbstractArray` assume that this operation is thread safe. In particular you can have such code in a generic package that does not know the type/soruce of `x`.\n\nFor PooledArrays.jl, as <@U67431ELR> noted the problem is that they internally store some information in a `Dict` that in such a thread can get corrupted. See <https://github.com/JuliaData/PooledArrays.jl/issues/55>","user":"U8JAMQGQY","ts":"1612441801.027900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fXK+8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"a broader context. Normally people write e.g.:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Threads.@threads for i in 1:length(x)\n    x[i] = i\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and if "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is an "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" assume that this operation is thread safe. In particular you can have such code in a generic package that does not know the type/soruce of "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":".\n\nFor PooledArrays.jl, as "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" noted the problem is that they internally store some information in a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" that in such a thread can get corrupted. See "},{"type":"link","url":"https://github.com/JuliaData/PooledArrays.jl/issues/55"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"5c8992f6-b7a1-4de0-b1fd-e878fb3a07df","type":"message","text":"We could add a `lock` field to PooledArray?","user":"U681ELA87","ts":"1612458678.028300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gUizF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We could add a "},{"type":"text","text":"lock","style":{"code":true}},{"type":"text","text":" field to PooledArray?"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"6678396e-28ee-4fa4-b046-75e1b57b3215","type":"message","text":"That would probably be OK to avoid conflicts when adding new values to the pool, but taking the lock each time we access invpool would prevent parallel `setindex!`.","user":"U67431ELR","ts":"1612458736.028500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uFK2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would probably be OK to avoid conflicts when adding new values to the pool, but taking the lock each time we access invpool would prevent parallel "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"4ca77107-71dd-4c04-9e24-7792fa8d4000","type":"message","text":"You could write a task serving the Dict over a channel. I did a demonstration of that with <https://github.com/JuliaActors/Actors.jl|Actors.jl>, see: <https://juliaactors.github.io/Actors.jl/dev/actors/#dict-server|Dict Server>","user":"UP9P4JFNJ","ts":"1612462963.028700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8jO4d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could write a task serving the Dict over a channel. I did a demonstration of that with "},{"type":"link","url":"https://github.com/JuliaActors/Actors.jl","text":"Actors.jl"},{"type":"text","text":", see: "},{"type":"link","url":"https://juliaactors.github.io/Actors.jl/dev/actors/#dict-server","text":"Dict Server"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"55d12ff4-f357-4e03-9d75-db24024886e8","type":"message","text":"Won't that be quite slow? We need a dict lookup for each `setindex!` call.","user":"U67431ELR","ts":"1612462996.028900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wf/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Won't that be quite slow? We need a dict lookup for each "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" call."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"eb7cffb6-651a-438d-a3be-e643a0cabc8b","type":"message","text":"there is a channel communication back and forth for each Dict access","user":"UP9P4JFNJ","ts":"1612463119.029100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ycXG6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there is a channel communication back and forth for each Dict access"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"65c132db-0483-44a2-91fc-e875ef8aef9b","type":"message","text":"Our use case might be a bit special because the dict lookup is 100% of the work here, contrary to workflows that would perform some computation and store the result in a dict.","user":"U67431ELR","ts":"1612463135.029300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lkQq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Our use case might be a bit special because the dict lookup is 100% of the work here, contrary to workflows that would perform some computation and store the result in a dict."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"4f0fc3c8-1a52-4e0c-9f0a-0893d62007ad","type":"message","text":"I guess with channels it should not be slower than locks, but it is composable (it does not interfere with locks from users)","user":"UP9P4JFNJ","ts":"1612463561.029500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eTm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess with channels it should not be slower than locks, but it is composable (it does not interfere with locks from users)"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"bc985ba0-2cd4-41db-ac17-53437acc6937","type":"message","text":"Ideally we would find a way to avoid locks... In theory that should be possible since we never modify existing entries in the dict, we only add new ones. We could replace the dict atomically with a new one when needed. But I'm not sure that's possible to detect when that's the case with the `Dict` implementation.","user":"U67431ELR","ts":"1612463754.029700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QTmsM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ideally we would find a way to avoid locks... In theory that should be possible since we never modify existing entries in the dict, we only add new ones. We could replace the dict atomically with a new one when needed. But I'm not sure that's possible to detect when that's the case with the "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" implementation."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"dbd8dd9d-087d-4f23-be1b-475717f6ff0a","type":"message","text":"&gt;  We could add a `lock` field to PooledArray?\nLock should be on both `pool` and `invpool` that should be stored in a separate sub-object. (likie in CategoricalArrays.jl there is such object and probably similar thing needs to be done)","user":"U8JAMQGQY","ts":"1612472702.039500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YPWd","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" We could add a "},{"type":"text","text":"lock","style":{"code":true}},{"type":"text","text":" field to PooledArray?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Lock should be on both "},{"type":"text","text":"pool","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"invpool","style":{"code":true}},{"type":"text","text":" that should be stored in a separate sub-object. (likie in CategoricalArrays.jl there is such object and probably similar thing needs to be done)"}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"},{"client_msg_id":"df0fc440-da68-4559-aa7d-cb0bc1475675","type":"message","text":"I think the performance would be out of window if you use a lock. But I think it is a very interesting problem. Throwing two random thoughts...\n\n1. Is packed/dense representation of `.pool` a hard requirement? Can you get away with using a hash function that maps onto `eltype(refs)` with a secondary dictionary for resolving the collision? You can then split the array into chunks sharing `refs` but with independent pool/invpool. I think it might be possible to merge the pools with relatively low cost if the entries are \"sparse\" enough (no collisions, no resize). It'd be then probably possible to give a not-so-horrible interface with Referenceables.jl and FLoops.jl.\n\n2. What are the typical use cases of threaded `setindex!` in the first place? Maybe it's beneficial to come up with better threaded algorithms for them? Is it for constructing PooledArray? If it's just for construction, I'd guess a two-pass approach that construct a `Set` first would be way faster than using a lock.","user":"UC7AF7NSU","ts":"1612507430.041200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7YGZG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the performance would be out of window if you use a lock. But I think it is a very interesting problem. Throwing two random thoughts...\n\n1. Is packed/dense representation of "},{"type":"text","text":".pool","style":{"code":true}},{"type":"text","text":" a hard requirement? Can you get away with using a hash function that maps onto "},{"type":"text","text":"eltype(refs)","style":{"code":true}},{"type":"text","text":" with a secondary dictionary for resolving the collision? You can then split the array into chunks sharing "},{"type":"text","text":"refs","style":{"code":true}},{"type":"text","text":" but with independent pool/invpool. I think it might be possible to merge the pools with relatively low cost if the entries are \"sparse\" enough (no collisions, no resize). It'd be then probably possible to give a not-so-horrible interface with Referenceables.jl and FLoops.jl.\n\n2. What are the typical use cases of threaded "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" in the first place? Maybe it's beneficial to come up with better threaded algorithms for them? Is it for constructing PooledArray? If it's just for construction, I'd guess a two-pass approach that construct a "},{"type":"text","text":"Set","style":{"code":true}},{"type":"text","text":" first would be way faster than using a lock."}]}]}],"thread_ts":"1612441539.027800","parent_user_id":"U67431ELR"}]