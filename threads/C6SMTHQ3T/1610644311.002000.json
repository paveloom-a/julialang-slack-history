[{"client_msg_id":"ea002995-cabe-488f-bd29-79a44ac33d9d","type":"message","text":"<@U67431ELR> is working on adding multi-threading to DataFrames.jl. When testing his code I am hitting the following issue. It seems that when we run several operations that heavily allocate (only temporarily and small chunks of memory) we have the following situation:\n1. with no threading I never have a problem\n2. as I increase the number of threads it becomes possible that the Julia process gets Killed (on Linux) because it runs out of memory before GC happens (in single-threaded mode it is not a problem because we never allocate a lot of memory)\nIs there a way to work around this issue. (this is a working hypothesis about the reason, the sure thing is that I get \"Killed\" result)","user":"U8JAMQGQY","ts":"1610644311.002000","team":"T68168MUP","edited":{"user":"U8JAMQGQY","ts":"1610644539.000000"},"blocks":[{"type":"rich_text","block_id":"pKE","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" is working on adding multi-threading to DataFrames.jl. When testing his code I am hitting the following issue. It seems that when we run several operations that heavily allocate (only temporarily and small chunks of memory) we have the following situation:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"with no threading I never have a problem"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"as I increase the number of threads it becomes possible that the Julia process gets Killed (on Linux) because it runs out of memory before GC happens (in single-threaded mode it is not a problem because we never allocate a lot of memory)"}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a way to work around this issue. (this is a working hypothesis about the reason, the sure thing is that I get \"Killed\" result)"}]}]}],"thread_ts":"1610644311.002000","reply_count":10,"reply_users_count":2,"latest_reply":"1610647340.004400","reply_users":["U67431ELR","U8JAMQGQY"],"subscribed":false},{"client_msg_id":"794349e1-181a-4e0a-b61f-f9782057dc01","type":"message","text":"There's a mention of GC in the manual: <https://docs.julialang.org/en/v1/manual/multi-threading/#Caveats>","user":"U67431ELR","ts":"1610644866.002300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Fgp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There's a mention of GC in the manual: "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/multi-threading/#Caveats"}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"d20d89bc-9ce8-4efe-825c-3fa5bb2b9487","type":"message","text":"The problem might be that the `sum` task doesn't allocate anything so the GC isn't run until it's done.","user":"U67431ELR","ts":"1610645034.002500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w+Rh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The problem might be that the "},{"type":"text","text":"sum","style":{"code":true}},{"type":"text","text":" task doesn't allocate anything so the GC isn't run until it's done."}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"e6ba7a55-e740-44e9-9d90-013478a6048b","type":"message","text":"For testing you could add `GC.safepoint()`  calls in the `groupreduce` inner loop. In practice of course this will be too slow so we need another solution. In the worst case we could disable multithreading if some operations use the fast path (like sum) but others don't.","user":"U67431ELR","ts":"1610645111.002700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Qy5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For testing you could add "},{"type":"text","text":"GC.safepoint()","style":{"code":true}},{"type":"text","text":"  calls in the "},{"type":"text","text":"groupreduce","style":{"code":true}},{"type":"text","text":" inner loop. In practice of course this will be too slow so we need another solution. In the worst case we could disable multithreading if some operations use the fast path (like sum) but others don't."}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"2e3cc6b9-e7e3-40e1-b155-56d468d33e62","type":"message","text":"but it seems that only the \"fast path\" gets the benefit of multithreading","user":"U8JAMQGQY","ts":"1610645661.002900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ffq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but it seems that only the \"fast path\" gets the benefit of multithreading"}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"f84d504a-2f1c-46c2-b73d-7d4a5e6fd46c","type":"message","text":"When multiple operations use the fast path we could allow it.","user":"U67431ELR","ts":"1610645790.003100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EGAzc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When multiple operations use the fast path we could allow it."}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"e181dd91-e6dc-49c4-828d-aed651b97b93","type":"message","text":"Since the crash doesn't happen on Julia 1.6, do you think the problem has been fixed or just improved a bit (enough for your RAM)?","user":"U67431ELR","ts":"1610646026.003300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5RR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Since the crash doesn't happen on Julia 1.6, do you think the problem has been fixed or just improved a bit (enough for your RAM)?"}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"type":"message","subtype":"thread_broadcast","text":"I would assume it is improved a bit on 1.6 because of lower RAM usage. Actually I hope that in this thread someone who knows exactly (maybe you do) how and when GC gets invoked in multi-threaded code could comment so I could better understand this aspect of how Julia works.","user":"U8JAMQGQY","ts":"1610646432.003500","thread_ts":"1610644311.002000","root":{"client_msg_id":"ea002995-cabe-488f-bd29-79a44ac33d9d","type":"message","text":"<@U67431ELR> is working on adding multi-threading to DataFrames.jl. When testing his code I am hitting the following issue. It seems that when we run several operations that heavily allocate (only temporarily and small chunks of memory) we have the following situation:\n1. with no threading I never have a problem\n2. as I increase the number of threads it becomes possible that the Julia process gets Killed (on Linux) because it runs out of memory before GC happens (in single-threaded mode it is not a problem because we never allocate a lot of memory)\nIs there a way to work around this issue. (this is a working hypothesis about the reason, the sure thing is that I get \"Killed\" result)","user":"U8JAMQGQY","ts":"1610644311.002000","team":"T68168MUP","edited":{"user":"U8JAMQGQY","ts":"1610644539.000000"},"blocks":[{"type":"rich_text","block_id":"pKE","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" is working on adding multi-threading to DataFrames.jl. When testing his code I am hitting the following issue. It seems that when we run several operations that heavily allocate (only temporarily and small chunks of memory) we have the following situation:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"with no threading I never have a problem"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"as I increase the number of threads it becomes possible that the Julia process gets Killed (on Linux) because it runs out of memory before GC happens (in single-threaded mode it is not a problem because we never allocate a lot of memory)"}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a way to work around this issue. (this is a working hypothesis about the reason, the sure thing is that I get \"Killed\" result)"}]}]}],"thread_ts":"1610644311.002000","reply_count":10,"reply_users_count":2,"latest_reply":"1610647340.004400","reply_users":["U67431ELR","U8JAMQGQY"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"mad","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would assume it is improved a bit on 1.6 because of lower RAM usage. Actually I hope that in this thread someone who knows exactly (maybe you do) how and when GC gets invoked in multi-threaded code could comment so I could better understand this aspect of how Julia works."}]}]}],"client_msg_id":"35af4205-ac67-41bc-ae41-d3e62978aefa"},{"client_msg_id":"0ee20740-731d-4d16-bab9-333062a39ec4","type":"message","text":"I don't really understand when GC runs, apart from what `?GC.safepoint()` says. What's the maximal RAM use you see on 1.6 compared with 1.5?","user":"U67431ELR","ts":"1610646501.003800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/UXUu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't really understand when GC runs, apart from what `?GC.safepoint()` says. What's the maximal RAM use you see on 1.6 compared with 1.5?"}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"type":"message","text":"I cannot reproduce it exactly but see the screenshot. Both jumps of memory usage are caused by running the same function twice. It seems that GC is not invoked when they finish and a lot of small objects ready for GC stay in memory. And then when I run it third time (not always) if GC is not done in time it seems that Julia uses too much memory.","files":[{"id":"F01JXMCSZFE","created":1610646848,"timestamp":1610646848,"name":"image.png","title":"image.png","mimetype":"image/png","filetype":"png","pretty_type":"PNG","user":"U8JAMQGQY","editable":false,"size":36194,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01JXMCSZFE/image.png","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01JXMCSZFE/download/image.png","thumb_64":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_64.png","thumb_80":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_80.png","thumb_360":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_360.png","thumb_360_w":360,"thumb_360_h":135,"thumb_480":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_480.png","thumb_480_w":480,"thumb_480_h":180,"thumb_160":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_160.png","thumb_720":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_720.png","thumb_720_w":720,"thumb_720_h":270,"thumb_800":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_800.png","thumb_800_w":800,"thumb_800_h":300,"thumb_960":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_960.png","thumb_960_w":960,"thumb_960_h":360,"thumb_1024":"https://files.slack.com/files-tmb/T68168MUP-F01JXMCSZFE-2a027ffd18/image_1024.png","thumb_1024_w":1024,"thumb_1024_h":384,"original_w":1198,"original_h":449,"thumb_tiny":"AwARADCpRSYNGKAClpKMUALRSUUAOHSkpR0pKACgUUCgAooooA//2Q==","permalink":"https://julialang.slack.com/files/U8JAMQGQY/F01JXMCSZFE/image.png","permalink_public":"https://slack-files.com/T68168MUP-F01JXMCSZFE-e8115cd14a","is_starred":false,"has_rich_preview":false}],"upload":false,"blocks":[{"type":"rich_text","block_id":"P=6um","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I cannot reproduce it exactly but see the screenshot. Both jumps of memory usage are caused by running the same function twice. It seems that GC is not invoked when they finish and a lot of small objects ready for GC stay in memory. And then when I run it third time (not always) if GC is not done in time it seems that Julia uses too much memory."}]}]}],"user":"U8JAMQGQY","display_as_bot":false,"ts":"1610646992.004000","thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"eab459ac-fda4-4790-9228-d4fbd11c8fcd","type":"message","text":"OK so it's just a bit better...","user":"U67431ELR","ts":"1610647340.004400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hba+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OK so it's just a bit better..."}]}]}],"thread_ts":"1610644311.002000","parent_user_id":"U8JAMQGQY"}]