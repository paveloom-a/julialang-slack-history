[{"client_msg_id":"3a29e15e-e1dd-4359-969b-dd310a30fa69","type":"message","text":"Hi everyone!\n\nI'm interested in lock-free and wait-free datastructures, does anyone know about implementations/drafts/challenges/ideas in combination with julia? I'd be happy about any pointers (hehe). I'm aware of some basic capability in `Base.Threads`, but as far as I can tell that's only lock-based. Thank you very much!","user":"UH24GRBLL","ts":"1612772094.053600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qAtBv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi everyone!\n\nI'm interested in lock-free and wait-free datastructures, does anyone know about implementations/drafts/challenges/ideas in combination with julia? I'd be happy about any pointers (hehe). I'm aware of some basic capability in "},{"type":"text","text":"Base.Threads","style":{"code":true}},{"type":"text","text":", but as far as I can tell that's only lock-based. Thank you very much!"}]}]}],"thread_ts":"1612772094.053600","reply_count":15,"reply_users_count":3,"latest_reply":"1612791804.058100","reply_users":["UH24GRBLL","U01CQTKB86N","UB7JS9CHF"],"subscribed":false},{"client_msg_id":"e4c4c917-4c0f-4cd3-a798-ae0987d394a3","type":"message","text":"One thing I have been thinking about is how/if I'd have to interact with GC at all - I've read some references that say I wouldn't have to worry about it at all, since the GC takes care of when noone refers to an element anymore anyway.","user":"UH24GRBLL","ts":"1612772739.053700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0HsU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One thing I have been thinking about is how/if I'd have to interact with GC at all - I've read some references that say I wouldn't have to worry about it at all, since the GC takes care of when noone refers to an element anymore anyway."}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"AE168ABA-F2AF-40A5-B942-93980CEC3D70","type":"message","text":"What’s wait-free? If something is in a queue, it’s waiting.","user":"U01CQTKB86N","ts":"1612775584.054900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s4mJX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What’s wait-free? If something is in a queue, it’s waiting."}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"4e9facc6-6f1e-4b9b-942f-1993ab94132e","type":"message","text":"wait-free means that at any given step, all threads can make progress (or more formal, the number of steps a process has to take is bounded)","user":"UH24GRBLL","ts":"1612775654.055100","team":"T68168MUP","edited":{"user":"UH24GRBLL","ts":"1612776629.000000"},"blocks":[{"type":"rich_text","block_id":"dArJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"wait-free means that at any given step, all threads can make progress (or more formal, the number of steps a process has to take is bounded)"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"5eb018c1-d19e-4c6f-b9a9-cea5c3cfb933","type":"message","text":"it's more abstract than just \"does a queue have elements\"","user":"UH24GRBLL","ts":"1612775665.055300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LUWF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it's more abstract than just \"does a queue have elements\""}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"bbba949e-094f-46ab-953b-1e690ca48c6a","type":"message","text":"there's a basic disambiguation at <https://en.wikipedia.org/wiki/Non-blocking_algorithm>","user":"UH24GRBLL","ts":"1612775728.055600","team":"T68168MUP","attachments":[{"title":"Non-blocking algorithm","title_link":"https://en.wikipedia.org/wiki/Non-blocking_algorithm","from_url":"https://en.wikipedia.org/wiki/Non-blocking_algorithm","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"In computer science, an algorithm is called non-blocking if failure or suspension of any thread cannot cause failure or suspension of another thread;  for some operations, these algorithms provide a useful alternative to traditional blocking implementations. A non-blocking algorithm is lock-free if there is guaranteed system-wide progress, and wait-free if there is also guaranteed per-thread progress. \"Non-blocking\" was used as a synonym for \"lock-free\" in the literature until the introduction of obstruction-freedom in 2003.The word \"non-blocking\" was traditionally used to describe telecommunications networks that could route a connection through a set of relays \"without having to re-arrange existing calls\", see Clos network. Also, if the telephone exchange \"is not defective, it can always make the connection\", see nonblocking minimal spanning switch.","fallback":"wikipedia: Non-blocking algorithm","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/Non-blocking_algorithm"}],"blocks":[{"type":"rich_text","block_id":"WyHYj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there's a basic disambiguation at "},{"type":"link","url":"https://en.wikipedia.org/wiki/Non-blocking_algorithm"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"acac9153-c0ee-471f-8bc7-bc5635e9ceda","type":"message","text":"the concept is not really novel (first explored theoretically in the 80s, as basically all data structures are nowadays) but there has been a few interesting developments in the last 10 years and I thought it'd be interesting to look at a julia implementation for my final bachelors project","user":"UH24GRBLL","ts":"1612775787.055900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kln","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the concept is not really novel (first explored theoretically in the 80s, as basically all data structures are nowadays) but there has been a few interesting developments in the last 10 years and I thought it'd be interesting to look at a julia implementation for my final bachelors project"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"type":"message","subtype":"thread_broadcast","text":"In particular, I think I'd need atomic references, but Base.Threads only seems to have atomics for isbits number types like Bool, Ints, Floats..","user":"UH24GRBLL","ts":"1612777531.056200","thread_ts":"1612772094.053600","root":{"client_msg_id":"3a29e15e-e1dd-4359-969b-dd310a30fa69","type":"message","text":"Hi everyone!\n\nI'm interested in lock-free and wait-free datastructures, does anyone know about implementations/drafts/challenges/ideas in combination with julia? I'd be happy about any pointers (hehe). I'm aware of some basic capability in `Base.Threads`, but as far as I can tell that's only lock-based. Thank you very much!","user":"UH24GRBLL","ts":"1612772094.053600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qAtBv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi everyone!\n\nI'm interested in lock-free and wait-free datastructures, does anyone know about implementations/drafts/challenges/ideas in combination with julia? I'd be happy about any pointers (hehe). I'm aware of some basic capability in "},{"type":"text","text":"Base.Threads","style":{"code":true}},{"type":"text","text":", but as far as I can tell that's only lock-based. Thank you very much!"}]}]}],"thread_ts":"1612772094.053600","reply_count":15,"reply_users_count":3,"latest_reply":"1612791804.058100","reply_users":["UH24GRBLL","U01CQTKB86N","UB7JS9CHF"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"okd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In particular, I think I'd need atomic references, but Base.Threads only seems to have atomics for isbits number types like Bool, Ints, Floats.."}]}]}],"client_msg_id":"c983b452-55a9-4be7-b090-fb74576d2820"},{"client_msg_id":"9e8c9c16-d2dd-4ff1-90b0-b0d3aa2328a0","type":"message","text":"Would this be of any use? <https://github.com/JuliaDynamics/Agents.jl>","user":"U01CQTKB86N","ts":"1612782613.056500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9JQO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Would this be of any use? "},{"type":"link","url":"https://github.com/JuliaDynamics/Agents.jl"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"be611854-dd8b-4986-9095-bae0cfe971e1","type":"message","text":"Agents don’t appear to be what that Wikipedia article is talking about.","user":"U01CQTKB86N","ts":"1612783524.056700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3BlJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Agents don’t appear to be what that Wikipedia article is talking about."}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"15ffcf57-93cd-480b-a333-c2d93c8203d3","type":"message","text":"no :sweat_smile:","user":"UH24GRBLL","ts":"1612783627.056900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IPs4F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"ae8bfe4d-9822-4fb3-b63f-bb6dc9e3d1e6","type":"message","text":"This is much lower level :)","user":"UH24GRBLL","ts":"1612783639.057100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kqyuM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is much lower level :)"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"ef2a985b-0c5d-40ab-895a-dd4c80c9a2fa","type":"message","text":"For some of the algorithms, you need a double pointer size compare-and-swap instruction.  I’m not sure if Julia yet exposes that.","user":"UB7JS9CHF","ts":"1612791206.057500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RYHk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For some of the algorithms, you need a double pointer size compare-and-swap instruction.  I’m not sure if Julia yet exposes that."}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"0e07c4b8-60d5-4263-8d5e-a1033d5f2dce","type":"message","text":"I'm reading a paper right now that claims to be faster than those, haven't gotten to the pure algorithm yet","user":"UH24GRBLL","ts":"1612791380.057700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d+Hk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm reading a paper right now that claims to be faster than those, haven't gotten to the pure algorithm yet"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"04892237-56c0-4dfa-a712-cc9a01b5a385","type":"message","text":"or at least, have the wait-free version not be slower than the lock-free one","user":"UH24GRBLL","ts":"1612791775.057900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DVnlM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or at least, have the wait-free version not be slower than the lock-free one"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"},{"client_msg_id":"b6f62dde-1e13-4339-bfb0-2a3d4440f461","type":"message","text":"But yeah, the main blocker right now seems to be a lack of atomic references :thinking_face:","user":"UH24GRBLL","ts":"1612791804.058100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k2B4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But yeah, the main blocker right now seems to be a lack of atomic references "},{"type":"emoji","name":"thinking_face"}]}]}],"thread_ts":"1612772094.053600","parent_user_id":"UH24GRBLL"}]