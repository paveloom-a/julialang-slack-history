[{"client_msg_id":"21b1594a-c2e7-40d4-aed8-eefaa32fc431","type":"message","text":"I just opened a PR for \"teaching\" parallelism to the compiler <https://github.com/JuliaLang/julia/pull/39773>","user":"UC7AF7NSU","ts":"1613887980.000300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"etCG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just opened a PR for \"teaching\" parallelism to the compiler "},{"type":"link","url":"https://github.com/JuliaLang/julia/pull/39773"}]}]}],"thread_ts":"1613887980.000300","reply_count":12,"reply_users_count":2,"latest_reply":"1613896250.003900","reply_users":["UH24GRBLL","UC7AF7NSU"],"subscribed":false,"reactions":[{"name":"mind_blown","users":["UH8A351DJ","U681ELA87","UDGT4PM41","U8MPCDJAY","ULX78CTC3","U8T0YV7QC","U6QGE7S86"],"count":7},{"name":"rocket","users":["U8D9768Q6","U8MPCDJAY","UCZ7VBGUD","UBGJ599D3","UAUPJLBQX","U8T0YV7QC","U6QGE7S86"],"count":7},{"name":"100","users":["U8D9768Q6","U8MPCDJAY","U881D0W2C","U6QGE7S86"],"count":4},{"name":"sonic","users":["U01CQTKB86N","U8T0YV7QC","U6QGE7S86"],"count":3},{"name":"fast_parrot","users":["U01C3624SGJ","U8T0YV7QC","U6QGE7S86"],"count":3}]},{"client_msg_id":"ef4160b4-4e71-4417-84fa-6ddb0a495dcd","type":"message","text":"Very nice!","user":"UH24GRBLL","ts":"1613894372.001400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YmdU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Very nice!"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"c56aafbb-c686-4599-8b1d-91331fee1ae9","type":"message","text":"In the DCE example, couldn't the summation of `b` also be constant folded, since the range is not dynamically created?","user":"UH24GRBLL","ts":"1613894404.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Nj22I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In the DCE example, couldn't the summation of "},{"type":"text","text":"b","style":{"code":true}},{"type":"text","text":" also be constant folded, since the range is not dynamically created?"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"fe6495e4-5507-4cdf-93f3-040bc8774a77","type":"message","text":"yeah, I think LLVM does it. though I guess it can happen for the non-Tapir example.","user":"UC7AF7NSU","ts":"1613895341.001900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"khWL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, I think LLVM does it. though I guess it can happen for the non-Tapir example."}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"fbedd052-46c7-4708-bed2-2ce5409f48b4","type":"message","text":"but, the loop is not eliminated for some reason. you can see it in standard Julia, too\n\n```julia&gt; @inline function eliminatable_computation(xs)\n           a = typemax(UInt)\n           b = 0\n           for x in xs\n               a = (typemax(a) + a) ÷ ifelse(x == 0, 1, x)\n               b += x\n           end\n           return (a, b)\n       end\neliminatable_computation (generic function with 1 method)\n\njulia&gt; f() = eliminatable_computation(UInt(1):UInt(33554432))[2]\nf (generic function with 1 method)\n\njulia&gt; @code_llvm f()\n;  @ REPL[2]:1 within `f'\ndefine i64 @julia_f_163() {\ntop:\n; ┌ @ REPL[1]:4 within `eliminatable_computation'\n   br label %L27\n\nL27:                                              ; preds = %L41, %top\n   %value_phi = phi i64 [ 1, %top ], [ %2, %L41 ]\n   %0 = phi i1 [ true, %top ], [ false, %L41 ]\n   %1 = phi i1 [ false, %top ], [ true, %L41 ]\n; └\n; ┌ @ REPL[1]:6 within `eliminatable_computation'\n   %brmerge = or i1 %0, %1\n   br i1 %brmerge, label %L41, label %L39\n\nL39:                                              ; preds = %L27\n   call void @jl_throw({}* inttoptr (i64 140655315119536 to {}*))\n   unreachable\n\nL41:                                              ; preds = %L27\n; │┌ @ range.jl:740 within `iterate'\n; ││┌ @ promotion.jl:409 within `=='\n     %.not24.not = icmp eq i64 %value_phi, 33554432\n; ││└\n    %2 = add nuw nsw i64 %value_phi, 1\n; │└\n   br i1 %.not24.not, label %L47.L53_crit_edge, label %L27\n\nL47.L53_crit_edge:                                ; preds = %L41\n; └\n  ret i64 562949970198528\n}```\nI wonder if it's because LLVM doesn't know `(true or false) or (false or true)` is `true`?","user":"UC7AF7NSU","ts":"1613895357.002100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2=8a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but, the loop is not eliminated for some reason. you can see it in standard Julia, too\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @inline function eliminatable_computation(xs)\n           a = typemax(UInt)\n           b = 0\n           for x in xs\n               a = (typemax(a) + a) ÷ ifelse(x == 0, 1, x)\n               b += x\n           end\n           return (a, b)\n       end\neliminatable_computation (generic function with 1 method)\n\njulia> f() = eliminatable_computation(UInt(1):UInt(33554432))[2]\nf (generic function with 1 method)\n\njulia> @code_llvm f()\n;  @ REPL[2]:1 within `f'\ndefine i64 @julia_f_163() {\ntop:\n; ┌ @ REPL[1]:4 within `eliminatable_computation'\n   br label %L27\n\nL27:                                              ; preds = %L41, %top\n   %value_phi = phi i64 [ 1, %top ], [ %2, %L41 ]\n   %0 = phi i1 [ true, %top ], [ false, %L41 ]\n   %1 = phi i1 [ false, %top ], [ true, %L41 ]\n; └\n; ┌ @ REPL[1]:6 within `eliminatable_computation'\n   %brmerge = or i1 %0, %1\n   br i1 %brmerge, label %L41, label %L39\n\nL39:                                              ; preds = %L27\n   call void @jl_throw({}* inttoptr (i64 140655315119536 to {}*))\n   unreachable\n\nL41:                                              ; preds = %L27\n; │┌ @ range.jl:740 within `iterate'\n; ││┌ @ promotion.jl:409 within `=='\n     %.not24.not = icmp eq i64 %value_phi, 33554432\n; ││└\n    %2 = add nuw nsw i64 %value_phi, 1\n; │└\n   br i1 %.not24.not, label %L47.L53_crit_edge, label %L27\n\nL47.L53_crit_edge:                                ; preds = %L41\n; └\n  ret i64 562949970198528\n}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI wonder if it's because LLVM doesn't know "},{"type":"text","text":"(true or false) or (false or true)","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"true","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"fc727dbe-9cee-4285-8f77-ce7b59588dba","type":"message","text":"...or maybe because I used UInt?","user":"UC7AF7NSU","ts":"1613895386.002300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7daw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"...or maybe because I used UInt?"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"928b2e7a-5c13-4050-93bb-068f3b26a4e1","type":"message","text":"I'm not sure either","user":"UH24GRBLL","ts":"1613895393.002500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aW1q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure either"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"7d1d659a-f379-4845-962f-034423853da1","type":"message","text":"`a` should be eliminated because of DCE, and `b` is just a simple summation over a constant, which it should also be able to constant fold","user":"UH24GRBLL","ts":"1613895420.002700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dSYHE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" should be eliminated because of DCE, and "},{"type":"text","text":"b","style":{"code":true}},{"type":"text","text":" is just a simple summation over a constant, which it should also be able to constant fold"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"f99e3b10-0804-40f0-b3eb-ce6f48e21d8a","type":"message","text":"I was initially confused because I've seen it eliminate such summations of constants - they don't take 30ms anymore like in the benchmark","user":"UH24GRBLL","ts":"1613895465.002900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lfvw3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was initially confused because I've seen it eliminate such summations of constants - they don't take 30ms anymore like in the benchmark"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"9dae4037-3b5f-4447-8f86-68acb582489c","type":"message","text":"still, allowing us to think about \"wait why is this optimization not applied\" at all is amazing!","user":"UH24GRBLL","ts":"1613895485.003100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8a68","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"still, allowing us to think about \"wait why is this optimization not applied\" at all is amazing!"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"1d442058-9ecf-4a97-a776-bf778e6558a4","type":"message","text":"As I understand it, without Tapir the answer would basically be \"because of parallelism\"","user":"UH24GRBLL","ts":"1613895504.003300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8vVg+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As I understand it, without Tapir the answer would basically be \"because of parallelism\""}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"3ae10202-766b-4746-955c-c04473ef7531","type":"message","text":"there's also a task spawn/wait cost (thought that's much smaller than 30ms). in principle, when everything is const-folded in a task, we should eliminate task spawn. but, since const fold happens at LLVM level, we need to do the task lowering _after_ a LLVM pass did the fold.","user":"UC7AF7NSU","ts":"1613896150.003500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j9LnZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there's also a task spawn/wait cost (thought that's much smaller than 30ms). in principle, when everything is const-folded in a task, we should eliminate task spawn. but, since const fold happens at LLVM level, we need to do the task lowering "},{"type":"text","text":"after","style":{"italic":true}},{"type":"text","text":" a LLVM pass did the fold."}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"092129a1-83ad-403d-ad93-8d1776f2c1e2","type":"message","text":"right - judging by the `julia -t 1` benchmark from your PR, the overhead may be more on the scale of 0.3-0.4ms","user":"UH24GRBLL","ts":"1613896250.003900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZYhcF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"right - judging by the "},{"type":"text","text":"julia -t 1","style":{"code":true}},{"type":"text","text":" benchmark from your PR, the overhead may be more on the scale of 0.3-0.4ms"}]}]}],"thread_ts":"1613887980.000300","parent_user_id":"UC7AF7NSU"}]