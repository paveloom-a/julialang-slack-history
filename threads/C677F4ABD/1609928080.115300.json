[{"client_msg_id":"102e9e50-9b82-4687-8e1f-aabc9f5ae498","type":"message","text":"Question: if I were to extend `LinearAlgebra.diag` for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?","user":"U014LRLJXRP","ts":"1609928080.115300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"E8G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Question: if I were to extend "},{"type":"text","text":"LinearAlgebra.diag","style":{"code":true}},{"type":"text","text":" for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?"}]}]}],"thread_ts":"1609928080.115300","reply_count":6,"reply_users_count":2,"latest_reply":"1609932413.116600","reply_users":["U014LRLJXRP","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"0f6ae558-271a-4006-97ab-c0e31ab0201d","type":"message","text":"An implementation of the former would be something like this (I wrote the self-evident `allequal` function, but it’s trivial so I won’t put it here):\n```function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]```\nI don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯.","user":"U014LRLJXRP","ts":"1609928226.115400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tZE+O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"An implementation of the former would be something like this (I wrote the self-evident "},{"type":"text","text":"allequal","style":{"code":true}},{"type":"text","text":" function, but it’s trivial so I won’t put it here):\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"e9a67a22-ddd0-4927-b686-560106208aa8","type":"message","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n```julia&gt; x = reshape(1:3^3,3,3,3);\n\njulia&gt; @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia&gt; @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27```","user":"UD0NS8PDF","ts":"1609928795.115600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9+4j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> x = reshape(1:3^3,3,3,3);\n\njulia> @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia> @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"64c000dd-0a5e-4007-9784-9d2dfa9d532e","type":"message","text":"Oh, that’s a clever way to do that.  I can’t immediately think of a better way to do the latter solution, so `@einsum` is very good, thank you.  I have seen Einsum.jl from your Tillio.jl package.  The only problem is that I don’t know very much about multilinear algebra, so I will have to have a read…  Any resources you suggest?\n\nRegarding the `@einsum` method for the first method, here are benchmarking results on my computer:\n```julia&gt; @btime @einsum y[i] := x[i,i,i]\n  2.017 μs (12 allocations: 656 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27\n\njulia&gt; @btime y = diag(x)\n  192.694 ns (3 allocations: 304 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27```\nIs there any benefit to using `@einsum` over my `diag` adaptation?  (I suspect `@einsum` is more robust…).","user":"U014LRLJXRP","ts":"1609931577.115800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6lIu/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, that’s a clever way to do that.  I can’t immediately think of a better way to do the latter solution, so "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is very good, thank you.  I have seen Einsum.jl from your Tillio.jl package.  The only problem is that I don’t know very much about multilinear algebra, so I will have to have a read…  Any resources you suggest?\n\nRegarding the "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" method for the first method, here are benchmarking results on my computer:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime @einsum y[i] := x[i,i,i]\n  2.017 μs (12 allocations: 656 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27\n\njulia> @btime y = diag(x)\n  192.694 ns (3 allocations: 304 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there any benefit to using "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" over my "},{"type":"text","text":"diag","style":{"code":true}},{"type":"text","text":" adaptation?  (I suspect "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is more robust…)."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"430c0bfc-74f5-46fa-8a68-6e9abdcf9dd7","type":"message","text":"The only thing that might be hard to do is generalise the `@einsum` methods to higher dimensions.  Can you think of a way, instead of hard coding, `[i, i, k]`, for instance?","user":"U014LRLJXRP","ts":"1609931649.116000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kkc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The only thing that might be hard to do is generalise the "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" methods to higher dimensions.  Can you think of a way, instead of hard coding, "},{"type":"text","text":"[i, i, k]","style":{"code":true}},{"type":"text","text":", for instance?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"13eea792-0af1-43e8-9848-131ce91dc99f","type":"message","text":"<@UD0NS8PDF> the other thing I was told to use `@tullio` for was for matrix multiplication of arbitrary dimension.  But again, I think it might be difficult to generalise this method (see above).  Can you think of a way?  Thank you :slightly_smiling_face:","user":"U014LRLJXRP","ts":"1609931945.116400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f2v","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" the other thing I was told to use "},{"type":"text","text":"@tullio","style":{"code":true}},{"type":"text","text":" for was for matrix multiplication of arbitrary dimension.  But again, I think it might be difficult to generalise this method (see above).  Can you think of a way?  Thank you "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"6e7afd24-5f21-4d18-b883-71e7dc0307ed","type":"message","text":"Re times, Einsum is just a simple loop, should not have much overhead:\n```julia&gt; @btime diag(x)  setup=(x=randn(5,5));\n  52.351 ns (1 allocation: 128 bytes)\n\njulia&gt; @btime @einsum(y[i] := x[i,i])  setup=(x=randn(5,5));\n  36.270 ns (1 allocation: 128 bytes)```\nIt is possible to wrap that into a function, something like this:\n```julia&gt; @generated function alldiag(x::AbstractArray)\n       is =  [:i for _ in 1:ndims(x)]\n       :( @einsum y[i] := x[$(is...)] )\n       end;\n\njulia&gt; alldiag(x)\n3-element Vector{Int64}:\n  1\n 14\n 27```\nalthough honestly there will be better ways — the point of using `@einsum` is for such things more that it will be obvious to your future self which particular diagonal you are extracting, rather than trying to remember what some `mydiag(x, dims=(1,2))` means.","user":"UD0NS8PDF","ts":"1609932413.116600","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1609932445.000000"},"blocks":[{"type":"rich_text","block_id":"pIF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Re times, Einsum is just a simple loop, should not have much overhead:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime diag(x)  setup=(x=randn(5,5));\n  52.351 ns (1 allocation: 128 bytes)\n\njulia> @btime @einsum(y[i] := x[i,i])  setup=(x=randn(5,5));\n  36.270 ns (1 allocation: 128 bytes)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It is possible to wrap that into a function, something like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @generated function alldiag(x::AbstractArray)\n       is =  [:i for _ in 1:ndims(x)]\n       :( @einsum y[i] := x[$(is...)] )\n       end;\n\njulia> alldiag(x)\n3-element Vector{Int64}:\n  1\n 14\n 27"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"although honestly there will be better ways — the point of using "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is for such things more that it will be obvious to your future self which particular diagonal you are extracting, rather than trying to remember what some "},{"type":"text","text":"mydiag(x, dims=(1,2))","style":{"code":true}},{"type":"text","text":" means."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"}]