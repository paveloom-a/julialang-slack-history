[{"client_msg_id":"102e9e50-9b82-4687-8e1f-aabc9f5ae498","type":"message","text":"Question: if I were to extend `LinearAlgebra.diag` for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?","user":"U014LRLJXRP","ts":"1609928080.115300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"E8G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Question: if I were to extend "},{"type":"text","text":"LinearAlgebra.diag","style":{"code":true}},{"type":"text","text":" for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?"}]}]}],"thread_ts":"1609928080.115300","reply_count":32,"reply_users_count":2,"latest_reply":"1609975228.129600","reply_users":["U014LRLJXRP","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"0f6ae558-271a-4006-97ab-c0e31ab0201d","type":"message","text":"An implementation of the former would be something like this (I wrote the self-evident `allequal` function, but it’s trivial so I won’t put it here):\n```function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]```\nI don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯.","user":"U014LRLJXRP","ts":"1609928226.115400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tZE+O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"An implementation of the former would be something like this (I wrote the self-evident "},{"type":"text","text":"allequal","style":{"code":true}},{"type":"text","text":" function, but it’s trivial so I won’t put it here):\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"e9a67a22-ddd0-4927-b686-560106208aa8","type":"message","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n```julia&gt; x = reshape(1:3^3,3,3,3);\n\njulia&gt; @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia&gt; @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27```","user":"UD0NS8PDF","ts":"1609928795.115600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9+4j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> x = reshape(1:3^3,3,3,3);\n\njulia> @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia> @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"64c000dd-0a5e-4007-9784-9d2dfa9d532e","type":"message","text":"Oh, that’s a clever way to do that.  I can’t immediately think of a better way to do the latter solution, so `@einsum` is very good, thank you.  I have seen Einsum.jl from your Tillio.jl package.  The only problem is that I don’t know very much about multilinear algebra, so I will have to have a read…  Any resources you suggest?\n\nRegarding the `@einsum` method for the first method, here are benchmarking results on my computer:\n```julia&gt; @btime @einsum y[i] := x[i,i,i]\n  2.017 μs (12 allocations: 656 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27\n\njulia&gt; @btime y = diag(x)\n  192.694 ns (3 allocations: 304 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27```\nIs there any benefit to using `@einsum` over my `diag` adaptation?  (I suspect `@einsum` is more robust…).","user":"U014LRLJXRP","ts":"1609931577.115800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6lIu/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, that’s a clever way to do that.  I can’t immediately think of a better way to do the latter solution, so "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is very good, thank you.  I have seen Einsum.jl from your Tillio.jl package.  The only problem is that I don’t know very much about multilinear algebra, so I will have to have a read…  Any resources you suggest?\n\nRegarding the "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" method for the first method, here are benchmarking results on my computer:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime @einsum y[i] := x[i,i,i]\n  2.017 μs (12 allocations: 656 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27\n\njulia> @btime y = diag(x)\n  192.694 ns (3 allocations: 304 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there any benefit to using "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" over my "},{"type":"text","text":"diag","style":{"code":true}},{"type":"text","text":" adaptation?  (I suspect "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is more robust…)."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"430c0bfc-74f5-46fa-8a68-6e9abdcf9dd7","type":"message","text":"The only thing that might be hard to do is generalise the `@einsum` methods to higher dimensions.  Can you think of a way, instead of hard coding, `[i, i, k]`, for instance?","user":"U014LRLJXRP","ts":"1609931649.116000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kkc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The only thing that might be hard to do is generalise the "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" methods to higher dimensions.  Can you think of a way, instead of hard coding, "},{"type":"text","text":"[i, i, k]","style":{"code":true}},{"type":"text","text":", for instance?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"13eea792-0af1-43e8-9848-131ce91dc99f","type":"message","text":"<@UD0NS8PDF> the other thing I was told to use `@tullio` for was for matrix multiplication of arbitrary dimension.  But again, I think it might be difficult to generalise this method (see above).  Can you think of a way?  Thank you :slightly_smiling_face:","user":"U014LRLJXRP","ts":"1609931945.116400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f2v","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" the other thing I was told to use "},{"type":"text","text":"@tullio","style":{"code":true}},{"type":"text","text":" for was for matrix multiplication of arbitrary dimension.  But again, I think it might be difficult to generalise this method (see above).  Can you think of a way?  Thank you "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"6e7afd24-5f21-4d18-b883-71e7dc0307ed","type":"message","text":"Re times, Einsum is just a simple loop, should not have much overhead:\n```julia&gt; @btime diag(x)  setup=(x=randn(5,5));\n  52.351 ns (1 allocation: 128 bytes)\n\njulia&gt; @btime @einsum(y[i] := x[i,i])  setup=(x=randn(5,5));\n  36.270 ns (1 allocation: 128 bytes)```\nIt is possible to wrap that into a function, something like this:\n```julia&gt; @generated function alldiag(x::AbstractArray)\n       is =  [:i for _ in 1:ndims(x)]\n       :( @einsum y[i] := x[$(is...)] )\n       end;\n\njulia&gt; alldiag(x)\n3-element Vector{Int64}:\n  1\n 14\n 27```\nalthough honestly there will be better ways — the point of using `@einsum` is for such things more that it will be obvious to your future self which particular diagonal you are extracting, rather than trying to remember what some `mydiag(x, dims=(1,2))` means.","user":"UD0NS8PDF","ts":"1609932413.116600","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1609932445.000000"},"blocks":[{"type":"rich_text","block_id":"pIF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Re times, Einsum is just a simple loop, should not have much overhead:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime diag(x)  setup=(x=randn(5,5));\n  52.351 ns (1 allocation: 128 bytes)\n\njulia> @btime @einsum(y[i] := x[i,i])  setup=(x=randn(5,5));\n  36.270 ns (1 allocation: 128 bytes)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It is possible to wrap that into a function, something like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @generated function alldiag(x::AbstractArray)\n       is =  [:i for _ in 1:ndims(x)]\n       :( @einsum y[i] := x[$(is...)] )\n       end;\n\njulia> alldiag(x)\n3-element Vector{Int64}:\n  1\n 14\n 27"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"although honestly there will be better ways — the point of using "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is for such things more that it will be obvious to your future self which particular diagonal you are extracting, rather than trying to remember what some "},{"type":"text","text":"mydiag(x, dims=(1,2))","style":{"code":true}},{"type":"text","text":" means."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"+1","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"5599a915-95c9-4df9-8d6c-c580421425bf","type":"message","text":"BTW I think you can do better than filtering the indices to find `diagind`, one idea is this:\n```julia&gt; function _diagind(x::AbstractArray)\n         ax1 = axes(x,1)\n         for d in 2:ndims(x)\n           axes(x,d) == ax1 || throw(\"dimensionmismatch?\")\n         end\n         map(i -&gt; CartesianIndex(ntuple(d-&gt;i, ndims(x))), ax1)\n       end;```\nbut at least for Arrays you could figure out how to return linear indices like the built-in one does for matrices, `diagind(rand(5,5)) === 1:6:25`. Or avoid creating this array of indices by doing this in diag instead.","user":"UD0NS8PDF","ts":"1609933540.117400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dwR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"BTW I think you can do better than filtering the indices to find "},{"type":"text","text":"diagind","style":{"code":true}},{"type":"text","text":", one idea is this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function _diagind(x::AbstractArray)\n         ax1 = axes(x,1)\n         for d in 2:ndims(x)\n           axes(x,d) == ax1 || throw(\"dimensionmismatch?\")\n         end\n         map(i -> CartesianIndex(ntuple(d->i, ndims(x))), ax1)\n       end;"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but at least for Arrays you could figure out how to return linear indices like the built-in one does for matrices, "},{"type":"text","text":"diagind(rand(5,5)) === 1:6:25","style":{"code":true}},{"type":"text","text":". Or avoid creating this array of indices by doing this in diag instead."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"open_mouth","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"45df8cc1-0cfb-4b1b-b7a0-6cb5b2ef461e","type":"message","text":"Good point.  Thank you for the `alldiag` function, that will work well.  I know what you mean about readability for your future self!\n\nOne thing to note re time, is that `@einsum` scales _much_ better than mine:\n```julia&gt; @btime diag(x)  setup=(x=randn(5,5,5,5));\n  819.418 ns (4 allocations: 624 bytes)\n\njulia&gt; @btime @einsum(y[i] := x[i,i,i,i])  setup=(x=randn(5,5,5,5));\n  57.873 ns (1 allocation: 128 bytes)```\n","user":"U014LRLJXRP","ts":"1609933544.117600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6g8BG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Good point.  Thank you for the "},{"type":"text","text":"alldiag","style":{"code":true}},{"type":"text","text":" function, that will work well.  I know what you mean about readability for your future self!\n\nOne thing to note re time, is that "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" scales "},{"type":"text","text":"much","style":{"italic":true}},{"type":"text","text":" better than mine:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime diag(x)  setup=(x=randn(5,5,5,5));\n  819.418 ns (4 allocations: 624 bytes)\n\njulia> @btime @einsum(y[i] := x[i,i,i,i])  setup=(x=randn(5,5,5,5));\n  57.873 ns (1 allocation: 128 bytes)"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"6fcea35b-bded-4da8-9333-7636b081fe79","type":"message","text":"Thank you, I really like your `_diagind` method!  That is so clever :sweat_smile:","user":"U014LRLJXRP","ts":"1609933848.117900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SJH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you, I really like your "},{"type":"text","text":"_diagind","style":{"code":true}},{"type":"text","text":" method!  That is so clever "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"f0291682-8872-464b-9edf-933c23441250","type":"message","text":"Is it better to iterate through all of the dimensions and check they are the same, or to check that all of `size(x)` are the same?","user":"U014LRLJXRP","ts":"1609934018.118100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it better to iterate through all of the dimensions and check they are the same, or to check that all of "},{"type":"text","text":"size(x)","style":{"code":true}},{"type":"text","text":" are the same?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"9b418264-8fa7-4eaa-a019-ef4cf2681e5c","type":"message","text":"Somewhere is has to iterate, I guess. I think a loop like this ought to be quite efficient, it knows `ndims(x)` when compiling. Some functions in Base are a bit more paranoid about putting throw() in another function… not sure that’s necc.","user":"UD0NS8PDF","ts":"1609934264.118300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C3vi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Somewhere is has to iterate, I guess. I think a loop like this ought to be quite efficient, it knows "},{"type":"text","text":"ndims(x)","style":{"code":true}},{"type":"text","text":" when compiling. Some functions in Base are a bit more paranoid about putting throw() in another function… not sure that’s necc."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"+1","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"d528a3dd-f03f-4431-8f92-7659e9ed75f9","type":"message","text":"Yes, I’ve noticed that too.  But is it strictly necessary that a diagonal function takes a square/cube/hypercube?  e.g. why can’t the `diag` of\n```3×4 Array{Int8,2}:\n  -10  -100  -63   -46\n -122    10  -74   -70\n  -96  -126   37  -102```\nbe\n```3-element Array{Int64,1}:\n -10\n  10\n  37```\n?","user":"U014LRLJXRP","ts":"1609934815.118700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hGH/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, I’ve noticed that too.  But is it strictly necessary that a diagonal function takes a square/cube/hypercube?  e.g. why can’t the "},{"type":"text","text":"diag","style":{"code":true}},{"type":"text","text":" of\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"3×4 Array{Int8,2}:\n  -10  -100  -63   -46\n -122    10  -74   -70\n  -96  -126   37  -102"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"be\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"3-element Array{Int64,1}:\n -10\n  10\n  37"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"d5a8cfbc-ce68-4477-b076-841983ec2702","type":"message","text":"I guess `diag(rand(3,4))` does allow that, I forgot.","user":"UD0NS8PDF","ts":"1609935109.118900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DrJ=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess "},{"type":"text","text":"diag(rand(3,4))","style":{"code":true}},{"type":"text","text":" does allow that, I forgot."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"2364082f-24ae-4fb4-b6c8-9531b4aa24d1","type":"message","text":"It does---but my question is, _should_ it?  (I don’t know :stuck_out_tongue:)","user":"U014LRLJXRP","ts":"1609935172.119100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BBeq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It does---but my question is, "},{"type":"text","text":"should","style":{"italic":true}},{"type":"text","text":" it?  (I don’t know "},{"type":"emoji","name":"stuck_out_tongue"},{"type":"text","text":")"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"13067fa3-ad31-48a0-bc8e-977aff0a5aac","type":"message","text":"<@UD0NS8PDF> also see my earlier question on matrix multiplication for arbitrary dimensions ^.  I tried using your TensorCast.jl’s `@matmul` macro but with limited success:\n```julia&gt; using TensorCast\n\njulia&gt; @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: UndefVarError: @matmul not defined```","user":"U014LRLJXRP","ts":"1609935775.119300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xW05","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" also see my earlier question on matrix multiplication for arbitrary dimensions ^.  I tried using your TensorCast.jl’s "},{"type":"text","text":"@matmul","style":{"code":true}},{"type":"text","text":" macro but with limited success:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using TensorCast\n\njulia> @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: UndefVarError: @matmul not defined"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"2fa18bf6-8506-41b8-974a-175e443f7c15","type":"message","text":"Oh that’s weird, maybe somehow Pkg gave you a super-old version?\n\nWhat you write can be done, but not by `@matmul`… although its error message is not the most informative thing ever, apparently:\n```julia&gt; using TensorCast\n\njulia&gt; A = rand(2,2); B = rand(2,2);\n\njulia&gt; @cast M[i] := A[i, i] * B[i, i]\n2-element Vector{Float64}:\n 0.6822161953643253\n 0.34471244612266333\n\njulia&gt; @matmul M[i,j] := sum(k) A[i, k] * B[j, k]\n2×2 Matrix{Float64}:\n 0.726812  0.708086\n 0.16645   0.399531\n\n(jl_zGpJ7r) pkg&gt; st TensorCast\nStatus `/private/var/folders/d0/hrtbsjqj66qf8zm88ycw9_580000gp/T/jl_zGpJ7r/Project.toml`\n  [02d47bb6] TensorCast v0.3.2\n\njulia&gt; @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: MethodError: Cannot `convert` an object of type Expr to an object of type Symbol```","user":"UD0NS8PDF","ts":"1609936011.119500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Y=K2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh that’s weird, maybe somehow Pkg gave you a super-old version?\n\nWhat you write can be done, but not by "},{"type":"text","text":"@matmul","style":{"code":true}},{"type":"text","text":"… although its error message is not the most informative thing ever, apparently:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using TensorCast\n\njulia> A = rand(2,2); B = rand(2,2);\n\njulia> @cast M[i] := A[i, i] * B[i, i]\n2-element Vector{Float64}:\n 0.6822161953643253\n 0.34471244612266333\n\njulia> @matmul M[i,j] := sum(k) A[i, k] * B[j, k]\n2×2 Matrix{Float64}:\n 0.726812  0.708086\n 0.16645   0.399531\n\n(jl_zGpJ7r) pkg> st TensorCast\nStatus `/private/var/folders/d0/hrtbsjqj66qf8zm88ycw9_580000gp/T/jl_zGpJ7r/Project.toml`\n  [02d47bb6] TensorCast v0.3.2\n\njulia> @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: MethodError: Cannot `convert` an object of type Expr to an object of type Symbol"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"29405430-4e23-429d-a9aa-583736028f5e","type":"message","text":"Oh, you’re right.  It did give me an old version:\n```(@v1.5) pkg&gt; st TensorCast\nStatus `~/.julia/environments/v1.5/Project.toml`\n  [02d47bb6] TensorCast v0.1.5```\n","user":"U014LRLJXRP","ts":"1609936238.119700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lE/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, you’re right.  It did give me an old version:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"(@v1.5) pkg> st TensorCast\nStatus `~/.julia/environments/v1.5/Project.toml`\n  [02d47bb6] TensorCast v0.1.5"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"e96365a2-10b7-4c23-982c-77bf4838c854","type":"message","text":"So to clarify, you would use `@cast` to multiply matrices together?  :slightly_smiling_face:","user":"U014LRLJXRP","ts":"1609936401.119900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"56CFj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So to clarify, you would use "},{"type":"text","text":"@cast","style":{"code":true}},{"type":"text","text":" to multiply matrices together?  "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"0762da0d-4325-4669-bc87-ece581efd6bf","type":"message","text":"`@cast` needs all the same indices on the left &amp; right. It’s doing pretty much `M = diag(A) .* diag(B)` here, there’s no sum/reduction.","user":"UD0NS8PDF","ts":"1609936582.120100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ijUZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"@cast","style":{"code":true}},{"type":"text","text":" needs all the same indices on the left & right. It’s doing pretty much "},{"type":"text","text":"M = diag(A) .* diag(B)","style":{"code":true}},{"type":"text","text":" here, there’s no sum/reduction."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"16c09c15-feef-409f-8744-c5547e46b329","type":"message","text":"Oh, right.  What do I do with `@cast` to replicate matrix multiplication?\n```julia&gt; @cast(M[i, j] := A[i, j] * B[j, i]) == A * B\nfalse```","user":"U014LRLJXRP","ts":"1609936682.120300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1qEB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, right.  What do I do with "},{"type":"text","text":"@cast","style":{"code":true}},{"type":"text","text":" to replicate matrix multiplication?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @cast(M[i, j] := A[i, j] * B[j, i]) == A * B\nfalse"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"37ff5ad2-744d-4345-b1df-f0d1b7dc477c","type":"message","text":"You can’t, this is `.*`, while matrix multiplication needs a reduction. But the other two macros can:\n```julia&gt; @pretty @matmul M[i,j] := sum(k) A[i, k] * B[j, k] \nbegin\n    local lobster = permutedims(B, (2, 1))\n    local boar = A * lobster\n    M = boar\nend\n\njulia&gt; @pretty @reduce M[i,j] := sum(k) A[i, k] * B[j, k]\nbegin\n    local lobster = orient(PermuteDims(B), (*, :, :))\n    M = dropdims(sum(@__dot__(A * lobster), dims = 2), dims = 2)\nend```","user":"UD0NS8PDF","ts":"1609936883.120500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QEp7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can’t, this is "},{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":", while matrix multiplication needs a reduction. But the other two macros can:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @pretty @matmul M[i,j] := sum(k) A[i, k] * B[j, k] \nbegin\n    local lobster = permutedims(B, (2, 1))\n    local boar = A * lobster\n    M = boar\nend\n\njulia> @pretty @reduce M[i,j] := sum(k) A[i, k] * B[j, k]\nbegin\n    local lobster = orient(PermuteDims(B), (*, :, :))\n    M = dropdims(sum(@__dot__(A * lobster), dims = 2), dims = 2)\nend"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"+1","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"077daff2-0e02-4d6d-b6b6-fdb6da8044ca","type":"message","text":"Okay, I think I understand…  Now to fight with some generating functions to generalise this :sweat_smile:","user":"U014LRLJXRP","ts":"1609937374.120800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A22Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Okay, I think I understand…  Now to fight with some generating functions to generalise this "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"4eb1865d-1a7b-4ab4-a406-0190610e5720","type":"message","text":"Oh, btw <@UD0NS8PDF>, the hyperplane slice thing doesn’t seem to want to generalise very well?\n```julia&gt; size(A)\n(3, 3, 3, 3)\n\njulia&gt; @einsum y[i, i, k] := A[i, i, i, k]\nERROR: BoundsError: attempt to access 3×3 Array{Int8,2} at index [1, 1, 2]```","user":"U014LRLJXRP","ts":"1609937578.121000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sglq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, btw "},{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":", the hyperplane slice thing doesn’t seem to want to generalise very well?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> size(A)\n(3, 3, 3, 3)\n\njulia> @einsum y[i, i, k] := A[i, i, i, k]\nERROR: BoundsError: attempt to access 3×3 Array{Int8,2} at index [1, 1, 2]"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"780292e0-981a-40e7-983d-36ee573579fc","type":"message","text":"&gt; `@pretty @reduce M[i,j] := sum(k) A[i, k] * B[j, k]`\nThis still doesn’t quite do what I want\n```julia&gt; @reduce M[i,j] := sum(k) A[i, k] * B[j, k]\n3×3 Array{Int64,2}:\n -98  -98  -159\n  20    2   -82\n 150  120    75\n\njulia&gt; A * B # not the same as ^\n3×3 Array{Int8,2}:\n  106   21  -56\n  124  -86  122\n -110   23   98```\nAnyway, I have to sleep now (it is late over here).  Thank you ever so much for your help today.  You’ve been so helpful :slightly_smiling_face:","user":"U014LRLJXRP","ts":"1609937903.121200","team":"T68168MUP","edited":{"user":"U014LRLJXRP","ts":"1609937924.000000"},"blocks":[{"type":"rich_text","block_id":"puYr","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"@pretty @reduce M[i,j] := sum(k) A[i, k] * B[j, k]","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"This still doesn’t quite do what I want\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @reduce M[i,j] := sum(k) A[i, k] * B[j, k]\n3×3 Array{Int64,2}:\n -98  -98  -159\n  20    2   -82\n 150  120    75\n\njulia> A * B # not the same as ^\n3×3 Array{Int8,2}:\n  106   21  -56\n  124  -86  122\n -110   23   98"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Anyway, I have to sleep now (it is late over here).  Thank you ever so much for your help today.  You’ve been so helpful "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"6e7a8917-86b0-4460-b0f2-218c4dfac52a","type":"message","text":"Not sure if that’s a bug or a feature. What value should `y[1,2,3]` have, for which there is no RHS? It works in-place:\n```julia&gt; y = rand(3,3,3);\n\njulia&gt; @einsum y[i, i, k] = A[i, i, i, k]\n3×3×3 Array{Float64, 3}:\n[:, :, 1] =\n -14.0         0.334915   0.763704\n   0.921505  -84.0        0.237027\n   0.870557    0.667352  71.0\n\n[:, :, 2] =\n -45.0        0.0174538     0.499537\n   0.999103  27.0           0.720973\n   0.939182   0.263149   -128.0\n\n[:, :, 3] =\n 55.0        0.151163    0.527953\n  0.897389  17.0         0.727647\n  0.18156    0.494597  -81.0```\nand my macro assumes it should be filled with zeros off-diagonal:\n```julia&gt; @tullio y[i, i, k] := A[i, i, i, k]\n3×3×3 Array{Int8, 3}:\n[:, :, 1] =\n -14    0   0\n   0  -84   0\n   0    0  71\n\n[:, :, 2] =\n -45   0     0\n   0  27     0\n   0   0  -128\n\n[:, :, 3] =\n 55   0    0\n  0  17    0\n  0   0  -81```","user":"UD0NS8PDF","ts":"1609937962.121500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r3F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not sure if that’s a bug or a feature. What value should "},{"type":"text","text":"y[1,2,3]","style":{"code":true}},{"type":"text","text":" have, for which there is no RHS? It works in-place:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> y = rand(3,3,3);\n\njulia> @einsum y[i, i, k] = A[i, i, i, k]\n3×3×3 Array{Float64, 3}:\n[:, :, 1] =\n -14.0         0.334915   0.763704\n   0.921505  -84.0        0.237027\n   0.870557    0.667352  71.0\n\n[:, :, 2] =\n -45.0        0.0174538     0.499537\n   0.999103  27.0           0.720973\n   0.939182   0.263149   -128.0\n\n[:, :, 3] =\n 55.0        0.151163    0.527953\n  0.897389  17.0         0.727647\n  0.18156    0.494597  -81.0"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and my macro assumes it should be filled with zeros off-diagonal:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @tullio y[i, i, k] := A[i, i, i, k]\n3×3×3 Array{Int8, 3}:\n[:, :, 1] =\n -14    0   0\n   0  -84   0\n   0    0  71\n\n[:, :, 2] =\n -45   0     0\n   0  27     0\n   0   0  -128\n\n[:, :, 3] =\n 55   0    0\n  0  17    0\n  0   0  -81"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"a4edc2cb-3ea1-4641-a367-e88ac7e716b6","type":"message","text":"There’s a transpose in there, since the summed index is the last one on B, not the neighbour:\n```julia&gt; A = rand(2,2); B = rand(2,2);\n\njulia&gt; @reduce M[i,j] := sum(k) A[i, k] * B[j, k];\n\njulia&gt; M ≈ A * B'\ntrue```\nAnd, sure!","user":"UD0NS8PDF","ts":"1609938068.121700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YZalp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There’s a transpose in there, since the summed index is the last one on B, not the neighbour:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> A = rand(2,2); B = rand(2,2);\n\njulia> @reduce M[i,j] := sum(k) A[i, k] * B[j, k];\n\njulia> M ≈ A * B'\ntrue"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"And, sure!"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"182622a6-50a6-47df-9620-51821fb88b8b","type":"message","text":"<@UD0NS8PDF> ohh, that’s good---that means that\n```julia&gt; @matmul M[i,j] := sum(k) A[i, k] * transpose(B)[j, k];\n\njulia&gt; M == A * B```\nworks!  Thank you!!  But how would I generalise that to higher dimensions?  I don’t think this works:\n```@generated function *(A::AbstractArray{T, N}, B::AbstractArray{T, N}) where {T, N}\n    C = transpose(B)\n    return :(@matmul M[i,j] := sum(k) A[i, k] * C[j, k])\nend```\nDo I need to use `genym` to get all of the indices as symbolic parameters, perhaps?","user":"U014LRLJXRP","ts":"1609972575.128600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IVhP","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" ohh, that’s good---that means that\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @matmul M[i,j] := sum(k) A[i, k] * transpose(B)[j, k];\n\njulia> M == A * B"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"works!  Thank you!!  But how would I generalise that to higher dimensions?  I don’t think this works:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@generated function *(A::AbstractArray{T, N}, B::AbstractArray{T, N}) where {T, N}\n    C = transpose(B)\n    return :(@matmul M[i,j] := sum(k) A[i, k] * C[j, k])\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Do I need to use "},{"type":"text","text":"genym","style":{"code":true}},{"type":"text","text":" to get all of the indices as symbolic parameters, perhaps?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"b88de608-4752-4053-8a53-e43d68ae40b3","type":"message","text":"Yes I guess you could mess with this, you will need more indices which could probably be e.g. `Symbol.(:i_, 1:4)`. But more importantly you need to decide how to contract them. With two matrices you can do `A*B`, `A'B`, `A*B'` or `A'B'` and that’s all, but with two 4-tensors there are many different pairwise contractions possible. The reason to use these macros is that you can write the one you need in a particular formula.","user":"UD0NS8PDF","ts":"1609973152.128800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VHIE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes I guess you could mess with this, you will need more indices which could probably be e.g. "},{"type":"text","text":"Symbol.(:i_, 1:4)","style":{"code":true}},{"type":"text","text":". But more importantly you need to decide how to contract them. With two matrices you can do "},{"type":"text","text":"A*B","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"A'B","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"A*B'","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"A'B'","style":{"code":true}},{"type":"text","text":" and that’s all, but with two 4-tensors there are many different pairwise contractions possible. The reason to use these macros is that you can write the one you need in a particular formula."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"55b27fc6-adfc-4216-aeef-72415e1392ee","type":"message","text":"Oh dear, you’re right…  Do you know the best way to go about this to write such a function myself?  (I.e., without `@mathmul`)?  I haven’t really worked with tensors before… but I guess I could see each element of an n-dimensional array as a lower-dimensional slice, and multiply out from them?  Or maybe that wouldn’t work…  I am very lost :sweat_smile:","user":"U014LRLJXRP","ts":"1609973278.129000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Bu8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh dear, you’re right…  Do you know the best way to go about this to write such a function myself?  (I.e., without "},{"type":"text","text":"@mathmul","style":{"code":true}},{"type":"text","text":")?  I haven’t really worked with tensors before… but I guess I could see each element of an n-dimensional array as a lower-dimensional slice, and multiply out from them?  Or maybe that wouldn’t work…  I am very lost "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"5bdd81e7-000d-456c-b72d-a4e0d9466f3a","type":"message","text":"There are two paths basically. You can write the loops explicitly. Or you can re-arrange all the data to feed it to standard matmul. The first is what Einsum and Tullio do. The second is what `@matmul` and TensorOperations do.","user":"UD0NS8PDF","ts":"1609974923.129200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=JbH2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are two paths basically. You can write the loops explicitly. Or you can re-arrange all the data to feed it to standard matmul. The first is what Einsum and Tullio do. The second is what "},{"type":"text","text":"@matmul","style":{"code":true}},{"type":"text","text":" and TensorOperations do."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"4ba7ac71-d0ca-41cf-ba27-df31ffa29312","type":"message","text":"Hmm…  I feel as though reshaping data back and forth might be hard to write?  What do you think?\n\nAlso, what do those loops look like for 2 dimensions?  I’m not exactly sure, but it would be easy to generalise from there, once I know how they look","user":"U014LRLJXRP","ts":"1609975051.129400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sIr2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm…  I feel as though reshaping data back and forth might be hard to write?  What do you think?\n\nAlso, what do those loops look like for 2 dimensions?  I’m not exactly sure, but it would be easy to generalise from there, once I know how they look"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"e3afcb42-6879-44f0-9325-023be5ee0ad9","type":"message","text":"Both `@matmul` and `@einsum` generate fairly simple code, you can `@macroexpand1` them for different examples and see.","user":"UD0NS8PDF","ts":"1609975228.129600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RDv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Both "},{"type":"text","text":"@matmul","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" generate fairly simple code, you can "},{"type":"text","text":"@macroexpand1","style":{"code":true}},{"type":"text","text":" them for different examples and see."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"+1","users":["U014LRLJXRP"],"count":1}]}]