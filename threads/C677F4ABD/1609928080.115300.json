[{"client_msg_id":"102e9e50-9b82-4687-8e1f-aabc9f5ae498","type":"message","text":"Question: if I were to extend `LinearAlgebra.diag` for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?","user":"U014LRLJXRP","ts":"1609928080.115300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"E8G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Question: if I were to extend "},{"type":"text","text":"LinearAlgebra.diag","style":{"code":true}},{"type":"text","text":" for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?"}]}]}],"thread_ts":"1609928080.115300","reply_count":16,"reply_users_count":2,"latest_reply":"1609936011.119500","reply_users":["U014LRLJXRP","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"0f6ae558-271a-4006-97ab-c0e31ab0201d","type":"message","text":"An implementation of the former would be something like this (I wrote the self-evident `allequal` function, but it’s trivial so I won’t put it here):\n```function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]```\nI don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯.","user":"U014LRLJXRP","ts":"1609928226.115400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tZE+O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"An implementation of the former would be something like this (I wrote the self-evident "},{"type":"text","text":"allequal","style":{"code":true}},{"type":"text","text":" function, but it’s trivial so I won’t put it here):\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"e9a67a22-ddd0-4927-b686-560106208aa8","type":"message","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n```julia&gt; x = reshape(1:3^3,3,3,3);\n\njulia&gt; @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia&gt; @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27```","user":"UD0NS8PDF","ts":"1609928795.115600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9+4j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> x = reshape(1:3^3,3,3,3);\n\njulia> @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia> @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"64c000dd-0a5e-4007-9784-9d2dfa9d532e","type":"message","text":"Oh, that’s a clever way to do that.  I can’t immediately think of a better way to do the latter solution, so `@einsum` is very good, thank you.  I have seen Einsum.jl from your Tillio.jl package.  The only problem is that I don’t know very much about multilinear algebra, so I will have to have a read…  Any resources you suggest?\n\nRegarding the `@einsum` method for the first method, here are benchmarking results on my computer:\n```julia&gt; @btime @einsum y[i] := x[i,i,i]\n  2.017 μs (12 allocations: 656 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27\n\njulia&gt; @btime y = diag(x)\n  192.694 ns (3 allocations: 304 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27```\nIs there any benefit to using `@einsum` over my `diag` adaptation?  (I suspect `@einsum` is more robust…).","user":"U014LRLJXRP","ts":"1609931577.115800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6lIu/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, that’s a clever way to do that.  I can’t immediately think of a better way to do the latter solution, so "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is very good, thank you.  I have seen Einsum.jl from your Tillio.jl package.  The only problem is that I don’t know very much about multilinear algebra, so I will have to have a read…  Any resources you suggest?\n\nRegarding the "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" method for the first method, here are benchmarking results on my computer:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime @einsum y[i] := x[i,i,i]\n  2.017 μs (12 allocations: 656 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27\n\njulia> @btime y = diag(x)\n  192.694 ns (3 allocations: 304 bytes)\n3-element Array{Int64,1}:\n  1\n 14\n 27"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there any benefit to using "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" over my "},{"type":"text","text":"diag","style":{"code":true}},{"type":"text","text":" adaptation?  (I suspect "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is more robust…)."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"430c0bfc-74f5-46fa-8a68-6e9abdcf9dd7","type":"message","text":"The only thing that might be hard to do is generalise the `@einsum` methods to higher dimensions.  Can you think of a way, instead of hard coding, `[i, i, k]`, for instance?","user":"U014LRLJXRP","ts":"1609931649.116000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kkc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The only thing that might be hard to do is generalise the "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" methods to higher dimensions.  Can you think of a way, instead of hard coding, "},{"type":"text","text":"[i, i, k]","style":{"code":true}},{"type":"text","text":", for instance?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"13eea792-0af1-43e8-9848-131ce91dc99f","type":"message","text":"<@UD0NS8PDF> the other thing I was told to use `@tullio` for was for matrix multiplication of arbitrary dimension.  But again, I think it might be difficult to generalise this method (see above).  Can you think of a way?  Thank you :slightly_smiling_face:","user":"U014LRLJXRP","ts":"1609931945.116400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f2v","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" the other thing I was told to use "},{"type":"text","text":"@tullio","style":{"code":true}},{"type":"text","text":" for was for matrix multiplication of arbitrary dimension.  But again, I think it might be difficult to generalise this method (see above).  Can you think of a way?  Thank you "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"6e7afd24-5f21-4d18-b883-71e7dc0307ed","type":"message","text":"Re times, Einsum is just a simple loop, should not have much overhead:\n```julia&gt; @btime diag(x)  setup=(x=randn(5,5));\n  52.351 ns (1 allocation: 128 bytes)\n\njulia&gt; @btime @einsum(y[i] := x[i,i])  setup=(x=randn(5,5));\n  36.270 ns (1 allocation: 128 bytes)```\nIt is possible to wrap that into a function, something like this:\n```julia&gt; @generated function alldiag(x::AbstractArray)\n       is =  [:i for _ in 1:ndims(x)]\n       :( @einsum y[i] := x[$(is...)] )\n       end;\n\njulia&gt; alldiag(x)\n3-element Vector{Int64}:\n  1\n 14\n 27```\nalthough honestly there will be better ways — the point of using `@einsum` is for such things more that it will be obvious to your future self which particular diagonal you are extracting, rather than trying to remember what some `mydiag(x, dims=(1,2))` means.","user":"UD0NS8PDF","ts":"1609932413.116600","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1609932445.000000"},"blocks":[{"type":"rich_text","block_id":"pIF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Re times, Einsum is just a simple loop, should not have much overhead:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime diag(x)  setup=(x=randn(5,5));\n  52.351 ns (1 allocation: 128 bytes)\n\njulia> @btime @einsum(y[i] := x[i,i])  setup=(x=randn(5,5));\n  36.270 ns (1 allocation: 128 bytes)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It is possible to wrap that into a function, something like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @generated function alldiag(x::AbstractArray)\n       is =  [:i for _ in 1:ndims(x)]\n       :( @einsum y[i] := x[$(is...)] )\n       end;\n\njulia> alldiag(x)\n3-element Vector{Int64}:\n  1\n 14\n 27"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"although honestly there will be better ways — the point of using "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" is for such things more that it will be obvious to your future self which particular diagonal you are extracting, rather than trying to remember what some "},{"type":"text","text":"mydiag(x, dims=(1,2))","style":{"code":true}},{"type":"text","text":" means."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"+1","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"5599a915-95c9-4df9-8d6c-c580421425bf","type":"message","text":"BTW I think you can do better than filtering the indices to find `diagind`, one idea is this:\n```julia&gt; function _diagind(x::AbstractArray)\n         ax1 = axes(x,1)\n         for d in 2:ndims(x)\n           axes(x,d) == ax1 || throw(\"dimensionmismatch?\")\n         end\n         map(i -&gt; CartesianIndex(ntuple(d-&gt;i, ndims(x))), ax1)\n       end;```\nbut at least for Arrays you could figure out how to return linear indices like the built-in one does for matrices, `diagind(rand(5,5)) === 1:6:25`. Or avoid creating this array of indices by doing this in diag instead.","user":"UD0NS8PDF","ts":"1609933540.117400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dwR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"BTW I think you can do better than filtering the indices to find "},{"type":"text","text":"diagind","style":{"code":true}},{"type":"text","text":", one idea is this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function _diagind(x::AbstractArray)\n         ax1 = axes(x,1)\n         for d in 2:ndims(x)\n           axes(x,d) == ax1 || throw(\"dimensionmismatch?\")\n         end\n         map(i -> CartesianIndex(ntuple(d->i, ndims(x))), ax1)\n       end;"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but at least for Arrays you could figure out how to return linear indices like the built-in one does for matrices, "},{"type":"text","text":"diagind(rand(5,5)) === 1:6:25","style":{"code":true}},{"type":"text","text":". Or avoid creating this array of indices by doing this in diag instead."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"open_mouth","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"45df8cc1-0cfb-4b1b-b7a0-6cb5b2ef461e","type":"message","text":"Good point.  Thank you for the `alldiag` function, that will work well.  I know what you mean about readability for your future self!\n\nOne thing to note re time, is that `@einsum` scales _much_ better than mine:\n```julia&gt; @btime diag(x)  setup=(x=randn(5,5,5,5));\n  819.418 ns (4 allocations: 624 bytes)\n\njulia&gt; @btime @einsum(y[i] := x[i,i,i,i])  setup=(x=randn(5,5,5,5));\n  57.873 ns (1 allocation: 128 bytes)```\n","user":"U014LRLJXRP","ts":"1609933544.117600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6g8BG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Good point.  Thank you for the "},{"type":"text","text":"alldiag","style":{"code":true}},{"type":"text","text":" function, that will work well.  I know what you mean about readability for your future self!\n\nOne thing to note re time, is that "},{"type":"text","text":"@einsum","style":{"code":true}},{"type":"text","text":" scales "},{"type":"text","text":"much","style":{"italic":true}},{"type":"text","text":" better than mine:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime diag(x)  setup=(x=randn(5,5,5,5));\n  819.418 ns (4 allocations: 624 bytes)\n\njulia> @btime @einsum(y[i] := x[i,i,i,i])  setup=(x=randn(5,5,5,5));\n  57.873 ns (1 allocation: 128 bytes)"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"6fcea35b-bded-4da8-9333-7636b081fe79","type":"message","text":"Thank you, I really like your `_diagind` method!  That is so clever :sweat_smile:","user":"U014LRLJXRP","ts":"1609933848.117900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SJH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you, I really like your "},{"type":"text","text":"_diagind","style":{"code":true}},{"type":"text","text":" method!  That is so clever "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"f0291682-8872-464b-9edf-933c23441250","type":"message","text":"Is it better to iterate through all of the dimensions and check they are the same, or to check that all of `size(x)` are the same?","user":"U014LRLJXRP","ts":"1609934018.118100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it better to iterate through all of the dimensions and check they are the same, or to check that all of "},{"type":"text","text":"size(x)","style":{"code":true}},{"type":"text","text":" are the same?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"9b418264-8fa7-4eaa-a019-ef4cf2681e5c","type":"message","text":"Somewhere is has to iterate, I guess. I think a loop like this ought to be quite efficient, it knows `ndims(x)` when compiling. Some functions in Base are a bit more paranoid about putting throw() in another function… not sure that’s necc.","user":"UD0NS8PDF","ts":"1609934264.118300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C3vi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Somewhere is has to iterate, I guess. I think a loop like this ought to be quite efficient, it knows "},{"type":"text","text":"ndims(x)","style":{"code":true}},{"type":"text","text":" when compiling. Some functions in Base are a bit more paranoid about putting throw() in another function… not sure that’s necc."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP","reactions":[{"name":"+1","users":["U014LRLJXRP"],"count":1}]},{"client_msg_id":"d528a3dd-f03f-4431-8f92-7659e9ed75f9","type":"message","text":"Yes, I’ve noticed that too.  But is it strictly necessary that a diagonal function takes a square/cube/hypercube?  e.g. why can’t the `diag` of\n```3×4 Array{Int8,2}:\n  -10  -100  -63   -46\n -122    10  -74   -70\n  -96  -126   37  -102```\nbe\n```3-element Array{Int64,1}:\n -10\n  10\n  37```\n?","user":"U014LRLJXRP","ts":"1609934815.118700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hGH/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, I’ve noticed that too.  But is it strictly necessary that a diagonal function takes a square/cube/hypercube?  e.g. why can’t the "},{"type":"text","text":"diag","style":{"code":true}},{"type":"text","text":" of\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"3×4 Array{Int8,2}:\n  -10  -100  -63   -46\n -122    10  -74   -70\n  -96  -126   37  -102"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"be\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"3-element Array{Int64,1}:\n -10\n  10\n  37"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"?"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"d5a8cfbc-ce68-4477-b076-841983ec2702","type":"message","text":"I guess `diag(rand(3,4))` does allow that, I forgot.","user":"UD0NS8PDF","ts":"1609935109.118900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DrJ=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess "},{"type":"text","text":"diag(rand(3,4))","style":{"code":true}},{"type":"text","text":" does allow that, I forgot."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"2364082f-24ae-4fb4-b6c8-9531b4aa24d1","type":"message","text":"It does---but my question is, _should_ it?  (I don’t know :stuck_out_tongue:)","user":"U014LRLJXRP","ts":"1609935172.119100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BBeq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It does---but my question is, "},{"type":"text","text":"should","style":{"italic":true}},{"type":"text","text":" it?  (I don’t know "},{"type":"emoji","name":"stuck_out_tongue"},{"type":"text","text":")"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"13067fa3-ad31-48a0-bc8e-977aff0a5aac","type":"message","text":"<@UD0NS8PDF> also see my earlier question on matrix multiplication for arbitrary dimensions ^.  I tried using your TensorCast.jl’s `@matmul` macro but with limited success:\n```julia&gt; using TensorCast\n\njulia&gt; @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: UndefVarError: @matmul not defined```","user":"U014LRLJXRP","ts":"1609935775.119300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xW05","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" also see my earlier question on matrix multiplication for arbitrary dimensions ^.  I tried using your TensorCast.jl’s "},{"type":"text","text":"@matmul","style":{"code":true}},{"type":"text","text":" macro but with limited success:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using TensorCast\n\njulia> @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: UndefVarError: @matmul not defined"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"2fa18bf6-8506-41b8-974a-175e443f7c15","type":"message","text":"Oh that’s weird, maybe somehow Pkg gave you a super-old version?\n\nWhat you write can be done, but not by `@matmul`… although its error message is not the most informative thing ever, apparently:\n```julia&gt; using TensorCast\n\njulia&gt; A = rand(2,2); B = rand(2,2);\n\njulia&gt; @cast M[i] := A[i, i] * B[i, i]\n2-element Vector{Float64}:\n 0.6822161953643253\n 0.34471244612266333\n\njulia&gt; @matmul M[i,j] := sum(k) A[i, k] * B[j, k]\n2×2 Matrix{Float64}:\n 0.726812  0.708086\n 0.16645   0.399531\n\n(jl_zGpJ7r) pkg&gt; st TensorCast\nStatus `/private/var/folders/d0/hrtbsjqj66qf8zm88ycw9_580000gp/T/jl_zGpJ7r/Project.toml`\n  [02d47bb6] TensorCast v0.3.2\n\njulia&gt; @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: MethodError: Cannot `convert` an object of type Expr to an object of type Symbol```","user":"UD0NS8PDF","ts":"1609936011.119500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Y=K2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh that’s weird, maybe somehow Pkg gave you a super-old version?\n\nWhat you write can be done, but not by "},{"type":"text","text":"@matmul","style":{"code":true}},{"type":"text","text":"… although its error message is not the most informative thing ever, apparently:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using TensorCast\n\njulia> A = rand(2,2); B = rand(2,2);\n\njulia> @cast M[i] := A[i, i] * B[i, i]\n2-element Vector{Float64}:\n 0.6822161953643253\n 0.34471244612266333\n\njulia> @matmul M[i,j] := sum(k) A[i, k] * B[j, k]\n2×2 Matrix{Float64}:\n 0.726812  0.708086\n 0.16645   0.399531\n\n(jl_zGpJ7r) pkg> st TensorCast\nStatus `/private/var/folders/d0/hrtbsjqj66qf8zm88ycw9_580000gp/T/jl_zGpJ7r/Project.toml`\n  [02d47bb6] TensorCast v0.3.2\n\njulia> @matmul M[i] = A[i, i] * B[i, i]\nERROR: LoadError: MethodError: Cannot `convert` an object of type Expr to an object of type Symbol"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"}]