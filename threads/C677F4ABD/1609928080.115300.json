[{"client_msg_id":"102e9e50-9b82-4687-8e1f-aabc9f5ae498","type":"message","text":"Question: if I were to extend `LinearAlgebra.diag` for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?","user":"U014LRLJXRP","ts":"1609928080.115300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"E8G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Question: if I were to extend "},{"type":"text","text":"LinearAlgebra.diag","style":{"code":true}},{"type":"text","text":" for an arbitrary dimension, what would it look like?  Would it be all of the indices that are the same (thus returning a vector)?  I.e., (1, 1, …, 1), (2, 2, …, 2), …, (n, n, …, n)?  Or would it be a diagonal hyperplane that is one dimension less than the given matrix?"}]}]}],"thread_ts":"1609928080.115300","reply_count":2,"reply_users_count":2,"latest_reply":"1609928795.115600","reply_users":["U014LRLJXRP","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"0f6ae558-271a-4006-97ab-c0e31ab0201d","type":"message","text":"An implementation of the former would be something like this (I wrote the self-evident `allequal` function, but it’s trivial so I won’t put it here):\n```function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]```\nI don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯.","user":"U014LRLJXRP","ts":"1609928226.115400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tZE+O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"An implementation of the former would be something like this (I wrote the self-evident "},{"type":"text","text":"allequal","style":{"code":true}},{"type":"text","text":" function, but it’s trivial so I won’t put it here):\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function LinearAlgebra.diagind(A::AbstractArray)\n    return CartesianIndex{ndims(A)}[i for i in CartesianIndices(A) if allequal(i.I)]\nend\nLinearAlgebra.diag(A::AbstractArray) = A[diagind(A)]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know how I would go about the latter, though.  Or which one is more correct ¯\\_(ツ)_/¯."}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"},{"client_msg_id":"e9a67a22-ddd0-4927-b686-560106208aa8","type":"message","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n```julia&gt; x = reshape(1:3^3,3,3,3);\n\njulia&gt; @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia&gt; @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27```","user":"UD0NS8PDF","ts":"1609928795.115600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9+4j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess it depends on your problem — you can imagine cases where any particular diagonal (or trace) is what matters. One way is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> x = reshape(1:3^3,3,3,3);\n\njulia> @einsum y[i] := x[i,i,i]\n3-element Vector{Int64}:\n  1\n 14\n 27\n\njulia> @einsum y[i,k] := x[i,i,k]\n3×3 Matrix{Int64}:\n 1  10  19\n 5  14  23\n 9  18  27"}]}]}],"thread_ts":"1609928080.115300","parent_user_id":"U014LRLJXRP"}]