[{"client_msg_id":"5bef2a46-2203-4286-8c71-64b862dc5353","type":"message","text":"I am currently often extracting submatrices of large sparse matrices `A[i,j]`  and passing them on to other processes. (I am writing a sparse direct solver/multifrontal method)\n\nThese submatrices are often just zero-matrices or sometimes not sparse enough for `A[i,j]`  to be efficient, so instead I run `Matrix(view(A, i, j))` . Is there some Julia-way of smartly selecting the best representation and using that? I would be happy if I could smartly choose between Fill-matrices for 0-blocks, sparse matrices and dense matrices. (I am not even sure Fill-matrices have a big benefit over sparse matrices with 0 entries)","user":"U01L0RJC6FM","ts":"1617723851.112400","team":"T68168MUP","edited":{"user":"U01L0RJC6FM","ts":"1617724045.000000"},"blocks":[{"type":"rich_text","block_id":"PuPX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am currently often extracting submatrices of large sparse matrices "},{"type":"text","text":"A[i,j]","style":{"code":true}},{"type":"text","text":"  and passing them on to other processes. (I am writing a sparse direct solver/multifrontal method)\n\nThese submatrices are often just zero-matrices or sometimes not sparse enough for "},{"type":"text","text":"A[i,j]","style":{"code":true}},{"type":"text","text":"  to be efficient, so instead I run "},{"type":"text","text":"Matrix(view(A, i, j))","style":{"code":true}},{"type":"text","text":" . Is there some Julia-way of smartly selecting the best representation and using that? I would be happy if I could smartly choose between Fill-matrices for 0-blocks, sparse matrices and dense matrices. (I am not even sure Fill-matrices have a big benefit over sparse matrices with 0 entries)"}]}]}],"thread_ts":"1617723851.112400","reply_count":9,"reply_users_count":2,"latest_reply":"1617885287.118400","reply_users":["U011TRN4QBU","U01L0RJC6FM"],"is_locked":false,"subscribed":false},{"client_msg_id":"e3ea0f92-5008-4c47-8a30-89b5e5f280aa","type":"message","text":"From what I understand, this sounds like a type-unstable approach. Not sure if you will benefit from such a value-dependent representation of your submatrices at hand.","user":"U011TRN4QBU","ts":"1617873824.116200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bvor","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"From what I understand, this sounds like a type-unstable approach. Not sure if you will benefit from such a value-dependent representation of your submatrices at hand."}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"234e088a-ea0f-4be3-ad4f-54452f122388","type":"message","text":"Hi Daniel thanks for the response - I am not sure I understand.  `A`  is type stable but the function which wraps the call to `A[i,j]` is unstable. Although all of `A, i, j`  are type-stable. So that would be an issue? I would think that `getindex`  itself would be type-stable and therefore this wouldn't be a problem.\n\n I have decided to give my library a re-write in the hopes of resolving the type-instability","user":"U01L0RJC6FM","ts":"1617881740.116500","team":"T68168MUP","edited":{"user":"U01L0RJC6FM","ts":"1617881856.000000"},"blocks":[{"type":"rich_text","block_id":"SKPz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi Daniel thanks for the response - I am not sure I understand.  "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":"  is type stable but the function which wraps the call to "},{"type":"text","text":"A[i,j]","style":{"code":true}},{"type":"text","text":" is unstable. Although all of "},{"type":"text","text":"A, i, j","style":{"code":true}},{"type":"text","text":"  are type-stable. So that would be an issue? I would think that "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":"  itself would be type-stable and therefore this wouldn't be a problem.\n\n I have decided to give my library a re-write in the hopes of resolving the type-instability"}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"eb3a404c-d696-453a-bfce-3d690dceeffb","type":"message","text":"I thought you would want to produce sometimes sparse, sometimes dense submatrices, depending on whether you have any nonzero entries or not. But maybe I misunderstood your problem. BTW, i and j are not just scalars, but some abstract vectors (like ranges)?","user":"U011TRN4QBU","ts":"1617883233.116900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PPue","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I thought you would want to produce sometimes sparse, sometimes dense submatrices, depending on whether you have any nonzero entries or not. But maybe I misunderstood your problem. BTW, i and j are not just scalars, but some abstract vectors (like ranges)?"}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"65f1eaaf-4a7a-44ae-b91d-9eca5ac37189","type":"message","text":"oh sorry I got mixed up from all the questions I posted and I realize my previous response might have been out of context. In fact I can live with always getting sparse matrix outputs as long as this is fast.","user":"U01L0RJC6FM","ts":"1617884936.117300","team":"T68168MUP","edited":{"user":"U01L0RJC6FM","ts":"1617885196.000000"},"blocks":[{"type":"rich_text","block_id":"51n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh sorry I got mixed up from all the questions I posted and I realize my previous response might have been out of context. In fact I can live with always getting sparse matrix outputs as long as this is fast."}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"374611eb-be5b-4f47-ac22-50e47ef51dd1","type":"message","text":"Yes `i` and `j`  are `AbstractVector{Int}` . Is that an issue? I convert them to `UnitRange{Int}`  if I know that they are contigious but this operation is type-unstable so perhaps better to avoid that","user":"U01L0RJC6FM","ts":"1617885052.117500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SyaQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"j","style":{"code":true}},{"type":"text","text":"  are "},{"type":"text","text":"AbstractVector{Int}","style":{"code":true}},{"type":"text","text":" . Is that an issue? I convert them to "},{"type":"text","text":"UnitRange{Int}","style":{"code":true}},{"type":"text","text":"  if I know that they are contigious but this operation is type-unstable so perhaps better to avoid that"}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"58bd2cff-1aa4-4f3b-82ac-2eb4451923a0","type":"message","text":"I see that `A[i,j]`  has a smart access function if `I`  is a Unit range so that was the idea behind that","user":"U01L0RJC6FM","ts":"1617885104.117700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S51","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see that "},{"type":"text","text":"A[i,j]","style":{"code":true}},{"type":"text","text":"  has a smart access function if "},{"type":"text","text":"I","style":{"code":true}},{"type":"text","text":"  is a Unit range so that was the idea behind that"}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"179b2d9d-75b8-414b-a279-391621897d06","type":"message","text":"No, it's fine, it was just for me to make sure I understood the context.","user":"U011TRN4QBU","ts":"1617885137.117900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hxEwd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, it's fine, it was just for me to make sure I understood the context."}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"b38bc115-eec7-4663-b934-80db09ef7c79","type":"message","text":"Currently I scale my problem without increasing the number of non-zeros per column and the cost of `A[i,j]`  explodes. For some reason this is not the case with `Matrix(view(A,i,j))`  which is obviously not what I want if I want linear scaling","user":"U01L0RJC6FM","ts":"1617885232.118200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KLP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Currently I scale my problem without increasing the number of non-zeros per column and the cost of "},{"type":"text","text":"A[i,j]","style":{"code":true}},{"type":"text","text":"  explodes. For some reason this is not the case with "},{"type":"text","text":"Matrix(view(A,i,j))","style":{"code":true}},{"type":"text","text":"  which is obviously not what I want if I want linear scaling"}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"b513256f-cb81-454d-a057-385fa282a26e","type":"message","text":"so basically now I am trying to eliminate the type-instability that wraps the call to `A[i,j]`  in the hopes of gettng the correct behaviour","user":"U01L0RJC6FM","ts":"1617885287.118400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6cfe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so basically now I am trying to eliminate the type-instability that wraps the call to "},{"type":"text","text":"A[i,j]","style":{"code":true}},{"type":"text","text":"  in the hopes of gettng the correct behaviour"}]}]}],"thread_ts":"1617723851.112400","parent_user_id":"U01L0RJC6FM"}]