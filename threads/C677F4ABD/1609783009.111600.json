[{"client_msg_id":"83ea5a66-310f-4225-afc5-ea64ca74d10d","type":"message","text":"What is the best way to do matrix multiplications of the form `C .+= A*P*A^T`, where `P` and `C` are `positive definite` matrices. The code should be compatible with `ForwardDiff`, meaning any of the elements of `A`, `P` or `C` could be of `Dual` type.","user":"UQEDP1Q5V","ts":"1609783009.111600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KOYR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What is the best way to do matrix multiplications of the form "},{"type":"text","text":"C .+= A*P*A^T","style":{"code":true}},{"type":"text","text":", where "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":" are "},{"type":"text","text":"positive definite","style":{"code":true}},{"type":"text","text":" matrices. The code should be compatible with "},{"type":"text","text":"ForwardDiff","style":{"code":true}},{"type":"text","text":", meaning any of the elements of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":" could be of "},{"type":"text","text":"Dual","style":{"code":true}},{"type":"text","text":" type."}]}]}],"thread_ts":"1609783009.111600","reply_count":13,"reply_users_count":3,"latest_reply":"1609785267.114500","reply_users":["UCT7E536E","UQEDP1Q5V","U6A936746"],"subscribed":false},{"client_msg_id":"cd894075-8db0-473b-af0f-6585cc25b6e6","type":"message","text":"Is `A` a `SparseMatrixCSC` ? Or can it be any type?","user":"UCT7E536E","ts":"1609783256.111700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JNK2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" a "},{"type":"text","text":"SparseMatrixCSC","style":{"code":true}},{"type":"text","text":" ? Or can it be any type?"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"0dd6c79f-8169-4393-9c7c-d41c1c381fdb","type":"message","text":"A is of type Matrix{Dual{...}}","user":"UQEDP1Q5V","ts":"1609783403.111900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uaRc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A is of type Matrix{Dual{...}}"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"0ec2a963-ceb3-4a61-9aad-f04493385125","type":"message","text":"if you can make `P` a `PDMat` in advance, then\nI suspect `C .+= X_A_Xt(P, A)` from <https://github.com/JuliaStats/PDMats.jl>\n\nthough not tested this at all","user":"U6A936746","ts":"1609783810.112100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RGQnU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you can make "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" a "},{"type":"text","text":"PDMat","style":{"code":true}},{"type":"text","text":" in advance, then\nI suspect "},{"type":"text","text":"C .+= X_A_Xt(P, A)","style":{"code":true}},{"type":"text","text":" from "},{"type":"link","url":"https://github.com/JuliaStats/PDMats.jl"},{"type":"text","text":"\n\nthough not tested this at all"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"0b4c9c41-4d83-4dac-b82b-4a54ab499cbc","type":"message","text":"If it were BLAS_compatible (for the sake of illustration), I would do it as follows:\n• Compute `P = LL'` (cholesky factorization)\n• Compute `B = A * L`\n• Compute `C += BB'` , for which one can use the `syrk!` function (which only updates one triangle of `C`)\nIf the (i) Cholesky factorization is not too expensive (e.g. `P` is diagonal) and (ii) you might use it several times, then I'd say something along those lines would be the fastest.\nAn alternative to the Cholesky part is to do `B = A*P` and then `C += B*A'`  (so you do 2 matrix-matrix products).\n\nThe motivation for using `C += BB'` is that you can use a more efficient `syrk!` -like implementation.","user":"UCT7E536E","ts":"1609783878.112300","team":"T68168MUP","edited":{"user":"UCT7E536E","ts":"1609783964.000000"},"blocks":[{"type":"rich_text","block_id":"HuP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If it were BLAS_compatible (for the sake of illustration), I would do it as follows:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Compute "},{"type":"text","text":"P = LL'","style":{"code":true}},{"type":"text","text":" (cholesky factorization)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Compute "},{"type":"text","text":"B = A * L","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Compute "},{"type":"text","text":"C += BB'","style":{"code":true}},{"type":"text","text":" , for which one can use the "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" function (which only updates one triangle of "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":")"}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"If the (i) Cholesky factorization is not too expensive (e.g. "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" is diagonal) and (ii) you might use it several times, then I'd say something along those lines would be the fastest.\nAn alternative to the Cholesky part is to do "},{"type":"text","text":"B = A*P","style":{"code":true}},{"type":"text","text":" and then "},{"type":"text","text":"C += B*A'","style":{"code":true}},{"type":"text","text":"  (so you do 2 matrix-matrix products).\n\nThe motivation for using "},{"type":"text","text":"C += BB'","style":{"code":true}},{"type":"text","text":" is that you can use a more efficient "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" -like implementation."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"72ff3e69-5b89-424c-b423-6929dd2efc2d","type":"message","text":"I have not tried that in some time, but last time I could not get the Dual numbers through `PDMat`.","user":"UQEDP1Q5V","ts":"1609783911.112500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DQuOR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have not tried that in some time, but last time I could not get the Dual numbers through "},{"type":"text","text":"PDMat","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V","reactions":[{"name":"disappointed","users":["U6A936746"],"count":1}]},{"client_msg_id":"e24aba78-486c-468b-81be-a90275f67619","type":"message","text":"`syrk!` is an option if I add a custom differentiation rule, or maybe some other Julia AD is compatible with `syrk!`.","user":"UQEDP1Q5V","ts":"1609784282.112800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k/j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" is an option if I add a custom differentiation rule, or maybe some other Julia AD is compatible with "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"f3b45f3f-6e23-4726-afea-e78a55a78225","type":"message","text":"I think `syrk!` is only defined in BLAS, so you would have to implement your own :confused:\nIt's pretty straightforward to do (I did it a couple years back), but unless you know how to use blocking (I didn't :shrug: ) performance is quite bad for large-ish matrices.","user":"UCT7E536E","ts":"1609784544.113100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tcoq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" is only defined in BLAS, so you would have to implement your own "},{"type":"emoji","name":"confused"},{"type":"text","text":"\nIt's pretty straightforward to do (I did it a couple years back), but unless you know how to use blocking (I didn't "},{"type":"emoji","name":"shrug"},{"type":"text","text":" ) performance is quite bad for large-ish matrices."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"9616c872-57ab-47c7-a1f8-d3de9c417c33","type":"message","text":"5-arg  `mul!`  will all `syrk!` if you give it appropriate inputs\n<https://github.com/JuliaLang/julia/blob/5be3e27e029835cb56dd6934d302680c26f6e21b/stdlib/LinearAlgebra/src/matmul.jl#L371>\n\nWeirdly I can’t find the bit where it guards against non-BLAS floats.\nWhich it should have,  so that it falls back to a generic methods.\nthey are probably there and i am just missing them","user":"U6A936746","ts":"1609784587.113300","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1609784668.000000"},"blocks":[{"type":"rich_text","block_id":"7SIP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"5-arg  "},{"type":"text","text":"mul!","style":{"code":true}},{"type":"text","text":"  will all "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" if you give it appropriate inputs\n"},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/5be3e27e029835cb56dd6934d302680c26f6e21b/stdlib/LinearAlgebra/src/matmul.jl#L371"},{"type":"text","text":"\n\nWeirdly I can’t find the bit where it guards against non-BLAS floats.\nWhich it should have,  so that it falls back to a generic methods.\nthey are probably there and i am just missing them"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"daed856a-57bb-4154-bb2b-566f1fa94b74","type":"message","text":"I don't think it does:\n```methods(LinearAlgebra.syrk_wrapper!)                                                                                                                                                                                                  # 3 methods for generic function \"syrk_wrapper!\":                                                                                                                                                                                            [1] syrk_wrapper!(C::StridedArray{T, 2}, tA::AbstractChar, A::StridedVecOrMat{T}) where T&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64} in LinearAlgebra at /opt/julia/1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:476                                                                                                                                                                                                                                       [2] syrk_wrapper!(C::StridedArray{T, 2}, tA::AbstractChar, A::StridedVecOrMat{T}, α::Number) where T&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64} in LinearAlgebra at /opt/julia/1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:476                                                                                                                                                                                                                            [3] syrk_wrapper!(C::StridedArray{T, 2}, tA::AbstractChar, A::StridedVecOrMat{T}, α::Number, β::Number) where T&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64} in LinearAlgebra at /opt/julia/1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:476```","user":"UCT7E536E","ts":"1609784878.113600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"anQ7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think it does:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"methods(LinearAlgebra.syrk_wrapper!)                                                                                                                                                                                                  # 3 methods for generic function \"syrk_wrapper!\":                                                                                                                                                                                            [1] syrk_wrapper!(C::StridedArray{T, 2}, tA::AbstractChar, A::StridedVecOrMat{T}) where T<:Union{Complex{Float32}, Complex{Float64}, Float32, Float64} in LinearAlgebra at /opt/julia/1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:476                                                                                                                                                                                                                                       [2] syrk_wrapper!(C::StridedArray{T, 2}, tA::AbstractChar, A::StridedVecOrMat{T}, α::Number) where T<:Union{Complex{Float32}, Complex{Float64}, Float32, Float64} in LinearAlgebra at /opt/julia/1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:476                                                                                                                                                                                                                            [3] syrk_wrapper!(C::StridedArray{T, 2}, tA::AbstractChar, A::StridedVecOrMat{T}, α::Number, β::Number) where T<:Union{Complex{Float32}, Complex{Float64}, Float32, Float64} in LinearAlgebra at /opt/julia/1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:476"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"d1fbf617-e36a-437c-9e19-6eb561fbb986","type":"message","text":"That should then give an error at some point which would be a julia bug, right?","user":"U6A936746","ts":"1609784908.113800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C9K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That should then give an error at some point which would be a julia bug, right?"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"80ce6399-c304-4121-912e-a5a625e7efd5","type":"message","text":"The method you pointed only handles dense matrices and BlasFloat types, so I would say no.\nI guess for other eltypes it just uses the generic `mul!`","user":"UCT7E536E","ts":"1609785050.114000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5BC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The method you pointed only handles dense matrices and BlasFloat types, so I would say no.\nI guess for other eltypes it just uses the generic "},{"type":"text","text":"mul!","style":{"code":true}}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"c51f711c-f98f-4280-95e2-6699d1df9490","type":"message","text":"I doubt you will find an AD with `syrk!`  defined.\nNabla has a bunch of BLAS rules, defined, and it doesn’t have `syrk!`.\nZygote doesn’t support mutation so it doesn’t have `syrk!`\nDefining custom rules for matrixes is hard in ForwardDiff.\nForwardDiff2 will fix that if it ever comes back (but doesn’t yet because ChainRules doesn’t have custom rule `syrk!` , though it has other BLAS rules, not not `syrk` nor `syrk!`)\nYota has no BLAS rules,\nAutoGrad.jl has no BLAS rules\nReverseDiff.jl has no BLAS rules\nTracker.jl has no BLAS rules","user":"U6A936746","ts":"1609785152.114200","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1609785199.000000"},"blocks":[{"type":"rich_text","block_id":"5yVxy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I doubt you will find an AD with "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":"  defined.\nNabla has a bunch of BLAS rules, defined, and it doesn’t have "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":".\nZygote doesn’t support mutation so it doesn’t have "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":"\nDefining custom rules for matrixes is hard in ForwardDiff.\nForwardDiff2 will fix that if it ever comes back (but doesn’t yet because ChainRules doesn’t have custom rule "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" , though it has other BLAS rules, not not "},{"type":"text","text":"syrk","style":{"code":true}},{"type":"text","text":" nor "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":")\nYota has no BLAS rules,\nAutoGrad.jl has no BLAS rules\nReverseDiff.jl has no BLAS rules\nTracker.jl has no BLAS rules"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"5c34600d-3ef5-4997-84c9-eb1adf6bba3f","type":"message","text":"&gt;  The method you pointed only handles dense matrices and BlasFloat types, so I would say no.\n&gt; I guess for other eltypes it just uses the generic `mul!`\nAh, i didn’t read the second line.\nyes, you are correct","user":"U6A936746","ts":"1609785267.114500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tec","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" The method you pointed only handles dense matrices and BlasFloat types, so I would say no.\nI guess for other eltypes it just uses the generic "},{"type":"text","text":"mul!","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, i didn’t read the second line.\nyes, you are correct"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"}]