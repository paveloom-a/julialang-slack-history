[{"client_msg_id":"83ea5a66-310f-4225-afc5-ea64ca74d10d","type":"message","text":"What is the best way to do matrix multiplications of the form `C .+= A*P*A^T`, where `P` and `C` are `positive definite` matrices. The code should be compatible with `ForwardDiff`, meaning any of the elements of `A`, `P` or `C` could be of `Dual` type.","user":"UQEDP1Q5V","ts":"1609783009.111600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KOYR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What is the best way to do matrix multiplications of the form "},{"type":"text","text":"C .+= A*P*A^T","style":{"code":true}},{"type":"text","text":", where "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":" are "},{"type":"text","text":"positive definite","style":{"code":true}},{"type":"text","text":" matrices. The code should be compatible with "},{"type":"text","text":"ForwardDiff","style":{"code":true}},{"type":"text","text":", meaning any of the elements of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":" could be of "},{"type":"text","text":"Dual","style":{"code":true}},{"type":"text","text":" type."}]}]}],"thread_ts":"1609783009.111600","reply_count":6,"reply_users_count":3,"latest_reply":"1609784282.112800","reply_users":["UCT7E536E","UQEDP1Q5V","U6A936746"],"subscribed":false},{"client_msg_id":"cd894075-8db0-473b-af0f-6585cc25b6e6","type":"message","text":"Is `A` a `SparseMatrixCSC` ? Or can it be any type?","user":"UCT7E536E","ts":"1609783256.111700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JNK2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" a "},{"type":"text","text":"SparseMatrixCSC","style":{"code":true}},{"type":"text","text":" ? Or can it be any type?"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"0dd6c79f-8169-4393-9c7c-d41c1c381fdb","type":"message","text":"A is of type Matrix{Dual{...}}","user":"UQEDP1Q5V","ts":"1609783403.111900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uaRc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A is of type Matrix{Dual{...}}"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"0ec2a963-ceb3-4a61-9aad-f04493385125","type":"message","text":"if you can make `P` a `PDMat` in advance, then\nI suspect `C .+= X_A_Xt(P, A)` from <https://github.com/JuliaStats/PDMats.jl>\n\nthough not tested this at all","user":"U6A936746","ts":"1609783810.112100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RGQnU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you can make "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" a "},{"type":"text","text":"PDMat","style":{"code":true}},{"type":"text","text":" in advance, then\nI suspect "},{"type":"text","text":"C .+= X_A_Xt(P, A)","style":{"code":true}},{"type":"text","text":" from "},{"type":"link","url":"https://github.com/JuliaStats/PDMats.jl"},{"type":"text","text":"\n\nthough not tested this at all"}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"0b4c9c41-4d83-4dac-b82b-4a54ab499cbc","type":"message","text":"If it were BLAS_compatible (for the sake of illustration), I would do it as follows:\n• Compute `P = LL'` (cholesky factorization)\n• Compute `B = A * L`\n• Compute `C += BB'` , for which one can use the `syrk!` function (which only updates one triangle of `C`)\nIf the (i) Cholesky factorization is not too expensive (e.g. `P` is diagonal) and (ii) you might use it several times, then I'd say something along those lines would be the fastest.\nAn alternative to the Cholesky part is to do `B = A*P` and then `C += B*A'`  (so you do 2 matrix-matrix products).\n\nThe motivation for using `C += BB'` is that you can use a more efficient `syrk!` -like implementation.","user":"UCT7E536E","ts":"1609783878.112300","team":"T68168MUP","edited":{"user":"UCT7E536E","ts":"1609783964.000000"},"blocks":[{"type":"rich_text","block_id":"HuP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If it were BLAS_compatible (for the sake of illustration), I would do it as follows:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Compute "},{"type":"text","text":"P = LL'","style":{"code":true}},{"type":"text","text":" (cholesky factorization)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Compute "},{"type":"text","text":"B = A * L","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Compute "},{"type":"text","text":"C += BB'","style":{"code":true}},{"type":"text","text":" , for which one can use the "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" function (which only updates one triangle of "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":")"}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"If the (i) Cholesky factorization is not too expensive (e.g. "},{"type":"text","text":"P","style":{"code":true}},{"type":"text","text":" is diagonal) and (ii) you might use it several times, then I'd say something along those lines would be the fastest.\nAn alternative to the Cholesky part is to do "},{"type":"text","text":"B = A*P","style":{"code":true}},{"type":"text","text":" and then "},{"type":"text","text":"C += B*A'","style":{"code":true}},{"type":"text","text":"  (so you do 2 matrix-matrix products).\n\nThe motivation for using "},{"type":"text","text":"C += BB'","style":{"code":true}},{"type":"text","text":" is that you can use a more efficient "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" -like implementation."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"},{"client_msg_id":"72ff3e69-5b89-424c-b423-6929dd2efc2d","type":"message","text":"I have not tried that in some time, but last time I could not get the Dual numbers through `PDMat`.","user":"UQEDP1Q5V","ts":"1609783911.112500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DQuOR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have not tried that in some time, but last time I could not get the Dual numbers through "},{"type":"text","text":"PDMat","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V","reactions":[{"name":"disappointed","users":["U6A936746"],"count":1}]},{"client_msg_id":"e24aba78-486c-468b-81be-a90275f67619","type":"message","text":"`syrk!` is an option if I add a custom differentiation rule, or maybe some other Julia AD is compatible with `syrk!`.","user":"UQEDP1Q5V","ts":"1609784282.112800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k/j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":" is an option if I add a custom differentiation rule, or maybe some other Julia AD is compatible with "},{"type":"text","text":"syrk!","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609783009.111600","parent_user_id":"UQEDP1Q5V"}]