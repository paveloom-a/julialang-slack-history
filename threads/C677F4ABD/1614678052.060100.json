[{"client_msg_id":"6ef28f67-8a0b-430c-8f77-d5f2a3827b21","type":"message","text":"I have some complex code involving compound types with sparse matrices in them. To make the code a bit more cleaner and readable, I introduced these redefinitions, which allow for Matlab-like behaviour, allowing sparse right-hand sides. (I know memory is not an issue)\n```ldiv!(A::Factorization, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::Factorization, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::Factorization) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::Factorization) = rdiv!(Vector(A), B)\nldiv!(A::AbstractMatrix, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::AbstractMatrix, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::AbstractMatrix) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::AbstractMatrix) = rdiv!(Vector(A), B)```\nHowever, I get this warning: An imported function has been extended without using module defined typed arguments. Any clues on how to resolve this?","user":"U01L0RJC6FM","ts":"1614678052.060100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Sxp8y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have some complex code involving compound types with sparse matrices in them. To make the code a bit more cleaner and readable, I introduced these redefinitions, which allow for Matlab-like behaviour, allowing sparse right-hand sides. (I know memory is not an issue)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ldiv!(A::Factorization, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::Factorization, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::Factorization) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::Factorization) = rdiv!(Vector(A), B)\nldiv!(A::AbstractMatrix, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::AbstractMatrix, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::AbstractMatrix) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::AbstractMatrix) = rdiv!(Vector(A), B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"However, I get this warning: An imported function has been extended without using module defined typed arguments. Any clues on how to resolve this?"}]}]}],"thread_ts":"1614678052.060100","reply_count":30,"reply_users_count":4,"latest_reply":"1614723073.079500","reply_users":["UCZ7VBGUD","UB197FRCL","U011TRN4QBU","U01L0RJC6FM"],"subscribed":false},{"client_msg_id":"49BAFDB3-3EE5-477F-9366-82818761C58D","type":"message","text":"This warning is because this kind of definition is “type piracy” (<https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy|https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy>). This particular case is probably not a very dangerous one because it changes code that errors into code that runs (instead of changing code that runs to code that does something else). But it’s generally not good practice to have such code in packages because it changes the behavior for all users and downstream packages. (It can be very convenient and powerful in scripts though, as long as you’re aware of what you’re doing).","user":"UCZ7VBGUD","ts":"1614679060.067000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ez/dX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This warning is because this kind of definition is “type piracy” ("},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy","text":"https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy"},{"type":"text","text":"). This particular case is probably not a very dangerous one because it changes code that errors into code that runs (instead of changing code that runs to code that does something else). But it’s generally not good practice to have such code in packages because it changes the behavior for all users and downstream packages. (It can be very convenient and powerful in scripts though, as long as you’re aware of what you’re doing)."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"3a529575-57e8-42bb-942f-2c1c5615a239","type":"message","text":"I'm not sure this is quite the right way to do this. It seems to me like a more complicated way to just do `A \\ B` and `B / A` , since your new methods for `ldiv!` and `rdiv!` are actually not in-place functions and don't mutate `B`. (And afterall it makes sense that `ldiv!` and `rdiv!` don't work for sparse `B` , since there is no way to know if `A \\ B` or `B / A` wouldn't fill `B` in entries that were structural zeros.) But maybe I'm missing something here?","user":"UB197FRCL","ts":"1614686249.067300","team":"T68168MUP","edited":{"user":"UB197FRCL","ts":"1614686270.000000"},"blocks":[{"type":"rich_text","block_id":"fxDil","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure this is quite the right way to do this. It seems to me like a more complicated way to just do "},{"type":"text","text":"A \\ B","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B / A","style":{"code":true}},{"type":"text","text":" , since your new methods for "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rdiv!","style":{"code":true}},{"type":"text","text":" are actually not in-place functions and don't mutate "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":". (And afterall it makes sense that "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rdiv!","style":{"code":true}},{"type":"text","text":" don't work for sparse "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" , since there is no way to know if "},{"type":"text","text":"A \\ B","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"B / A","style":{"code":true}},{"type":"text","text":" wouldn't fill "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" in entries that were structural zeros.) But maybe I'm missing something here?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"71bb3777-ec72-4c3f-848a-8df2f0349936","type":"message","text":"I also think that this might fail silently, e.g., if you have a line in your code doing just\n```ldiv!(A, B)```\nexpecting to mutate `B`. Then your methods will actually not do anything (to `B`). To modify `B`, you'd have to either write\n```B .= ldiv!(A, B)```\nbut then this would not work with sparse `B` , or write\n```B = lidv!(A, B)```\nbut then this is not inplace anyway and you might as well have used\n```B = A \\ B```\nfrom the start.","user":"UB197FRCL","ts":"1614686702.067600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kou","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I also think that this might fail silently, e.g., if you have a line in your code doing just\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ldiv!(A, B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"expecting to mutate "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":". Then your methods will actually not do anything (to "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":"). To modify "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":", you'd have to either write\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"B .= ldiv!(A, B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but then this would not work with sparse "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" , or write\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"B = lidv!(A, B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but then this is not inplace anyway and you might as well have used\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"B = A \\ B"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"from the start."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"71a55f04-bef3-44f9-8933-f30605324515","type":"message","text":"I agree with what has been said and would like to add a little something. If anything, you should _not_ overwrite the action of `ldiv!` and `rdiv!` for `AbstractSparseMatrix`, but only for your own type, and refer to the sparse matrix field, say, `MyType.smat`. That keeps you from committing type piracy, because you own the decisive type.","user":"U011TRN4QBU","ts":"1614719105.067800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BBz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree with what has been said and would like to add a little something. If anything, you should "},{"type":"text","text":"not","style":{"italic":true}},{"type":"text","text":" overwrite the action of "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rdiv!","style":{"code":true}},{"type":"text","text":" for "},{"type":"text","text":"AbstractSparseMatrix","style":{"code":true}},{"type":"text","text":", but only for your own type, and refer to the sparse matrix field, say, "},{"type":"text","text":"MyType.smat","style":{"code":true}},{"type":"text","text":". That keeps you from committing type piracy, because you own the decisive type."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"9d9e2727-a5ac-4619-87fb-4646afcf4561","type":"message","text":"Thanks for all the helpful input! In fact I realized that I would have to probably modify `ldiv!(Y, A, B)` . (But not sure that would be the right way to do it either)\nJust to clarify and follow up on the question: I have my own struct which is a 2x2 block matrix, where individual blocks can be all sorts of matrices. I would like to implement routines for applying the inverse of the block matrix which calls `\\` and `/` . Sometimes, this happens with sparse right-hand sides but rewriting everything with `Matrix(...)` would be cumbersome and involve a lot of code-duplication as I do not want to always typecast to dense matrices. I really appreciate all your help and any pointers on how to do this in the best way possible!","user":"U01L0RJC6FM","ts":"1614719654.068000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z/ACR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for all the helpful input! In fact I realized that I would have to probably modify "},{"type":"text","text":"ldiv!(Y, A, B)","style":{"code":true}},{"type":"text","text":" . (But not sure that would be the right way to do it either)\nJust to clarify and follow up on the question: I have my own struct which is a 2x2 block matrix, where individual blocks can be all sorts of matrices. I would like to implement routines for applying the inverse of the block matrix which calls "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"/","style":{"code":true}},{"type":"text","text":" . Sometimes, this happens with sparse right-hand sides but rewriting everything with "},{"type":"text","text":"Matrix(...)","style":{"code":true}},{"type":"text","text":" would be cumbersome and involve a lot of code-duplication as I do not want to always typecast to dense matrices. I really appreciate all your help and any pointers on how to do this in the best way possible!"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"B0054ABF-DAD9-42F2-A243-49B7DA470C28","type":"message","text":"But I don’t think you need to add anything for `/` or `\\` to work.","user":"UB197FRCL","ts":"1614719927.069500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0nw+6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I don’t think you need to add anything for "},{"type":"text","text":"/","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" to work."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"FCB753F2-E92E-46BC-B551-C2373A5108AA","type":"message","text":"Are you using a block matrix package?","user":"UB197FRCL","ts":"1614719980.070300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NIU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Are you using a block matrix package?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"138651D2-806D-428E-B543-317075E260D5","type":"message","text":"(BlockArrays is the biggest one IIRC)","user":"UB197FRCL","ts":"1614720002.071000","team":"T68168MUP","edited":{"user":"UB197FRCL","ts":"1614720039.000000"},"blocks":[{"type":"rich_text","block_id":"ZPcsr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(BlockArrays is the biggest one IIRC)"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"237d0c05-06db-4982-9c6f-749139e478a5","type":"message","text":"no I am avoiding it, because it handles a few things differently from what I need. I really only need 2x2 matrices and some of them are of my own type (HSS matrices)","user":"U01L0RJC6FM","ts":"1614720048.071300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"H9i2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no I am avoiding it, because it handles a few things differently from what I need. I really only need 2x2 matrices and some of them are of my own type (HSS matrices)"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM","reactions":[{"name":"+1","users":["UB197FRCL"],"count":1}]},{"client_msg_id":"6ad75000-b732-4ef3-847d-75753ef3ad5f","type":"message","text":"`sprandn(100,100,0.3)\\sprandn(100,5,0.1)`","user":"U01L0RJC6FM","ts":"1614720088.071800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QQ=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sprandn(100,100,0.3)\\sprandn(100,5,0.1)","style":{"code":true}}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"009e1fb2-1dce-437b-8dcd-5eb710fe6c4c","type":"message","text":"this gives me an error that there is no `ldiv!` for sparse rhs","user":"U01L0RJC6FM","ts":"1614720109.072500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zAlT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"this gives me an error that there is no "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" for sparse rhs"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"1DDFDE9B-982B-406F-BD87-6988DEEFB513","type":"message","text":"Oh I did not know that","user":"UB197FRCL","ts":"1614720151.073100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2YC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh I did not know that"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"590ab961-fb45-442a-9ece-a0c74dd83ad8","type":"message","text":"I believe the idea is to avoid memory issues. The downside of course is that writing `A\\Matrix(B)` everywhere is not only cumbersome but sometimes just bad if you for instance have abstract types where you want to avoid the typecast to dense","user":"U01L0RJC6FM","ts":"1614720319.073600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t/wf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I believe the idea is to avoid memory issues. The downside of course is that writing "},{"type":"text","text":"A\\Matrix(B)","style":{"code":true}},{"type":"text","text":" everywhere is not only cumbersome but sometimes just bad if you for instance have abstract types where you want to avoid the typecast to dense"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"51B0CA85-1201-42EE-8D86-314E9E63CAE7","type":"message","text":"Is there a reason to avoid dense RHS?","user":"UB197FRCL","ts":"1614720409.074300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1WbR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a reason to avoid dense RHS?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"8f33a1c2-0783-437c-949d-010fc3e97603","type":"message","text":"The reason why there’s no sparse rhs inplace solver was mentioned earlier: in general you cannot know that your solution is “sparse”.","user":"U011TRN4QBU","ts":"1614720425.074500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yJWuh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The reason why there’s no sparse rhs inplace solver was mentioned earlier: in general you cannot know that your solution is “sparse”."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"6F15E16B-6435-45AF-8FE6-6923C8CDC7DF","type":"message","text":"~Yea but I thought it would return a dense vector or matrix~ ","user":"UB197FRCL","ts":"1614720497.075600","team":"T68168MUP","edited":{"user":"UB197FRCL","ts":"1614720543.000000"},"blocks":[{"type":"rich_text","block_id":"mlF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yea but I thought it would return a dense vector or matrix ","style":{"strike":true}}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"9DFF7D32-23C2-4B51-9740-515B629D5DDC","type":"message","text":"Sorry, misread your message. ","user":"UB197FRCL","ts":"1614720523.076200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DRr1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry, misread your message. "}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"A0C9710B-29C1-46C1-A95F-1398E24C9941","type":"message","text":"But why is there no sparse RHS backslash ?","user":"UB197FRCL","ts":"1614720567.077100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O7=u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But why is there no sparse RHS backslash ?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ce51b244-2a5b-46cf-83fa-26c6faea2525","type":"message","text":"yes, dense matrix as return is what Matlab does. I believe it's just a philosophical decision","user":"U01L0RJC6FM","ts":"1614720611.077300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LlfY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, dense matrix as return is what Matlab does. I believe it's just a philosophical decision"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ad54754c-bc00-48c2-9e18-fd479e333806","type":"message","text":"It’s not wise to represent a dense matrix by a sparse type: you need way more(!) memory, and subsequent steps may be much slower than with a LAPACK-suitable matrix.","user":"U011TRN4QBU","ts":"1614720824.077500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I4L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s not wise to represent a dense matrix by a sparse type: you need way more(!) memory, and subsequent steps may be much slower than with a LAPACK-suitable matrix."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"f33fb0f5-4fcd-4ec0-b4ca-f711330ef1c1","type":"message","text":"Yea, and returning a dense vector is no longer “inplace”. I think it’s designed to make the user think what (s)he really needs, and which price to accept. You can use `convert(Matrix, A)` to make `A` dense when it is sparse, and it is a no-op for dense matrices.","user":"U011TRN4QBU","ts":"1614720949.077700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b0ss","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yea, and returning a dense vector is no longer “inplace”. I think it’s designed to make the user think what (s)he really needs, and which price to accept. You can use "},{"type":"text","text":"convert(Matrix, A)","style":{"code":true}},{"type":"text","text":" to make "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" dense when it is sparse, and it is a no-op for dense matrices."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"3db0b6f9-ffb6-4a17-b184-1b1d2891f656","type":"message","text":"hmm, but what if sometimes `A\\B`  gets called with HSS matrices or Low-rank matrices where I want the respective routines to be used?","user":"U01L0RJC6FM","ts":"1614721026.077900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0k5t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm, but what if sometimes "},{"type":"text","text":"A\\B","style":{"code":true}},{"type":"text","text":"  gets called with HSS matrices or Low-rank matrices where I want the respective routines to be used?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"2d0ea468-6784-4c8e-a4da-873239a6697c","type":"message","text":"it just seems contrary to Julia's philosophy and benefits to having to rewrite this code for each instance of types that I am getting","user":"U01L0RJC6FM","ts":"1614721063.078100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e3G1f","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it just seems contrary to Julia's philosophy and benefits to having to rewrite this code for each instance of types that I am getting"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"0c203f89-3572-4e9c-86a9-25ef972daf1b","type":"message","text":"You could write your own `\\`  like `mysolve`, which falls back to `\\` generically but uses converts or other special functions in specific cases. That’s more like the multiple dispatch approach.","user":"U011TRN4QBU","ts":"1614721222.078300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pyx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could write your own "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":"  like "},{"type":"text","text":"mysolve","style":{"code":true}},{"type":"text","text":", which falls back to "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" generically but uses converts or other special functions in specific cases. That’s more like the multiple dispatch approach."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"5572ff4d-8d7f-49fb-befc-69dc2f36acee","type":"message","text":"oh I see, so basically I do the same as before but I just avoid the type piracy?","user":"U01L0RJC6FM","ts":"1614721263.078500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fB2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh I see, so basically I do the same as before but I just avoid the type piracy?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"bd58a741-0030-42f2-926a-24c8a6ba70d3","type":"message","text":"It seems like you’re trying to insist of using `\\` when there is good reasons for this to be not working in some special cases. So you would avoid this by “copying” `\\` but at the same time teach it how to handle cases `\\` doesn’t. The difference is that `\\` is generic and owned by `LinearAlgebra`, and not everybody may agree with you choice of how to handle, e.g., sparse rhs.","user":"U011TRN4QBU","ts":"1614721366.078700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XH7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems like you’re trying to insist of using "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" when there is good reasons for this to be not working in some special cases. So you would avoid this by “copying” "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" but at the same time teach it how to handle cases "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" doesn’t. The difference is that "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" is generic and owned by "},{"type":"text","text":"LinearAlgebra","style":{"code":true}},{"type":"text","text":", and not everybody may agree with you choice of how to handle, e.g., sparse rhs."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"74eb5795-6d8d-40c1-859c-1ba5c2dcc750","type":"message","text":"If you instead define your own function, there is (i) no chance for type piracy to begin with (you own that function), (ii) it’s fine to still rely on `Base` or stdlib behavior generically, and (iii) any reader of your code will understand that you are doing “own things”, and will know that one has to study that function and its methods in detail.","user":"U011TRN4QBU","ts":"1614721496.078900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"x2tf0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you instead define your own function, there is (i) no chance for type piracy to begin with (you own that function), (ii) it’s fine to still rely on "},{"type":"text","text":"Base","style":{"code":true}},{"type":"text","text":" or stdlib behavior generically, and (iii) any reader of your code will understand that you are doing “own things”, and will know that one has to study that function and its methods in detail."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM","reactions":[{"name":"clap","users":["U01L0RJC6FM"],"count":1}]},{"client_msg_id":"87cc4778-93f7-4633-b3ee-07f48c0bf817","type":"message","text":"yes I see, in fact you are right in that I would have liked to use `\\`  for the purpose of readability but my main goal of asking this question was to understand how to do it in the \"right\" way, while avoiding code duplication as much as possible.","user":"U01L0RJC6FM","ts":"1614722925.079100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JGR0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes I see, in fact you are right in that I would have liked to use "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":"  for the purpose of readability but my main goal of asking this question was to understand how to do it in the \"right\" way, while avoiding code duplication as much as possible."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"e7fab401-9ae6-45f0-a7c6-708cf2cc1809","type":"message","text":"So to reiterate the right thing to do is to have my own function that just defaults to `A\\B` or `A\\convert(Matrix,B)`  depending on whether `A` is sparse or not.","user":"U01L0RJC6FM","ts":"1614723028.079300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gX/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So to reiterate the right thing to do is to have my own function that just defaults to "},{"type":"text","text":"A\\B","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"A\\convert(Matrix,B)","style":{"code":true}},{"type":"text","text":"  depending on whether "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" is sparse or not."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"5fe17a26-cb7c-47f4-9eb7-70879a47a41e","type":"message","text":"I really appreciate all your answers, thanks a lot for your time and help :slightly_smiling_face:","user":"U01L0RJC6FM","ts":"1614723073.079500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tXnPJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I really appreciate all your answers, thanks a lot for your time and help "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"}]