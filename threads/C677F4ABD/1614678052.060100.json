[{"client_msg_id":"6ef28f67-8a0b-430c-8f77-d5f2a3827b21","type":"message","text":"I have some complex code involving compound types with sparse matrices in them. To make the code a bit more cleaner and readable, I introduced these redefinitions, which allow for Matlab-like behaviour, allowing sparse right-hand sides. (I know memory is not an issue)\n```ldiv!(A::Factorization, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::Factorization, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::Factorization) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::Factorization) = rdiv!(Vector(A), B)\nldiv!(A::AbstractMatrix, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::AbstractMatrix, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::AbstractMatrix) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::AbstractMatrix) = rdiv!(Vector(A), B)```\nHowever, I get this warning: An imported function has been extended without using module defined typed arguments. Any clues on how to resolve this?","user":"U01L0RJC6FM","ts":"1614678052.060100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Sxp8y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have some complex code involving compound types with sparse matrices in them. To make the code a bit more cleaner and readable, I introduced these redefinitions, which allow for Matlab-like behaviour, allowing sparse right-hand sides. (I know memory is not an issue)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ldiv!(A::Factorization, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::Factorization, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::Factorization) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::Factorization) = rdiv!(Vector(A), B)\nldiv!(A::AbstractMatrix, B::AbstractSparseMatrix) = ldiv!(A, Matrix(B))\nldiv!(A::AbstractMatrix, B::AbstractSparseVector) = ldiv!(A, Vector(B))\nrdiv!(A::AbstractSparseMatrix, B::AbstractMatrix) = rdiv!(Matrix(A), B)\nrdiv!(A::AbstractSparseVector, B::AbstractMatrix) = rdiv!(Vector(A), B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"However, I get this warning: An imported function has been extended without using module defined typed arguments. Any clues on how to resolve this?"}]}]}],"thread_ts":"1614678052.060100","reply_count":5,"reply_users_count":4,"latest_reply":"1614719654.068000","reply_users":["UCZ7VBGUD","UB197FRCL","U011TRN4QBU","U01L0RJC6FM"],"subscribed":false},{"client_msg_id":"49BAFDB3-3EE5-477F-9366-82818761C58D","type":"message","text":"This warning is because this kind of definition is “type piracy” (<https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy|https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy>). This particular case is probably not a very dangerous one because it changes code that errors into code that runs (instead of changing code that runs to code that does something else). But it’s generally not good practice to have such code in packages because it changes the behavior for all users and downstream packages. (It can be very convenient and powerful in scripts though, as long as you’re aware of what you’re doing).","user":"UCZ7VBGUD","ts":"1614679060.067000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ez/dX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This warning is because this kind of definition is “type piracy” ("},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy","text":"https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy"},{"type":"text","text":"). This particular case is probably not a very dangerous one because it changes code that errors into code that runs (instead of changing code that runs to code that does something else). But it’s generally not good practice to have such code in packages because it changes the behavior for all users and downstream packages. (It can be very convenient and powerful in scripts though, as long as you’re aware of what you’re doing)."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"3a529575-57e8-42bb-942f-2c1c5615a239","type":"message","text":"I'm not sure this is quite the right way to do this. It seems to me like a more complicated way to just do `A \\ B` and `B / A` , since your new methods for `ldiv!` and `rdiv!` are actually not in-place functions and don't mutate `B`. (And afterall it makes sense that `ldiv!` and `rdiv!` don't work for sparse `B` , since there is no way to know if `A \\ B` or `B / A` wouldn't fill `B` in entries that were structural zeros.) But maybe I'm missing something here?","user":"UB197FRCL","ts":"1614686249.067300","team":"T68168MUP","edited":{"user":"UB197FRCL","ts":"1614686270.000000"},"blocks":[{"type":"rich_text","block_id":"fxDil","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure this is quite the right way to do this. It seems to me like a more complicated way to just do "},{"type":"text","text":"A \\ B","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B / A","style":{"code":true}},{"type":"text","text":" , since your new methods for "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rdiv!","style":{"code":true}},{"type":"text","text":" are actually not in-place functions and don't mutate "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":". (And afterall it makes sense that "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rdiv!","style":{"code":true}},{"type":"text","text":" don't work for sparse "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" , since there is no way to know if "},{"type":"text","text":"A \\ B","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"B / A","style":{"code":true}},{"type":"text","text":" wouldn't fill "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" in entries that were structural zeros.) But maybe I'm missing something here?"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"71bb3777-ec72-4c3f-848a-8df2f0349936","type":"message","text":"I also think that this might fail silently, e.g., if you have a line in your code doing just\n```ldiv!(A, B)```\nexpecting to mutate `B`. Then your methods will actually not do anything (to `B`). To modify `B`, you'd have to either write\n```B .= ldiv!(A, B)```\nbut then this would not work with sparse `B` , or write\n```B = lidv!(A, B)```\nbut then this is not inplace anyway and you might as well have used\n```B = A \\ B```\nfrom the start.","user":"UB197FRCL","ts":"1614686702.067600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kou","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I also think that this might fail silently, e.g., if you have a line in your code doing just\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ldiv!(A, B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"expecting to mutate "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":". Then your methods will actually not do anything (to "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":"). To modify "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":", you'd have to either write\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"B .= ldiv!(A, B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but then this would not work with sparse "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" , or write\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"B = lidv!(A, B)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but then this is not inplace anyway and you might as well have used\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"B = A \\ B"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"from the start."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"71a55f04-bef3-44f9-8933-f30605324515","type":"message","text":"I agree with what has been said and would like to add a little something. If anything, you should _not_ overwrite the action of `ldiv!` and `rdiv!` for `AbstractSparseMatrix`, but only for your own type, and refer to the sparse matrix field, say, `MyType.smat`. That keeps you from committing type piracy, because you own the decisive type.","user":"U011TRN4QBU","ts":"1614719105.067800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BBz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree with what has been said and would like to add a little something. If anything, you should "},{"type":"text","text":"not","style":{"italic":true}},{"type":"text","text":" overwrite the action of "},{"type":"text","text":"ldiv!","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rdiv!","style":{"code":true}},{"type":"text","text":" for "},{"type":"text","text":"AbstractSparseMatrix","style":{"code":true}},{"type":"text","text":", but only for your own type, and refer to the sparse matrix field, say, "},{"type":"text","text":"MyType.smat","style":{"code":true}},{"type":"text","text":". That keeps you from committing type piracy, because you own the decisive type."}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"9d9e2727-a5ac-4619-87fb-4646afcf4561","type":"message","text":"Thanks for all the helpful input! In fact I realized that I would have to probably modify `ldiv!(Y, A, B)` . (But not sure that would be the right way to do it either)\nJust to clarify and follow up on the question: I have my own struct which is a 2x2 block matrix, where individual blocks can be all sorts of matrices. I would like to implement routines for applying the inverse of the block matrix which calls `\\` and `/` . Sometimes, this happens with sparse right-hand sides but rewriting everything with `Matrix(...)` would be cumbersome and involve a lot of code-duplication as I do not want to always typecast to dense matrices. I really appreciate all your help and any pointers on how to do this in the best way possible!","user":"U01L0RJC6FM","ts":"1614719654.068000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z/ACR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for all the helpful input! In fact I realized that I would have to probably modify "},{"type":"text","text":"ldiv!(Y, A, B)","style":{"code":true}},{"type":"text","text":" . (But not sure that would be the right way to do it either)\nJust to clarify and follow up on the question: I have my own struct which is a 2x2 block matrix, where individual blocks can be all sorts of matrices. I would like to implement routines for applying the inverse of the block matrix which calls "},{"type":"text","text":"\\","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"/","style":{"code":true}},{"type":"text","text":" . Sometimes, this happens with sparse right-hand sides but rewriting everything with "},{"type":"text","text":"Matrix(...)","style":{"code":true}},{"type":"text","text":" would be cumbersome and involve a lot of code-duplication as I do not want to always typecast to dense matrices. I really appreciate all your help and any pointers on how to do this in the best way possible!"}]}]}],"thread_ts":"1614678052.060100","parent_user_id":"U01L0RJC6FM"}]