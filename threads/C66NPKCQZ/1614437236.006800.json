[{"client_msg_id":"8b1a536f-8728-431b-85b9-48856470abcf","type":"message","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?","user":"UDSG73JTH","ts":"1614437236.006800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KxVV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?"}]}]}],"thread_ts":"1614437236.006800","reply_count":37,"reply_users_count":5,"latest_reply":"1615041937.021800","reply_users":["U67G3QRJM","UGHS7LC64","UDSG73JTH","U72B7LTMX","U67D54KS8"],"subscribed":false},{"client_msg_id":"55bcd9e9-7d59-4bb6-8f71-39cde459dff2","type":"message","text":"What is step differentiation?","user":"U67G3QRJM","ts":"1614448748.007300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rqYGl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What is step differentiation?"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"a50072b9-782b-4c0b-b709-ea207f524490","type":"message","text":"I'm not sure what you are looking for either, but maybe have a look at <https://github.com/JuliaGeometry/Rotations.jl>","user":"UGHS7LC64","ts":"1614451967.007500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ekT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure what you are looking for either, but maybe have a look at "},{"type":"link","url":"https://github.com/JuliaGeometry/Rotations.jl"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"ddee1516-1308-4c64-ae80-2659a6f97dd6","type":"message","text":"I’m using “step” in the same way as is used to describe complex “step” differentiation; $f(x+ih)$. Using quaternions can differentiate (a subset of?) complex functions.","user":"UDSG73JTH","ts":"1614454508.007700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b5DE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m using “step” in the same way as is used to describe complex “step” differentiation; $f(x+ih)$. Using quaternions can differentiate (a subset of?) complex functions."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"df92daf0-962b-4d0a-8d41-60b441d999bd","type":"message","text":"So it seems like it should just be 1 line of Julia to do yourself?","user":"U67G3QRJM","ts":"1614455828.008000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HeMMH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So it seems like it should just be 1 line of Julia to do yourself?"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"6b6aa595-d583-4aba-9589-7ecc6d9edfcf","type":"message","text":"That does seem like it might be a good idea, though","user":"U67G3QRJM","ts":"1614456158.008200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/BonO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That does seem like it might be a good idea, though"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"b0514388-5192-4450-8b91-aaf2ffd26d35","type":"message","text":"<https://arxiv.org/abs/2010.09543>","user":"U67G3QRJM","ts":"1614456198.008400","team":"T68168MUP","attachments":[{"service_name":"arXiv.org","title":"Quaternionic Step Derivative: Automatic Differentiation of...","title_link":"https://arxiv.org/abs/2010.09543","text":"Complex Step Derivative (CSD) allows easy and accurate differentiation up to machine precision of real functions by evaluating them a small imaginary step next to the real line. The current paper...","fallback":"arXiv.org: Quaternionic Step Derivative: Automatic Differentiation of...","from_url":"https://arxiv.org/abs/2010.09543","service_icon":"https://static.arxiv.org/static/browse/0.3.2.6/images/icons/favicon.ico","id":1,"original_url":"https://arxiv.org/abs/2010.09543"}],"blocks":[{"type":"rich_text","block_id":"YRE","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://arxiv.org/abs/2010.09543"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"9d89fcf5-79f6-4060-892b-89366ff60669","type":"message","text":"It seems as though it should. I had a quick go, but it didn’t work out according to my (naive?) expectiations.","user":"UDSG73JTH","ts":"1614521399.008700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dhs8y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems as though it should. I had a quick go, but it didn’t work out according to my (naive?) expectiations."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"8766fe8b-db17-4953-b363-5a3c47a2ef14","type":"message","text":"That’s the article I found. I haven’t read it yet though.","user":"UDSG73JTH","ts":"1614521481.008900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nQsR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s the article I found. I haven’t read it yet though."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"a70c7fbb-e900-4bb4-bf53-cbf5a7f80965","type":"message","text":":sweat_smile: the first paragraph of section 2…","user":"UDSG73JTH","ts":"1614522472.009100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P/QU","elements":[{"type":"rich_text_section","elements":[{"type":"emoji","name":"sweat_smile"},{"type":"text","text":" the first paragraph of section 2…"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"52812daa-abfb-4bcc-8bf8-28dad81a3924","type":"message","text":"Why not just use automatic differentiation? Although I'm not sure which package can handle complex numbers right now.","user":"U67G3QRJM","ts":"1614524538.009300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rkAgl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why not just use automatic differentiation? Although I'm not sure which package can handle complex numbers right now."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"point_up","users":["U6A936746","U72B7LTMX"],"count":2}]},{"client_msg_id":"ca52c306-2017-4be7-bb22-93235152cabb","type":"message","text":"I don’t think any can handle complex numbers yet. I need to evaluate the derivative of functions at complex locations in a way that’s amenable to forward rather than reverse differentiation.","user":"UDSG73JTH","ts":"1614525788.009500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Y2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t think any can handle complex numbers yet. I need to evaluate the derivative of functions at complex locations in a way that’s amenable to forward rather than reverse differentiation."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"8c7cdfaa-b692-436e-8919-869b843e6a9f","type":"message","text":"Did you try forwarddiff.jl? It now is supposed to have \"limited support\" for complex functions","user":"U67G3QRJM","ts":"1614537975.009700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5K9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Did you try forwarddiff.jl? It now is supposed to have \"limited support\" for complex functions"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"3ce0466e-1a4f-4b05-9678-0601d450fda9","type":"message","text":"Just tried it. Seems my use case is outside of the supported functionality\n```julia&gt; ForwardDiff.derivative(f, x)\nERROR: MethodError: no method matching derivative(::typeof(f), ::ComplexF64)\nClosest candidates are:\n  derivative(::F, ::R) where {F, R&lt;:Real}```","user":"UDSG73JTH","ts":"1614538142.009900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ynweB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just tried it. Seems my use case is outside of the supported functionality\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> ForwardDiff.derivative(f, x)\nERROR: MethodError: no method matching derivative(::typeof(f), ::ComplexF64)\nClosest candidates are:\n  derivative(::F, ::R) where {F, R<:Real}"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"0baff3d4-7e4a-4c21-a4ec-f28d02a34f36","type":"message","text":"<@U67G3QRJM> I made a gist of a working (but susceptible to floating point errors) implementation <https://gist.github.com/jwscook/e096706547684ef091dd8c3b98b611cb>","user":"UDSG73JTH","ts":"1614715475.010900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R8f","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":" I made a gist of a working (but susceptible to floating point errors) implementation "},{"type":"link","url":"https://gist.github.com/jwscook/e096706547684ef091dd8c3b98b611cb"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"5feaed7a-fa8a-4fc3-9618-ed96121ec773","type":"message","text":"Any ad is susceptible to round off error. Use IntervalArithmetic.jl to bound that","user":"U67G3QRJM","ts":"1614717114.011200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UlrAW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Any ad is susceptible to round off error. Use IntervalArithmetic.jl to bound that"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"type":"message","subtype":"thread_broadcast","text":"As far as I understand, complex step differentiation is a \"hacky\" way to achieve automatic differentiation. I don't see a need for it if forward-mode automatic differentiation (e.g. using Dual numbers) is available.","user":"U72B7LTMX","ts":"1614885165.012000","thread_ts":"1614437236.006800","root":{"client_msg_id":"8b1a536f-8728-431b-85b9-48856470abcf","type":"message","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?","user":"UDSG73JTH","ts":"1614437236.006800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KxVV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone know if there’s a Julia implementation of Quaternion step differentiation?"}]}]}],"thread_ts":"1614437236.006800","reply_count":37,"reply_users_count":5,"latest_reply":"1615041937.021800","reply_users":["U67G3QRJM","UGHS7LC64","UDSG73JTH","U72B7LTMX","U67D54KS8"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"jYuly","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As far as I understand, complex step differentiation is a \"hacky\" way to achieve automatic differentiation. I don't see a need for it if forward-mode automatic differentiation (e.g. using Dual numbers) is available."}]}]}],"client_msg_id":"29eab17e-ea1e-41ed-be9a-50d4b6fac960"},{"client_msg_id":"47c05a3c-8d57-4caf-9237-4d925e371b9b","type":"message","text":"<https://julialang.slack.com/archives/C66NPKCQZ/p1614525788009500?thread_ts=1614437236.006800&amp;cid=C66NPKCQZ|https://julialang.slack.com/archives/C66NPKCQZ/p1614525788009500?thread_ts=1614437236.006800&amp;cid=C66NPKCQZ>","user":"U67D54KS8","ts":"1614885539.012300","team":"T68168MUP","attachments":[{"from_url":"https://julialang.slack.com/archives/C66NPKCQZ/p1614525788009500?thread_ts=1614437236.006800&amp;cid=C66NPKCQZ","fallback":"[February 28th, 2021 7:23 AM] cookjws: I don’t think any can handle complex numbers yet. I need to evaluate the derivative of functions at complex locations in a way that’s amenable to forward rather than reverse differentiation.","ts":"1614525788.009500","author_id":"UDSG73JTH","author_subname":"James Cook","channel_id":"C66NPKCQZ","channel_name":"maths","is_msg_unfurl":true,"is_reply_unfurl":true,"text":"I don’t think any can handle complex numbers yet. I need to evaluate the derivative of functions at complex locations in a way that’s amenable to forward rather than reverse differentiation.","author_name":"James Cook","author_link":"https://julialang.slack.com/team/UDSG73JTH","author_icon":"https://secure.gravatar.com/avatar/13f298f0f34a331cf7acd848387223b7.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0002-48.png","mrkdwn_in":["text"],"id":1,"original_url":"https://julialang.slack.com/archives/C66NPKCQZ/p1614525788009500?thread_ts=1614437236.006800&amp;cid=C66NPKCQZ","footer":"From a thread in #maths"}],"blocks":[{"type":"rich_text","block_id":"GQuo","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://julialang.slack.com/archives/C66NPKCQZ/p1614525788009500?thread_ts=1614437236.006800&cid=C66NPKCQZ","text":"https://julialang.slack.com/archives/C66NPKCQZ/p1614525788009500?thread_ts=1614437236.006800&cid=C66NPKCQZ"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["U72B7LTMX"],"count":1}]},{"client_msg_id":"a2bd6859-0f2b-445f-b496-a83e4588bc23","type":"message","text":"\"Complex step differentiation\" is a way to compute derivatives (approximations, due to  some truncation error, though less than with finite differences) of functions over the Real domain.\nPerhaps \"quaternion step differentiation\" is a way to get derivatives of functions on complex domains. But my feeling is that it's still a \"hack\"","user":"U72B7LTMX","ts":"1614885723.012600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Rli","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"\"Complex step differentiation\" is a way to compute derivatives (approximations, due to  some truncation error, though less than with finite differences) of functions over the Real domain.\nPerhaps \"quaternion step differentiation\" is a way to get derivatives of functions on complex domains. But my feeling is that it's still a \"hack\""}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"a6760c91-e9cc-4b24-8709-92e79fe9bb11","type":"message","text":"It’s hacky, true, but it works. <https://github.com/jwscook/BiComplex.jl>. It will save me a lot of grotty “if has analytical derivative that someone has written down, else if real then use ForwardDiff, else use finite differences”.","user":"UDSG73JTH","ts":"1614974167.012900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mNN0P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s hacky, true, but it works. "},{"type":"link","url":"https://github.com/jwscook/BiComplex.jl"},{"type":"text","text":". It will save me a lot of grotty “if has analytical derivative that someone has written down, else if real then use ForwardDiff, else use finite differences”."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"096ae3da-5cb9-48b4-b4a4-adc7a4562c64","type":"message","text":"The tests pass on my machine with 1.6. Not sure whats going on with those extra floating point inaccuracies with 1.5 on the CI.","user":"UDSG73JTH","ts":"1614974238.013100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gCR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The tests pass on my machine with 1.6. Not sure whats going on with those extra floating point inaccuracies with 1.5 on the CI."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"baa0ff52-859c-420c-b496-dd6f752cb16d","type":"message","text":"<@U72B7LTMX> The point seems to be that there is no workable autodiff solution for complex functions right now","user":"U67G3QRJM","ts":"1614974867.013300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hsa","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U72B7LTMX"},{"type":"text","text":" The point seems to be that there is no workable autodiff solution for complex functions right now"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"de5309e3-3823-4fa5-8c48-a7c99c7da360","type":"message","text":"<@UDSG73JTH> Is a BiComplex basically a `Dual{Complex}`, i.e. a dual number with two complex numbers inside?","user":"U67G3QRJM","ts":"1614974992.013500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ltL+","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDSG73JTH"},{"type":"text","text":" Is a BiComplex basically a "},{"type":"text","text":"Dual{Complex}","style":{"code":true}},{"type":"text","text":", i.e. a dual number with two complex numbers inside?"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"d18c827b-2f9a-4c16-86b2-f6c0e4067dee","type":"message","text":"I didn't check if that implementation in that `BiComplex.jl` is consitent with <https://en.wikipedia.org/wiki/Bicomplex_number>\nbut if it is, the answer to <@U67G3QRJM>’s question is \"no\".  The multiplication table for a `Dual{Complex{T}}` or a `Complex{Dual{T}` (they should behave the same up to isomorphism, if it weren't for imo pesky type constraints) crucially contains zeros, in the same crucial way that $\\epsilon ^2 = 0$ in dual numbers.","user":"U72B7LTMX","ts":"1614976998.013700","team":"T68168MUP","attachments":[{"title":"Bicomplex number","title_link":"https://en.wikipedia.org/wiki/Bicomplex_number","from_url":"https://en.wikipedia.org/wiki/Bicomplex_number","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"In abstract algebra, a bicomplex number is a pair (w, z) of complex numbers constructed by the Cayley–Dickson process that defines the bicomplex conjugate \n  \n    \n      \n        (\n        w\n        ,\n        z\n        \n          )\n          \n            ∗\n          \n        \n        =\n        (\n        w\n        ,\n        −\n        z\n        )\n      \n    \n    {\\displaystyle (w,z)^{*}=(w,-z)}\n  , and the product of two bicomplex numbers as\n\n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n        (\n        w\n        ,\n        z\n        )\n        =\n        (\n        u\n        w\n        −\n        v\n        z\n        ,\n        u\n        z\n        +\n        v\n        w\n        )\n        .\n      \n    \n    {\\displaystyle (u,v)(w,z)=(uw-vz,uz+vw).}\n  Then the bicomplex norm is given by\n\n  \n    \n      \n        (\n        w\n        ,\n        z\n        \n          )\n          \n            ∗\n          \n        \n        (\n        w\n        ,\n        z\n        )\n        =\n        (\n        w\n        ,\n        −\n        z\n        )\n        (\n        w\n        ,\n        z\n        )\n        =\n        (\n        \n          w\n          \n            2\n          \n        \n        +\n        \n          z\n          \n            2\n          \n        \n        ,\n        0\n        )\n        ,\n      \n    \n    {\\displaystyle (w,z)^{*}(w,z)=(w,-z)(w,z)=(w^{2}+z^{2},0),}\n   a quadratic form in the first component.The bicomplex numbers form a commutative algebra over C of dimension two, which is isomorphic to the direct sum of algebras C ⊕ C.\nThe product of two bicomplex numbers yields a quadratic form value that is the product of the individual quadratic forms of the numbers: \na verification of this property of the quadratic form of a product refers to the Brahmagupta–Fibonacci identity. This property of the quadratic form of a bicomplex number indicates that these numbers form a composition algebra. In fact, bicomplex numbers arise at the binarion level of the Cayley–Dickson construction based on ℂ with norm z2.\nThe general bicomplex number can be represented by the matrix \n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  w\n                \n                \n                  i\n                  z\n                \n              \n              \n                \n                  i\n                  z\n                \n                \n                  w\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}w&amp;iz\\\\iz&amp;w\\end{pmatrix}}}\n  , which has determinant \n  \n    \n      \n        \n          w\n          \n            2\n          \n        \n        +\n        \n          z\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle w^{2}+z^{2}}\n  .  Thus, the composing property of the quadratic form concurs with the composing property of the determinant.","fallback":"wikipedia: Bicomplex number","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/Bicomplex_number"}],"blocks":[{"type":"rich_text","block_id":"VpN0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I didn't check if that implementation in that "},{"type":"text","text":"BiComplex.jl","style":{"code":true}},{"type":"text","text":" is consitent with "},{"type":"link","url":"https://en.wikipedia.org/wiki/Bicomplex_number"},{"type":"text","text":"\nbut if it is, the answer to "},{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":"’s question is \"no\".  The multiplication table for a "},{"type":"text","text":"Dual{Complex{T}}","style":{"code":true}},{"type":"text","text":" or a "},{"type":"text","text":"Complex{Dual{T}","style":{"code":true}},{"type":"text","text":" (they should behave the same up to isomorphism, if it weren't for imo pesky type constraints) crucially contains zeros, in the same crucial way that $\\epsilon ^2 = 0$ in dual numbers."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"4f7357b4-eb74-4f81-b3d1-a9a4ecc8f220","type":"message","text":"<@UDSG73JTH> if I'm understanding correctly, it's easier to define e.g. `sin(::Bicomplex)` than it is to define `sin(::DualComplex)`?  (cf <https://github.com/jwscook/BiComplex.jl/blob/3c2d993cd31bbc2fcbb5af58e4bbb67f380861f6/src/implementation.jl#L45-L48>)","user":"U72B7LTMX","ts":"1614977217.014000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AsZ","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDSG73JTH"},{"type":"text","text":" if I'm understanding correctly, it's easier to define e.g. "},{"type":"text","text":"sin(::Bicomplex)","style":{"code":true}},{"type":"text","text":" than it is to define "},{"type":"text","text":"sin(::DualComplex)","style":{"code":true}},{"type":"text","text":"?  (cf "},{"type":"link","url":"https://github.com/jwscook/BiComplex.jl/blob/3c2d993cd31bbc2fcbb5af58e4bbb67f380861f6/src/implementation.jl#L45-L48"},{"type":"text","text":")"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"f3128db6-8803-421d-a2b8-33d2e7e004dc","type":"message","text":"This is an ancient and mostly useless package: <https://github.com/goretkin/ComplexDualNumbers.jl> but I just remembered that the README contains the multiplication table for \"basically a `Dual{Complex}`\".","user":"U72B7LTMX","ts":"1614977386.014200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d4Fo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is an ancient and mostly useless package: "},{"type":"link","url":"https://github.com/goretkin/ComplexDualNumbers.jl"},{"type":"text","text":" but I just remembered that the README contains the multiplication table for \"basically a "},{"type":"text","text":"Dual{Complex}","style":{"code":true}},{"type":"text","text":"\"."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"f32a0582-87c9-499e-8045-7aeca538cadd","type":"message","text":"What happens if you just put complex numbers through a naive `Dual` implementation?","user":"U67G3QRJM","ts":"1614977617.014400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"osn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What happens if you just put complex numbers through a naive "},{"type":"text","text":"Dual","style":{"code":true}},{"type":"text","text":" implementation?"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"537e6a5c-7ae0-413d-9ce2-50fe36bfb300","type":"message","text":"<@UDSG73JTH> I wonder if another option for you is to rely on definitions of these functions on square matrices. You might get what you want for free (terms and conditions apply: performance and numerical issues).\n\nExample:\n\n```using LinearAlgebra: I\ndual_to_mat(primal, dual) = primal * I(2)  + dual * [ 0 1 ; 0 0 ]```\n```# sin′(πish) = 1\njulia&gt; sin(dual_to_mat(π, 1))\n2×2 Matrix{Float64}:\n 2.35127e-16  -1.0\n 0.0           2.35127e-16```\n```# cos′(0) = 0\njulia&gt; cos(dual_to_mat(0, 1))\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0```","user":"U72B7LTMX","ts":"1614977981.014600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uKI","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDSG73JTH"},{"type":"text","text":" I wonder if another option for you is to rely on definitions of these functions on square matrices. You might get what you want for free (terms and conditions apply: performance and numerical issues).\n\nExample:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using LinearAlgebra: I\ndual_to_mat(primal, dual) = primal * I(2)  + dual * [ 0 1 ; 0 0 ]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"# sin′(πish) = 1\njulia> sin(dual_to_mat(π, 1))\n2×2 Matrix{Float64}:\n 2.35127e-16  -1.0\n 0.0           2.35127e-16"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"# cos′(0) = 0\njulia> cos(dual_to_mat(0, 1))\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"e2f755af-ac0e-4f64-8f35-1948fc8bfedb","type":"message","text":"And I expect it to work over complex instead of over real:\n\n\n```julia&gt; cos(dual_to_mat(0 + 1 * im, 1 + 2 * im))\n2×2 Matrix{ComplexF64}:\n 1.54308+0.0im   2.3504-1.1752im\n     0.0+0.0im  1.54308+0.0im```\nI don't know if those numbers make sense, but this is what putting complex numbers through a naive `Dual` implementation _should_ give <@U67G3QRJM>. However, a user of `Dual` might assume that `real(::Dual)` returns the \"real\" part of dual, which is perhaps better called the \"primal\" part, since in a `Dual{Complex{T}}` it isn't a `T&lt;:Real` but in fact a `Complex{T}`.","user":"U72B7LTMX","ts":"1614978131.014800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Fgzw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And I expect it to work over complex instead of over real:\n\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> cos(dual_to_mat(0 + 1 * im, 1 + 2 * im))\n2×2 Matrix{ComplexF64}:\n 1.54308+0.0im   2.3504-1.1752im\n     0.0+0.0im  1.54308+0.0im"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI don't know if those numbers make sense, but this is what putting complex numbers through a naive "},{"type":"text","text":"Dual","style":{"code":true}},{"type":"text","text":" implementation "},{"type":"text","text":"should","style":{"italic":true}},{"type":"text","text":" give "},{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":". However, a user of "},{"type":"text","text":"Dual","style":{"code":true}},{"type":"text","text":" might assume that "},{"type":"text","text":"real(::Dual)","style":{"code":true}},{"type":"text","text":" returns the \"real\" part of dual, which is perhaps better called the \"primal\" part, since in a "},{"type":"text","text":"Dual{Complex{T}}","style":{"code":true}},{"type":"text","text":" it isn't a "},{"type":"text","text":"T<:Real","style":{"code":true}},{"type":"text","text":" but in fact a "},{"type":"text","text":"Complex{T}","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"4c6a09a1-2e8b-4644-adcd-a9488d84bd12","type":"message","text":"I just use the words “value” and “deriv” for Duals","user":"U67G3QRJM","ts":"1614978196.015000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GSCO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just use the words “value” and “deriv” for Duals"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"11382c43-d811-418f-9038-748f657ef5ce","type":"message","text":"If it helps, this is why this works: <https://en.wikipedia.org/wiki/Dual_number#Representation_in_algebras>\n\nIf you want to extend the idea even further, you can represent a `Complex{T}` as 2-by-2 `Matrix{T}` (<https://en.wikipedia.org/wiki/Complex_number#Matrix_representation_of_complex_numbers>) and then take the `kron` of these two 2-by-2 matrices and get a 4-by-4 `Matrix{&lt;:Real}`. `kron(complex_mat, dual_mat)` and `kron(dual_mat, complex_mat)` give two different representations, but they both have the same multiplication table. I think of it exactly like I do `Complex{Dual{T}}` vs `Dual{Complex{T}}`","user":"U72B7LTMX","ts":"1614978429.015200","team":"T68168MUP","edited":{"user":"U72B7LTMX","ts":"1614978443.000000"},"blocks":[{"type":"rich_text","block_id":"eEH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If it helps, this is why this works: "},{"type":"link","url":"https://en.wikipedia.org/wiki/Dual_number#Representation_in_algebras"},{"type":"text","text":"\n\nIf you want to extend the idea even further, you can represent a "},{"type":"text","text":"Complex{T}","style":{"code":true}},{"type":"text","text":" as 2-by-2 "},{"type":"text","text":"Matrix{T}","style":{"code":true}},{"type":"text","text":" ("},{"type":"link","url":"https://en.wikipedia.org/wiki/Complex_number#Matrix_representation_of_complex_numbers"},{"type":"text","text":") and then take the "},{"type":"text","text":"kron","style":{"code":true}},{"type":"text","text":" of these two 2-by-2 matrices and get a 4-by-4 "},{"type":"text","text":"Matrix{<:Real}","style":{"code":true}},{"type":"text","text":". "},{"type":"text","text":"kron(complex_mat, dual_mat)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"kron(dual_mat, complex_mat)","style":{"code":true}},{"type":"text","text":" give two different representations, but they both have the same multiplication table. I think of it exactly like I do "},{"type":"text","text":"Complex{Dual{T}}","style":{"code":true}},{"type":"text","text":" vs "},{"type":"text","text":"Dual{Complex{T}}","style":{"code":true}}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"61ae5ce2-dfad-4ff8-aab5-5a7f25c77980","type":"message","text":"Idk. monkey code, monkey tests pass, monkey happy. The benefit of bicomplex numbers is that the idempotent representation means it take 30 mins to code up an entirely adequate solution. There's a lot of chat about ad for complex numbers on the discourse that seems to be so complicated that no one has been able to ship a solution; caveat, I'm only a Physicist and not a mathematician. As it stands I've got code that needs the principal value of a Cauchy integral and I've got a lot of extra LOC for supplying the derivative at a Complex location.","user":"UDSG73JTH","ts":"1614979113.015700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"30FSd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Idk. monkey code, monkey tests pass, monkey happy. The benefit of bicomplex numbers is that the idempotent representation means it take 30 mins to code up an entirely adequate solution. There's a lot of chat about ad for complex numbers on the discourse that seems to be so complicated that no one has been able to ship a solution; caveat, I'm only a Physicist and not a mathematician. As it stands I've got code that needs the principal value of a Cauchy integral and I've got a lot of extra LOC for supplying the derivative at a Complex location."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"sweat_smile","users":["U67G3QRJM"],"count":1},{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"10bfd976-ab50-40ce-8e9e-70ad0a240dea","type":"message","text":"My question is: If I code a naive representation of AD with `value` and `deriv` fields in a struct, and I put complex numbers in, will that do AD on complex functions?","user":"U67G3QRJM","ts":"1614979301.016200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"osfKN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My question is: If I code a naive representation of AD with "},{"type":"text","text":"value","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"deriv","style":{"code":true}},{"type":"text","text":" fields in a struct, and I put complex numbers in, will that do AD on complex functions?"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"d3e7dab6-55a2-437a-94b8-e9b0d3fe42ec","type":"message","text":"Yeah, I hear that. I am not totally sure about the crux of the issue regarding complex auto diff, other than there being multiple notions of derivative. This matrix representation that I suggested is in my eyes fairly \"monkey\" coding. If anything was unclear, just let me know. The benefit is that it avoids all truncation error whereas I don't think BiComplex will.","user":"U72B7LTMX","ts":"1614979349.016400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aZ1hL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I hear that. I am not totally sure about the crux of the issue regarding complex auto diff, other than there being multiple notions of derivative. This matrix representation that I suggested is in my eyes fairly \"monkey\" coding. If anything was unclear, just let me know. The benefit is that it avoids all truncation error whereas I don't think BiComplex will."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"58175109-3b07-4272-9a4b-0d2046499a4b","type":"message","text":"<@U67G3QRJM> I think that hinges completely on how the functions are defined on `::Dual`.  I expect it to work mathematically.\n\ne.g. `sin(x::Dual) = Dual(sin(x.value),  x.deriv * cos(x.value))`. I think that definition works with  `Dual{&lt;:Real}` and `Dual{&lt;:Complex}` .\n\nI guess so would\n\n`constant_f(x::Dual) = Dual(constant_f(x.value), zero(x.deriv))`\n\nI can't think of an example off the top of my head, but I bet there are definitions that look correct, and that work for `Dual{&lt;:Real}` but not for `Dual{&lt;:Complex}`.","user":"U72B7LTMX","ts":"1614980982.016800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"beE","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":" I think that hinges completely on how the functions are defined on "},{"type":"text","text":"::Dual","style":{"code":true}},{"type":"text","text":".  I expect it to work mathematically.\n\ne.g. "},{"type":"text","text":"sin(x::Dual) = Dual(sin(x.value),  x.deriv * cos(x.value))","style":{"code":true}},{"type":"text","text":". I think that definition works with  "},{"type":"text","text":"Dual{<:Real}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Dual{<:Complex}","style":{"code":true}},{"type":"text","text":" .\n\nI guess so would\n\n"},{"type":"text","text":"constant_f(x::Dual) = Dual(constant_f(x.value), zero(x.deriv))","style":{"code":true}},{"type":"text","text":"\n\nI can't think of an example off the top of my head, but I bet there are definitions that look correct, and that work for "},{"type":"text","text":"Dual{<:Real}","style":{"code":true}},{"type":"text","text":" but not for "},{"type":"text","text":"Dual{<:Complex}","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"f9a91415-4fbd-461c-bd19-b3f519e42e89","type":"message","text":"Btw, I followed <https://core.ac.uk/download/pdf/215754454.pdf|this paper>. One downside is that `f^{-1}(f(x)) != x`  sometimes, which is a bit of a downer. I suppose this is because my code isn’t guaranteed to find the same branch again.","user":"UDSG73JTH","ts":"1614981103.017000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"33vy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Btw, I followed "},{"type":"link","url":"https://core.ac.uk/download/pdf/215754454.pdf","text":"this paper"},{"type":"text","text":". One downside is that "},{"type":"text","text":"f^{-1}(f(x)) != x","style":{"code":true}},{"type":"text","text":"  sometimes, which is a bit of a downer. I suppose this is because my code isn’t guaranteed to find the same branch again."}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"16ff0c4f-4355-40b0-b0d5-0b70f7e394e8","type":"message","text":"<@U72B7LTMX> My bet is that all the normal functions just work","user":"U67G3QRJM","ts":"1614981920.017300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IX7","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U72B7LTMX"},{"type":"text","text":" My bet is that all the normal functions just work"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH"},{"client_msg_id":"fee9fc29-ec8e-4dfe-937d-759a934eddf6","type":"message","text":"Whelp. Looks like I needn’t have bothered, <@U67G3QRJM> and <@U72B7LTMX>:\n```julia&gt; using DualNumbers\n\njulia&gt; f(x) = (1, -2 *x) .* exp(-x^2) # value and deriv\nf (generic function with 1 method)\n\njulia&gt; f(1.0 + im)\n(-0.4161468365471424 - 0.9092974268256817im, -0.9863011805570786 + 2.650888526745648im)\n\njulia&gt; f(Dual(1.0 + im, 1))\n(-0.4161468365471424 - 0.9092974268256817im - 0.9863011805570786ɛ + 2.650888526745648imɛ, -0.9863011805570786 + 2.650888526745648im + 8.106673087699738ɛ - 1.5105798387257754imɛ)```","user":"UDSG73JTH","ts":"1615041937.021800","team":"T68168MUP","edited":{"user":"UDSG73JTH","ts":"1615042042.000000"},"blocks":[{"type":"rich_text","block_id":"rrijm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Whelp. Looks like I needn’t have bothered, "},{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":" and "},{"type":"user","user_id":"U72B7LTMX"},{"type":"text","text":":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using DualNumbers\n\njulia> f(x) = (1, -2 *x) .* exp(-x^2) # value and deriv\nf (generic function with 1 method)\n\njulia> f(1.0 + im)\n(-0.4161468365471424 - 0.9092974268256817im, -0.9863011805570786 + 2.650888526745648im)\n\njulia> f(Dual(1.0 + im, 1))\n(-0.4161468365471424 - 0.9092974268256817im - 0.9863011805570786ɛ + 2.650888526745648imɛ, -0.9863011805570786 + 2.650888526745648im + 8.106673087699738ɛ - 1.5105798387257754imɛ)"}]}]}],"thread_ts":"1614437236.006800","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["U72B7LTMX","U67G3QRJM"],"count":2}]}]