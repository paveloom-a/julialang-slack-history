[{"client_msg_id":"61d0fa74-5841-47fd-9a0d-939f09651eaf","type":"message","text":"There has been some interest in code that will trap a NaN as it is generated and give some call chain info.  It turns out this is possible with the current versions of Julia, working with the REPL, if and only if there is nothing `print`ed or otherwise `show`n within the NaN trapping or NaN trap handling code (or so it seems).  It would be great to have that restriction eliminated (Julia goes somewhat bonkers, specifics depend on how it is caused, and often, eventually, closes itself) -- it appears to be caused either by some interaction within Ryu or by some interaction in the code that outputs to the screen thereafter), idk what though. Here is some code with an example: <https://gist.github.com/JeffreySarnoff/db217673bc220360dc388136ab170e76|nancatcher.jl>","user":"U68QW0PUZ","ts":"1608346896.097900","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1608357323.000000"},"blocks":[{"type":"rich_text","block_id":"e19mv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There has been some interest in code that will trap a NaN as it is generated and give some call chain info.  It turns out this is possible with the current versions of Julia, working with the REPL, if and only if there is nothing "},{"type":"text","text":"print","style":{"code":true}},{"type":"text","text":"ed or otherwise "},{"type":"text","text":"show","style":{"code":true}},{"type":"text","text":"n within the NaN trapping or NaN trap handling code (or so it seems).  It would be great to have that restriction eliminated (Julia goes somewhat bonkers, specifics depend on how it is caused, and often, eventually, closes itself) -- it appears to be caused either by some interaction within Ryu or by some interaction in the code that outputs to the screen thereafter), idk what though. Here is some code with an example: "},{"type":"link","url":"https://gist.github.com/JeffreySarnoff/db217673bc220360dc388136ab170e76","text":"nancatcher.jl"}]}]}],"thread_ts":"1608346896.097900","reply_count":1,"reply_users_count":1,"latest_reply":"1608367930.099900","reply_users":["UM30MT6RF"],"subscribed":false},{"client_msg_id":"fccfd78b-9eb2-4b7d-b645-161c68f37513","type":"message","text":"It's definitely expected that very weird things happen and code crashes if you redefine functions like `+` for `Float64`. The proper way to do this is to either introduce a new type and use dispatch for this or write a `Cassette` / `IRTools` pass, as <@U6740K1SP> pointed out.","user":"UM30MT6RF","ts":"1608367930.099900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"H1W2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's definitely expected that very weird things happen and code crashes if you redefine functions like "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" for "},{"type":"text","text":"Float64","style":{"code":true}},{"type":"text","text":". The proper way to do this is to either introduce a new type and use dispatch for this or write a "},{"type":"text","text":"Cassette","style":{"code":true}},{"type":"text","text":" / "},{"type":"text","text":"IRTools","style":{"code":true}},{"type":"text","text":" pass, as "},{"type":"user","user_id":"U6740K1SP"},{"type":"text","text":" pointed out."}]}]}],"thread_ts":"1608346896.097900","parent_user_id":"U68QW0PUZ"}]