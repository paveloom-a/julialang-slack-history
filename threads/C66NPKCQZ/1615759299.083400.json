[{"client_msg_id":"af1ba220-b9c8-4001-88f9-5053929afad4","type":"message","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form `[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]` where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first `length(a)` elements of the result (or in \"batched\" mode, `CartesianIndices(a)`)*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of `ifft(fft(a_padded) .* fft(b_padded))` stays real and not complex. It works and is fairly fast (at least compared to a naive `mapreduce` impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the `DSP.conv` but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the `NNlib.conv` doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size).","user":"UHDNY2YMA","ts":"1615759299.083400","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615759799.000000"},"blocks":[{"type":"rich_text","block_id":"wSgu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form "},{"type":"text","text":"[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]","style":{"code":true}},{"type":"text","text":" where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first "},{"type":"text","text":"length(a)","style":{"code":true}},{"type":"text","text":" elements of the result (or in \"batched\" mode, "},{"type":"text","text":"CartesianIndices(a)","style":{"code":true}},{"type":"text","text":")*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of "},{"type":"text","text":"ifft(fft(a_padded) .* fft(b_padded))","style":{"code":true}},{"type":"text","text":" stays real and not complex. It works and is fairly fast (at least compared to a naive "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":" impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the "},{"type":"text","text":"DSP.conv","style":{"code":true}},{"type":"text","text":" but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the "},{"type":"text","text":"NNlib.conv","style":{"code":true}},{"type":"text","text":" doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size)."}]}]}],"thread_ts":"1615759299.083400","reply_count":1,"reply_users_count":1,"latest_reply":"1615760201.083600","reply_users":["UM30MT6RF"],"subscribed":false},{"client_msg_id":"ac91c2aa-6542-486e-9459-a087fec6065d","type":"message","text":"Tullio.jl might be an option, although performance is not ideal on the GPU","user":"UM30MT6RF","ts":"1615760201.083600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tgd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tullio.jl might be an option, although performance is not ideal on the GPU"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"}]