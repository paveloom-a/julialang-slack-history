[{"client_msg_id":"af1ba220-b9c8-4001-88f9-5053929afad4","type":"message","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form `[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]` where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first `length(a)` elements of the result (or in \"batched\" mode, `CartesianIndices(a)`)*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of `ifft(fft(a_padded) .* fft(b_padded))` stays real and not complex. It works and is fairly fast (at least compared to a naive `mapreduce` impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the `DSP.conv` but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the `NNlib.conv` doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size).","user":"UHDNY2YMA","ts":"1615759299.083400","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615759799.000000"},"blocks":[{"type":"rich_text","block_id":"wSgu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form "},{"type":"text","text":"[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]","style":{"code":true}},{"type":"text","text":" where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first "},{"type":"text","text":"length(a)","style":{"code":true}},{"type":"text","text":" elements of the result (or in \"batched\" mode, "},{"type":"text","text":"CartesianIndices(a)","style":{"code":true}},{"type":"text","text":")*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of "},{"type":"text","text":"ifft(fft(a_padded) .* fft(b_padded))","style":{"code":true}},{"type":"text","text":" stays real and not complex. It works and is fairly fast (at least compared to a naive "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":" impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the "},{"type":"text","text":"DSP.conv","style":{"code":true}},{"type":"text","text":" but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the "},{"type":"text","text":"NNlib.conv","style":{"code":true}},{"type":"text","text":" doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size)."}]}]}],"thread_ts":"1615759299.083400","reply_count":35,"reply_users_count":3,"latest_reply":"1615810078.091400","reply_users":["UM30MT6RF","UHDNY2YMA","UH24GRBLL"],"is_locked":false,"subscribed":false},{"client_msg_id":"ac91c2aa-6542-486e-9459-a087fec6065d","type":"message","text":"Tullio.jl might be an option, although performance is not ideal on the GPU","user":"UM30MT6RF","ts":"1615760201.083600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tgd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tullio.jl might be an option, although performance is not ideal on the GPU"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"684d9c40-9c47-40b4-a02d-58e0f32c6dbc","type":"message","text":"Can Tullio.jl handle variable upper-bounds on indices? E.g. LoopVectorization.jl does not (which I'm aware is used by Tullio unless otherwise specified by the user). And if I try something like\n```@tullio c[i] := u[j] * v[i - j] (j in 1:i)```\nIt complains that `i` is not defined.","user":"UHDNY2YMA","ts":"1615762103.084000","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615762143.000000"},"blocks":[{"type":"rich_text","block_id":"FVhM=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can Tullio.jl handle variable upper-bounds on indices? E.g. LoopVectorization.jl does not (which I'm aware is used by Tullio unless otherwise specified by the user). And if I try something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@tullio c[i] := u[j] * v[i - j] (j in 1:i)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It complains that "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":" is not defined."}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"c458de8e-56c4-4860-8d32-55741863087f","type":"message","text":"Ah, I might have misunderstood. I don't think this is currently supported","user":"UM30MT6RF","ts":"1615762242.084300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F+aQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, I might have misunderstood. I don't think this is currently supported"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"4556a4aa-4ca1-489d-8154-94b40eb1c702","type":"message","text":"No worries:) You reminded me that Tullio.jl exists, which I might need for other reasons! Currently using TensorOperations.jl for some parts of my code, but seems like I should just replace those parts with Tullio.jl.","user":"UHDNY2YMA","ts":"1615762324.084500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ucw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No worries:) You reminded me that Tullio.jl exists, which I might need for other reasons! Currently using TensorOperations.jl for some parts of my code, but seems like I should just replace those parts with Tullio.jl."}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"2e019c1b-10c7-4891-8705-8aac0003e534","type":"message","text":"Actually it might be worth using Tullio.jl and just \"left\" zero-pad one of them and reverse the other, e.g.\n```function tullio_conv(u::AbstractVector, v::AbstractVector)\n    # Left pad\n    upad = NNlib.pad_zeros(u, (length(v) - 1, 0))\n    v_rev = v[end:-1:1]\n\n    @tullio y[i+_] := upad[i+a] * v_rev[a]\nend```\nI'll try it out tomorrow; thanks!","user":"UHDNY2YMA","ts":"1615763918.084700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OmF+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Actually it might be worth using Tullio.jl and just \"left\" zero-pad one of them and reverse the other, e.g.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function tullio_conv(u::AbstractVector, v::AbstractVector)\n    # Left pad\n    upad = NNlib.pad_zeros(u, (length(v) - 1, 0))\n    v_rev = v[end:-1:1]\n\n    @tullio y[i+_] := upad[i+a] * v_rev[a]\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I'll try it out tomorrow; thanks!"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"c78c392d-e539-4f54-bcf2-3306887b15a8","type":"message","text":"you probably want to `@view` the reversal","user":"UH24GRBLL","ts":"1615788636.085300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=j7qb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you probably want to "},{"type":"text","text":"@view","style":{"code":true}},{"type":"text","text":" the reversal"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"00f54d42-9921-4a0c-8879-c8f167b8dd88","type":"message","text":"Actually did try `view` initially, but a quick `@btime` told me that was actually worse and so I just reverted the change. I'll do proper benchmarks though, as it might just have been the input size or something (?)","user":"UHDNY2YMA","ts":"1615798035.085500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O3z/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Actually did try "},{"type":"text","text":"view","style":{"code":true}},{"type":"text","text":" initially, but a quick "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" told me that was actually worse and so I just reverted the change. I'll do proper benchmarks though, as it might just have been the input size or something (?)"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"a82c468a-d2ff-420f-8b3d-c69f916ab835","type":"message","text":"hm, i suppose iteration order could maybe make a difference and because of that the copy is worth it?","user":"UH24GRBLL","ts":"1615807624.085700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=kn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hm, i suppose iteration order could maybe make a difference and because of that the copy is worth it?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"02108878-dec7-4a19-8ab7-006315cb7ea6","type":"message","text":"That's what I was thinking (and I think I ran this on a short vector and so the copy was prob cheap) but shouldn't the CPU be clever enough to notice I'm traversing in reverse order and load into the CPU cache accordingly?","user":"UHDNY2YMA","ts":"1615807859.085900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hF+UY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's what I was thinking (and I think I ran this on a short vector and so the copy was prob cheap) but shouldn't the CPU be clever enough to notice I'm traversing in reverse order and load into the CPU cache accordingly?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"35922cdf-07a5-4f7f-9e20-7a35c1c3dbf4","type":"message","text":"yeah, absolutely","user":"UH24GRBLL","ts":"1615807940.086100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oDwx=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, absolutely"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"c4c2e700-3370-488b-a73f-b0826be375f8","type":"message","text":"Also I ran into an issue when using Tullio to do this:  Tullio starts using scalar indexing on the GPU. Guessing it's because of the incremental indexing `i+_` and it's maybe not supported on GPU?","user":"UHDNY2YMA","ts":"1615807968.086300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rIdPv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also I ran into an issue when using Tullio to do this:  Tullio starts using scalar indexing on the GPU. Guessing it's because of the incremental indexing "},{"type":"text","text":"i+_","style":{"code":true}},{"type":"text","text":" and it's maybe not supported on GPU?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"766ab192-e03a-4edc-87ec-4f0c2e2a490e","type":"message","text":"Did you do `using CUDA, KernelAbstractions` first?","user":"UM30MT6RF","ts":"1615808024.086500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F6Ya","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Did you do "},{"type":"text","text":"using CUDA, KernelAbstractions","style":{"code":true}},{"type":"text","text":" first?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"dfca9c31-f9c7-4083-88e6-c6b7a0b95985","type":"message","text":"Import, but I assume that doesn't matter?","user":"UHDNY2YMA","ts":"1615808087.086700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+SFC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Import, but I assume that doesn't matter?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"3970dad5-32c8-4684-8b0f-2d8cfdf9978f","type":"message","text":"It does, since Tullio detects this during macro expansion","user":"UM30MT6RF","ts":"1615808116.086900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZJCch","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It does, since Tullio detects this during macro expansion"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"03821e6c-0557-4bf2-9f95-2f0ec98eba88","type":"message","text":"Actually, sorry, not sure it matters, but it might","user":"UM30MT6RF","ts":"1615808147.087100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tV+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Actually, sorry, not sure it matters, but it might"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"9f95b7c5-7ab7-4bf5-a4a3-fb33493fbdbe","type":"message","text":"Aaaah, aight I'll try or check source code (didn't have a look yet; figured it was using requires or smth)","user":"UHDNY2YMA","ts":"1615808186.087300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xrv/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Aaaah, aight I'll try or check source code (didn't have a look yet; figured it was using requires or smth)"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"89d91750-1ef1-4ef0-8d4d-033b3869532d","type":"message","text":"Nah, also fails with `using`","user":"UHDNY2YMA","ts":"1615808423.087500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ufK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Nah, also fails with "},{"type":"text","text":"using","style":{"code":true}}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"0f007ee1-c8ce-4687-9b6d-40474fd6129c","type":"message","text":"Hmm, are all your arrays CuArrays?","user":"UM30MT6RF","ts":"1615808445.087700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zG4g","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm, are all your arrays CuArrays?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"ec142bdc-c5f0-4407-9003-b4bd4921a8c9","type":"message","text":"Yep","user":"UHDNY2YMA","ts":"1615808466.087900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L30A2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yep"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"b73355d0-c799-483b-8e49-999a8c82035c","type":"message","text":"Can you double check? Are there perhaps any wrapper types? You could also try passing `verbose=2` to the `@tullio` macro","user":"UM30MT6RF","ts":"1615808588.088100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Msw5L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can you double check? Are there perhaps any wrapper types? You could also try passing "},{"type":"text","text":"verbose=2","style":{"code":true}},{"type":"text","text":" to the "},{"type":"text","text":"@tullio","style":{"code":true}},{"type":"text","text":" macro"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"920cecf3-210b-472d-bb8c-06f135a3a986","type":"message","text":"Changed the code to:\n```_tullio_conv(u, v) = @tullio y[i+_] := u[i+a] * v[a]\n\n\nfunction tullio_conv(u::AbstractVector, v::AbstractVector)\n    # Left pad\n    upad = NNlib.pad_zeros(u, (length(v) - 1, 0))\n    v_rev = @view v[end:-1:1]\n\n    return _tullio_conv(upad, v_rev)\nend```\nand now I'm getting `\"KernelAbstractions can't handle OffsetArrays here\"`.","user":"UHDNY2YMA","ts":"1615808614.088300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jDy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Changed the code to:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"_tullio_conv(u, v) = @tullio y[i+_] := u[i+a] * v[a]\n\n\nfunction tullio_conv(u::AbstractVector, v::AbstractVector)\n    # Left pad\n    upad = NNlib.pad_zeros(u, (length(v) - 1, 0))\n    v_rev = @view v[end:-1:1]\n\n    return _tullio_conv(upad, v_rev)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and now I'm getting "},{"type":"text","text":"\"KernelAbstractions can't handle OffsetArrays here\"","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"4fb2de8e-32df-4752-9313-64854e259c4d","type":"message","text":"&gt; Can you double check? Are there perhaps any wrapper types? You could also try passing verbose=2 to the @tullio macro\nDone, but uuuh what should I look for? Want me to add the output?\n\nCan also move this over to a github issue if you prefer.","user":"UHDNY2YMA","ts":"1615808706.088500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DbnVG","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Can you double check? Are there perhaps any wrapper types? You could also try passing verbose=2 to the @tullio macro"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nDone, but uuuh what should I look for? Want me to add the output?\n\nCan also move this over to a github issue if you prefer."}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"a4104e37-c8ee-4b33-81d8-0a9aeb96d737","type":"message","text":"I think the problem here might be that Tullio is confused what the axes for the resulting `y` should be. You could try the inplace version instead and manually create `y`, e.g. with `similar`","user":"UM30MT6RF","ts":"1615808776.088700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"y7BsT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the problem here might be that Tullio is confused what the axes for the resulting "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" should be. You could try the inplace version instead and manually create "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":", e.g. with "},{"type":"text","text":"similar","style":{"code":true}}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"f3076f75-3a28-4355-a219-c0f90372a4d2","type":"message","text":"&gt; and now I'm getting \"KernelAbstractions can't handle OffsetArrays here\".\nThat should at least mean it's dispatching to the right method, so looks like your array types are ok","user":"UM30MT6RF","ts":"1615808816.088900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cjl","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"and now I'm getting \"KernelAbstractions can't handle OffsetArrays here\"."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"That should at least mean it's dispatching to the right method, so looks like your array types are ok"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"ec93ddef-e333-4961-8f06-9eecac602e69","type":"message","text":"It ain't too happy about\n```_tullio_conv!(u, v, o) = @tullio o[i+_] = u[i+a] * v[a] verbose=2```\nwhich results in `LoadError: \"can't use _ as an index name\"`. Isn't the above valid code?","user":"UHDNY2YMA","ts":"1615808942.089100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jkx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It ain't too happy about\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"_tullio_conv!(u, v, o) = @tullio o[i+_] = u[i+a] * v[a] verbose=2"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which results in "},{"type":"text","text":"LoadError: \"can't use _ as an index name\"","style":{"code":true}},{"type":"text","text":". Isn't the above valid code?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"83ca13bd-e61f-4e51-ad6d-f6b319982f41","type":"message","text":"Is this mentioned in the README?","user":"UM30MT6RF","ts":"1615808987.089300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EEFG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is this mentioned in the README?"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"7bd8f83e-3ce8-487d-9d88-14744a7617c8","type":"message","text":"In general, `_` can't be used as a normal variable name in Julia","user":"UM30MT6RF","ts":"1615809009.089500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8fdm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In general, "},{"type":"text","text":"_","style":{"code":true}},{"type":"text","text":" can't be used as a normal variable name in Julia"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"fc24becd-d476-4251-a5e0-ffa732aa334d","type":"message","text":"Sure, but it's the syntax used for the incremental indexing in Tullio.jl, right? And it works when I use non-mutating version, i.e. `:=` rather than `=`","user":"UHDNY2YMA","ts":"1615809059.089700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yq/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sure, but it's the syntax used for the incremental indexing in Tullio.jl, right? And it works when I use non-mutating version, i.e. "},{"type":"text","text":":=","style":{"code":true}},{"type":"text","text":" rather than "},{"type":"text","text":"=","style":{"code":true}}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"1390b8d4-ffe0-46e0-96c2-7ed30421ab1c","type":"message","text":"Ah, I see, that's odd","user":"UM30MT6RF","ts":"1615809101.089900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GPSvS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, I see, that's odd"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"0936fd95-fc3d-4471-b6ff-4fed72a951b5","type":"message","text":"Probably good to open an issue","user":"UM30MT6RF","ts":"1615809124.090100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pTb92","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Probably good to open an issue"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"ceea4da9-a8f2-490b-be5b-4f19177fff71","type":"message","text":"Will do :+1: But it seems like it's just KernelAbstractions.jl doesn't support `OffsetArrays`. I'll check KernelAbstractions.jl and see if there's an existing one for this","user":"UHDNY2YMA","ts":"1615809344.090300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O0n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will do "},{"type":"emoji","name":"+1"},{"type":"text","text":" But it seems like it's just KernelAbstractions.jl doesn't support "},{"type":"text","text":"OffsetArrays","style":{"code":true}},{"type":"text","text":". I'll check KernelAbstractions.jl and see if there's an existing one for this"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"c6f100d9-0bd3-4643-9ddd-252d9173cd11","type":"message","text":"It's not really an inherent issue with KerrnelAbstractions per se, it has more to do with how Tullio generates its KernelAbstractions code","user":"UM30MT6RF","ts":"1615809571.090500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RZx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's not really an inherent issue with KerrnelAbstractions per se, it has more to do with how Tullio generates its KernelAbstractions code"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"f0f79c49-6b7e-4c71-81e5-a6f434e86afb","type":"message","text":"Ah, aight :+1:","user":"UHDNY2YMA","ts":"1615809585.090700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o368T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, aight "},{"type":"emoji","name":"+1"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"6ba25f3b-7105-4c6f-905a-15f38ce16507","type":"message","text":"<https://github.com/mcabbott/Tullio.jl/issues/88>","user":"UHDNY2YMA","ts":"1615809650.090900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ynO","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/mcabbott/Tullio.jl/issues/88"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"type":"message","subtype":"thread_broadcast","text":"For temporary closure: I've ended up with the following piece of code as the fastest (for sufficiently large lengths) and \"most compatible\":\n```function fftpad(u::AbstractArray, su, outsize, dims)\n    # HACK: This seems way too hacky. Surely exists better solution?\n    j = 0\n    Δsu = ntuple(length(su)) do i\n        i in dims ? (0, outsize[j += 1] - su[i]) : (0, 0)\n    end\n\n    return NNlib.pad_zeros(u, NNlib.tuplejoin(Δsu...))\nend\n\n\nfunction fftconv(u::AbstractArray, v::AbstractArray, dims = 1:ndims(u))\n    su, sv = size(u), size(v)\n    outsize = size(u)[dims] .+ size(v)[dims] .- 1\n    \n    upad = fftpad(u, su, outsize, dims)\n    vpad = fftpad(v, sv, outsize, dims) \n    \n    uft = fft(real(upad), dims)\n    vft = fft(real(vpad), dims)\n    \n    return real(ifft(uft .* vft, dims))\nend```\nIt should also work for convolutions along any dimension (though don't quote me on that until I've added some testing) + is AD-able (at least using Zygote).\n\nIdeally `DSP.conv` should also allow the `dims` keyword (since it's using FFT under the hood anyways, which supports it) and be differentiable (currently not because of mutations) or just have a custom `rrule`. Might give implementing that a go in the future if no one else beats me to it or there are good reasons not to:)","user":"UHDNY2YMA","ts":"1615810078.091400","thread_ts":"1615759299.083400","root":{"client_msg_id":"af1ba220-b9c8-4001-88f9-5053929afad4","type":"message","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form `[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]` where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first `length(a)` elements of the result (or in \"batched\" mode, `CartesianIndices(a)`)*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of `ifft(fft(a_padded) .* fft(b_padded))` stays real and not complex. It works and is fairly fast (at least compared to a naive `mapreduce` impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the `DSP.conv` but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the `NNlib.conv` doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size).","user":"UHDNY2YMA","ts":"1615759299.083400","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615759799.000000"},"blocks":[{"type":"rich_text","block_id":"wSgu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form "},{"type":"text","text":"[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]","style":{"code":true}},{"type":"text","text":" where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first "},{"type":"text","text":"length(a)","style":{"code":true}},{"type":"text","text":" elements of the result (or in \"batched\" mode, "},{"type":"text","text":"CartesianIndices(a)","style":{"code":true}},{"type":"text","text":")*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of "},{"type":"text","text":"ifft(fft(a_padded) .* fft(b_padded))","style":{"code":true}},{"type":"text","text":" stays real and not complex. It works and is fairly fast (at least compared to a naive "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":" impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the "},{"type":"text","text":"DSP.conv","style":{"code":true}},{"type":"text","text":" but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the "},{"type":"text","text":"NNlib.conv","style":{"code":true}},{"type":"text","text":" doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size)."}]}]}],"thread_ts":"1615759299.083400","reply_count":35,"reply_users_count":3,"latest_reply":"1615810078.091400","reply_users":["UM30MT6RF","UHDNY2YMA","UH24GRBLL"],"is_locked":false,"subscribed":false},"blocks":[{"type":"rich_text","block_id":"nph","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For temporary closure: I've ended up with the following piece of code as the fastest (for sufficiently large lengths) and \"most compatible\":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function fftpad(u::AbstractArray, su, outsize, dims)\n    # HACK: This seems way too hacky. Surely exists better solution?\n    j = 0\n    Δsu = ntuple(length(su)) do i\n        i in dims ? (0, outsize[j += 1] - su[i]) : (0, 0)\n    end\n\n    return NNlib.pad_zeros(u, NNlib.tuplejoin(Δsu...))\nend\n\n\nfunction fftconv(u::AbstractArray, v::AbstractArray, dims = 1:ndims(u))\n    su, sv = size(u), size(v)\n    outsize = size(u)[dims] .+ size(v)[dims] .- 1\n    \n    upad = fftpad(u, su, outsize, dims)\n    vpad = fftpad(v, sv, outsize, dims) \n    \n    uft = fft(real(upad), dims)\n    vft = fft(real(vpad), dims)\n    \n    return real(ifft(uft .* vft, dims))\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It should also work for convolutions along any dimension (though don't quote me on that until I've added some testing) + is AD-able (at least using Zygote).\n\nIdeally "},{"type":"text","text":"DSP.conv","style":{"code":true}},{"type":"text","text":" should also allow the "},{"type":"text","text":"dims","style":{"code":true}},{"type":"text","text":" keyword (since it's using FFT under the hood anyways, which supports it) and be differentiable (currently not because of mutations) or just have a custom "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":". Might give implementing that a go in the future if no one else beats me to it or there are good reasons not to:)"}]}]}],"client_msg_id":"1641a925-e87d-4282-a70b-24daa1b6b4a5","edited":{"user":"UHDNY2YMA","ts":"1615811665.000000"}}]