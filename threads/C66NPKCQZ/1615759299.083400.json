[{"client_msg_id":"af1ba220-b9c8-4001-88f9-5053929afad4","type":"message","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form `[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]` where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first `length(a)` elements of the result (or in \"batched\" mode, `CartesianIndices(a)`)*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of `ifft(fft(a_padded) .* fft(b_padded))` stays real and not complex. It works and is fairly fast (at least compared to a naive `mapreduce` impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the `DSP.conv` but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the `NNlib.conv` doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size).","user":"UHDNY2YMA","ts":"1615759299.083400","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615759799.000000"},"blocks":[{"type":"rich_text","block_id":"wSgu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey! Any of you clever humans have a efficient way of doing convolutions of the form "},{"type":"text","text":"[dot(a[1:t], b[reverse(t:1)]) for t = 1:length(a)]","style":{"code":true}},{"type":"text","text":" where a and b are of same length?\n\nA couple of desired features:\n1. Differentiable.\n2. Super fast, both on CPU and GPU.\n3. Can be done in \"batches\", e.g. a and b can be arrays and we compute convolution across a given dimension.\n\nBest I've come up with this far is using FFT together with the convolution theorem + zero padding to ensure the kernel doesn't wrap around, and then just take the first "},{"type":"text","text":"length(a)","style":{"code":true}},{"type":"text","text":" elements of the result (or in \"batched\" mode, "},{"type":"text","text":"CartesianIndices(a)","style":{"code":true}},{"type":"text","text":")*. Zygote has AD rules for FFT and its inverse, so I only need to define a custom adjoint to ensure that the pullback of "},{"type":"text","text":"ifft(fft(a_padded) .* fft(b_padded))","style":{"code":true}},{"type":"text","text":" stays real and not complex. It works and is fairly fast (at least compared to a naive "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":" impl I had from before) but it seems like there should be an easier approach.\n\nAnd there is the "},{"type":"text","text":"DSP.conv","style":{"code":true}},{"type":"text","text":" but this has a couple of issues:\n1. AFAIK doesn't support the \"batching\" I refer to above.\n2. Not Zygote compat.\nAnd the "},{"type":"text","text":"NNlib.conv","style":{"code":true}},{"type":"text","text":" doesn't support 1D convolutions (plus I assume it's optimized for cases where one is much smaller than the other rather than of equal size)."}]}]}],"thread_ts":"1615759299.083400","reply_count":5,"reply_users_count":2,"latest_reply":"1615763918.084700","reply_users":["UM30MT6RF","UHDNY2YMA"],"subscribed":false},{"client_msg_id":"ac91c2aa-6542-486e-9459-a087fec6065d","type":"message","text":"Tullio.jl might be an option, although performance is not ideal on the GPU","user":"UM30MT6RF","ts":"1615760201.083600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tgd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tullio.jl might be an option, although performance is not ideal on the GPU"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"684d9c40-9c47-40b4-a02d-58e0f32c6dbc","type":"message","text":"Can Tullio.jl handle variable upper-bounds on indices? E.g. LoopVectorization.jl does not (which I'm aware is used by Tullio unless otherwise specified by the user). And if I try something like\n```@tullio c[i] := u[j] * v[i - j] (j in 1:i)```\nIt complains that `i` is not defined.","user":"UHDNY2YMA","ts":"1615762103.084000","team":"T68168MUP","edited":{"user":"UHDNY2YMA","ts":"1615762143.000000"},"blocks":[{"type":"rich_text","block_id":"FVhM=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can Tullio.jl handle variable upper-bounds on indices? E.g. LoopVectorization.jl does not (which I'm aware is used by Tullio unless otherwise specified by the user). And if I try something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@tullio c[i] := u[j] * v[i - j] (j in 1:i)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It complains that "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":" is not defined."}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"c458de8e-56c4-4860-8d32-55741863087f","type":"message","text":"Ah, I might have misunderstood. I don't think this is currently supported","user":"UM30MT6RF","ts":"1615762242.084300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F+aQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, I might have misunderstood. I don't think this is currently supported"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"4556a4aa-4ca1-489d-8154-94b40eb1c702","type":"message","text":"No worries:) You reminded me that Tullio.jl exists, which I might need for other reasons! Currently using TensorOperations.jl for some parts of my code, but seems like I should just replace those parts with Tullio.jl.","user":"UHDNY2YMA","ts":"1615762324.084500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ucw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No worries:) You reminded me that Tullio.jl exists, which I might need for other reasons! Currently using TensorOperations.jl for some parts of my code, but seems like I should just replace those parts with Tullio.jl."}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"2e019c1b-10c7-4891-8705-8aac0003e534","type":"message","text":"Actually it might be worth using Tullio.jl and just \"left\" zero-pad one of them and reverse the other, e.g.\n```function tullio_conv(u::AbstractVector, v::AbstractVector)\n    # Left pad\n    upad = NNlib.pad_zeros(u, (length(v) - 1, 0))\n    v_rev = v[end:-1:1]\n\n    @tullio y[i+_] := upad[i+a] * v_rev[a]\nend```\nI'll try it out tomorrow; thanks!","user":"UHDNY2YMA","ts":"1615763918.084700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OmF+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Actually it might be worth using Tullio.jl and just \"left\" zero-pad one of them and reverse the other, e.g.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function tullio_conv(u::AbstractVector, v::AbstractVector)\n    # Left pad\n    upad = NNlib.pad_zeros(u, (length(v) - 1, 0))\n    v_rev = v[end:-1:1]\n\n    @tullio y[i+_] := upad[i+a] * v_rev[a]\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I'll try it out tomorrow; thanks!"}]}]}],"thread_ts":"1615759299.083400","parent_user_id":"UHDNY2YMA"}]