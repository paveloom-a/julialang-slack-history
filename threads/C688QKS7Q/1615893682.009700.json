[{"client_msg_id":"e9c8c1e8-d29e-4422-965c-dbeff963b3fa","type":"message","text":"I am not sure if it is worth opening an issue for this, but we recently had discussion with <@U67431ELR> about the following topic. Polars (<https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/>) has the following optimizations that might be potentially useful in Julia Base (both operations are relevant for having high performance DataFrames.jl, but maybe it is better to have it in Julia Base or some more general packages?):\n• section \"4.3 Performance: filter-trick\" of post: optimized filtering of `BitVector`. In Julia Base when you do `(1:10)[trues(10)]` then an intermediate step is:\n```julia&gt; Base.to_indices(1:10, (trues(10),))\n([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],)```\nwhich is slow. What Polars does is taking 64 bit chunks of `BitVector` and avoids allocating the integer index array at all but processes chunks sequentially in particular taking advantage of the fact that there are many leading 1s or 0s in the 64 bit chunk (as you do not have to branch to handle them). They claim that it improves performance visibly (except for unlikely bit patterns like `101010101010101010101`).\n•  section \"5.2.2 Lock-free hashing\" is in general an approach to allow to populate `Dict` using multiple threads without having to lock it (essentially you distribute one dict into multiple `Dict`s based on modulus of hash against number of threads). This is probably not something that will go into Julia Base, but my question is do we have such a structure already in the ecosystem (so that we do not reinvent the wheel in DataFrames.jl) + in general are there any plans for collections supporting multiple threads in Julia Base (as I assume we now have enough maturity of threading in Julia that it is a good moment to start thinking about such things)\nThank you for any comments!","user":"U8JAMQGQY","ts":"1615893682.009700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pKzG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am not sure if it is worth opening an issue for this, but we recently had discussion with "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" about the following topic. Polars ("},{"type":"link","url":"https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/"},{"type":"text","text":") has the following optimizations that might be potentially useful in Julia Base (both operations are relevant for having high performance DataFrames.jl, but maybe it is better to have it in Julia Base or some more general packages?):\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"section \"4.3 Performance: filter-trick\" of post: optimized filtering of "},{"type":"text","text":"BitVector","style":{"code":true}},{"type":"text","text":". In Julia Base when you do "},{"type":"text","text":"(1:10)[trues(10)]","style":{"code":true}},{"type":"text","text":" then an intermediate step is:"}]}],"style":"bullet","indent":0},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Base.to_indices(1:10, (trues(10),))\n([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which is slow. What Polars does is taking 64 bit chunks of "},{"type":"text","text":"BitVector","style":{"code":true}},{"type":"text","text":" and avoids allocating the integer index array at all but processes chunks sequentially in particular taking advantage of the fact that there are many leading 1s or 0s in the 64 bit chunk (as you do not have to branch to handle them). They claim that it improves performance visibly (except for unlikely bit patterns like "},{"type":"text","text":"101010101010101010101","style":{"code":true}},{"type":"text","text":").\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":" section \"5.2.2 Lock-free hashing\" is in general an approach to allow to populate "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" using multiple threads without having to lock it (essentially you distribute one dict into multiple "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":"s based on modulus of hash against number of threads). This is probably not something that will go into Julia Base, but my question is do we have such a structure already in the ecosystem (so that we do not reinvent the wheel in DataFrames.jl) + in general are there any plans for collections supporting multiple threads in Julia Base (as I assume we now have enough maturity of threading in Julia that it is a good moment to start thinking about such things)"}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you for any comments!"}]}]}],"thread_ts":"1615893682.009700","reply_count":4,"reply_users_count":3,"latest_reply":"1615902323.010700","reply_users":["UM30MT6RF","UB7JS9CHF","U8JAMQGQY"],"subscribed":false,"reactions":[{"name":"+1","users":["U67431ELR","UM30MT6RF","U0179G7FG4F","U011V2YN59N","UBF9YRB6H"],"count":5}]},{"client_msg_id":"163e768c-3a6c-43d0-ae60-cc6673932242","type":"message","text":"The first one does sounds like an optimization we probably want to have in Base for `getindex` with `BitArray`s, if it turns out to be advantageous.","user":"UM30MT6RF","ts":"1615894477.009900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"E=VhH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The first one does sounds like an optimization we probably want to have in Base for "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"BitArray","style":{"code":true}},{"type":"text","text":"s, if it turns out to be advantageous."}]}]}],"thread_ts":"1615893682.009700","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"6a045061-6c51-47ef-a233-f741143bd752","type":"message","text":"That lock-free hashing trick I think depends on having a different structure for hash tables, where you have separate chains, instead of scanning to find a free slot for insertion (which is the technique Base Dict uses)","user":"UB7JS9CHF","ts":"1615900475.010300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2C9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That lock-free hashing trick I think depends on having a different structure for hash tables, where you have separate chains, instead of scanning to find a free slot for insertion (which is the technique Base Dict uses)"}]}]}],"thread_ts":"1615893682.009700","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"b6ad8cca-32d9-4da2-a7f7-74e13b687505","type":"message","text":"Yes - you need to have as many tables as you have treads and distribute the update to an appropriate one.","user":"U8JAMQGQY","ts":"1615900590.010500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UDWp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes - you need to have as many tables as you have treads and distribute the update to an appropriate one."}]}]}],"thread_ts":"1615893682.009700","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"a5828fb4-7715-48d3-84bb-a60e9711e9eb","type":"message","text":"Well, you just have each thread handle multiple chains (or tables), it’s still lock free that way.","user":"UB7JS9CHF","ts":"1615902323.010700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o22","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well, you just have each thread handle multiple chains (or tables), it’s still lock free that way."}]}]}],"thread_ts":"1615893682.009700","parent_user_id":"U8JAMQGQY"}]