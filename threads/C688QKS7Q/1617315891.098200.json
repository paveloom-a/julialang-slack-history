[{"client_msg_id":"8e46c47a-7c65-4207-b71c-924980e741bb","type":"message","text":"A random thought: coming from languages like Haskell and OCaml, I have built up confidence with programming patterns involving arrow types, higher order functions and currying. What is the history behind the design choice of making julia's functions expose just the `Function` type, although under the surface methods have signatures? One of my dreams for future Julia is doing things with optimized higher order functions like `function foo(x::Vector{T}, y::Y, z::Function{T,Y}) where {T}` . Playing around in optimizing my package with Cthulhu.jl, I've noticed that by now, using higher order functions somehow limits the space of optimizations, and implies some slowdowns. In my (probably wrong) intuition, couldn't the type of `z` be dispatched against its method table ahead of time? Or maybe things already work like this on a lower level?","user":"U01K2JB9GPJ","ts":"1617315891.098200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pQl9P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A random thought: coming from languages like Haskell and OCaml, I have built up confidence with programming patterns involving arrow types, higher order functions and currying. What is the history behind the design choice of making julia's functions expose just the "},{"type":"text","text":"Function","style":{"code":true}},{"type":"text","text":" type, although under the surface methods have signatures? One of my dreams for future Julia is doing things with optimized higher order functions like "},{"type":"text","text":"function foo(x::Vector{T}, y::Y, z::Function{T,Y}) where {T}","style":{"code":true}},{"type":"text","text":" . Playing around in optimizing my package with Cthulhu.jl, I've noticed that by now, using higher order functions somehow limits the space of optimizations, and implies some slowdowns. In my (probably wrong) intuition, couldn't the type of "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" be dispatched against its method table ahead of time? Or maybe things already work like this on a lower level?"}]}]}],"thread_ts":"1617315891.098200","reply_count":23,"reply_users_count":5,"latest_reply":"1617592570.109600","reply_users":["U6795JH6H","U01K2JB9GPJ","USU9FRPEU","U674T3KB3","UDGT4PM41"],"is_locked":false,"subscribed":false},{"client_msg_id":"2874b758-0945-47e1-930a-efe6e7e10a6d","type":"message","text":"I’ll answer your question with another question: What should the type of the `+` function in Julia be?","user":"U6795JH6H","ts":"1617316245.098300","team":"T68168MUP","edited":{"user":"U6795JH6H","ts":"1617316362.000000"},"blocks":[{"type":"rich_text","block_id":"/Kc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’ll answer your question with another question: What should the type of the "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" function in Julia be?"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"89f83d7b-a180-40c1-8f34-4bdea1990659","type":"message","text":"Using function arguments should not have a performance penalty since specialized code is generated for each specific function that is passed as an argument (there are some heuristics that limit specialization, but that’s a rough first order approximation)","user":"U6795JH6H","ts":"1617316333.098500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zayNk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Using function arguments should not have a performance penalty since specialized code is generated for each specific function that is passed as an argument (there are some heuristics that limit specialization, but that’s a rough first order approximation)"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"cb19dcac-6e53-4072-a131-5efcc883b626","type":"message","text":"So in your example, there will be a version of `foo` compiled for each function `z` that you pass to it","user":"U6795JH6H","ts":"1617316435.098800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iMi6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So in your example, there will be a version of "},{"type":"text","text":"foo","style":{"code":true}},{"type":"text","text":" compiled for each function "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" that you pass to it"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"35010af8-a19b-4a5c-b4ac-1d93048be2df","type":"message","text":"This allows full type inference based on whatever `z` does and even inlining","user":"U6795JH6H","ts":"1617316470.099000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BYRsn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This allows full type inference based on whatever "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" does and even inlining"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"7d38540e-7b1e-49e8-bd92-98691a247b82","type":"message","text":"In general, functional programming in Julia should have far higher performance than it does in Haskell or OCaml","user":"U6795JH6H","ts":"1617316495.099200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w8S","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In general, functional programming in Julia should have far higher performance than it does in Haskell or OCaml"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ","reactions":[{"name":"sunglasses","users":["U680THK2S","UGU761DU2","U7THT3TM3"],"count":3}]},{"client_msg_id":"3a62a76d-4139-4c01-afe3-e4460f1d834d","type":"message","text":"Thanks! Explained it all.","user":"U01K2JB9GPJ","ts":"1617316648.099500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S34se","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks! Explained it all."}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"3443b99f-9176-4142-8537-df3390de9b67","type":"message","text":"Functors might allow for some of the functionality you are looking for though:\n<https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects>","user":"USU9FRPEU","ts":"1617316655.099700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DfeCq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Functors might allow for some of the functionality you are looking for though:\n"},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"39f75d12-aded-4a28-a1b2-20e423d2bd04","type":"message","text":"The reason being that those languages only compile one version of each function and rely on uniform data representation, i.e. that all values are represented as pointers to a boxed value with the typical exception of integers, which are often stored immediately using 63 bits, as an optimization (if you’re working with floats, you’re out of luck, those get boxed)","user":"U6795JH6H","ts":"1617316669.099900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UKp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The reason being that those languages only compile one version of each function and rely on uniform data representation, i.e. that all values are represented as pointers to a boxed value with the typical exception of integers, which are often stored immediately using 63 bits, as an optimization (if you’re working with floats, you’re out of luck, those get boxed)"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"f2aa58e8-c896-48fe-9bfe-f3936d450153","type":"message","text":"OpaqueClosure also have the pre-dispatch behavior if you need it for performance","user":"U674T3KB3","ts":"1617316736.100100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fbc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OpaqueClosure also have the pre-dispatch behavior if you need it for performance"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"713e81a8-d8d9-499c-8018-62326b57ebbd","type":"message","text":"To spell out the design problem: generic functions have lots of methods and while it might make sense for methods to have arrow types, arrow types don’t really make sense with the extreme polymorphism of functions","user":"U6795JH6H","ts":"1617316894.100300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NtU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To spell out the design problem: generic functions have lots of methods and while it might make sense for methods to have arrow types, arrow types don’t really make sense with the extreme polymorphism of functions"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ","reactions":[{"name":"+1","users":["UGU761DU2","U01K2JB9GPJ"],"count":2}]},{"client_msg_id":"536c4409-534e-4ad3-b11b-90853403e49b","type":"message","text":"There are a few possible features that would be nice though, including being able to constrain the allowable signatures of a generic function","user":"U6795JH6H","ts":"1617316933.100500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"692fE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are a few possible features that would be nice though, including being able to constrain the allowable signatures of a generic function"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ","reactions":[{"name":"100","users":["U01HD5VFXJM"],"count":1}]},{"client_msg_id":"f83a4fcc-3ad9-49c1-9a7b-c00c74a3cca6","type":"message","text":"Like saying that `convert(::Type{T}, _)` has to return something of type `T`","user":"U6795JH6H","ts":"1617316955.100700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4CDL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like saying that "},{"type":"text","text":"convert(::Type{T}, _)","style":{"code":true}},{"type":"text","text":" has to return something of type "},{"type":"text","text":"T","style":{"code":true}}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ","reactions":[{"name":"+1","users":["UDGT4PM41","ULG5V164A"],"count":2}]},{"client_msg_id":"a4b3cf27-af98-4faa-b8e3-990bc2cfb086","type":"message","text":"That would help enforce sane definitions for generic functions and limit invalidations since inference could know the return type even in the presence of many methods","user":"U6795JH6H","ts":"1617317019.100900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w9Ny","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would help enforce sane definitions for generic functions and limit invalidations since inference could know the return type even in the presence of many methods"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ","reactions":[{"name":"+1","users":["UDGT4PM41"],"count":1}]},{"client_msg_id":"e4b593e4-7c50-496e-a1a7-044620983102","type":"message","text":"What if we widen the concept of a type by including behavior","user":"UDGT4PM41","ts":"1617318061.101300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mCH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What if we widen the concept of a type by including behavior"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"4a166b5b-89fb-46dc-8de9-b0b91fee3937","type":"message","text":"Then it might make sense to say there's something about \"addness\" or mathematical structure that all addable types have","user":"UDGT4PM41","ts":"1617318110.101500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+8SiL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Then it might make sense to say there's something about \"addness\" or mathematical structure that all addable types have"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"ca2f1601-0138-4180-a575-f92bc3872fa7","type":"message","text":"I guess I'm wondering if the extreme polymorphism precludes pervasive  function types because we have nominal typing","user":"UDGT4PM41","ts":"1617318186.101700","team":"T68168MUP","edited":{"user":"UDGT4PM41","ts":"1617318203.000000"},"blocks":[{"type":"rich_text","block_id":"4PPi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess I'm wondering if the extreme polymorphism precludes pervasive  function types because we have nominal typing"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"090d63a0-29aa-4634-be6f-54028ee710e8","type":"message","text":"Clearly there's an abstract  idea of + in my head, otherwise overloading the function wouldn't make sense (or be useful for interop). It seems like a restriction of the type system that I can't express that. Which is why we sometimes have to forgo typing methods","user":"UDGT4PM41","ts":"1617318289.102000","team":"T68168MUP","edited":{"user":"UDGT4PM41","ts":"1617318456.000000"},"blocks":[{"type":"rich_text","block_id":"0Sj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Clearly there's an abstract  idea of + in my head, otherwise overloading the function wouldn't make sense (or be useful for interop). It seems like a restriction of the type system that I can't express that. Which is why we sometimes have to forgo typing methods"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"2862252d-b6b2-4ee0-87e8-7004445190a5","type":"message","text":"Like interfaces, static hasmethod, traits, typeclasses, protocols whatever. Stuff that groups nominal types together","user":"UDGT4PM41","ts":"1617318363.102300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/ZTd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like interfaces, static hasmethod, traits, typeclasses, protocols whatever. Stuff that groups nominal types together"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"d6c20ffa-977e-4194-b47e-8155c18b0765","type":"message","text":"You mean typeclasses?","user":"U01K2JB9GPJ","ts":"1617319134.102700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LKQk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You mean typeclasses?"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"56cb43a1-af6b-4316-8e52-522a55e5743f","type":"message","text":"Yea stuff like that. I dnk, I'm just an interested layperson wrt pl theory so maybe I'm way off base here.","user":"UDGT4PM41","ts":"1617319398.102900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tdUHq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yea stuff like that. I dnk, I'm just an interested layperson wrt pl theory so maybe I'm way off base here."}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"1d850a01-66ec-4531-9fe3-833dae71ef6a","type":"message","text":"I’d like to add that it’s not that we haven’t thought about arrow types and even wanted them at times. The issue is that it’s far from obvious how arrow types would work with multiple dispatch, and especially in a dynamic language. So it remains a very open question whether there’s anything we could do that would make sense. There might be, but it’s not like “just add arrow types like ML language have” was an option. If it was, we would have done that.","user":"U6795JH6H","ts":"1617334865.103600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VfLO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’d like to add that it’s not that we haven’t thought about arrow types and even wanted them at times. The issue is that it’s far from obvious how arrow types would work with multiple dispatch, and especially in a dynamic language. So it remains a very open question whether there’s anything we could do that would make sense. There might be, but it’s not like “just add arrow types like ML language have” was an option. If it was, we would have done that."}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"6eda0cf7-e3e2-4f34-9cb0-76797d122a46","type":"message","text":"Early on we even reserved the `A --&gt; B` syntax for arrow types. But we never figured out a good way to use that syntax. For the 1.0 version of Julia, we found that we just didn’t need arrow types and so we stuck with just `Function`.","user":"U6795JH6H","ts":"1617334953.104000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0etV5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Early on we even reserved the "},{"type":"text","text":"A --> B","style":{"code":true}},{"type":"text","text":" syntax for arrow types. But we never figured out a good way to use that syntax. For the 1.0 version of Julia, we found that we just didn’t need arrow types and so we stuck with just "},{"type":"text","text":"Function","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"d41568a4-54d8-4c95-98c7-607c588acd86","type":"message","text":"Yea that makes sense. As usual in  Julia it's clear that this decision has  reasons and taken the brunt of a good deal of thought","user":"UDGT4PM41","ts":"1617592570.109600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UGH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yea that makes sense. As usual in  Julia it's clear that this decision has  reasons and taken the brunt of a good deal of thought"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"}]