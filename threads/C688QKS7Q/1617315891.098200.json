[{"client_msg_id":"8e46c47a-7c65-4207-b71c-924980e741bb","type":"message","text":"A random thought: coming from languages like Haskell and OCaml, I have built up confidence with programming patterns involving arrow types, higher order functions and currying. What is the history behind the design choice of making julia's functions expose just the `Function` type, although under the surface methods have signatures? One of my dreams for future Julia is doing things with optimized higher order functions like `function foo(x::Vector{T}, y::Y, z::Function{T,Y}) where {T}` . Playing around in optimizing my package with Cthulhu.jl, I've noticed that by now, using higher order functions somehow limits the space of optimizations, and implies some slowdowns. In my (probably wrong) intuition, couldn't the type of `z` be dispatched against its method table ahead of time? Or maybe things already work like this on a lower level?","user":"U01K2JB9GPJ","ts":"1617315891.098200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pQl9P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A random thought: coming from languages like Haskell and OCaml, I have built up confidence with programming patterns involving arrow types, higher order functions and currying. What is the history behind the design choice of making julia's functions expose just the "},{"type":"text","text":"Function","style":{"code":true}},{"type":"text","text":" type, although under the surface methods have signatures? One of my dreams for future Julia is doing things with optimized higher order functions like "},{"type":"text","text":"function foo(x::Vector{T}, y::Y, z::Function{T,Y}) where {T}","style":{"code":true}},{"type":"text","text":" . Playing around in optimizing my package with Cthulhu.jl, I've noticed that by now, using higher order functions somehow limits the space of optimizations, and implies some slowdowns. In my (probably wrong) intuition, couldn't the type of "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" be dispatched against its method table ahead of time? Or maybe things already work like this on a lower level?"}]}]}],"thread_ts":"1617315891.098200","reply_count":13,"reply_users_count":4,"latest_reply":"1617317019.100900","reply_users":["U6795JH6H","U01K2JB9GPJ","USU9FRPEU","U674T3KB3"],"is_locked":false,"subscribed":false},{"client_msg_id":"2874b758-0945-47e1-930a-efe6e7e10a6d","type":"message","text":"I’ll answer your question with another question: What should the type of the `+` function in Julia be?","user":"U6795JH6H","ts":"1617316245.098300","team":"T68168MUP","edited":{"user":"U6795JH6H","ts":"1617316362.000000"},"blocks":[{"type":"rich_text","block_id":"/Kc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’ll answer your question with another question: What should the type of the "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" function in Julia be?"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"89f83d7b-a180-40c1-8f34-4bdea1990659","type":"message","text":"Using function arguments should not have a performance penalty since specialized code is generated for each specific function that is passed as an argument (there are some heuristics that limit specialization, but that’s a rough first order approximation)","user":"U6795JH6H","ts":"1617316333.098500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zayNk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Using function arguments should not have a performance penalty since specialized code is generated for each specific function that is passed as an argument (there are some heuristics that limit specialization, but that’s a rough first order approximation)"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"cb19dcac-6e53-4072-a131-5efcc883b626","type":"message","text":"So in your example, there will be a version of `foo` compiled for each function `z` that you pass to it","user":"U6795JH6H","ts":"1617316435.098800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iMi6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So in your example, there will be a version of "},{"type":"text","text":"foo","style":{"code":true}},{"type":"text","text":" compiled for each function "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" that you pass to it"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"35010af8-a19b-4a5c-b4ac-1d93048be2df","type":"message","text":"This allows full type inference based on whatever `z` does and even inlining","user":"U6795JH6H","ts":"1617316470.099000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BYRsn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This allows full type inference based on whatever "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" does and even inlining"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"7d38540e-7b1e-49e8-bd92-98691a247b82","type":"message","text":"In general, functional programming in Julia should have far higher performance than it does in Haskell or OCaml","user":"U6795JH6H","ts":"1617316495.099200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w8S","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In general, functional programming in Julia should have far higher performance than it does in Haskell or OCaml"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ","reactions":[{"name":"sunglasses","users":["U680THK2S"],"count":1}]},{"client_msg_id":"3a62a76d-4139-4c01-afe3-e4460f1d834d","type":"message","text":"Thanks! Explained it all.","user":"U01K2JB9GPJ","ts":"1617316648.099500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S34se","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks! Explained it all."}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"3443b99f-9176-4142-8537-df3390de9b67","type":"message","text":"Functors might allow for some of the functionality you are looking for though:\n<https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects>","user":"USU9FRPEU","ts":"1617316655.099700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DfeCq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Functors might allow for some of the functionality you are looking for though:\n"},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"39f75d12-aded-4a28-a1b2-20e423d2bd04","type":"message","text":"The reason being that those languages only compile one version of each function and rely on uniform data representation, i.e. that all values are represented as pointers to a boxed value with the typical exception of integers, which are often stored immediately using 63 bits, as an optimization (if you’re working with floats, you’re out of luck, those get boxed)","user":"U6795JH6H","ts":"1617316669.099900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UKp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The reason being that those languages only compile one version of each function and rely on uniform data representation, i.e. that all values are represented as pointers to a boxed value with the typical exception of integers, which are often stored immediately using 63 bits, as an optimization (if you’re working with floats, you’re out of luck, those get boxed)"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"f2aa58e8-c896-48fe-9bfe-f3936d450153","type":"message","text":"OpaqueClosure also have the pre-dispatch behavior if you need it for performance","user":"U674T3KB3","ts":"1617316736.100100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fbc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OpaqueClosure also have the pre-dispatch behavior if you need it for performance"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"713e81a8-d8d9-499c-8018-62326b57ebbd","type":"message","text":"To spell out the design problem: generic functions have lots of methods and while it might make sense for methods to have arrow types, arrow types don’t really make sense with the extreme polymorphism of functions","user":"U6795JH6H","ts":"1617316894.100300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NtU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To spell out the design problem: generic functions have lots of methods and while it might make sense for methods to have arrow types, arrow types don’t really make sense with the extreme polymorphism of functions"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"536c4409-534e-4ad3-b11b-90853403e49b","type":"message","text":"There are a few possible features that would be nice though, including being able to constrain the allowable signatures of a generic function","user":"U6795JH6H","ts":"1617316933.100500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"692fE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are a few possible features that would be nice though, including being able to constrain the allowable signatures of a generic function"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"f83a4fcc-3ad9-49c1-9a7b-c00c74a3cca6","type":"message","text":"Like saying that `convert(::Type{T}, _)` has to return something of type `T`","user":"U6795JH6H","ts":"1617316955.100700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4CDL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like saying that "},{"type":"text","text":"convert(::Type{T}, _)","style":{"code":true}},{"type":"text","text":" has to return something of type "},{"type":"text","text":"T","style":{"code":true}}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"},{"client_msg_id":"a4b3cf27-af98-4faa-b8e3-990bc2cfb086","type":"message","text":"That would help enforce sane definitions for generic functions and limit invalidations since inference could know the return type even in the presence of many methods","user":"U6795JH6H","ts":"1617317019.100900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w9Ny","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would help enforce sane definitions for generic functions and limit invalidations since inference could know the return type even in the presence of many methods"}]}]}],"thread_ts":"1617315891.098200","parent_user_id":"U01K2JB9GPJ"}]