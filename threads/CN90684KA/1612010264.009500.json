[{"client_msg_id":"bc48cbcc-fa34-4ce6-888b-42321684b50b","type":"message","text":"I think Rust is pretty cool with its memory safety - but the single dispatch OOP and syntax leave me rather cold.  Best to make libraries out of Rust, and control things from Julia :slightly_smiling_face:","user":"UB7JS9CHF","ts":"1612010264.009500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UcU2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think Rust is pretty cool with its memory safety - but the single dispatch OOP and syntax leave me rather cold.  Best to make libraries out of Rust, and control things from Julia "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1612010264.009500","reply_count":53,"reply_users_count":8,"latest_reply":"1612258122.042000","reply_users":["UPUBAM63X","U011V2YN59N","UB7JS9CHF","UPQP0RWTH","U7HAYKY9X","UDSU53PEG","UDGT4PM41","U8D9768Q6"],"subscribed":false},{"client_msg_id":"64bf2408-b6af-4b74-b501-6c51af21f577","type":"message","text":"So Rust is single dispatch but it does support generics. For example,\n```#[derive(Copy, Clone, Default)]\nstruct Edge&lt;U:Eq + Hash + Copy, T: Default + Copy = ()&gt; {\n    id: U,\n    x: T,\n}```\nIs a struct where U can take any kind of Int, or thing that satisfies those traits. Same goes for T, could be a float8,16,32, or whatever.\n\nI'm actually pretty impressed with how Rust isn't strongly OOP oriented, and how FP, is essential in it. It's more trait oriented which is a modern-ish paradigm.\n\nThat said I do agree, Rust is best for libraries, Julia is best for quickly gluing things together and prototyping. I think once I get better at Rust I could prototype in it, but noting beats Julia's syntax for mathy stuff.","user":"UPUBAM63X","ts":"1612018086.009900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7=nn=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So Rust is single dispatch but it does support generics. For example,\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"#[derive(Copy, Clone, Default)]\nstruct Edge<U:Eq + Hash + Copy, T: Default + Copy = ()> {\n    id: U,\n    x: T,\n}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is a struct where U can take any kind of Int, or thing that satisfies those traits. Same goes for T, could be a float8,16,32, or whatever.\n\nI'm actually pretty impressed with how Rust isn't strongly OOP oriented, and how FP, is essential in it. It's more trait oriented which is a modern-ish paradigm.\n\nThat said I do agree, Rust is best for libraries, Julia is best for quickly gluing things together and prototyping. I think once I get better at Rust I could prototype in it, but noting beats Julia's syntax for mathy stuff."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"2b3c3393-6640-4c04-b53c-ef51258fac1e","type":"message","text":"rust has a better type system than julia tbh","user":"U011V2YN59N","ts":"1612024771.010200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K/B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"rust has a better type system than julia tbh"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"b94deebc-a703-4a0d-af79-c89bbf39892b","type":"message","text":"static typing is still best","user":"U011V2YN59N","ts":"1612024785.010400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C+GoB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"static typing is still best"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF","reactions":[{"name":"face_vomiting","users":["U8D9768Q6"],"count":1}]},{"client_msg_id":"a5a1e788-c163-4c7f-919a-c37967a29e7f","type":"message","text":"Totally disagree about that though.  I am so much more productive with the things I can accomplish with Julia’s type system.","user":"UB7JS9CHF","ts":"1612024859.010600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+1f/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Totally disagree about that though.  I am so much more productive with the things I can accomplish with Julia’s type system."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"14d7a09c-7a3d-42a3-92a2-24bfc6e15867","type":"message","text":"with julia we could have both","user":"U011V2YN59N","ts":"1612025147.010800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mFtfI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"with julia we could have both"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF","reactions":[{"name":"1000","users":["UB7JS9CHF"],"count":1}]},{"client_msg_id":"1f201745-a745-42d3-a784-67dfabb3a450","type":"message","text":"I know some people are working on static analysis tools for julia","user":"U011V2YN59N","ts":"1612025156.011000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LcSHD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I know some people are working on static analysis tools for julia"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF","reactions":[{"name":"+1","users":["UB7JS9CHF","UPUBAM63X"],"count":2}]},{"client_msg_id":"f2ba984b-1fb9-4bd9-a3d8-65c3526fa9d2","type":"message","text":"I do think that, if I had to choose between Julia’s type system and other languages’ static typing, I’d always prefer Julia’s.  *However*, I am 100% in agreement, that also having static analysis tools for Julia would be wonderful.","user":"UB7JS9CHF","ts":"1612025637.011400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0szVa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do think that, if I had to choose between Julia’s type system and other languages’ static typing, I’d always prefer Julia’s.  "},{"type":"text","text":"However","style":{"bold":true}},{"type":"text","text":", I am 100% in agreement, that also having static analysis tools for Julia would be wonderful."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"955a8407-0078-425e-b9a6-0e586d1a4721","type":"message","text":"The traits + some cool crypto libraries are my main interest to learn Rust in the future. <@UPUBAM63X> could you comment on the pitfalls in expressibility, which is easy to do in Julia and are problematic in Rust (apart from notorious borrow checker). Does the trait oriented paradigm allow the same kind of modularization as multiple dispatch with type system does?","user":"UPQP0RWTH","ts":"1612025763.011900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JH4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The traits + some cool crypto libraries are my main interest to learn Rust in the future. "},{"type":"user","user_id":"UPUBAM63X"},{"type":"text","text":" could you comment on the pitfalls in expressibility, which is easy to do in Julia and are problematic in Rust (apart from notorious borrow checker). Does the trait oriented paradigm allow the same kind of modularization as multiple dispatch with type system does?"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"31e5b7b9-f42d-48b9-9e84-f3cf3151ff26","type":"message","text":"So ironically i haven't had trouble with the borrow checkers. I've had a harder time knowing the syntax to use the borrow checker appropriately (IE: &amp;mut etc). But - I also have spent some time in C++ so your mileage may vary.","user":"UPUBAM63X","ts":"1612031636.012200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AWF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So ironically i haven't had trouble with the borrow checkers. I've had a harder time knowing the syntax to use the borrow checker appropriately (IE: &mut etc). But - I also have spent some time in C++ so your mileage may vary."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"6bb4cde7-e136-4430-937b-8ef530c0cb16","type":"message","text":"Okay I can only comment from the perspective of an end user, not like compiler knowledge. I feel like multidispatch, and template/trait based generics feel very similar. Go is more restrictive than Rust IMO.\n\nIf I have to compare the two tools I would say with Rust you do have to be slightly more thoughtful for a first pass on a project. I mean - it will make you be more thoughtful (ie deriving traits to distinguish things, etc). But with Julia you can kind of do `any`thing whenever or however with fewer gaurd rails. That said Julia's guard rails are MUCH nicer than say pythons.","user":"UPUBAM63X","ts":"1612031777.012400","team":"T68168MUP","edited":{"user":"UPUBAM63X","ts":"1612031783.000000"},"blocks":[{"type":"rich_text","block_id":"AcdFs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Okay I can only comment from the perspective of an end user, not like compiler knowledge. I feel like multidispatch, and template/trait based generics feel very similar. Go is more restrictive than Rust IMO.\n\nIf I have to compare the two tools I would say with Rust you do have to be slightly more thoughtful for a first pass on a project. I mean - it will make you be more thoughtful (ie deriving traits to distinguish things, etc). But with Julia you can kind of do "},{"type":"text","text":"any","style":{"code":true}},{"type":"text","text":"thing whenever or however with fewer gaurd rails. That said Julia's guard rails are MUCH nicer than say pythons."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"15a1c1e6-2b92-4f76-aea5-2c87a47b6d98","type":"message","text":"Modularization isn't the same, because of `impls`  like your code can and likely will have some larger blocks in it than say Julia code(which often looks like a pile of functions and structs), but really imples are just a flag to say \"hey this belongs to that\".\nSo in some ways there can be less \"immediate\" reuse of code across types/traits. But in reality, once you make a design, it's not burdensome at all. You can make a buncha structs with functions if you want, but it seems less advantageous. That said it's nothing like nested classes of inherited abstract interface class whatevers in Java.","user":"UPUBAM63X","ts":"1612032005.012700","team":"T68168MUP","edited":{"user":"UPUBAM63X","ts":"1612032229.000000"},"blocks":[{"type":"rich_text","block_id":"0jW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Modularization isn't the same, because of "},{"type":"text","text":"impls","style":{"code":true}},{"type":"text","text":"  like your code can and likely will have some larger blocks in it than say Julia code(which often looks like a pile of functions and structs), but really imples are just a flag to say \"hey this belongs to that\".\nSo in some ways there can be less \"immediate\" reuse of code across types/traits. But in reality, once you make a design, it's not burdensome at all. You can make a buncha structs with functions if you want, but it seems less advantageous. That said it's nothing like nested classes of inherited abstract interface class whatevers in Java."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"ac02401b-194a-49b5-a4e2-ec164eff73b3","type":"message","text":"I think OOP, dynamic/static and how the type system is built are three completely different things that you can mix and match how you want.\nI think Julia nails it on the multiple dispatch as opposed to Rust's OOP, that dynamic/staticness have both pros and cons depending on the situation, and that Rust's trait based type system is superior to Julia's.","user":"U7HAYKY9X","ts":"1612036983.013000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"54w09","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think OOP, dynamic/static and how the type system is built are three completely different things that you can mix and match how you want.\nI think Julia nails it on the multiple dispatch as opposed to Rust's OOP, that dynamic/staticness have both pros and cons depending on the situation, and that Rust's trait based type system is superior to Julia's."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"59291a9a-8e55-439b-b479-1459bb177ad6","type":"message","text":"But I don't see any reasons someone couldn't make a dynamic, multiple dispatch language with a trait-based type system, for example","user":"U7HAYKY9X","ts":"1612037015.013200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JPjI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I don't see any reasons someone couldn't make a dynamic, multiple dispatch language with a trait-based type system, for example"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"9ed6a905-e365-432f-b850-defa5282acd5","type":"message","text":"Rust isn't very good at broad type-level metaprogramming without encoding all of the computations required into trait bounds, so there is a pretty severe lack of generality and power and the outcome of this is pretty ugly function signatures and other boiler-plate.","user":"UDSU53PEG","ts":"1612037771.013400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LiXOZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Rust isn't very good at broad type-level metaprogramming without encoding all of the computations required into trait bounds, so there is a pretty severe lack of generality and power and the outcome of this is pretty ugly function signatures and other boiler-plate."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"1e614bf0-6175-4df4-99e3-aaac0f9ef275","type":"message","text":"If Rust were to get refinement types it would help but that would be a monumental change that hasn't even earnestly started afiak","user":"UDSU53PEG","ts":"1612037945.013600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aMu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If Rust were to get refinement types it would help but that would be a monumental change that hasn't even earnestly started afiak"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"41B4EA11-AB8D-4C9E-B2CC-2A6233C4AF44","type":"message","text":"<@U7HAYKY9X> You don’t like using Holy traits in Julia?","user":"UB7JS9CHF","ts":"1612038487.014500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Ha73","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" You don’t like using Holy traits in Julia?"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"46ae4770-43a7-4881-aabb-523f7b4db638","type":"message","text":"No. There's a few problems with them.\n1. Most importantly, they're not ubiquitous, they exist alongside another type system. I think it's better to stick to one system unless that system runs into limitations. For example, most types in Base don't have Holy traits associated with them\n2. They fill up the type signatures which is annoying\n3. They end up giving wierd error messages","user":"U7HAYKY9X","ts":"1612038645.014700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NnNwL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No. There's a few problems with them.\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Most importantly, they're not ubiquitous, they exist alongside another type system. I think it's better to stick to one system unless that system runs into limitations. For example, most types in Base don't have Holy traits associated with them"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"They fill up the type signatures which is annoying"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"They end up giving wierd error messages"}]}],"style":"ordered","indent":0}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"a3f8a5e4-a162-4ead-80a6-a8b106cc6c36","type":"message","text":"I mean, I do like them, it's not just not the same as having a trait-based type system. But perhaps Oliver is right it leads to a lot of boilerplate (\"I need a type A, which must support indexing, and is heap-allocated and contain integers, and type B which [blah blag blah]\" is much longer than \"I need an array and a Dict\")","user":"U7HAYKY9X","ts":"1612038833.014900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HXlT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, I do like them, it's not just not the same as having a trait-based type system. But perhaps Oliver is right it leads to a lot of boilerplate (\"I need a type A, which must support indexing, and is heap-allocated and contain integers, and type B which [blah blag blah]\" is much longer than \"I need an array and a Dict\")"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"75364d95-5f2a-466f-a989-e36ab7b03f98","type":"message","text":"Although I guess you could just have abstract types being a set of traits","user":"U7HAYKY9X","ts":"1612038939.016200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pAcVI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Although I guess you could just have abstract types being a set of traits"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"ACF6E1F1-7106-4C7F-8F07-F7DEDC579D04","type":"message","text":"I think the two systems are complementary, my only issues with Holy traits is not (yet) having more convenient syntax, and, as you said, not all of the Base types even use traits (arrays do, more and more)","user":"UB7JS9CHF","ts":"1612039019.018300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sI/r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the two systems are complementary, my only issues with Holy traits is not (yet) having more convenient syntax, and, as you said, not all of the Base types even use traits (arrays do, more and more)"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"2E246741-99F6-4833-BB52-8D5E9A0ABCE4","type":"message","text":"I feel like some of your complaints are more about how types / traits are currently most commonly used in Julia &amp; Rust at the moment, and not so much about the functionality.\nI don’t think Julia is missing any functionality that is present in Rust, as far as traits and the type system is concerned, but Rust does feel like it lacks some of the possibilities present with Julia (but I would be happy to be proven wrong by some Rustacean!)","user":"UB7JS9CHF","ts":"1612039319.024300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OqkF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I feel like some of your complaints are more about how types / traits are currently most commonly used in Julia & Rust at the moment, and not so much about the functionality.\nI don’t think Julia is missing any functionality that is present in Rust, as far as traits and the type system is concerned, but Rust does feel like it lacks some of the possibilities present with Julia (but I would be happy to be proven wrong by some Rustacean!)"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"927a8447-a2ba-4bd0-87ab-8d74e02ab951","type":"message","text":"That's right, although I would argue that having the possibility of doing X in language Y is much less important than language Y actually doing X. In practise, it's not possible to write generic functions in Julia using trait constrains.","user":"U7HAYKY9X","ts":"1612039432.024500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dMQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's right, although I would argue that having the possibility of doing X in language Y is much less important than language Y actually doing X. In practise, it's not possible to write generic functions in Julia using trait constrains."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"51D53293-9B1C-4B55-9908-6B559CE32A08","type":"message","text":"Hmmm, I don’t think I’d have any difficulty doing so at all in Julia","user":"UB7JS9CHF","ts":"1612039518.025800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MH0Ej","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmmm, I don’t think I’d have any difficulty doing so at all in Julia"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"FE260895-D2DE-4B60-B3EC-C145F5DD1F0C","type":"message","text":"I did more complex trait based dispatching years ago in Julia","user":"UB7JS9CHF","ts":"1612039567.026600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O+X","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I did more complex trait based dispatching years ago in Julia"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"e95dfd7f-4353-450e-8e0e-306110c94a3b","type":"message","text":"But there are no notions in Julia of being \"callable\" or \"indexable\", or \"dict-like\" or \"searchable in O(1)\", or anything? There are only a handful of traits in actual use?","user":"U7HAYKY9X","ts":"1612039569.026800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cbSX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But there are no notions in Julia of being \"callable\" or \"indexable\", or \"dict-like\" or \"searchable in O(1)\", or anything? There are only a handful of traits in actual use?"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"6B0EB7FA-1310-4731-B048-369AC2622ECF","type":"message","text":"Trivial to add whatever you want though","user":"UB7JS9CHF","ts":"1612039592.027400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"g9tE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Trivial to add whatever you want though"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"1e153f8f-3b88-40b0-9db6-bd0c12a1a339","type":"message","text":"No, because apart from being a huge piece of work to do for all types, it's no longer generic. Because\n1. There is no way to check if you remembered to add all types\n2. It will not work with other packages who are not in on your exact trait of schemes","user":"U7HAYKY9X","ts":"1612039648.028200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kMMg8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, because apart from being a huge piece of work to do for all types, it's no longer generic. Because\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is no way to check if you remembered to add all types"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It will not work with other packages who are not in on your exact trait of schemes"}]}],"style":"ordered","indent":0}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"60888CA9-7099-4C32-90C9-C93CD5976AD3","type":"message","text":"You make your own trait, write functions for the different types with fallbacks, and use those","user":"UB7JS9CHF","ts":"1612039667.028800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CUY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You make your own trait, write functions for the different types with fallbacks, and use those"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"B204616E-EB0E-4E28-86C3-8C385B838741","type":"message","text":"Fallbacks!","user":"UB7JS9CHF","ts":"1612039679.029200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TO3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fallbacks!"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"76F31FAD-5B2B-44C6-A1E9-CBCDD3CFB9C0","type":"message","text":"You don’t *need * to handle all types","user":"UB7JS9CHF","ts":"1612039709.029900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ny38a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You don’t *need * to handle all types"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"820D65A1-B2E8-4516-8E5F-BC9B85DE1A7D","type":"message","text":"That’s also where abstract types can help out a lot","user":"UB7JS9CHF","ts":"1612039728.030500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UkP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s also where abstract types can help out a lot"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"326faf16-41a1-4887-bf9d-c02b46d4612b","type":"message","text":"But... what doesn't actually work? E.g. how can I possibly do a fallback for `Callable`  or `Iterable`  or `Indexable` ? I don't underatand.","user":"U7HAYKY9X","ts":"1612039729.030700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ImOWj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But... what doesn't actually work? E.g. how can I possibly do a fallback for "},{"type":"text","text":"Callable","style":{"code":true}},{"type":"text","text":"  or "},{"type":"text","text":"Iterable","style":{"code":true}},{"type":"text","text":"  or "},{"type":"text","text":"Indexable","style":{"code":true}},{"type":"text","text":" ? I don't underatand."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"fcb0b02a-e456-4665-bf2d-86c3f8cfbd8c","type":"message","text":"I’m not sure what you mean by that. `Callable` exists, but `Iterable` and `Indexable` don’t.","user":"UB7JS9CHF","ts":"1612040112.030900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/9jm0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m not sure what you mean by that. "},{"type":"text","text":"Callable","style":{"code":true}},{"type":"text","text":" exists, but "},{"type":"text","text":"Iterable","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Indexable","style":{"code":true}},{"type":"text","text":" don’t."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"af42de2a-0fab-4447-957e-5815cc31d849","type":"message","text":"Arrays have a number of traits like `HasEltype`, `HasShape`, `HasLength`","user":"UB7JS9CHF","ts":"1612040248.031100","team":"T68168MUP","edited":{"user":"UB7JS9CHF","ts":"1612040289.000000"},"blocks":[{"type":"rich_text","block_id":"CYyi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Arrays have a number of traits like "},{"type":"text","text":"HasEltype","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"HasShape","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"HasLength","style":{"code":true}}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"1827d70d-a80a-43fb-b579-4a1d1750a17e","type":"message","text":"What I mean is that, suppose for example I want to statically check whether I can call function `foo` on my value of `MyType` . `foo` needs a few things for its argument: It needs to iterate over it and its elements needs to be callable. There is no way to check that in Julia, statically.","user":"U7HAYKY9X","ts":"1612040381.031400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AUtVm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What I mean is that, suppose for example I want to statically check whether I can call function "},{"type":"text","text":"foo","style":{"code":true}},{"type":"text","text":" on my value of "},{"type":"text","text":"MyType","style":{"code":true}},{"type":"text","text":" . "},{"type":"text","text":"foo","style":{"code":true}},{"type":"text","text":" needs a few things for its argument: It needs to iterate over it and its elements needs to be callable. There is no way to check that in Julia, statically."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"7bd421e5-f80a-4568-97e8-c265c53c3af7","type":"message","text":"In dynamic-language land, you can replace that with \"I want to dispatch on X\" instead.","user":"U7HAYKY9X","ts":"1612040406.031600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BYuLc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In dynamic-language land, you can replace that with \"I want to dispatch on X\" instead."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"7e7095ad-a1ae-457e-947c-fa82d150ee54","type":"message","text":"`methodswith` ?","user":"UB7JS9CHF","ts":"1612040719.031800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gvBs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"methodswith","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"6e71b5ae-d0a8-4f96-b3a9-f82964cc680d","type":"message","text":"`which`?","user":"UB7JS9CHF","ts":"1612040957.032000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pskid","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"which","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"fa6ea004-3cf4-492b-acb0-f2e29d64453d","type":"message","text":"Julia just isn’t a static language - but if you just want to see if there is a method that accepts your type X, that isn’t a problem.","user":"UB7JS9CHF","ts":"1612041023.032200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jyf1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Julia just isn’t a static language - but if you just want to see if there is a method that accepts your type X, that isn’t a problem."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"804b9960-f91f-4557-9d71-6be1dbecaa3f","type":"message","text":"```julia&gt; which(*, (Str, Str))\n*(s1::Union{C1, S1}, ss::Union{C2, S2}...) where {C1&lt;:Chr, C2&lt;:Chr, S1&lt;:Str, S2&lt;:Str} in StrBase at /Users/scott/s/StrBase.jl/src/support.jl:682```","user":"UB7JS9CHF","ts":"1612041071.032400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8B9","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> which(*, (Str, Str))\n*(s1::Union{C1, S1}, ss::Union{C2, S2}...) where {C1<:Chr, C2<:Chr, S1<:Str, S2<:Str} in StrBase at /Users/scott/s/StrBase.jl/src/support.jl:682"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"f816bf54-b32f-46b7-8a3c-559e384fbcfd","type":"message","text":"That can't be known statically, can it?","user":"U7HAYKY9X","ts":"1612041536.032600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KidNh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That can't be known statically, can it?"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"7E6F6024-FE0D-4436-B1EA-7C5C1B258AA1","type":"message","text":"I don’t think so","user":"UB7JS9CHF","ts":"1612042546.033000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jm3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t think so"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"c991fdf3-921d-4673-9ea7-3f6a422aae04","type":"message","text":"With dynamic typing in Julia the most you could say in advance is that there is already a method that handles that type signature, and in that case, it can’t disappear in the future (but you might get a *different* method, that is more specific), however, you cannot say that at some point in the future, a method that handles it doesn’t get added.","user":"UB7JS9CHF","ts":"1612054104.033200","team":"T68168MUP","edited":{"user":"UB7JS9CHF","ts":"1612054133.000000"},"blocks":[{"type":"rich_text","block_id":"49F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"With dynamic typing in Julia the most you could say in advance is that there is already a method that handles that type signature, and in that case, it can’t disappear in the future (but you might get a "},{"type":"text","text":"different","style":{"bold":true}},{"type":"text","text":" method, that is more specific), however, you cannot say that at some point in the future, a method that handles it doesn’t get added."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"ec36340c-c43b-4365-91e2-0f18fade82fa","type":"message","text":"thats kind of the beauty and the curse of dynamic typing I guess.","user":"UPUBAM63X","ts":"1612055251.033500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"G28","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thats kind of the beauty and the curse of dynamic typing I guess."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"efdcba92-76f3-450a-a952-06c5bda65d15","type":"message","text":"<@U7HAYKY9X> I'm thinking of starting a document with usecases that aren't served well by current adhoc trait system","user":"UDGT4PM41","ts":"1612193498.035100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Btts","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" I'm thinking of starting a document with usecases that aren't served well by current adhoc trait system"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"1d66a130-1fda-4649-8a59-34eec71cc29b","type":"message","text":"Maybe get the community talking about other solutions for 2.0 / 1.x","user":"UDGT4PM41","ts":"1612193533.035300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vw3E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe get the community talking about other solutions for 2.0 / 1.x"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"9e264226-3e13-4528-bbbc-09f7fe5d03f0","type":"message","text":"Those things *can* be known statically in julia for what it's worth <@U7HAYKY9X>","user":"U8D9768Q6","ts":"1612212352.036200","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1612212362.000000"},"blocks":[{"type":"rich_text","block_id":"n2Rbb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Those things "},{"type":"text","text":"can","style":{"bold":true}},{"type":"text","text":" be known statically in julia for what it's worth "},{"type":"user","user_id":"U7HAYKY9X"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"fd546691-8705-48c9-b150-9d407e3a9af1","type":"message","text":"It's just not properly supported from Base. <https://github.com/oxinabox/Tricks.jl> is a proof of concept for a subset of those sorts of static introspection questions","user":"U8D9768Q6","ts":"1612212418.036500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"auR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's just not properly supported from Base. "},{"type":"link","url":"https://github.com/oxinabox/Tricks.jl"},{"type":"text","text":" is a proof of concept for a subset of those sorts of static introspection questions"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"11eb743c-ff04-4449-a10b-60be9d9780e9","type":"message","text":"I'm a bit skeptical at how practical the static compilation efforts are. Don't get me wrong, I want to see it happen really bad, but at the end of the day I feel like there's going to be some code serious dragons to slay for it to be realized in a practical way. I'll still always use Julia dynamic or not, but, yea.","user":"UPUBAM63X","ts":"1612217511.037900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D8YU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm a bit skeptical at how practical the static compilation efforts are. Don't get me wrong, I want to see it happen really bad, but at the end of the day I feel like there's going to be some code serious dragons to slay for it to be realized in a practical way. I'll still always use Julia dynamic or not, but, yea."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"ac4c9f5a-a8e3-42a8-ab73-ca1c6bd791da","type":"message","text":"I don't think the above discussion was about static compilation. It was about statically deciding whether types have various methods so we don't pay a runtime penalty for it.","user":"U8D9768Q6","ts":"1612217947.038100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pass","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think the above discussion was about static compilation. It was about statically deciding whether types have various methods so we don't pay a runtime penalty for it."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF","reactions":[{"name":"+1","users":["UPUBAM63X","U011V2YN59N"],"count":2}]},{"client_msg_id":"4b92eb70-0c0f-43d5-bf0b-ec0c8fe536e6","type":"message","text":"(which is very much in Julia's traditional wheelhouse)","user":"U8D9768Q6","ts":"1612218607.038500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hgIX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(which is very much in Julia's traditional wheelhouse)"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"039a9f10-637f-4f44-a18b-32bd2cb34931","type":"message","text":"Yea sorry I've been thinking a lot about static compilation lately.","user":"UPUBAM63X","ts":"1612226744.040200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VaY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yea sorry I've been thinking a lot about static compilation lately."}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF"},{"client_msg_id":"50079c87-be6a-47d0-a4db-fb01de7b0e3a","type":"message","text":"<@U8D9768Q6> That's very cool. Neat idea using the idea of edges between methodinstances to statically determine this. That could build a good trait system. It just needs to be used ubiquitously :)","user":"U7HAYKY9X","ts":"1612258122.042000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NxLi","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8D9768Q6"},{"type":"text","text":" That's very cool. Neat idea using the idea of edges between methodinstances to statically determine this. That could build a good trait system. It just needs to be used ubiquitously :)"}]}]}],"thread_ts":"1612010264.009500","parent_user_id":"UB7JS9CHF","reactions":[{"name":"+1","users":["U011V2YN59N"],"count":1}]}]