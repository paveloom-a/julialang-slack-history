[{"client_msg_id":"a48699da-35d2-4607-adfd-eafefda0caba","type":"message","text":"Can I convert an Array with `Any` elements with something thats more concrete? I have code that looks like\n```function run_sims(params) \n    nsims = 5\n    sols = []\n    for sim in 1:nsims       \n        println(\"sim: $sim\")   \n        sample_params(params)\n        push!(sols, _simulate(params))\n    end\n    return sols\nend```\nbut the `typeof(sols)` says it's an array with element `Any`. The return object from `_simulate` is actually is known. It's an ODE Solution, but the type is quite long.\n```julia&gt; typeof(sol)\nODESolution{Float64,2,Array{Array{Float64,1},1},Nothing,Nothing,Array{Float64,1},Array{Array{Array{Float64,1},1},1},ODEProblem{Array{Float64,1},Tuple{Float64,Float64},true,ModelParameters,ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},Rodas4{0,false,DefaultLinSolve,DataType},OrdinaryDiffEq.InterpolationData{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Array{Float64,1},1},Array{Float64,1},Array{Array{Array{Float64,1},1},1},OrdinaryDiffEq.Rodas4Cache{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},OrdinaryDiffEq.RodasTableau{Float64,Float64},DiffEqBase.TimeGradientWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Float64,1},ModelParameters},DiffEqBase.UJacobianWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Float64,ModelParameters},DefaultLinSolve,FiniteDiff.JacobianCache{Array{Float64,1},Array{Float64,1},Array{Float64,1},UnitRange{Int64},Nothing,Val{:forward}(),Float64},FiniteDiff.GradientCache{Nothing,Array{Float64,1},Array{Float64,1},Float64,Val{:forward}(),Float64,Val{true}()}}},DiffEqBase.DEStats}```","user":"U6Z8377N2","ts":"1613453704.136800","team":"T68168MUP","edited":{"user":"U6Z8377N2","ts":"1613453834.000000"},"blocks":[{"type":"rich_text","block_id":"Q=Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can I convert an Array with "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" elements with something thats more concrete? I have code that looks like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function run_sims(params) \n    nsims = 5\n    sols = []\n    for sim in 1:nsims       \n        println(\"sim: $sim\")   \n        sample_params(params)\n        push!(sols, _simulate(params))\n    end\n    return sols\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but the "},{"type":"text","text":"typeof(sols)","style":{"code":true}},{"type":"text","text":" says it's an array with element "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":". The return object from "},{"type":"text","text":"_simulate","style":{"code":true}},{"type":"text","text":" is actually is known. It's an ODE Solution, but the type is quite long.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> typeof(sol)\nODESolution{Float64,2,Array{Array{Float64,1},1},Nothing,Nothing,Array{Float64,1},Array{Array{Array{Float64,1},1},1},ODEProblem{Array{Float64,1},Tuple{Float64,Float64},true,ModelParameters,ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},Rodas4{0,false,DefaultLinSolve,DataType},OrdinaryDiffEq.InterpolationData{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Array{Float64,1},1},Array{Float64,1},Array{Array{Array{Float64,1},1},1},OrdinaryDiffEq.Rodas4Cache{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},OrdinaryDiffEq.RodasTableau{Float64,Float64},DiffEqBase.TimeGradientWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Float64,1},ModelParameters},DiffEqBase.UJacobianWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Float64,ModelParameters},DefaultLinSolve,FiniteDiff.JacobianCache{Array{Float64,1},Array{Float64,1},Array{Float64,1},UnitRange{Int64},Nothing,Val{:forward}(),Float64},FiniteDiff.GradientCache{Nothing,Array{Float64,1},Array{Float64,1},Float64,Val{:forward}(),Float64,Val{true}()}}},DiffEqBase.DEStats}"}]}]}],"thread_ts":"1613453704.136800","reply_count":2,"reply_users_count":2,"latest_reply":"1613486674.158300","reply_users":["U8D9768Q6","UBF9YRB6H"],"subscribed":false},{"type":"message","subtype":"thread_broadcast","text":"You can just do `identity.(xs)`\n```julia&gt; xs = Any[1, 2.0, 3]\n3-element Vector{Any}:\n 1\n 2.0\n 3\n\njulia&gt; identity.(xs)\n3-element Vector{Real}:\n 1\n 2.0\n 3 ```","user":"U8D9768Q6","ts":"1613458326.144900","thread_ts":"1613453704.136800","root":{"client_msg_id":"a48699da-35d2-4607-adfd-eafefda0caba","type":"message","text":"Can I convert an Array with `Any` elements with something thats more concrete? I have code that looks like\n```function run_sims(params) \n    nsims = 5\n    sols = []\n    for sim in 1:nsims       \n        println(\"sim: $sim\")   \n        sample_params(params)\n        push!(sols, _simulate(params))\n    end\n    return sols\nend```\nbut the `typeof(sols)` says it's an array with element `Any`. The return object from `_simulate` is actually is known. It's an ODE Solution, but the type is quite long.\n```julia&gt; typeof(sol)\nODESolution{Float64,2,Array{Array{Float64,1},1},Nothing,Nothing,Array{Float64,1},Array{Array{Array{Float64,1},1},1},ODEProblem{Array{Float64,1},Tuple{Float64,Float64},true,ModelParameters,ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},Rodas4{0,false,DefaultLinSolve,DataType},OrdinaryDiffEq.InterpolationData{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Array{Float64,1},1},Array{Float64,1},Array{Array{Array{Float64,1},1},1},OrdinaryDiffEq.Rodas4Cache{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},OrdinaryDiffEq.RodasTableau{Float64,Float64},DiffEqBase.TimeGradientWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Float64,1},ModelParameters},DiffEqBase.UJacobianWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Float64,ModelParameters},DefaultLinSolve,FiniteDiff.JacobianCache{Array{Float64,1},Array{Float64,1},Array{Float64,1},UnitRange{Int64},Nothing,Val{:forward}(),Float64},FiniteDiff.GradientCache{Nothing,Array{Float64,1},Array{Float64,1},Float64,Val{:forward}(),Float64,Val{true}()}}},DiffEqBase.DEStats}```","user":"U6Z8377N2","ts":"1613453704.136800","team":"T68168MUP","edited":{"user":"U6Z8377N2","ts":"1613453834.000000"},"blocks":[{"type":"rich_text","block_id":"Q=Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can I convert an Array with "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" elements with something thats more concrete? I have code that looks like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function run_sims(params) \n    nsims = 5\n    sols = []\n    for sim in 1:nsims       \n        println(\"sim: $sim\")   \n        sample_params(params)\n        push!(sols, _simulate(params))\n    end\n    return sols\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but the "},{"type":"text","text":"typeof(sols)","style":{"code":true}},{"type":"text","text":" says it's an array with element "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":". The return object from "},{"type":"text","text":"_simulate","style":{"code":true}},{"type":"text","text":" is actually is known. It's an ODE Solution, but the type is quite long.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> typeof(sol)\nODESolution{Float64,2,Array{Array{Float64,1},1},Nothing,Nothing,Array{Float64,1},Array{Array{Array{Float64,1},1},1},ODEProblem{Array{Float64,1},Tuple{Float64,Float64},true,ModelParameters,ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},Rodas4{0,false,DefaultLinSolve,DataType},OrdinaryDiffEq.InterpolationData{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Array{Float64,1},1},Array{Float64,1},Array{Array{Array{Float64,1},1},1},OrdinaryDiffEq.Rodas4Cache{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},OrdinaryDiffEq.RodasTableau{Float64,Float64},DiffEqBase.TimeGradientWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Array{Float64,1},ModelParameters},DiffEqBase.UJacobianWrapper{ODEFunction{true,typeof(aModel!),UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing},Float64,ModelParameters},DefaultLinSolve,FiniteDiff.JacobianCache{Array{Float64,1},Array{Float64,1},Array{Float64,1},UnitRange{Int64},Nothing,Val{:forward}(),Float64},FiniteDiff.GradientCache{Nothing,Array{Float64,1},Array{Float64,1},Float64,Val{:forward}(),Float64,Val{true}()}}},DiffEqBase.DEStats}"}]}]}],"thread_ts":"1613453704.136800","reply_count":2,"reply_users_count":2,"latest_reply":"1613486674.158300","reply_users":["U8D9768Q6","UBF9YRB6H"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"D450","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can just do "},{"type":"text","text":"identity.(xs)","style":{"code":true}},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> xs = Any[1, 2.0, 3]\n3-element Vector{Any}:\n 1\n 2.0\n 3\n\njulia> identity.(xs)\n3-element Vector{Real}:\n 1\n 2.0\n 3 "}]}]}],"client_msg_id":"E75836F7-3F13-4774-B6B5-7FD36497D73E","edited":{"user":"U8D9768Q6","ts":"1613458396.000000"},"reactions":[{"name":"point_up","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"102b1adf-fc46-458a-9dd0-4a1b1b88a1e6","type":"message","text":"That only narrows to the abstract type. It has something to do with `promote_type` and `promote_typejoin`. I actually think a utility method for this should be added to base.","user":"UBF9YRB6H","ts":"1613486674.158300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dfvcW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That only narrows to the abstract type. It has something to do with "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"promote_typejoin","style":{"code":true}},{"type":"text","text":". I actually think a utility method for this should be added to base."}]}]}],"thread_ts":"1613453704.136800","parent_user_id":"U6Z8377N2"}]