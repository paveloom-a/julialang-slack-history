[{"client_msg_id":"1a68fa52-e509-46da-887c-fe25d8fa9929","type":"message","text":"I'm working on a Julia interface for some C codes and I'm not sure what I should do for the structure :\n```struct zqrm_spfct_type_c{\n  int          *cperm_in;\n  int           icntl[20];\n  float         rcntl[10];\n  long int      gstats[10];\n  void         *h; \n};```\nIn Julia, it should be :\n```mutable struct qrm_spfct{T} &lt;: Factorization{T}\n  cperm_in :: Ptr{Cint}\n  icntl    :: NTuple{20, Cint}\n  rcntl    :: NTuple{10, Cfloat}\n  gstats   :: NTuple{10, Clonglong}\n  h        :: Ptr{Cvoid}\nend```\nbut some C routines update `icntl`  and `rcntl` . It's a problem because `NTuple` are immutable.\n\nShould I use `Ptr{Cint}` and `Ptr{Cfloat}` instead ?","user":"UGG8Z375L","ts":"1614822230.470500","team":"T68168MUP","edited":{"user":"UGG8Z375L","ts":"1614822534.000000"},"blocks":[{"type":"rich_text","block_id":"uvhg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm working on a Julia interface for some C codes and I'm not sure what I should do for the structure :\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct zqrm_spfct_type_c{\n  int          *cperm_in;\n  int           icntl[20];\n  float         rcntl[10];\n  long int      gstats[10];\n  void         *h; \n};"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"In Julia, it should be :\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct qrm_spfct{T} <: Factorization{T}\n  cperm_in :: Ptr{Cint}\n  icntl    :: NTuple{20, Cint}\n  rcntl    :: NTuple{10, Cfloat}\n  gstats   :: NTuple{10, Clonglong}\n  h        :: Ptr{Cvoid}\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but some C routines update "},{"type":"text","text":"icntl","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"rcntl","style":{"code":true}},{"type":"text","text":" . It's a problem because "},{"type":"text","text":"NTuple","style":{"code":true}},{"type":"text","text":" are immutable.\n\nShould I use "},{"type":"text","text":"Ptr{Cint}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Ptr{Cfloat}","style":{"code":true}},{"type":"text","text":" instead ?"}]}]}],"thread_ts":"1614822230.470500","reply_count":13,"reply_users_count":4,"latest_reply":"1614896023.060700","reply_users":["U69J94HT9","U01FKQQ7J0J","U010ZKG6T60","UGG8Z375L"],"subscribed":false},{"client_msg_id":"f7ae91eb-081a-4b91-9f6e-48eff00ada51","type":"message","text":"You might try using an `MVector` from StaticArrays.jl, which implements mutation on top of NTuples. I'm not sure if it will translate across ccall properly given that it's a wrapper type but you could always try.","user":"U69J94HT9","ts":"1614823200.471100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FhX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might try using an "},{"type":"text","text":"MVector","style":{"code":true}},{"type":"text","text":" from StaticArrays.jl, which implements mutation on top of NTuples. I'm not sure if it will translate across ccall properly given that it's a wrapper type but you could always try."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"2c5e89ed-ea35-4288-be69-64f717d6c562","type":"message","text":"The Julia Manual states that \"Arrays of parameters can be expressed with `NTuple`\": <https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences>","user":"U01FKQQ7J0J","ts":"1614834913.473800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LUnf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The Julia Manual states that \"Arrays of parameters can be expressed with "},{"type":"text","text":"NTuple","style":{"code":true}},{"type":"text","text":"\": "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"377e69c0-28ba-4eef-9464-06c29f82dd4a","type":"message","text":"You can modify the \"immutable\" ntuples like so\n```instance = qrm_spfct(...)\nGC.@preserve instance unsafe_store!(Ptr{Cint}(pointer_from_objref(instance) + fieldoffset(qrm_spfct, 2)), convert(Cint, 9881), 7)```\nwhich is the same as\n```instance = qrm_spfct(...)\ninstance.icntl[7] = 9881```\nif I didn't mess up smth.","user":"U010ZKG6T60","ts":"1614853995.476700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v/5p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can modify the \"immutable\" ntuples like so\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"instance = qrm_spfct(...)\nGC.@preserve instance unsafe_store!(Ptr{Cint}(pointer_from_objref(instance) + fieldoffset(qrm_spfct, 2)), convert(Cint, 9881), 7)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which is the same as\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"instance = qrm_spfct(...)\ninstance.icntl[7] = 9881"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"if I didn't mess up smth."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"ab81e850-2458-48b1-bf06-974de2b88625","type":"message","text":"This is what MVector does under-the-hood, but you can't just use an MVector instead of an NTuple since it's a mutable wrapper and what'll get stored inside qrm_spfct is a pointer to that mutable struct and not 20 Cints in the case of `icntl::NTuple{20, Cint}`","user":"U010ZKG6T60","ts":"1614854103.476900","team":"T68168MUP","edited":{"user":"U010ZKG6T60","ts":"1614854498.000000"},"blocks":[{"type":"rich_text","block_id":"U2sFB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is what MVector does under-the-hood, but you can't just use an MVector instead of an NTuple since it's a mutable wrapper and what'll get stored inside qrm_spfct is a pointer to that mutable struct and not 20 Cints in the case of "},{"type":"text","text":"icntl::NTuple{20, Cint}","style":{"code":true}}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L","reactions":[{"name":"ok_hand","users":["U69J94HT9","UGG8Z375L"],"count":2},{"name":"1000","users":["UGG8Z375L"],"count":1}]},{"client_msg_id":"02d47d26-2c89-4d18-b9e3-6ab591f5c9e3","type":"message","text":"Now doing this all over the place will lead to ugly code, you could make it nicer somehow like this:","user":"U010ZKG6T60","ts":"1614857956.477700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J2xVe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Now doing this all over the place will lead to ugly code, you could make it nicer somehow like this:"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"cb3ba91e-bc63-42c8-9a77-8b94bdbcc5cd","type":"message","text":"```\nstruct MutableNTupleWrapper{Tx,Ty}\n    owner::Tx\n    n_field::UInt64\nend\n\nfunction Base.setindex!(self::MutableNTupleWrapper{Tx,Ty}, value, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_store!(ptr, convert(Ty, value), key)\nend\n\nfunction Base.getindex(self::MutableNTupleWrapper{Tx,Ty}, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_load(ptr, key)\nend\n\n\nmutable struct qrm_spfct\n    cperm_in::Ptr{Cint}\n    icntl::NTuple{20,Cint}\n    rcntl::NTuple{10,Cfloat}\n    gstats::NTuple{10,Clonglong}\n    h::Ptr{Cvoid}\n    qrm_spfct() = new() #for testing\nend\n\nfunction Base.getproperty(self::qrm_spfct, name::Symbol)\n    name == :icntl ? MutableNTupleWrapper{qrm_spfct,Cint}(self, 2) :\n    name == :rcntl ? MutableNTupleWrapper{qrm_spfct,Cfloat}(self, 3) :\n    name == :gstats ? MutableNTupleWrapper{qrm_spfct,Clonglong}(self, 4) :\n    getfield(self, name)\nend```\nand\n```julia&gt; a = qrm_spfct()\nqrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000)\n\njulia&gt; a.rcntl\nMutableNTupleWrapper{qrm_spfct, Float32}(qrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000), 0x0000000000000003)\n\njulia&gt; a.rcntl[3]\n1.853113f-29\n\njulia&gt; a.rcntl[3] = 34.69\n34.69\n\njulia&gt; a.rcntl[3]\n34.69f0```\n","user":"U010ZKG6T60","ts":"1614857988.477900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rXB","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\nstruct MutableNTupleWrapper{Tx,Ty}\n    owner::Tx\n    n_field::UInt64\nend\n\nfunction Base.setindex!(self::MutableNTupleWrapper{Tx,Ty}, value, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_store!(ptr, convert(Ty, value), key)\nend\n\nfunction Base.getindex(self::MutableNTupleWrapper{Tx,Ty}, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_load(ptr, key)\nend\n\n\nmutable struct qrm_spfct\n    cperm_in::Ptr{Cint}\n    icntl::NTuple{20,Cint}\n    rcntl::NTuple{10,Cfloat}\n    gstats::NTuple{10,Clonglong}\n    h::Ptr{Cvoid}\n    qrm_spfct() = new() #for testing\nend\n\nfunction Base.getproperty(self::qrm_spfct, name::Symbol)\n    name == :icntl ? MutableNTupleWrapper{qrm_spfct,Cint}(self, 2) :\n    name == :rcntl ? MutableNTupleWrapper{qrm_spfct,Cfloat}(self, 3) :\n    name == :gstats ? MutableNTupleWrapper{qrm_spfct,Clonglong}(self, 4) :\n    getfield(self, name)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> a = qrm_spfct()\nqrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000)\n\njulia> a.rcntl\nMutableNTupleWrapper{qrm_spfct, Float32}(qrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000), 0x0000000000000003)\n\njulia> a.rcntl[3]\n1.853113f-29\n\njulia> a.rcntl[3] = 34.69\n34.69\n\njulia> a.rcntl[3]\n34.69f0"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"0552b4b1-2c85-4261-a8ff-9a84a15c3032","type":"message","text":"Thanks a lot for our answers !!!\n<@U010ZKG6T60> I like your `MutableNTupleWrapper` structure ! It allows us to update parameters directly in Julia instead of using the C routines. I didn't understand why the same object in memory was mutable in C and immutable in Julia.","user":"UGG8Z375L","ts":"1614884655.016500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8c01x","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks a lot for our answers !!!\n"},{"type":"user","user_id":"U010ZKG6T60"},{"type":"text","text":" I like your "},{"type":"text","text":"MutableNTupleWrapper","style":{"code":true}},{"type":"text","text":" structure ! It allows us to update parameters directly in Julia instead of using the C routines. I didn't understand why the same object in memory was mutable in C and immutable in Julia."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"fb315c8b-fd8d-46c2-9397-ed8f87e6f15a","type":"message","text":"In fact they are also mutable in Julia :+1:","user":"UGG8Z375L","ts":"1614884700.016900","team":"T68168MUP","edited":{"user":"UGG8Z375L","ts":"1614884777.000000"},"blocks":[{"type":"rich_text","block_id":"hybX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In fact they are also mutable in Julia "},{"type":"emoji","name":"+1"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"adab7846-6797-44ef-9baf-092a96aaff36","type":"message","text":"Note that what's mutable here is the mutable struct qrm_spfct, which has a guaranteed memory address that we can take with `pointer_from_objref`, which will fail for immutable structs like if we directly used it on the NTuple. The `MutableNTupleWrapper` really only holds qrm_spfct, which under-hood is actually a pointer to it since it's a mutable struct, and the nth field of that qrm_spfct instance that we'll modify. We don't modify `MutableNTupleWrapper` or the NTuple directly, we only modify the qrm_spfct struct which is declared mutable. Julia's a bit tricky when it comes to its memory layout if I were to admit but you'll get used to it!","user":"U010ZKG6T60","ts":"1614885887.017600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PefA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Note that what's mutable here is the mutable struct qrm_spfct, which has a guaranteed memory address that we can take with "},{"type":"text","text":"pointer_from_objref","style":{"code":true}},{"type":"text","text":", which will fail for immutable structs like if we directly used it on the NTuple. The "},{"type":"text","text":"MutableNTupleWrapper","style":{"code":true}},{"type":"text","text":" really only holds qrm_spfct, which under-hood is actually a pointer to it since it's a mutable struct, and the nth field of that qrm_spfct instance that we'll modify. We don't modify "},{"type":"text","text":"MutableNTupleWrapper","style":{"code":true}},{"type":"text","text":" or the NTuple directly, we only modify the qrm_spfct struct which is declared mutable. Julia's a bit tricky when it comes to its memory layout if I were to admit but you'll get used to it!"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"0b6fdb7a-184f-4610-9d7a-51e2d92ce4a7","type":"message","text":"Oh ok, It's a side effect that the NTuple is modified.","user":"UGG8Z375L","ts":"1614886122.017800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q+Qs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh ok, It's a side effect that the NTuple is modified."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"51d38b1f-cafb-479c-a599-1688169c2559","type":"message","text":"A last question Balen, it's not all the nth field of that `qrm_spfact` instance that is modified but only a part of it ? What we are doing if not creating a new NTuple ?","user":"UGG8Z375L","ts":"1614887080.018300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lI2/l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A last question Balen, it's not all the nth field of that "},{"type":"text","text":"qrm_spfact","style":{"code":true}},{"type":"text","text":" instance that is modified but only a part of it ? What we are doing if not creating a new NTuple ?"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"9508aa52-6607-4cb1-85af-2cee01c48085","type":"message","text":"only part of it is modified, `unsafe_store!(ptr, convert(Ty, value), key)` modifies sizeof(Ty) bytes, so in the case of Cint and Cfloat that's 4 bytes and in the case of Clonglong that's 8 bytes. What's happening is simply `*(int*)(SOME_ADDRESS) = SOME_VALUE` for the case of the Cint NTuple. This is modifying memory directly hence the unsafe prefixes(though nothing is unsafe here)","user":"U010ZKG6T60","ts":"1614895786.060000","team":"T68168MUP","edited":{"user":"U010ZKG6T60","ts":"1614895828.000000"},"blocks":[{"type":"rich_text","block_id":"JSn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"only part of it is modified, "},{"type":"text","text":"unsafe_store!(ptr, convert(Ty, value), key)","style":{"code":true}},{"type":"text","text":" modifies sizeof(Ty) bytes, so in the case of Cint and Cfloat that's 4 bytes and in the case of Clonglong that's 8 bytes. What's happening is simply "},{"type":"text","text":"*(int*)(SOME_ADDRESS) = SOME_VALUE","style":{"code":true}},{"type":"text","text":" for the case of the Cint NTuple. This is modifying memory directly hence the unsafe prefixes(though nothing is unsafe here)"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"4076aefe-5fd0-47d0-9015-d8a528af8a75","type":"message","text":"you could've replaced the entire icntl with a new NTuple with one changed field (no need for unsafe then) but I am not sure how efficient that is or whether it gets optimized away(probably not). That'd be the same as modifying 80 bytes\n```julia&gt; sizeof(NTuple{20, Cint})                                                                                                                                                                                                                                                                                              80     ```\ncompared to modifying 4 bytes for changing one element of the NTuple if it doesn't get optimized away.","user":"U010ZKG6T60","ts":"1614896023.060700","team":"T68168MUP","edited":{"user":"U010ZKG6T60","ts":"1614896086.000000"},"blocks":[{"type":"rich_text","block_id":"W1VR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you could've replaced the entire icntl with a new NTuple with one changed field (no need for unsafe then) but I am not sure how efficient that is or whether it gets optimized away(probably not). That'd be the same as modifying 80 bytes\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> sizeof(NTuple{20, Cint})                                                                                                                                                                                                                                                                                              80     "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"compared to modifying 4 bytes for changing one element of the NTuple if it doesn't get optimized away."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"}]