[{"client_msg_id":"1a68fa52-e509-46da-887c-fe25d8fa9929","type":"message","text":"I'm working on a Julia interface for some C codes and I'm not sure what I should do for the structure :\n```struct zqrm_spfct_type_c{\n  int          *cperm_in;\n  int           icntl[20];\n  float         rcntl[10];\n  long int      gstats[10];\n  void         *h; \n};```\nIn Julia, it should be :\n```mutable struct qrm_spfct{T} &lt;: Factorization{T}\n  cperm_in :: Ptr{Cint}\n  icntl    :: NTuple{20, Cint}\n  rcntl    :: NTuple{10, Cfloat}\n  gstats   :: NTuple{10, Clonglong}\n  h        :: Ptr{Cvoid}\nend```\nbut some C routines update `icntl`  and `rcntl` . It's a problem because `NTuple` are immutable.\n\nShould I use `Ptr{Cint}` and `Ptr{Cfloat}` instead ?","user":"UGG8Z375L","ts":"1614822230.470500","team":"T68168MUP","edited":{"user":"UGG8Z375L","ts":"1614822534.000000"},"blocks":[{"type":"rich_text","block_id":"uvhg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm working on a Julia interface for some C codes and I'm not sure what I should do for the structure :\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct zqrm_spfct_type_c{\n  int          *cperm_in;\n  int           icntl[20];\n  float         rcntl[10];\n  long int      gstats[10];\n  void         *h; \n};"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"In Julia, it should be :\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct qrm_spfct{T} <: Factorization{T}\n  cperm_in :: Ptr{Cint}\n  icntl    :: NTuple{20, Cint}\n  rcntl    :: NTuple{10, Cfloat}\n  gstats   :: NTuple{10, Clonglong}\n  h        :: Ptr{Cvoid}\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but some C routines update "},{"type":"text","text":"icntl","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"rcntl","style":{"code":true}},{"type":"text","text":" . It's a problem because "},{"type":"text","text":"NTuple","style":{"code":true}},{"type":"text","text":" are immutable.\n\nShould I use "},{"type":"text","text":"Ptr{Cint}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Ptr{Cfloat}","style":{"code":true}},{"type":"text","text":" instead ?"}]}]}],"thread_ts":"1614822230.470500","reply_count":6,"reply_users_count":3,"latest_reply":"1614857988.477900","reply_users":["U69J94HT9","U01FKQQ7J0J","U010ZKG6T60"],"subscribed":false},{"client_msg_id":"f7ae91eb-081a-4b91-9f6e-48eff00ada51","type":"message","text":"You might try using an `MVector` from StaticArrays.jl, which implements mutation on top of NTuples. I'm not sure if it will translate across ccall properly given that it's a wrapper type but you could always try.","user":"U69J94HT9","ts":"1614823200.471100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FhX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might try using an "},{"type":"text","text":"MVector","style":{"code":true}},{"type":"text","text":" from StaticArrays.jl, which implements mutation on top of NTuples. I'm not sure if it will translate across ccall properly given that it's a wrapper type but you could always try."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"2c5e89ed-ea35-4288-be69-64f717d6c562","type":"message","text":"The Julia Manual states that \"Arrays of parameters can be expressed with `NTuple`\": <https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences>","user":"U01FKQQ7J0J","ts":"1614834913.473800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LUnf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The Julia Manual states that \"Arrays of parameters can be expressed with "},{"type":"text","text":"NTuple","style":{"code":true}},{"type":"text","text":"\": "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"377e69c0-28ba-4eef-9464-06c29f82dd4a","type":"message","text":"You can modify the \"immutable\" ntuples like so\n```instance = qrm_spfct(...)\nGC.@preserve instance unsafe_store!(Ptr{Cint}(pointer_from_objref(instance) + fieldoffset(qrm_spfct, 2)), convert(Cint, 9881), 7)```\nwhich is the same as\n```instance = qrm_spfct(...)\ninstance.icntl[7] = 9881```\nif I didn't mess up smth.","user":"U010ZKG6T60","ts":"1614853995.476700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v/5p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can modify the \"immutable\" ntuples like so\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"instance = qrm_spfct(...)\nGC.@preserve instance unsafe_store!(Ptr{Cint}(pointer_from_objref(instance) + fieldoffset(qrm_spfct, 2)), convert(Cint, 9881), 7)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which is the same as\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"instance = qrm_spfct(...)\ninstance.icntl[7] = 9881"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"if I didn't mess up smth."}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"ab81e850-2458-48b1-bf06-974de2b88625","type":"message","text":"This is what MVector does under-the-hood, but you can't just use an MVector instead of an NTuple since it's a mutable wrapper and what'll get stored inside qrm_spfct is a pointer to that mutable struct and not 20 Cints in the case of `icntl::NTuple{20, Cint}`","user":"U010ZKG6T60","ts":"1614854103.476900","team":"T68168MUP","edited":{"user":"U010ZKG6T60","ts":"1614854498.000000"},"blocks":[{"type":"rich_text","block_id":"U2sFB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is what MVector does under-the-hood, but you can't just use an MVector instead of an NTuple since it's a mutable wrapper and what'll get stored inside qrm_spfct is a pointer to that mutable struct and not 20 Cints in the case of "},{"type":"text","text":"icntl::NTuple{20, Cint}","style":{"code":true}}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L","reactions":[{"name":"ok_hand","users":["U69J94HT9"],"count":1}]},{"client_msg_id":"02d47d26-2c89-4d18-b9e3-6ab591f5c9e3","type":"message","text":"Now doing this all over the place will lead to ugly code, you could make it nicer somehow like this:","user":"U010ZKG6T60","ts":"1614857956.477700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J2xVe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Now doing this all over the place will lead to ugly code, you could make it nicer somehow like this:"}]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"},{"client_msg_id":"cb3ba91e-bc63-42c8-9a77-8b94bdbcc5cd","type":"message","text":"```\nstruct MutableNTupleWrapper{Tx,Ty}\n    owner::Tx\n    n_field::UInt64\nend\n\nfunction Base.setindex!(self::MutableNTupleWrapper{Tx,Ty}, value, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_store!(ptr, convert(Ty, value), key)\nend\n\nfunction Base.getindex(self::MutableNTupleWrapper{Tx,Ty}, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_load(ptr, key)\nend\n\n\nmutable struct qrm_spfct\n    cperm_in::Ptr{Cint}\n    icntl::NTuple{20,Cint}\n    rcntl::NTuple{10,Cfloat}\n    gstats::NTuple{10,Clonglong}\n    h::Ptr{Cvoid}\n    qrm_spfct() = new() #for testing\nend\n\nfunction Base.getproperty(self::qrm_spfct, name::Symbol)\n    name == :icntl ? MutableNTupleWrapper{qrm_spfct,Cint}(self, 2) :\n    name == :rcntl ? MutableNTupleWrapper{qrm_spfct,Cfloat}(self, 3) :\n    name == :gstats ? MutableNTupleWrapper{qrm_spfct,Clonglong}(self, 4) :\n    getfield(self, name)\nend```\nand\n```julia&gt; a = qrm_spfct()\nqrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000)\n\njulia&gt; a.rcntl\nMutableNTupleWrapper{qrm_spfct, Float32}(qrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000), 0x0000000000000003)\n\njulia&gt; a.rcntl[3]\n1.853113f-29\n\njulia&gt; a.rcntl[3] = 34.69\n34.69\n\njulia&gt; a.rcntl[3]\n34.69f0```\n","user":"U010ZKG6T60","ts":"1614857988.477900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rXB","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\nstruct MutableNTupleWrapper{Tx,Ty}\n    owner::Tx\n    n_field::UInt64\nend\n\nfunction Base.setindex!(self::MutableNTupleWrapper{Tx,Ty}, value, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_store!(ptr, convert(Ty, value), key)\nend\n\nfunction Base.getindex(self::MutableNTupleWrapper{Tx,Ty}, key, extra...) where {Tx,Ty}\n    ptr = Base.unsafe_convert(Ptr{Ty}, pointer_from_objref(self.owner) + fieldoffset(Tx, self.n_field))\n    unsafe_load(ptr, key)\nend\n\n\nmutable struct qrm_spfct\n    cperm_in::Ptr{Cint}\n    icntl::NTuple{20,Cint}\n    rcntl::NTuple{10,Cfloat}\n    gstats::NTuple{10,Clonglong}\n    h::Ptr{Cvoid}\n    qrm_spfct() = new() #for testing\nend\n\nfunction Base.getproperty(self::qrm_spfct, name::Symbol)\n    name == :icntl ? MutableNTupleWrapper{qrm_spfct,Cint}(self, 2) :\n    name == :rcntl ? MutableNTupleWrapper{qrm_spfct,Cfloat}(self, 3) :\n    name == :gstats ? MutableNTupleWrapper{qrm_spfct,Clonglong}(self, 4) :\n    getfield(self, name)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> a = qrm_spfct()\nqrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000)\n\njulia> a.rcntl\nMutableNTupleWrapper{qrm_spfct, Float32}(qrm_spfct(Ptr{Int32} @0x0000000019df9550, (18, 0, 563204, 0, 18, 0, 18, 0, 0, 0, 0, 0, 0, 0, 263974288, 0, 263974288, 0, 263974288, 0), (1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0, 1.853113f-29, 0.0f0), (263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288, 263974288), Ptr{Nothing} @0x0000000000000000), 0x0000000000000003)\n\njulia> a.rcntl[3]\n1.853113f-29\n\njulia> a.rcntl[3] = 34.69\n34.69\n\njulia> a.rcntl[3]\n34.69f0"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1614822230.470500","parent_user_id":"UGG8Z375L"}]