[{"client_msg_id":"f1c95b63-4126-43b5-b597-4f749ba96bfb","type":"message","text":"is there a compare/contrast between the module systems of the ML languages and Julia’s module system ? I’d be interested if someone with more expertise can comment on this.","user":"UKA81L34J","ts":"1610316122.180800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hjZv+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is there a compare/contrast between the module systems of the ML languages and Julia’s module system ? I’d be interested if someone with more expertise can comment on this."}]}]}],"thread_ts":"1610316122.180800","reply_count":3,"reply_users_count":2,"latest_reply":"1610380669.221800","reply_users":["UDGT4PM41","UKA81L34J"],"subscribed":false,"reactions":[{"name":"dromedary_camel","users":["U6A936746"],"count":1}]},{"client_msg_id":"b5cb34a4-0879-4326-8cc3-a78ad2b1391c","type":"message","text":"<@UF4N4QX71>","user":"UDGT4PM41","ts":"1610340146.200100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iyv","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UF4N4QX71"}]}]}],"thread_ts":"1610316122.180800","parent_user_id":"UKA81L34J"},{"client_msg_id":"7e8e50ba-bc27-4c75-97ba-5d0ee02e0053","type":"message","text":"I actually got a good read from: <https://www.stephendiehl.com/posts/exotic01.html>\n\nOne immediate thing is that modules are concrete in Julia - they don’t represent abstract contracts which can be implemented by inheritors of the module type.","user":"UKA81L34J","ts":"1610380487.221500","team":"T68168MUP","attachments":[{"title":"Exotic Programming Ideas: Part 1 (Module Systems)","title_link":"https://www.stephendiehl.com/posts/exotic01.html","text":"Personal Blog","fallback":"Exotic Programming Ideas: Part 1 (Module Systems)","from_url":"https://www.stephendiehl.com/posts/exotic01.html","service_name":"stephendiehl.com","id":1,"original_url":"https://www.stephendiehl.com/posts/exotic01.html"}],"blocks":[{"type":"rich_text","block_id":"pb2CV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I actually got a good read from: "},{"type":"link","url":"https://www.stephendiehl.com/posts/exotic01.html"},{"type":"text","text":"\n\nOne immediate thing is that modules are concrete in Julia - they don’t represent abstract contracts which can be implemented by inheritors of the module type."}]}]}],"thread_ts":"1610316122.180800","parent_user_id":"UKA81L34J"},{"client_msg_id":"6b8ef76c-d9be-4a81-942e-2e8617f954ac","type":"message","text":"I think this is what I’m saying:\n\nModules also don’t carry types in Julia. They are concrete instances of type `Module` - whereas in `OCaml` , a module defines a type which can be used to parametrize other things (including other modules!) - so modules which accept arguments are called _functors_ in OCaml world (although I don’t think there’s any of the normal category theoretic constraints here?)","user":"UKA81L34J","ts":"1610380669.221800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YnM9W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this is what I’m saying:\n\nModules also don’t carry types in Julia. They are concrete instances of type "},{"type":"text","text":"Module","style":{"code":true}},{"type":"text","text":" - whereas in "},{"type":"text","text":"OCaml","style":{"code":true}},{"type":"text","text":" , a module defines a type which can be used to parametrize other things (including other modules!) - so modules which accept arguments are called "},{"type":"text","text":"functors","style":{"italic":true}},{"type":"text","text":" in OCaml world (although I don’t think there’s any of the normal category theoretic constraints here?)"}]}]}],"thread_ts":"1610316122.180800","parent_user_id":"UKA81L34J"}]