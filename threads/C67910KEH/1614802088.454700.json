[{"client_msg_id":"6d8607a7-aaac-4993-adfa-b936ff5dec8a","type":"message","text":"I've been trying to think through what it is I actually enjoy about dynamic programming languages. I'm having a hard time convincing myself that I enjoy them at all, despite using them a lot! Over time, my programming style in dynamic languages has become more and more static, with only small parts requiring true dynamism. This particularly applies as a piece of code transitions from a more researchy state to a more stable, production state.\nDoes anyone have any clear opinions or thoughts on the benefits? \nContext: I have a good working knowledge of python, Julia, c++, &amp; a few other other static languages.","user":"UCNPT22MQ","ts":"1614802088.454700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nIR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've been trying to think through what it is I actually enjoy about dynamic programming languages. I'm having a hard time convincing myself that I enjoy them at all, despite using them a lot! Over time, my programming style in dynamic languages has become more and more static, with only small parts requiring true dynamism. This particularly applies as a piece of code transitions from a more researchy state to a more stable, production state.\nDoes anyone have any clear opinions or thoughts on the benefits? \nContext: I have a good working knowledge of python, Julia, c++, & a few other other static languages."}]}]}],"thread_ts":"1614802088.454700","reply_count":9,"reply_users_count":5,"latest_reply":"1614803932.457100","reply_users":["U9VG1AYSG","U019K6Q9N15","UCNPT22MQ","UM30MT6RF","ULMSM9MAL"],"subscribed":false},{"client_msg_id":"55ec255e-7033-4337-851b-5cc21cfb8739","type":"message","text":"to me having good generics is a lot more important than being dynamic.  Formally they have nothing to do with each other, but in practice I find it a lot easier to write generic code in dynamic languages.  Certainly that is true of Julia compared to C++ to an almost laughable degree","user":"U9VG1AYSG","ts":"1614802185.454800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NLn8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"to me having good generics is a lot more important than being dynamic.  Formally they have nothing to do with each other, but in practice I find it a lot easier to write generic code in dynamic languages.  Certainly that is true of Julia compared to C++ to an almost laughable degree"}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ","reactions":[{"name":"+1","users":["U8D9768Q6"],"count":1}]},{"client_msg_id":"7ff8fd1d-900a-4bae-8908-1c343deb5584","type":"message","text":"The feedback loop during development in dynamic programming languages is incomparable, viz. Clojure and Julia. Incomparable.","user":"U019K6Q9N15","ts":"1614802402.455200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RnjQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The feedback loop during development in dynamic programming languages is incomparable, viz. Clojure and Julia. Incomparable."}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"937f3c92-c727-4aa1-9352-690c69db0196","type":"message","text":"But I have the suspicion that that might be a function of the community intentionally putting an emphasis on the tooling there.","user":"U019K6Q9N15","ts":"1614802441.455400","team":"T68168MUP","edited":{"user":"U019K6Q9N15","ts":"1614802467.000000"},"blocks":[{"type":"rich_text","block_id":"7GX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I have the suspicion that that might be a function of the community intentionally putting an emphasis on the tooling there."}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"f16687ab-b1e6-4402-ac8e-6c5cd0ddb330","type":"message","text":"<@U9VG1AYSG> You mean just because the effort of thinking through the exact contract for your generic function, and even naming the return type can be very difficult?","user":"UCNPT22MQ","ts":"1614802473.455700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XhJX","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U9VG1AYSG"},{"type":"text","text":" You mean just because the effort of thinking through the exact contract for your generic function, and even naming the return type can be very difficult?"}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"7257624b-dcc2-4a4e-a507-31b960db9a3b","type":"message","text":"<@U019K6Q9N15> yeah, I see what you're saying, but I also think this is orthogonal to dynamic types. You have languages like Haskell and Scala that have very interactive, productive development, with static type systems","user":"UCNPT22MQ","ts":"1614802541.455900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FXNm","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U019K6Q9N15"},{"type":"text","text":" yeah, I see what you're saying, but I also think this is orthogonal to dynamic types. You have languages like Haskell and Scala that have very interactive, productive development, with static type systems"}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"e71bc578-5736-4f8f-9ec3-d599e9857f5f","type":"message","text":"I found this blog post a pretty good read: <https://erik-engheim.medium.com/the-many-advantages-of-dynamic-languages-267d08f4c7>. What Julia brings to the table is that it's a language with dynamic semantics, but a large subset of Julia programs can be optimized as if it was a static language. The correctness aspect of static type systems is something that gets brought up quite often. JET.jl will likely be able to address some of those use cases and I would argue that, at least for numerics, type checking really doesn't buy you much, since a lot of the time, you are just dealing with arrays of `Float64`s. Writing good unit tests is often a lot more important in those situations than being able to prove the type of every variable in your program. That said, I am definitely not denying that for some tasks, static languages might be better suited than dynamic ones, personally I just tend to prefer the workflow of a dynamic language for what I do.","user":"UM30MT6RF","ts":"1614803096.456200","team":"T68168MUP","edited":{"user":"UM30MT6RF","ts":"1614803104.000000"},"blocks":[{"type":"rich_text","block_id":"GVM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I found this blog post a pretty good read: "},{"type":"link","url":"https://erik-engheim.medium.com/the-many-advantages-of-dynamic-languages-267d08f4c7"},{"type":"text","text":". What Julia brings to the table is that it's a language with dynamic semantics, but a large subset of Julia programs can be optimized as if it was a static language. The correctness aspect of static type systems is something that gets brought up quite often. JET.jl will likely be able to address some of those use cases and I would argue that, at least for numerics, type checking really doesn't buy you much, since a lot of the time, you are just dealing with arrays of `Float64`s. Writing good unit tests is often a lot more important in those situations than being able to prove the type of every variable in your program. That said, I am definitely not denying that for some tasks, static languages might be better suited than dynamic ones, personally I just tend to prefer the workflow of a dynamic language for what I do."}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"5e411d52-5880-4998-b328-3a3a129ec096","type":"message","text":"I believe that tooling and established interactive workflows are very important. Having a (potentially) slow compile step might be a detriment, but it doesn't have to be that bad (e.g. go)\nInstead, Rust and Go, for instance, have excellent tooling tightly integrated. Personally, I find that very enjoyable to work with and much more dynamic.\nAlternatively, even a half decent REPL (let alone something like Julia's REPL) or something like Jupyter and Pluto notebooks allow you to iterate and experiment quickly and painlessly.\n\nCompare that to C++... I don't even know where to start. Yesterday I spent a couple of hours working with boost asio / beast and trying to make sense of compiler errors. I might not quite the same person anymore. Some part of me died in the process","user":"ULMSM9MAL","ts":"1614803187.456600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yAP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I believe that tooling and established interactive workflows are very important. Having a (potentially) slow compile step might be a detriment, but it doesn't have to be that bad (e.g. go)\nInstead, Rust and Go, for instance, have excellent tooling tightly integrated. Personally, I find that very enjoyable to work with and much more dynamic.\nAlternatively, even a half decent REPL (let alone something like Julia's REPL) or something like Jupyter and Pluto notebooks allow you to iterate and experiment quickly and painlessly.\n\nCompare that to C++... I don't even know where to start. Yesterday I spent a couple of hours working with boost asio / beast and trying to make sense of compiler errors. I might not quite the same person anymore. Some part of me died in the process"}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"742fc266-d9ab-4ea0-ab94-aa23e8fb99b7","type":"message","text":"<@UM30MT6RF> thanks. I didn't find the blog post that convincing: I feel like the author picked hard on C++, which has particularly decentralised/complex tooling, but the author didn't acknowledge what this tooling gives you (small, fast, opaque, portable, predictably-performing binaries)\nI agree with some of the sentiment in the rest of your comment though. Static type systems aren't going to fix your algorithmic bugs, but they're at least going to tell you when you've renamed a method but you've missed a usage on a particular branch. I'll have a deeper look at JET, seems handt","user":"UCNPT22MQ","ts":"1614803811.456900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"luJ","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UM30MT6RF"},{"type":"text","text":" thanks. I didn't find the blog post that convincing: I feel like the author picked hard on C++, which has particularly decentralised/complex tooling, but the author didn't acknowledge what this tooling gives you (small, fast, opaque, portable, predictably-performing binaries)\nI agree with some of the sentiment in the rest of your comment though. Static type systems aren't going to fix your algorithmic bugs, but they're at least going to tell you when you've renamed a method but you've missed a usage on a particular branch. I'll have a deeper look at JET, seems handt"}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"},{"client_msg_id":"47da2226-bb09-42b3-9d5c-c32f49130030","type":"message","text":"<@ULMSM9MAL> yes, agree that C++ is particularly miserable, and that there are more modern static languages that feel a lot lighter to write","user":"UCNPT22MQ","ts":"1614803932.457100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GEm=t","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"ULMSM9MAL"},{"type":"text","text":" yes, agree that C++ is particularly miserable, and that there are more modern static languages that feel a lot lighter to write"}]}]}],"thread_ts":"1614802088.454700","parent_user_id":"UCNPT22MQ"}]