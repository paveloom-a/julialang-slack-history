[{"client_msg_id":"d9526432-035d-453a-bc04-3938b56d5669","type":"message","text":"Hello! beginner question incomming\nI have two functions which should be (approximate---to numerical error) inverses of each-other. Is there any good way to unit test this except for trying a few values?\ni.e. in Haskell I'd use \"QuickCheck\" for this (to test properties)","user":"U01Q7MHAE5U","ts":"1617480975.200100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WfU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hello! beginner question incomming\nI have two functions which should be (approximate---to numerical error) inverses of each-other. Is there any good way to unit test this except for trying a few values?\ni.e. in Haskell I'd use \"QuickCheck\" for this (to test properties)"}]}]}],"thread_ts":"1617480975.200100","reply_count":12,"reply_users_count":6,"latest_reply":"1617533320.222400","reply_users":["U0179G7FG4F","U012XER8K4M","U01Q7MHAE5U","U6A936746","U01CQTKB86N","UH24GRBLL"],"is_locked":false,"subscribed":false},{"client_msg_id":"e719474c-b470-4a5c-99d6-3490c9e11160","type":"message","text":"I'd do this by making a vector `x`of test points and then using `all( f.(g.(x)) .==x )`","user":"U0179G7FG4F","ts":"1617482475.200200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dku8d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd do this by making a vector `x`of test points and then using "},{"type":"text","text":"all( f.(g.(x)) .==x )","style":{"code":true}}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"client_msg_id":"187a6b03-353e-45ef-af7d-a9bbfbc3c14c","type":"message","text":"Actually you want `≈` for approximate equality","user":"U0179G7FG4F","ts":"1617482525.200400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f+N3I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Actually you want "},{"type":"text","text":"≈","style":{"code":true}},{"type":"text","text":" for approximate equality"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"client_msg_id":"b975214a-2e3f-4da3-bce3-837d6dcd200f","type":"message","text":"Nothing stops you from generating randomized inputs (though I wouldn't prefer it) (in my very limited experience, quickcheck was mostly good at finding cornercases, i.e. \"NaN/0/inf\" etc. which.. probably won't work in this case anyway).","user":"U012XER8K4M","ts":"1617482574.200600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ua+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Nothing stops you from generating randomized inputs (though I wouldn't prefer it) (in my very limited experience, quickcheck was mostly good at finding cornercases, i.e. \"NaN/0/inf\" etc. which.. probably won't work in this case anyway)."}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"client_msg_id":"316c3946-b56b-41bc-ae8a-2d7695948584","type":"message","text":"Indeed, from my experience it's usually bad practice to generate random inputs","user":"U01Q7MHAE5U","ts":"1617482903.200800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aG1m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Indeed, from my experience it's usually bad practice to generate random inputs"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"client_msg_id":"68431c73-356a-4fb7-9ca9-250d8fbf1979","type":"message","text":"I often use `exp10.(range(-700.0, 700.0, length=10^6))` That gets you a good range of small, medium and large numbers (technichally you also need the negative version of that), and adding tests for `Inf` and `Nan` are a good idea)","user":"U0179G7FG4F","ts":"1617483186.201000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"flyqS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I often use "},{"type":"text","text":"exp10.(range(-700.0, 700.0, length=10^6))","style":{"code":true}},{"type":"text","text":" That gets you a good range of small, medium and large numbers (technichally you also need the negative version of that), and adding tests for "},{"type":"text","text":"Inf","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Nan","style":{"code":true}},{"type":"text","text":" are a good idea)"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U","reactions":[{"name":"+1","users":["U6A936746","UKG4WF8PJ"],"count":2}]},{"client_msg_id":"af70608b-0d99-4656-b6df-cda29205ab12","type":"message","text":"Doesn't QuickCheck effectively generate random inputs?","user":"U6A936746","ts":"1617486935.201200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9f5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Doesn't QuickCheck effectively generate random inputs?"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"type":"message","subtype":"thread_broadcast","text":"A property testing library like QuickCheck would be cool for Julia. there were a few prototypes a long long time ago, idk if there is anything current that woeks","user":"U6A936746","ts":"1617487105.201700","thread_ts":"1617480975.200100","root":{"client_msg_id":"d9526432-035d-453a-bc04-3938b56d5669","type":"message","text":"Hello! beginner question incomming\nI have two functions which should be (approximate---to numerical error) inverses of each-other. Is there any good way to unit test this except for trying a few values?\ni.e. in Haskell I'd use \"QuickCheck\" for this (to test properties)","user":"U01Q7MHAE5U","ts":"1617480975.200100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WfU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hello! beginner question incomming\nI have two functions which should be (approximate---to numerical error) inverses of each-other. Is there any good way to unit test this except for trying a few values?\ni.e. in Haskell I'd use \"QuickCheck\" for this (to test properties)"}]}]}],"thread_ts":"1617480975.200100","reply_count":12,"reply_users_count":6,"latest_reply":"1617533320.222400","reply_users":["U0179G7FG4F","U012XER8K4M","U01Q7MHAE5U","U6A936746","U01CQTKB86N","UH24GRBLL"],"is_locked":false,"subscribed":false},"blocks":[{"type":"rich_text","block_id":"JY1CN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A property testing library like QuickCheck would be cool for Julia. there were a few prototypes a long long time ago, idk if there is anything current that woeks"}]}]}],"client_msg_id":"3cacf275-30e0-4712-bbb6-a4b67f0cc746","reactions":[{"name":"heart","users":["U017J1FHTSA"],"count":1}]},{"client_msg_id":"aec2ced3-1502-454a-b006-7d48287f80d4","type":"message","text":"I'll have to admit that it was ages ago I used quickcheck, but as I recall, you basically have to tell it how to generate the inputs. In a complex algorithm, i recall it being next to impossible to write the properties that would generate a valid input.\nSimple cases you can filter out the non-valid testcases sure, but, if 99.999% or all random input are going to be non-valid (or at least not interesting, i.e. not triggering the core algorithm) it doesn't work well, and you just straight up have to supply your own generator.","user":"U012XER8K4M","ts":"1617488056.202000","team":"T68168MUP","edited":{"user":"U012XER8K4M","ts":"1617488082.000000"},"blocks":[{"type":"rich_text","block_id":"AxVTu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'll have to admit that it was ages ago I used quickcheck, but as I recall, you basically have to tell it how to generate the inputs. In a complex algorithm, i recall it being next to impossible to write the properties that would generate a valid input.\nSimple cases you can filter out the non-valid testcases sure, but, if 99.999% or all random input are going to be non-valid (or at least not interesting, i.e. not triggering the core algorithm) it doesn't work well, and you just straight up have to supply your own generator."}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"type":"message","subtype":"thread_broadcast","text":"Julia could probably do a lot better than random. You basically need to understand the boundaries/categories of the problem to know where to test. First, a Julia implementation can analyze the code being tested. Second, it intuitively sounds like the mechanisms used to implement AD could be used to understand where the boundaries are. A problem is that whether or not a print-statement is executed is not a numerical output that can be differentiated.","user":"U01CQTKB86N","ts":"1617522109.219200","thread_ts":"1617480975.200100","root":{"client_msg_id":"d9526432-035d-453a-bc04-3938b56d5669","type":"message","text":"Hello! beginner question incomming\nI have two functions which should be (approximate---to numerical error) inverses of each-other. Is there any good way to unit test this except for trying a few values?\ni.e. in Haskell I'd use \"QuickCheck\" for this (to test properties)","user":"U01Q7MHAE5U","ts":"1617480975.200100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WfU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hello! beginner question incomming\nI have two functions which should be (approximate---to numerical error) inverses of each-other. Is there any good way to unit test this except for trying a few values?\ni.e. in Haskell I'd use \"QuickCheck\" for this (to test properties)"}]}]}],"thread_ts":"1617480975.200100","reply_count":12,"reply_users_count":6,"latest_reply":"1617533320.222400","reply_users":["U0179G7FG4F","U012XER8K4M","U01Q7MHAE5U","U6A936746","U01CQTKB86N","UH24GRBLL"],"is_locked":false,"subscribed":false},"blocks":[{"type":"rich_text","block_id":"MHX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Julia could probably do a lot better than random. You basically need to understand the boundaries/categories of the problem to know where to test. First, a Julia implementation can analyze the code being tested. Second, it intuitively sounds like the mechanisms used to implement AD could be used to understand where the boundaries are. A problem is that whether or not a print-statement is executed is not a numerical output that can be differentiated."}]}]}],"client_msg_id":"36BAFD69-3E07-440B-97B0-3DEAE9DE2049"},{"client_msg_id":"8e09b518-a860-45b2-a517-7e00fb98069a","type":"message","text":"<https://hypothesis.works/articles/integrated-shrinking/>\n\nis basically what we'd want in julia","user":"UH24GRBLL","ts":"1617533234.221900","team":"T68168MUP","attachments":[{"title":" Integrated vs type based shrinking - Hypothesis ","title_link":"https://hypothesis.works/articles/integrated-shrinking/","text":"Integrated vs type based shrinking One of the big differences between Hypothesis and Haskell QuickCheck is how shrinking is handled. Specifically, the way shrinking is handled in Haskell QuickCheck is bad and the way it works in Hypothesis (and also in test.check and EQC) is good. If you’re implementing a property based testing system, you should use the good way. If you’re using a property based testing system and it doesn’t use the good way, you need to know about this failure mode. Unfortunately many (and possibly most) implementations of property based testing are based on Haskell’s QuickCheck and so make the same mistake. Test faster, fix more","fallback":" Integrated vs type based shrinking - Hypothesis ","from_url":"https://hypothesis.works/articles/integrated-shrinking/","service_name":"hypothesis.works","id":1,"original_url":"https://hypothesis.works/articles/integrated-shrinking/"}],"blocks":[{"type":"rich_text","block_id":"e/SI","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://hypothesis.works/articles/integrated-shrinking/"},{"type":"text","text":"\n\nis basically what we'd want in julia"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U","reactions":[{"name":"point_up::skin-tone-6","users":["U017J1FHTSA"],"count":1}]},{"client_msg_id":"de8b5253-8de9-4178-9c9c-02630a7ee62d","type":"message","text":"QuickCheck is much too dependent on the type system of haskell","user":"UH24GRBLL","ts":"1617533252.222200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vHQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"QuickCheck is much too dependent on the type system of haskell"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"},{"client_msg_id":"6b201a41-c070-4e8d-a40e-07489b02b3f5","type":"message","text":"nothing of the sort exists as a julia package right now though","user":"UH24GRBLL","ts":"1617533320.222400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kn7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"nothing of the sort exists as a julia package right now though"}]}]}],"thread_ts":"1617480975.200100","parent_user_id":"U01Q7MHAE5U"}]