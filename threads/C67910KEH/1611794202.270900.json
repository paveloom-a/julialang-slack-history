[{"client_msg_id":"b954de58-e7be-40e4-9a04-0b003f04d15b","type":"message","text":"Is there a Julia library that provides a `@fastmath` like macro in case you really don't care about accuracy (ie +- ~1% rather than `@fastmath` which goes +- a few ulps). For things like machine learning, this could be really useful as you often don't care at all about the exact values but instead just the shapes","user":"U0179G7FG4F","ts":"1611794202.270900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/wj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a Julia library that provides a "},{"type":"text","text":"@fastmath","style":{"code":true}},{"type":"text","text":" like macro in case you really don't care about accuracy (ie +- ~1% rather than "},{"type":"text","text":"@fastmath","style":{"code":true}},{"type":"text","text":" which goes +- a few ulps). For things like machine learning, this could be really useful as you often don't care at all about the exact values but instead just the shapes"}]}]}],"thread_ts":"1611794202.270900","reply_count":8,"reply_users_count":3,"latest_reply":"1611825591.274300","reply_users":["U6A936746","U0179G7FG4F","U7HAYKY9X"],"subscribed":false,"reactions":[{"name":"+1","users":["U6A936746","U7THT3TM3","UKG4WF8PJ"],"count":3}]},{"client_msg_id":"fc6ce0ba-2dd8-4f84-984c-3a3f3dd29660","type":"message","text":"SLEEF.jl is 3-5ulp iirc.","user":"U6A936746","ts":"1611794612.271000","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1611794623.000000"},"blocks":[{"type":"rich_text","block_id":"bCx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"SLEEF.jl is 3-5ulp iirc."}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"},{"client_msg_id":"e2af0cc8-6a70-4260-9399-46d0e7db95cd","type":"message","text":"Using Float16 gets you pretty low.\nBut iirc most Float16 ops runs as Float32 so don't get you that much speed.","user":"U6A936746","ts":"1611794727.271300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"95f=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Using Float16 gets you pretty low.\nBut iirc most Float16 ops runs as Float32 so don't get you that much speed."}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"},{"client_msg_id":"8236a7c1-7982-4ec1-ac89-404a5e340562","type":"message","text":"one of the things vaguely on my to-do list is to give Base special `Float16` versions of some special functions","user":"U0179G7FG4F","ts":"1611794784.271500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T5l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"one of the things vaguely on my to-do list is to give Base special "},{"type":"text","text":"Float16","style":{"code":true}},{"type":"text","text":" versions of some special functions"}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"},{"client_msg_id":"a55afefb-9413-4d13-b935-0d03e86c7a74","type":"message","text":"They still would use `Float32`, but would use simpler polynomials and not do anything fancy to get full `Float32` precision that you then round away anyway","user":"U0179G7FG4F","ts":"1611794857.271700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gw5/d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"They still would use "},{"type":"text","text":"Float32","style":{"code":true}},{"type":"text","text":", but would use simpler polynomials and not do anything fancy to get full "},{"type":"text","text":"Float32","style":{"code":true}},{"type":"text","text":" precision that you then round away anyway"}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F","reactions":[{"name":"+1","users":["U6A936746","U67G3QRJM"],"count":2}]},{"client_msg_id":"dc833418-906a-4b34-9079-0a8292440b90","type":"message","text":"It should be possible to replicate the  work that was done to find polynomials libm's to find ones with far fewer terms.\nYou might be able to find notes on how that is done around LibM.jl and Amal.jl","user":"U6A936746","ts":"1611794999.271900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0JkFZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It should be possible to replicate the  work that was done to find polynomials libm's to find ones with far fewer terms.\nYou might be able to find notes on how that is done around LibM.jl and Amal.jl"}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"},{"client_msg_id":"e8059a82-9471-47fe-ae2d-91d040c6a7e3","type":"message","text":"Well I just found a `Float16` bug `Float16(0.9997554299121412)`\nreturns `Float16(0.9995)`. What the hell?","user":"U0179G7FG4F","ts":"1611798315.272500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4i9k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well I just found a "},{"type":"text","text":"Float16","style":{"code":true}},{"type":"text","text":" bug "},{"type":"text","text":"Float16(0.9997554299121412)","style":{"code":true}},{"type":"text","text":"\nreturns "},{"type":"text","text":"Float16(0.9995)","style":{"code":true}},{"type":"text","text":". What the hell?"}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"},{"client_msg_id":"16d23161-e201-4561-b89e-7f4a83a7ddf1","type":"message","text":"<https://github.com/JuliaLang/julia/pull/39431> for exps and theres one for hyperbolic trig incoming soon","user":"U0179G7FG4F","ts":"1611811696.273800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XI2U","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/JuliaLang/julia/pull/39431"},{"type":"text","text":" for exps and theres one for hyperbolic trig incoming soon"}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"},{"client_msg_id":"04141d41-1a8c-46f9-9ca6-3a30eb4caef2","type":"message","text":"You could use fixed point numbers, perhaps? I'm not 100% certain, but I'd expect integers to be faster than float ops in some circumstances (IIRC, CPUs tend to have more floating point µops, but they have longer latency)","user":"U7HAYKY9X","ts":"1611825591.274300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YQzU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could use fixed point numbers, perhaps? I'm not 100% certain, but I'd expect integers to be faster than float ops in some circumstances (IIRC, CPUs tend to have more floating point µops, but they have longer latency)"}]}]}],"thread_ts":"1611794202.270900","parent_user_id":"U0179G7FG4F"}]