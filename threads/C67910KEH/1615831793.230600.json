[{"client_msg_id":"c0f9aea4-8e60-4ada-8358-a9d77b54500a","type":"message","text":"how clever is the compiler with types that are technically not known at compile time but for which the code for a function can be completely inferred?  For example\n```struct TestType{ùíØ}\n    z::ùíØ\n    x::Float64\n    y::Float64\nend\n\nf(t::TestType) = t.x + t.y\ng(t::TestType{&lt;:AbstractFloat}) = t.x + t.z\ng(t::TestType{&lt;:Complex}) = t.x + conj(t.z)```\nis it possible for `f` to be slow if the parameter `t` is not known at compile time because the pointer for `x` and `y` depends on the type of `z` (note I put the `z` first)?  Or does it somehow arrange things in memory such that `f` always has to output exactly the same code?","user":"U9VG1AYSG","ts":"1615831793.230600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hVFrR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"how clever is the compiler with types that are technically not known at compile time but for which the code for a function can be completely inferred?  For example\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct TestType{ùíØ}\n    z::ùíØ\n    x::Float64\n    y::Float64\nend\n\nf(t::TestType) = t.x + t.y\ng(t::TestType{<:AbstractFloat}) = t.x + t.z\ng(t::TestType{<:Complex}) = t.x + conj(t.z)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"is it possible for "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" to be slow if the parameter "},{"type":"text","text":"t","style":{"code":true}},{"type":"text","text":" is not known at compile time because the pointer for "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" depends on the type of "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" (note I put the "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" first)?  Or does it somehow arrange things in memory such that "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" always has to output exactly the same code?"}]}]}],"thread_ts":"1615831793.230600","reply_count":2,"reply_users_count":2,"latest_reply":"1615832172.231300","reply_users":["U9VG1AYSG","UH24GRBLL"],"subscribed":false},{"client_msg_id":"e020d738-999d-407c-8ed8-9c0e65484ce6","type":"message","text":"for the record, I have tried testing this, the LLVM IR indeed looks different depending on the type, but the assembly itself does not seem to depend on the type, so it's pretty inconclusive on how worried I should be about this","user":"U9VG1AYSG","ts":"1615832035.231000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SE4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for the record, I have tried testing this, the LLVM IR indeed looks different depending on the type, but the assembly itself does not seem to depend on the type, so it's pretty inconclusive on how worried I should be about this"}]}]}],"thread_ts":"1615831793.230600","parent_user_id":"U9VG1AYSG"},{"client_msg_id":"69512d91-bb30-4af4-b920-1dd17766e066","type":"message","text":"since it knows the sizes of `x` and `y`, presumably the only thing that would change based on `T` is the offset","user":"UH24GRBLL","ts":"1615832172.231300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"49rb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"since it knows the sizes of "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":", presumably the only thing that would change based on "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" is the offset"}]}]}],"thread_ts":"1615831793.230600","parent_user_id":"U9VG1AYSG"}]