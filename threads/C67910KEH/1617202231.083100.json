[{"client_msg_id":"d91f2aa8-79fd-4074-9648-9745a4b0e47c","type":"message","text":"Curious if anyone has thoughts on the Scalable Vector Extension 2 (SVE2) added to the new ARMv9. Will this be beneficial to Julia scientific computing, machine learning etc on ARM?","user":"UTJT285RN","ts":"1617202231.083100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MkOH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Curious if anyone has thoughts on the Scalable Vector Extension 2 (SVE2) added to the new ARMv9. Will this be beneficial to Julia scientific computing, machine learning etc on ARM?"}]}]}],"thread_ts":"1617202231.083100","reply_count":16,"reply_users_count":5,"latest_reply":"1617203969.086900","reply_users":["U0179G7FG4F","UTJT285RN","UH24GRBLL","U6N6VQE30","UAUPJLBQX"],"is_locked":false,"subscribed":false},{"client_msg_id":"0d970a0a-b640-404a-ba8e-535d905e9a26","type":"message","text":"SVE2 is awesome.","user":"U0179G7FG4F","ts":"1617202588.083300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m83","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"SVE2 is awesome."}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"a5f64889-57a6-4e30-8c04-cbabe27063bc","type":"message","text":"What do you think is awesome about them? I have look at RISC-V vector extensions in the past but don't know that much about SVE2. I have the impression they are quite similar.","user":"UTJT285RN","ts":"1617202685.083500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BBw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do you think is awesome about them? I have look at RISC-V vector extensions in the past but don't know that much about SVE2. I have the impression they are quite similar."}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"479a5265-fef8-46b1-8be2-a2c4d3614bc5","type":"message","text":"It's basically the same thing conceptually like SSE and AVX on x86","user":"UH24GRBLL","ts":"1617202760.083800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ofxK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's basically the same thing conceptually like SSE and AVX on x86"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"65434cda-10ab-4357-b009-d1c47a3d24cd","type":"message","text":"One thing that makes AVX instructions really annoying to work with is that they are very tightly tied to the chip architecture. The SVE2, (and RISC-V vector) instructions have the length as a parameter, so there (hopefully) won't be a new set every couple years when the processor gets a little bigger","user":"U0179G7FG4F","ts":"1617202808.084000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SpkZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One thing that makes AVX instructions really annoying to work with is that they are very tightly tied to the chip architecture. The SVE2, (and RISC-V vector) instructions have the length as a parameter, so there (hopefully) won't be a new set every couple years when the processor gets a little bigger"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"87b840b2-0ae3-4ff5-8b5f-592cf5f9af4b","type":"message","text":"SSE and AVX are more like NEON as far as I understand <@UH24GRBLL>. Meaning they are fixed length SIMD instructions. While with SVE2 and RVV you specify length of vector in register. The vector instructions themselves are basically polymorphic. They work on any length up to the max.","user":"UTJT285RN","ts":"1617202905.084300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ei/q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"SSE and AVX are more like NEON as far as I understand "},{"type":"user","user_id":"UH24GRBLL"},{"type":"text","text":". Meaning they are fixed length SIMD instructions. While with SVE2 and RVV you specify length of vector in register. The vector instructions themselves are basically polymorphic. They work on any length up to the max."}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"e4b0dac9-2776-44f0-af5c-93c596f7bb19","type":"message","text":"<@U0179G7FG4F> when I tried following this debate before it seems very contentious. Many opinion that variable length vectors are of no use for general computing. That you only need small vectors and if you need long vectors you should just use the GPU instead. Hard to make head or tails of this debate. Especially when you don't do this type of coding yourself (like me)","user":"UTJT285RN","ts":"1617203016.084600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=Tzp9","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U0179G7FG4F"},{"type":"text","text":" when I tried following this debate before it seems very contentious. Many opinion that variable length vectors are of no use for general computing. That you only need small vectors and if you need long vectors you should just use the GPU instead. Hard to make head or tails of this debate. Especially when you don't do this type of coding yourself (like me)"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"902a9117-7d2f-4623-8309-6626cbb64f6b","type":"message","text":"I mean, julia did not have any issues with SSE/AVX/AVX512 since it compiles on the target architecture anyways","user":"U6N6VQE30","ts":"1617203124.084800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YhKE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, julia did not have any issues with SSE/AVX/AVX512 since it compiles on the target architecture anyways"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN","reactions":[{"name":"100","users":["UAUPJLBQX"],"count":1}]},{"client_msg_id":"3ed6ad4c-641c-464a-9167-e0b76b2f6453","type":"message","text":"It's basically boiling down to whether LLVM emits those instructions","user":"UH24GRBLL","ts":"1617203156.085000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W8D","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's basically boiling down to whether LLVM emits those instructions"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"3a80ff55-a2b0-435d-ba4e-cc57806b7c83","type":"message","text":"from the julia side not much is going to change explicitly","user":"UH24GRBLL","ts":"1617203165.085200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YYRk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"from the julia side not much is going to change explicitly"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"f313f115-b302-44fe-98ba-468fbd5ca429","type":"message","text":"at most something like LoopVectorization would have to change some internals","user":"UH24GRBLL","ts":"1617203209.085400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6wj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"at most something like LoopVectorization would have to change some internals"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"d5ab99dd-0f2f-44bd-9aeb-a3bacafa8c49","type":"message","text":"What I mean is: SVE is interesting for languages that do static compilation, because you can compile once and run on different micro-archs without sacrificing performance. In julia you recompile all the time, so what's the point (except maybe generic sysimages...)?","user":"U6N6VQE30","ts":"1617203447.085600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Itl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What I mean is: SVE is interesting for languages that do static compilation, because you can compile once and run on different micro-archs without sacrificing performance. In julia you recompile all the time, so what's the point (except maybe generic sysimages...)?"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN","reactions":[{"name":"+1","users":["UTJT285RN"],"count":1}]},{"client_msg_id":"1f2496f9-6d29-4eda-8dd9-0c1dacf52f2e","type":"message","text":"recompile all the time...? I mean, across different executions maybe, but not during the same execution","user":"UH24GRBLL","ts":"1617203505.085800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TqM+q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"recompile all the time...? I mean, across different executions maybe, but not during the same execution"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"0aece148-9fe9-49eb-a5e7-e6806c7aaf86","type":"message","text":"<@U6N6VQE30> One advantage is that it makes <@UAUPJLBQX>'s job much easier.","user":"U0179G7FG4F","ts":"1617203518.086000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VQg","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6N6VQE30"},{"type":"text","text":" One advantage is that it makes "},{"type":"user","user_id":"UAUPJLBQX"},{"type":"text","text":"'s job much easier."}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"8ac8501c-7d71-4652-bfd4-c83cd10219ef","type":"message","text":"One problem with AVX512 is the market segmentation that results. People like Linus Torvalds will gripe about every bit of SIMD and floating point math they have to \"waste\" silicon on","user":"UAUPJLBQX","ts":"1617203914.086500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cWkzQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One problem with AVX512 is the market segmentation that results. People like Linus Torvalds will gripe about every bit of SIMD and floating point math they have to \"waste\" silicon on"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"c5417239-89ac-4dad-b0e9-7e0bbc8ced9a","type":"message","text":"while others (such as myself) like big vectors.","user":"UAUPJLBQX","ts":"1617203968.086700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ErDGB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"while others (such as myself) like big vectors."}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"},{"client_msg_id":"1a3c3b2e-f210-43ea-a332-1aaf0c7e9a0c","type":"message","text":"<@U0179G7FG4F> VectorizationBase is mapping to LLVM IR at the lowest level, and LLVM IR's vector types do not map 1-to-1 to hardware vectors, so you can work with \"dynamic\" vector sizes already","user":"U6N6VQE30","ts":"1617203969.086900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vya","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U0179G7FG4F"},{"type":"text","text":" VectorizationBase is mapping to LLVM IR at the lowest level, and LLVM IR's vector types do not map 1-to-1 to hardware vectors, so you can work with \"dynamic\" vector sizes already"}]}]}],"thread_ts":"1617202231.083100","parent_user_id":"UTJT285RN"}]