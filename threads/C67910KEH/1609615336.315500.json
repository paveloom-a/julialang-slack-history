[{"client_msg_id":"d664f2ae-ebeb-41e0-86ba-1f0dc9b2c1a1","type":"message","text":"This may be naive but besides large executable sizes, can't Julia perform equally as well in the systems software realm as C and Rust if you disable GC and manage memory manually?","user":"U01FAHWCMFF","ts":"1609615336.315500","team":"T68168MUP","edited":{"user":"U01FAHWCMFF","ts":"1609615368.000000"},"blocks":[{"type":"rich_text","block_id":"PGGMH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This may be naive but besides large executable sizes, can't Julia perform equally as well in the systems software realm as C and Rust if you disable GC and manage memory manually?"}]}]}],"thread_ts":"1609615336.315500","reply_count":26,"reply_users_count":8,"latest_reply":"1609633054.329200","reply_users":["U0179G7FG4F","U01FAHWCMFF","U6A936746","U7HAYKY9X","U01GXNFKY6R","UH24GRBLL","UM30MT6RF","U6795JH6H"],"subscribed":false},{"client_msg_id":"7f325174-e3d5-46db-a5ee-2410ff198df2","type":"message","text":"you'll also have a higher minimum ram usage since the julia runtime will be in memory","user":"U0179G7FG4F","ts":"1609615552.315800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IXl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you'll also have a higher minimum ram usage since the julia runtime will be in memory"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"+1","users":["U01FAHWCMFF","U6A936746"],"count":2}]},{"client_msg_id":"3691f128-f6f4-4c1c-aa5e-57108f6109b6","type":"message","text":"Whats the minimum RAM of C compared with Julia (is it just the file size of the executables with some slight overhead?)? Is there a way to lower Julias RAM consumption (without compromising on performance)?","user":"U01FAHWCMFF","ts":"1609615693.316100","team":"T68168MUP","edited":{"user":"U01FAHWCMFF","ts":"1609615767.000000"},"blocks":[{"type":"rich_text","block_id":"uj5sR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Whats the minimum RAM of C compared with Julia (is it just the file size of the executables with some slight overhead?)? Is there a way to lower Julias RAM consumption (without compromising on performance)?"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"e4623175-6a4c-42ab-9bbb-d40cee2ec754","type":"message","text":"minimum memory consumption is around 200mb for Julia. That won't get lower until julia gets a better way of making static binaries","user":"U0179G7FG4F","ts":"1609616855.317100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZOuF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"minimum memory consumption is around 200mb for Julia. That won't get lower until julia gets a better way of making static binaries"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"156e5596-0c9e-4220-b911-e56d6d3bb719","type":"message","text":"You can’t manage memory manually in julia, outside of very limitted circumstances where you can (and must) manage it in very limitted ways.","user":"U6A936746","ts":"1609616960.317400","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1609619363.000000"},"blocks":[{"type":"rich_text","block_id":"22d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can’t manage memory manually in julia, outside of very limitted circumstances where you can (and must) manage it in very limitted ways."}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"385eeded-18da-4901-935e-2bed52259f69","type":"message","text":"I would argue that even if Julia gets the ability to be statically compiled, you would probably prefer an actual static language in those use cases anyway.","user":"U7HAYKY9X","ts":"1609620877.320300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Iok","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would argue that even if Julia gets the ability to be statically compiled, you would probably prefer an actual static language in those use cases anyway."}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"type":"message","subtype":"thread_broadcast","text":"On a slightly related note, what if Julia had optional borrow checking for certain variables like rust? So GC would run regularly but for certain rust like variables, the memory could be cleaned up as soon as it goes out of scope. Is this even possible to do?","user":"U01GXNFKY6R","ts":"1609621185.320900","thread_ts":"1609615336.315500","root":{"client_msg_id":"d664f2ae-ebeb-41e0-86ba-1f0dc9b2c1a1","type":"message","text":"This may be naive but besides large executable sizes, can't Julia perform equally as well in the systems software realm as C and Rust if you disable GC and manage memory manually?","user":"U01FAHWCMFF","ts":"1609615336.315500","team":"T68168MUP","edited":{"user":"U01FAHWCMFF","ts":"1609615368.000000"},"blocks":[{"type":"rich_text","block_id":"PGGMH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This may be naive but besides large executable sizes, can't Julia perform equally as well in the systems software realm as C and Rust if you disable GC and manage memory manually?"}]}]}],"thread_ts":"1609615336.315500","reply_count":26,"reply_users_count":8,"latest_reply":"1609633054.329200","reply_users":["U0179G7FG4F","U01FAHWCMFF","U6A936746","U7HAYKY9X","U01GXNFKY6R","UH24GRBLL","UM30MT6RF","U6795JH6H"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"tEimw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On a slightly related note, what if Julia had optional borrow checking for certain variables like rust? So GC would run regularly but for certain rust like variables, the memory could be cleaned up as soon as it goes out of scope. Is this even possible to do?"}]}]}],"client_msg_id":"67de4de2-161a-4ca8-ac91-217c10e0692c"},{"client_msg_id":"d987f0e2-401d-4b4d-931a-3cbf064f3117","type":"message","text":"sure, if you want to touch gc.c","user":"UH24GRBLL","ts":"1609621527.322100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"puy1S","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sure, if you want to touch gc.c"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"sweat_smile","users":["U01GXNFKY6R"],"count":1}]},{"client_msg_id":"fed76cfc-94dc-49c9-b859-b5e2586742df","type":"message","text":"and probably a bunch of other files to make that actually visible in the language","user":"UH24GRBLL","ts":"1609621548.322500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ogA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and probably a bunch of other files to make that actually visible in the language"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"1d97eb3d-6325-4d3a-ab60-6c7ae354cbce","type":"message","text":"does rust have `eval` semantics?","user":"UH24GRBLL","ts":"1609621557.322700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4gL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"does rust have "},{"type":"text","text":"eval","style":{"code":true}},{"type":"text","text":" semantics?"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"fcc80b42-6fc4-41ed-a5bb-2f1ab4eef42b","type":"message","text":"It does! Check out the evcxr crate","user":"U01GXNFKY6R","ts":"1609622491.323300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"h5v","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It does! Check out the evcxr crate"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"c5e5e05f-e68b-4302-9df6-93ef48d04467","type":"message","text":"Allocating memory dynamically is pretty much always slow and unpredictable, no matter whether your language has GC or not. If your Julia code doesn't allocate, then you also won't have any overhead due to GC","user":"UM30MT6RF","ts":"1609622537.323500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2Fn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Allocating memory dynamically is pretty much always slow and unpredictable, no matter whether your language has GC or not. If your Julia code doesn't allocate, then you also won't have any overhead due to GC"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"69b44ad1-ba6c-43fb-bf67-cb12a4b3ec15","type":"message","text":"If I understand correctly, the big problem with GC is not the allocation, but the deallocation. If you have very large and complicated objects in memory, the GC becomes slow because it basically turns into a heap scanner","user":"U7HAYKY9X","ts":"1609622665.323800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NsR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I understand correctly, the big problem with GC is not the allocation, but the deallocation. If you have very large and complicated objects in memory, the GC becomes slow because it basically turns into a heap scanner"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"fe05ffc4-8593-4d28-b8c0-aeff151fe342","type":"message","text":"I think for us both are slower than they should be","user":"U0179G7FG4F","ts":"1609622692.324200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CsZxp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think for us both are slower than they should be"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"4e73d2f2-8663-470b-ba22-afa8bc54959a","type":"message","text":"I think it will only ever deallocate if you also have allocations. If you are running code that doesn't allocate, there is no reason for the GC to try to free memory","user":"UM30MT6RF","ts":"1609622785.324400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TcMs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it will only ever deallocate if you also have allocations. If you are running code that doesn't allocate, there is no reason for the GC to try to free memory"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"d081dd47-ef6c-48c0-a28a-530c824087fc","type":"message","text":"Correct. But some code needs to allocate, and then it matters.","user":"U7HAYKY9X","ts":"1609622816.324600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MlR2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Correct. But some code needs to allocate, and then it matters."}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"e3c42707-a6e2-4f90-8e8f-07fee2a9c945","type":"message","text":"Yes, of course","user":"UM30MT6RF","ts":"1609622840.324800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j5sh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, of course"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"96ce4301-98a7-444d-8c59-96f66a94fa07","type":"message","text":"My argument was more that `malloc` and `free` aren't cheap either and I believe in some cases GCs can be smarter about dividing up memory than is possible using just `malloc` and `free`","user":"UM30MT6RF","ts":"1609623058.325100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MqsX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My argument was more that "},{"type":"text","text":"malloc","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"free","style":{"code":true}},{"type":"text","text":" aren't cheap either and I believe in some cases GCs can be smarter about dividing up memory than is possible using just "},{"type":"text","text":"malloc","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"free","style":{"code":true}}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"heavy_check_mark","users":["U6A936746","U0179G7FG4F","U012FH66MFW","U6795JH6H"],"count":4}]},{"client_msg_id":"1b4240ef-f0ad-4dab-8ab1-0e117c958cbd","type":"message","text":"a good GC has better throughput than `malloc` + `free` or reference counting","user":"U6795JH6H","ts":"1609629627.327000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"halM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"a good GC has better throughput than "},{"type":"text","text":"malloc","style":{"code":true}},{"type":"text","text":" + "},{"type":"text","text":"free","style":{"code":true}},{"type":"text","text":" or reference counting"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"+1","users":["U67BJLYCS","U01FAHWCMFF","U01GXNFKY6R","UM30MT6RF"],"count":4}]},{"client_msg_id":"c2e8b758-22e6-4057-aec9-c3c48ae21235","type":"message","text":"reference counting and mallc/free avoid long pauses, so they have better latency","user":"U6795JH6H","ts":"1609629670.327200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=Td7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"reference counting and mallc/free avoid long pauses, so they have better latency"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"622e232b-9cb4-45a5-b515-09e1960853d4","type":"message","text":"unless you have a very clever reference counting implementation that eliminates most of the actual count operations, there is a lot of runtime overhead to reference counting","user":"U6795JH6H","ts":"1609629770.327400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nZ=0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"unless you have a very clever reference counting implementation that eliminates most of the actual count operations, there is a lot of runtime overhead to reference counting"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"8eecc720-4e38-4236-bd5c-c775c044886d","type":"message","text":"malloc/free avoids long pauses and has minimal runtime overhead, but you have to do manual memory management so it’s dangerous and puts a lot of burden on the user","user":"U6795JH6H","ts":"1609629897.327600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Aef","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"malloc/free avoids long pauses and has minimal runtime overhead, but you have to do manual memory management so it’s dangerous and puts a lot of burden on the user"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"0c791346-ce77-490f-b36c-20415dfff057","type":"message","text":"Thanks for weighing in <@U6795JH6H>! Do you think optional ownership semantics would ever make it into Julia? And do you think that would help users write performant code?","user":"U01GXNFKY6R","ts":"1609631945.328400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8xod","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for weighing in "},{"type":"user","user_id":"U6795JH6H"},{"type":"text","text":"! Do you think optional ownership semantics would ever make it into Julia? And do you think that would help users write performant code?"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"f7c3ff0b-3ebc-4d0b-a876-bda518dc1cb9","type":"message","text":"unfortunately, as far as I’ve been able to figure out, you basically need a static checker to do ownership semantics","user":"U6795JH6H","ts":"1609632492.328600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NNl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"unfortunately, as far as I’ve been able to figure out, you basically need a static checker to do ownership semantics"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"126c9ea5-122d-4368-bbfa-4e30204f7b49","type":"message","text":"unless you can prove that there’s no way code can access an object, you need to keep it around in case that happens. you could mark an object as invalid but then you’d have to check every access for validity, which could get expensive","user":"U6795JH6H","ts":"1609632665.328800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZuX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"unless you can prove that there’s no way code can access an object, you need to keep it around in case that happens. you could mark an object as invalid but then you’d have to check every access for validity, which could get expensive"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"f4b1da2f-0b6c-4298-be23-9f01baf055be","type":"message","text":"and since it doesn’t help with memory reclamation, it’s hard to see the point","user":"U6795JH6H","ts":"1609632680.329000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S14ES","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and since it doesn’t help with memory reclamation, it’s hard to see the point"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5185e885-32b0-47ca-8f86-148dcdfee97e","type":"message","text":"Having better support for immutable heap-allocated arrays and some kind of freeze/thaw could be really interesting though and might give us some of the benefits of ownership semantics","user":"UM30MT6RF","ts":"1609633054.329200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=HWn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Having better support for immutable heap-allocated arrays and some kind of freeze/thaw could be really interesting though and might give us some of the benefits of ownership semantics"}]}]}],"thread_ts":"1609615336.315500","parent_user_id":"U01FAHWCMFF"}]