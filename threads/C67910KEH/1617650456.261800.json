[{"client_msg_id":"bfc9416c-ca51-4b08-81a2-1b172bb06491","type":"message","text":"Hey!  What's the most \"Julian\" way of doing the following... just getting back into the language after a break.\n\nI want to have a user definable (from a config file) chain of transformations that accepts a datatype of like ten numbers and outputs the transformed version.  I know that I can use `reduce` with the function composition operator to turn everything into one function that's nice and performant.\n\nHowever, my problem is that I don't understand how to make \"parametric functions\".  Basically I want to be able to add a function into the list of transforms that depends on some user configuration.  As an example, I want one which adds normally distributed noise to one field of the input datatype (user selectable) with a programmable mean and standard deviation.  In python I would do this using classes and OOP and have a class `NormallyDistributedNoiseTransform` that has member variables `field`, `mu`, and `sigma` that determines how each instance acts.  Then I would have a list of Transform objects that are chained together.  I'm not sure how to approach this in Julia (performance is also key here since I will be running it like 1e6 times in a monte-carlo thing)  Any hints?","user":"U012MJL8EPN","ts":"1617650456.261800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8Kv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey!  What's the most \"Julian\" way of doing the following... just getting back into the language after a break.\n\nI want to have a user definable (from a config file) chain of transformations that accepts a datatype of like ten numbers and outputs the transformed version.  I know that I can use "},{"type":"text","text":"reduce","style":{"code":true}},{"type":"text","text":" with the function composition operator to turn everything into one function that's nice and performant.\n\nHowever, my problem is that I don't understand how to make \"parametric functions\".  Basically I want to be able to add a function into the list of transforms that depends on some user configuration.  As an example, I want one which adds normally distributed noise to one field of the input datatype (user selectable) with a programmable mean and standard deviation.  In python I would do this using classes and OOP and have a class "},{"type":"text","text":"NormallyDistributedNoiseTransform","style":{"code":true}},{"type":"text","text":" that has member variables "},{"type":"text","text":"field","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"mu","style":{"code":true}},{"type":"text","text":", and "},{"type":"text","text":"sigma","style":{"code":true}},{"type":"text","text":" that determines how each instance acts.  Then I would have a list of Transform objects that are chained together.  I'm not sure how to approach this in Julia (performance is also key here since I will be running it like 1e6 times in a monte-carlo thing)  Any hints?"}]}]}],"thread_ts":"1617650456.261800","reply_count":20,"reply_users_count":3,"latest_reply":"1617684277.317200","reply_users":["U017D4RFTFC","U012MJL8EPN","UMDEUKM29"],"is_locked":false,"subscribed":false},{"client_msg_id":"7ac6fa84-4b46-4320-a437-f05cb5f16b8d","type":"message","text":"A functor could achieve that","user":"U017D4RFTFC","ts":"1617663661.265500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1tq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A functor could achieve that"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"8a58386b-5e9d-4eb2-8fe8-edf29d446706","type":"message","text":"In the docs these are function like objects","user":"U017D4RFTFC","ts":"1617664050.265800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9jLb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In the docs these are function like objects"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"0860aec3-a13d-4255-9fb2-dd7fc3ea5f34","type":"message","text":"Thanks!  That does look like something i could use","user":"U012MJL8EPN","ts":"1617664415.266000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aMqSu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks!  That does look like something i could use"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"547153ca-fffe-474c-a064-c7d22fc4a618","type":"message","text":"I was also thinking of having a function that spits out the variants of the transforms","user":"U012MJL8EPN","ts":"1617664915.266200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5uqP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was also thinking of having a function that spits out the variants of the transforms"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"a7c99da0-b44a-4947-8c9f-7851d20d2803","type":"message","text":"Since once the transform is made i don't need to edit it","user":"U012MJL8EPN","ts":"1617664936.266400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ujt6+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Since once the transform is made i don't need to edit it"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"7491b01e-040c-4f49-8d72-bd95ef2caaef","type":"message","text":"What do you mean by variant? With your normally distributed example above.","user":"U017D4RFTFC","ts":"1617665004.266600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xZrH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do you mean by variant? With your normally distributed example above."}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"21635148-c223-4499-846c-24890cd21be3","type":"message","text":"For instance, i have ten fields in the input struct that I can add noise to.  Instead of writing ten different functions, i want a way of saying \"the transform that applies noise to the field &lt;x&gt;\"","user":"U012MJL8EPN","ts":"1617665245.266800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T6ZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For instance, i have ten fields in the input struct that I can add noise to.  Instead of writing ten different functions, i want a way of saying \"the transform that applies noise to the field <x>\""}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"d331cd9a-58e7-4b46-b4fa-ea8b483b7946","type":"message","text":"Then also having a user selectable size of the noise","user":"U012MJL8EPN","ts":"1617665287.267000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"15f9f","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Then also having a user selectable size of the noise"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"dea592c3-c7cf-4b1f-b0ba-701ff8593020","type":"message","text":"So ypu could have a function that takes a configuration for one of these transforms and spits out the hardcoded transform that takes an input struct and returns the transformed copy","user":"U012MJL8EPN","ts":"1617665355.267200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vdfzv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So ypu could have a function that takes a configuration for one of these transforms and spits out the hardcoded transform that takes an input struct and returns the transformed copy"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"2b8df0e9-4863-4022-b454-2b29c28bd94d","type":"message","text":"You could pass the functor a field and `getfield` it, not sure how fast that is. Could use a vector instead of a struct as input","user":"U017D4RFTFC","ts":"1617665357.267400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gNO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could pass the functor a field and "},{"type":"text","text":"getfield","style":{"code":true}},{"type":"text","text":" it, not sure how fast that is. Could use a vector instead of a struct as input"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"f1df5e64-a573-416a-858f-ee7c44d8d89f","type":"message","text":"Yep, i know about getfield","user":"U012MJL8EPN","ts":"1617665390.267600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i1=Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yep, i know about getfield"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"619c8f63-a7b7-4ab7-8437-a76a04b49fca","type":"message","text":"You could use a macro to build your functors","user":"U017D4RFTFC","ts":"1617665401.267800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+bL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could use a macro to build your functors"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"818413b3-db53-472a-8562-3b1329b7211b","type":"message","text":"Would be cool if there's a way of spitting out different compiled functions that just do it tho","user":"U012MJL8EPN","ts":"1617665415.268000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0Wz+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Would be cool if there's a way of spitting out different compiled functions that just do it tho"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"4946b555-0b36-4a4a-b06d-5c9d24408a76","type":"message","text":"I don't think jt will limit things but it is going inside a sort of tight loop","user":"U012MJL8EPN","ts":"1617665441.268200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+I+k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think jt will limit things but it is going inside a sort of tight loop"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"86663d9d-3df2-4147-8c9a-5946c19d034c","type":"message","text":"So cutting down overhead would be nice","user":"U012MJL8EPN","ts":"1617665458.268400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0bwv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So cutting down overhead would be nice"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"7538736a-a425-44d5-88ad-7248fd8e6962","type":"message","text":"Yeah I would use a macro to generate your functors then. Shouldnt be too hard, although if you want to accept arbitrary input types you'd need to do darker macro magic","user":"U017D4RFTFC","ts":"1617665789.268600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YhJL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah I would use a macro to generate your functors then. Shouldnt be too hard, although if you want to accept arbitrary input types you'd need to do darker macro magic"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"94a9ddae-342d-4648-ac20-e93c6fcd0534","type":"message","text":"Ahaha don't need arbitrary input","user":"U012MJL8EPN","ts":"1617665887.268800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8I=V3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ahaha don't need arbitrary input"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"0f16ba90-65ae-407b-89bc-1f3b5baf04b4","type":"message","text":"The real issue would be an explosion in the number of functor types. Could use parametric types to number which field is being transformed maybe","user":"U017D4RFTFC","ts":"1617665894.269000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TbD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The real issue would be an explosion in the number of functor types. Could use parametric types to number which field is being transformed maybe"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"ca6e38dc-c979-4e88-b288-9782c27dd72a","type":"message","text":"Just a well defined datatype that i transform","user":"U012MJL8EPN","ts":"1617665901.269200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jkgu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just a well defined datatype that i transform"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"},{"client_msg_id":"c4f9787c-27e5-4d76-8c23-a472efca6234","type":"message","text":"Have you looked at closures instead of types?","user":"UMDEUKM29","ts":"1617684277.317200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SGJY0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Have you looked at closures instead of types?"}]}]}],"thread_ts":"1617650456.261800","parent_user_id":"U012MJL8EPN"}]