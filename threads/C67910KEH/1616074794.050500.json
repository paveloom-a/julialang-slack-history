[{"client_msg_id":"3d74e1a2-6ae1-4fab-a32e-7c53b3a12609","type":"message","text":"do any channels get into how Julia alleviates the _Two Language Problem_?","user":"U01GZ9QPYPR","ts":"1616074794.050500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WCY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"do any channels get into how Julia alleviates the "},{"type":"text","text":"Two Language Problem","style":{"italic":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1616074794.050500","reply_count":11,"reply_users_count":5,"latest_reply":"1616082497.057100","reply_users":["UGU761DU2","UPTBGS6CC","U9VG1AYSG","U6A936746","U6QGE7S86"],"subscribed":false},{"client_msg_id":"07c78111-434f-4e57-9b59-e17a8c2ed010","type":"message","text":"I suppose it depends _which_ two-language problem. Julia certainly solved my personal two language problem, which was that I was previously using Matlab for everyday plotting / analysis / etc., and C for HPC, but now just use Julia for everything. <#CBFP2PTTR|hpc> isn’t the most active channel around here, but does have a bunch of active Julia HPC users subscribed, if that’s the two-language problem you have in mind.","user":"UGU761DU2","ts":"1616075491.051100","team":"T68168MUP","edited":{"user":"UGU761DU2","ts":"1616075889.000000"},"blocks":[{"type":"rich_text","block_id":"kbD7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I suppose it depends "},{"type":"text","text":"which","style":{"italic":true}},{"type":"text","text":" two-language problem. Julia certainly solved my personal two language problem, which was that I was previously using Matlab for everyday plotting / analysis / etc., and C for HPC, but now just use Julia for everything. "},{"type":"channel","channel_id":"CBFP2PTTR"},{"type":"text","text":" isn’t the most active channel around here, but does have a bunch of active Julia HPC users subscribed, if that’s the two-language problem you have in mind."}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"thumbsup_all","users":["U01GZ9QPYPR"],"count":1}]},{"client_msg_id":"f254d75f-6825-44d4-92e6-429f77012d2c","type":"message","text":"Personally also, while I came for the ability to have C-like speed in a high-level interactive language, I think the most compelling advantage of Julia long-term may be actually the composability that comes from dispatch-oriented programming (which is, of course, not unrelated to how Julia manages to achieve its balance of speed and interactivity)","user":"UGU761DU2","ts":"1616075599.051300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vOx9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Personally also, while I came for the ability to have C-like speed in a high-level interactive language, I think the most compelling advantage of Julia long-term may be actually the composability that comes from dispatch-oriented programming (which is, of course, not unrelated to how Julia manages to achieve its balance of speed and interactivity)"}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR"},{"client_msg_id":"17a6e715-70af-44d6-a2eb-9d157a933e8d","type":"message","text":"There is also the two-language problem for GPUs that the <#C689Y34LE|gpu> channel is focused on - letting people code up in Julia for both GPUs and CPUs without having to know CUDA/OpenCL.","user":"UPTBGS6CC","ts":"1616075752.051800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q08","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is also the two-language problem for GPUs that the "},{"type":"channel","channel_id":"C689Y34LE"},{"type":"text","text":" channel is focused on - letting people code up in Julia for both GPUs and CPUs without having to know CUDA/OpenCL."}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"gpu","users":["UGU761DU2","U7THT3TM3"],"count":2},{"name":"100","users":["UGU761DU2","U7THT3TM3","U67G3QRJM"],"count":3}]},{"client_msg_id":"91195c50-b165-4089-aba3-d5399bad5387","type":"message","text":"to put it bluntly, when people say that it's very much aimed at Python: Python is too slow to be used on its own, so basically everything is written in some combination of C, C++ and Fortran.  This introduces all sorts of problems coming from the fact that none of the packages are really that interoperable with eachother (at least without enormous effort) because from the Python level they all consist of a bunch of opaque C structs.  There is simply no such problem in e.g. Go, Crystal, nim, Rust, so it really isn't fair to say that \"Julia addresses the two language problem\" any better than those languages.  Also, while Julia can replace C or C++ or can be considered as an alternative to Rust in many cases, there is a large class of programs for which Julia does not attempt to compete with those languages because Julia is garbage collected while those are not.  In the cases where Julia can be an alternative to Rust or C++, many people would find it preferable because there's a lot of mental overhead for any language without garbage collection, even with a system as clever as Rust's.","user":"U9VG1AYSG","ts":"1616076160.052400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7Ok","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"to put it bluntly, when people say that it's very much aimed at Python: Python is too slow to be used on its own, so basically everything is written in some combination of C, C++ and Fortran.  This introduces all sorts of problems coming from the fact that none of the packages are really that interoperable with eachother (at least without enormous effort) because from the Python level they all consist of a bunch of opaque C structs.  There is simply no such problem in e.g. Go, Crystal, nim, Rust, so it really isn't fair to say that \"Julia addresses the two language problem\" any better than those languages.  Also, while Julia can replace C or C++ or can be considered as an alternative to Rust in many cases, there is a large class of programs for which Julia does not attempt to compete with those languages because Julia is garbage collected while those are not.  In the cases where Julia can be an alternative to Rust or C++, many people would find it preferable because there's a lot of mental overhead for any language without garbage collection, even with a system as clever as Rust's."}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"+1","users":["U6A936746","UM6JW2SF9","U7THT3TM3"],"count":3},{"name":"unpython","users":["UGU761DU2","U7THT3TM3"],"count":2}]},{"client_msg_id":"93b64a08-6638-473d-b5a1-2e1f78853c4b","type":"message","text":"(Python, R and Matlab, to be fair.)","user":"U6A936746","ts":"1616076292.052700","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1616076297.000000"},"blocks":[{"type":"rich_text","block_id":"S7nJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(Python, R and Matlab, to be fair.)"}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"point_up","users":["U9VG1AYSG","UDXST8ARK","U7THT3TM3","UPTBGS6CC","UH8A351DJ"],"count":5},{"name":"+1","users":["UGU761DU2","U7THT3TM3"],"count":2},{"name":"+1::skin-tone-5","users":["U6QGE7S86"],"count":1},{"name":"point_up::skin-tone-5","users":["U6QGE7S86"],"count":1}]},{"client_msg_id":"4f01f232-158b-4f17-90dc-dc5dec9db2a4","type":"message","text":"(right, I just didn't mention R and matlab because I personally have managed to stay way clear of them :laughing: )","user":"U9VG1AYSG","ts":"1616076318.053200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"whED","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(right, I just didn't mention R and matlab because I personally have managed to stay way clear of them "},{"type":"emoji","name":"laughing"},{"type":"text","text":" )"}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"unmatlab","users":["UGU761DU2","U7THT3TM3","U017D621ELC","U0138UTB7A4"],"count":4}]},{"client_msg_id":"40e8ded4-1f36-4a99-8946-0bfb43c6393b","type":"message","text":"In terms of “why can Julia solve these problems” I think both in the [:python:|:matlab:|:r:] + [:c:|:cpp:|:deep_fortran:] set of “two-language” problems and the CPU + GPU “two-language” problem, the key is very much the combination of JAOT compilation with multiple dispatch. While multiple dispatch is not new (c.f. Dylan), it has typically come with substantial runtime performance cost, which discouraged use and prevented the previous emergence of a truly dispatch-oriented programming paradigm.\n\nWhich in Julia is what lets someone make, for example, a new array type in Julia that offloads computations to the GPU and have it already work with the whole rest of the ecosystem (to exaggerate only very slightly).\n\nIf you haven’t watched it yet, Stefan’s 2019 JuliaCon talk might be a good place to start: <https://www.youtube.com/watch?v=kc9HwsxE1OY|https://www.youtube.com/watch?v=kc9HwsxE1OY>","user":"UGU761DU2","ts":"1616077709.053700","team":"T68168MUP","edited":{"user":"UGU761DU2","ts":"1616081093.000000"},"attachments":[{"service_name":"YouTube","service_url":"https://www.youtube.com/","title":"JuliaCon 2019 | The Unreasonable Effectiveness of Multiple Dispatch | Stefan Karpinski","title_link":"https://www.youtube.com/watch?v=kc9HwsxE1OY","author_name":"The Julia Programming Language","author_link":"https://www.youtube.com/user/JuliaLanguage","thumb_url":"https://i.ytimg.com/vi/kc9HwsxE1OY/hqdefault.jpg","thumb_width":480,"thumb_height":360,"fallback":"YouTube Video: JuliaCon 2019 | The Unreasonable Effectiveness of Multiple Dispatch | Stefan Karpinski","video_html":"<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/kc9HwsxE1OY?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","video_html_width":400,"video_html_height":225,"from_url":"https://www.youtube.com/watch?v=kc9HwsxE1OY","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png","id":1,"original_url":"https://www.youtube.com/watch?v=kc9HwsxE1OY"}],"blocks":[{"type":"rich_text","block_id":"kig8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In terms of “why can Julia solve these problems” I think both in the ["},{"type":"emoji","name":"python"},{"type":"text","text":"|"},{"type":"emoji","name":"matlab"},{"type":"text","text":"|"},{"type":"emoji","name":"r"},{"type":"text","text":"] + ["},{"type":"emoji","name":"c"},{"type":"text","text":"|"},{"type":"emoji","name":"cpp"},{"type":"text","text":"|"},{"type":"emoji","name":"deep_fortran"},{"type":"text","text":"] set of “two-language” problems and the CPU + GPU “two-language” problem, the key is very much the combination of JAOT compilation with multiple dispatch. While multiple dispatch is not new (c.f. Dylan), it has typically come with substantial runtime performance cost, which discouraged use and prevented the previous emergence of a truly dispatch-oriented programming paradigm.\n\nWhich in Julia is what lets someone make, for example, a new array type in Julia that offloads computations to the GPU and have it already work with the whole rest of the ecosystem (to exaggerate only very slightly).\n\nIf you haven’t watched it yet, Stefan’s 2019 JuliaCon talk might be a good place to start: "},{"type":"link","url":"https://www.youtube.com/watch?v=kc9HwsxE1OY","text":"https://www.youtube.com/watch?v=kc9HwsxE1OY"}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"+1","users":["U7THT3TM3"],"count":1}]},{"client_msg_id":"0b45998b-1065-412b-9480-f3bd19de3d37","type":"message","text":"And that same integration of dispatch and compilation, FWIW,  is what lets you type\n```julia&gt; @code_native 1+1\n\t.section\t__TEXT,__text,regular,pure_instructions\n; ┌ @ int.jl:86 within `+'\n\tleaq\t(%rdi,%rsi), %rax\n\tretq\n; └\n; ┌ @ int.jl:86 within `&lt;invalid&gt;'\n\tnopw\t%cs:(%rax,%rax)\n\tnop\n; └\n\njulia&gt; @code_native 1+1.0\n\t.section\t__TEXT,__text,regular,pure_instructions\n; ┌ @ promotion.jl:311 within `+'\n; │┌ @ promotion.jl:282 within `promote'\n; ││┌ @ promotion.jl:259 within `_promote'\n; │││┌ @ number.jl:7 within `convert'\n; ││││┌ @ float.jl:60 within `Float64'\n\tvcvtsi2sd\t%rdi, %xmm1, %xmm1\n; │└└└└\n; │ @ promotion.jl:311 within `+' @ float.jl:401\n\tvaddsd\t%xmm0, %xmm1, %xmm0\n; │ @ promotion.jl:311 within `+'\n\tretq\n\tnopw\t(%rax,%rax)\n; └```\nAnd get the correct, efficient,  machine code in both cases.\n\nI would also go so far as to say that in most cases where someone doesn’t “get” Julia and comes away frustrated, it is more often than not that the have not really understood the fact that multiple dispatch more or less implies a whole new programming paradigm, and thus also never really grasped concepts like _type-instability_ and how to avoid it.","user":"UGU761DU2","ts":"1616078018.054100","team":"T68168MUP","edited":{"user":"UGU761DU2","ts":"1616081108.000000"},"blocks":[{"type":"rich_text","block_id":"TiX5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And that same integration of dispatch and compilation, FWIW,  is what lets you type\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @code_native 1+1\n\t.section\t__TEXT,__text,regular,pure_instructions\n; ┌ @ int.jl:86 within `+'\n\tleaq\t(%rdi,%rsi), %rax\n\tretq\n; └\n; ┌ @ int.jl:86 within `<invalid>'\n\tnopw\t%cs:(%rax,%rax)\n\tnop\n; └\n\njulia> @code_native 1+1.0\n\t.section\t__TEXT,__text,regular,pure_instructions\n; ┌ @ promotion.jl:311 within `+'\n; │┌ @ promotion.jl:282 within `promote'\n; ││┌ @ promotion.jl:259 within `_promote'\n; │││┌ @ number.jl:7 within `convert'\n; ││││┌ @ float.jl:60 within `Float64'\n\tvcvtsi2sd\t%rdi, %xmm1, %xmm1\n; │└└└└\n; │ @ promotion.jl:311 within `+' @ float.jl:401\n\tvaddsd\t%xmm0, %xmm1, %xmm0\n; │ @ promotion.jl:311 within `+'\n\tretq\n\tnopw\t(%rax,%rax)\n; └"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"And get the correct, efficient,  machine code in both cases.\n\nI would also go so far as to say that in most cases where someone doesn’t “get” Julia and comes away frustrated, it is more often than not that the have not really understood the fact that multiple dispatch more or less implies a whole new programming paradigm, and thus also never really grasped concepts like "},{"type":"text","text":"type-instability","style":{"italic":true}},{"type":"text","text":" and how to avoid it."}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR"},{"client_msg_id":"4da65685-9e63-4e65-afcf-74f4984fd72d","type":"message","text":"I just want to qualify what <@U9VG1AYSG> said - I think the general idea is correct, but it's aimed at the technical computing environment.\nThere's other areas that have faced a Two Language Problem for entirely similar reasons, like formal verification.\nUsually, their :python: is a formal proving language (Like Coq/Isabelle) where they do math proofs of code cryptographic code, and then they have an enormous blob of C /Haskell + other fun stuff to compile down to efficient instructions.\n\nTo that end, F* tries to do both in the same language, and it seems to be doing quite well.\n<http://www.fstar-lang.org/>","user":"U6QGE7S86","ts":"1616081570.056500","team":"T68168MUP","edited":{"user":"U6QGE7S86","ts":"1616081608.000000"},"blocks":[{"type":"rich_text","block_id":"oGS4D","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just want to qualify what "},{"type":"user","user_id":"U9VG1AYSG"},{"type":"text","text":" said - I think the general idea is correct, but it's aimed at the technical computing environment.\nThere's other areas that have faced a Two Language Problem for entirely similar reasons, like formal verification.\nUsually, their "},{"type":"emoji","name":"python"},{"type":"text","text":" is a formal proving language (Like Coq/Isabelle) where they do math proofs of code cryptographic code, and then they have an enormous blob of C /Haskell + other fun stuff to compile down to efficient instructions.\n\nTo that end, F* tries to do both in the same language, and it seems to be doing quite well.\n"},{"type":"link","url":"http://www.fstar-lang.org/"}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"+1","users":["U6A936746","UGU761DU2"],"count":2}]},{"client_msg_id":"a19e523e-cb42-4287-bd89-f268d7ab18a2","type":"message","text":"I think of it as a long-lost cousin of Julia in spirit :smile:","user":"U6QGE7S86","ts":"1616081667.056800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AB99","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think of it as a long-lost cousin of Julia in spirit "},{"type":"emoji","name":"smile"}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"juliaspinner","users":["UGU761DU2"],"count":1},{"name":"+1","users":["UGU761DU2"],"count":1}]},{"client_msg_id":"54aa3a63-540b-4a86-87c2-37083d374315","type":"message","text":"It really is field dependent. While I mentioned GPUs earlier, my main two language problem is actually MATLAB + C or MATLAB + HDL. While Julia can nicely solve the MATLAB + C in some cases, it is still not quite there for embedded system implementations with real time guarantees (Rust is probably more suited to that at this point). It also really isn't anywhere close for the HDL case (but that is something I want to change in a few years if I get time + funding for it).","user":"UPTBGS6CC","ts":"1616082497.057100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0q/h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It really is field dependent. While I mentioned GPUs earlier, my main two language problem is actually MATLAB + C or MATLAB + HDL. While Julia can nicely solve the MATLAB + C in some cases, it is still not quite there for embedded system implementations with real time guarantees (Rust is probably more suited to that at this point). It also really isn't anywhere close for the HDL case (but that is something I want to change in a few years if I get time + funding for it)."}]}]}],"thread_ts":"1616074794.050500","parent_user_id":"U01GZ9QPYPR","reactions":[{"name":"100","users":["UGU761DU2"],"count":1}]}]