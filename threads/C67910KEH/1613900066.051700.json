[{"client_msg_id":"892922db-b355-4481-ace1-6ba21f112620","type":"message","text":"I don’t understand why Julia doesn’t support binding methods to structs at all. For example, all kinds of functions are just floating around in the module namespace of [Agents.jl](*<https://juliadynamics.github.io/Agents.jl/stable/api/#Agent/model-retrieval>)* with no anchor point. But some methods clearly belong to a certain struct: for example, `add_agent!` belongs to a model and `walk!` belongs to an agent. Agent-based modeling’s name already lends support to object-oriented programming, it’s really unfortunate that Julia insists on polluting the module’s namespace with myriad functions operating on different structs (many of them operate exclusively on a struct and there is no need for multiple dispatch).","user":"U01M24BJPTP","ts":"1613900066.051700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3ai","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t understand why Julia doesn’t support binding methods to structs at all. For example, all kinds of functions are just floating around in the module namespace of [Agents.jl]("},{"type":"link","url":"https://juliadynamics.github.io/Agents.jl/stable/api/#Agent/model-retrieval","style":{"bold":true}},{"type":"text","text":")","style":{"bold":true}},{"type":"text","text":" with no anchor point. But some methods clearly belong to a certain struct: for example, `add_agent!` belongs to a model and `walk!` belongs to an agent. Agent-based modeling’s name already lends support to object-oriented programming, it’s really unfortunate that Julia insists on polluting the module’s namespace with myriad functions operating on different structs (many of them operate exclusively on a struct and there is no need for multiple dispatch)."}]}]}],"thread_ts":"1613900066.051700","reply_count":41,"reply_users_count":7,"latest_reply":"1613915757.065800","reply_users":["U7HAYKY9X","U01M24BJPTP","U69BL50BF","UMDEUKM29","UDB26738Q","UH24GRBLL","U017LQ3A59U"],"subscribed":false},{"client_msg_id":"70f3b748-ca3f-41f6-abda-bfeb0a99d54e","type":"message","text":"The problem is that if you optionally support it, then you end up in a half-assed situation where you're not sure which methods are bound to objects and which are not.","user":"U7HAYKY9X","ts":"1613900141.051800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+uu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The problem is that if you optionally support it, then you end up in a half-assed situation where you're not sure which methods are bound to objects and which are not."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"45d47fbe-709d-4d00-975d-c8bcabdfbb06","type":"message","text":"Also, I would argue there are basically no benefits of binding methods to objects. The namespace being cluttered usually doesn't matter because there is dispatch, and you can shadow any functions inside a scope without any issues.","user":"U7HAYKY9X","ts":"1613900197.052000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dJEW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, I would argue there are basically no benefits of binding methods to objects. The namespace being cluttered usually doesn't matter because there is dispatch, and you can shadow any functions inside a scope without any issues."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP","reactions":[{"name":"+1","users":["U8D9768Q6","U7THT3TM3"],"count":2}]},{"client_msg_id":"bd3349cd-1891-411c-b88f-1e96a4b90b0f","type":"message","text":"With regards to discoverability, using `methodswith`  and `@less` is superior to tab-completing in OOP anyway","user":"U7HAYKY9X","ts":"1613900245.052200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xy=6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"With regards to discoverability, using "},{"type":"text","text":"methodswith","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"@less","style":{"code":true}},{"type":"text","text":" is superior to tab-completing in OOP anyway"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP","reactions":[{"name":"+1","users":["U01M24BJPTP","UB7JS9CHF"],"count":2},{"name":"thinking_face","users":["UCB7L9W49"],"count":1}]},{"client_msg_id":"8829bd3a-1f4d-4654-9b1e-c7eae80cc011","type":"message","text":"So you must rely on Julia REPL to read and reason about code? Sounds not fun.","user":"U01M24BJPTP","ts":"1613900718.052400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lit4o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So you must rely on Julia REPL to read and reason about code? Sounds not fun."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"10af895c-fbf0-4dac-b55e-92e6e8ef7f1d","type":"message","text":"Nope, you don't. You can also use an IDE to figure out what functions do - like any other programming language","user":"U7HAYKY9X","ts":"1613900790.052600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W49=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Nope, you don't. You can also use an IDE to figure out what functions do - like any other programming language"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"e931b2e5-1c43-4693-9846-791e4e72f0e1","type":"message","text":"Also, how does `add_agent!` belong to the agent? Why not to the model?","user":"U7HAYKY9X","ts":"1613900886.052800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bu2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, how does "},{"type":"text","text":"add_agent!","style":{"code":true}},{"type":"text","text":" belong to the agent? Why not to the model?"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"cc625a3a-3b52-4e7e-92ee-760c73be6839","type":"message","text":"&gt; *half-assed situation where you’re not sure which methods are bound to objects and which are not.*\nIn python, some functions live in the module namespace, some are methods bound to objects. There seems to be no such confusion.","user":"U01M24BJPTP","ts":"1613901854.053400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TWdfC","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"half-assed situation where you’re not sure which methods are bound to objects and which are not.","style":{"bold":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"In python, some functions live in the module namespace, some are methods bound to objects. There seems to be no such confusion."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"f4d512fd-a4d7-4abc-b886-3cfec20e7642","type":"message","text":"I used Python for many years, and I was certainly confused about that. For example, `np.median` is a function, but `arr.mean` is a method of arrays. Why?","user":"U7HAYKY9X","ts":"1613901953.053600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BA8Hv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I used Python for many years, and I was certainly confused about that. For example, "},{"type":"text","text":"np.median","style":{"code":true}},{"type":"text","text":" is a function, but "},{"type":"text","text":"arr.mean","style":{"code":true}},{"type":"text","text":" is a method of arrays. Why?"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP","reactions":[{"name":"heavy_check_mark","users":["UDXST8ARK","UM30MT6RF","U6A936746","UN97XTLCV","U8D9768Q6","U9J14HBSR","UH8A351DJ","UB7JS9CHF","U7THT3TM3","U01EF0QVAB0"],"count":10}]},{"client_msg_id":"b9a3ea83-be82-4c52-8bee-9b04bb561db7","type":"message","text":"it seems numpy arrays have a small number of stats methods attached to them but there are more np.functions. np.mean is written in python (which calls functions written in C) while arr.mean is a built_in_function_or_method (written in C probably). I don’t know why they do that but you can call np.function all the way.","user":"U01M24BJPTP","ts":"1613902904.053800","team":"T68168MUP","edited":{"user":"U01M24BJPTP","ts":"1613903084.000000"},"blocks":[{"type":"rich_text","block_id":"f9P34","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it seems numpy arrays have a small number of stats methods attached to them but there are more np.functions. np.mean is written in python (which calls functions written in C) while arr.mean is a built_in_function_or_method (written in C probably). I don’t know why they do that but you can call np.function all the way."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"8ee87a8e-7fb5-4403-80c7-395cfd532bb6","type":"message","text":"The point is that it's random and arbitrary what's a method and what's a function so there is indeed lots of confusion. It's even worse for methods that could belong to each of it's arguments. E.g. \"\".join(my_list) instead of my_list.join(\"\"). I've made that error lots of times","user":"U7HAYKY9X","ts":"1613903067.054200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fPai8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The point is that it's random and arbitrary what's a method and what's a function so there is indeed lots of confusion. It's even worse for methods that could belong to each of it's arguments. E.g. \"\".join(my_list) instead of my_list.join(\"\"). I've made that error lots of times"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP","reactions":[{"name":"heavy_check_mark","users":["UDXST8ARK","UM30MT6RF","U6A936746","UB7JS9CHF","U0179G7FG4F","U7THT3TM3"],"count":6}]},{"client_msg_id":"30232ed1-1d78-47d4-97a6-c2e550c58513","type":"message","text":"1. join(“”, my_list) v join(my_list, “”) is no less arbitrary.\n2. Where there is ambiguity, we can support both ways. ","user":"U01M24BJPTP","ts":"1613903222.054500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Im1KN","elements":[{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"join(“”, my_list) v join(my_list, “”) is no less arbitrary."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Where there is ambiguity, we can support both ways. "}]}],"style":"ordered","indent":0}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"type":"message","subtype":"thread_broadcast","text":"&gt; In python, some functions live in the module namespace, some are methods bound to objects. There seems to be no such confusion.\nUnlike Python, Julia tends to have a design philosophy, you can call the Zen of Julia, that there should be one, and preferably only one, way to do things. It simplifies the design and ensures uniformity and predictability.","user":"U69BL50BF","ts":"1613903366.054700","thread_ts":"1613900066.051700","root":{"client_msg_id":"892922db-b355-4481-ace1-6ba21f112620","type":"message","text":"I don’t understand why Julia doesn’t support binding methods to structs at all. For example, all kinds of functions are just floating around in the module namespace of [Agents.jl](*<https://juliadynamics.github.io/Agents.jl/stable/api/#Agent/model-retrieval>)* with no anchor point. But some methods clearly belong to a certain struct: for example, `add_agent!` belongs to a model and `walk!` belongs to an agent. Agent-based modeling’s name already lends support to object-oriented programming, it’s really unfortunate that Julia insists on polluting the module’s namespace with myriad functions operating on different structs (many of them operate exclusively on a struct and there is no need for multiple dispatch).","user":"U01M24BJPTP","ts":"1613900066.051700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3ai","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t understand why Julia doesn’t support binding methods to structs at all. For example, all kinds of functions are just floating around in the module namespace of [Agents.jl]("},{"type":"link","url":"https://juliadynamics.github.io/Agents.jl/stable/api/#Agent/model-retrieval","style":{"bold":true}},{"type":"text","text":")","style":{"bold":true}},{"type":"text","text":" with no anchor point. But some methods clearly belong to a certain struct: for example, `add_agent!` belongs to a model and `walk!` belongs to an agent. Agent-based modeling’s name already lends support to object-oriented programming, it’s really unfortunate that Julia insists on polluting the module’s namespace with myriad functions operating on different structs (many of them operate exclusively on a struct and there is no need for multiple dispatch)."}]}]}],"thread_ts":"1613900066.051700","reply_count":41,"reply_users_count":7,"latest_reply":"1613915757.065800","reply_users":["U7HAYKY9X","U01M24BJPTP","U69BL50BF","UMDEUKM29","UDB26738Q","UH24GRBLL","U017LQ3A59U"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"MM+","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"In python, some functions live in the module namespace, some are methods bound to objects. There seems to be no such confusion."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Unlike Python, Julia tends to have a design philosophy, you can call the Zen of Julia, that there should be one, and preferably only one, way to do things. It simplifies the design and ensures uniformity and predictability."}]}]}],"client_msg_id":"71ce5519-87b4-443e-80b3-0657a21f7a69","reactions":[{"name":"joy","users":["UDXST8ARK","U7QLM6E2E","UM30MT6RF","U6A936746","U6CCK2SCV","UEKT6136U","U66M57AN4","U69BK8S74","UN45LV5K6","UDDUC4R1Q","U66QZ3QF3","U9MED583T"],"count":12}]},{"client_msg_id":"de2b0797-6ffe-4db7-93b1-b53d3b766c8d","type":"message","text":"The join thing is not arbitrary, the Julia way is clearly the right way. People say \"join this array (with this separator)\", not \"join with this string this array\". It's an implementation detail that it's inversed in Python. In Python it NEEDS to be the \"wrong\" way because you can't implement the method for every iterable object that could be joined. You can do exactly that in Julia, easily","user":"U7HAYKY9X","ts":"1613903512.055400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zyo71","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The join thing is not arbitrary, the Julia way is clearly the right way. People say \"join this array (with this separator)\", not \"join with this string this array\". It's an implementation detail that it's inversed in Python. In Python it NEEDS to be the \"wrong\" way because you can't implement the method for every iterable object that could be joined. You can do exactly that in Julia, easily"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"4e7b3527-531a-42e9-93ba-23c608cf8049","type":"message","text":"But that's beside the point. The point is that many functions don't belong to either object. Like, Python claims \"1 + 2\" belongs to the 1 as opposed to the 2, which is weird.","user":"U7HAYKY9X","ts":"1613903672.055600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EDj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But that's beside the point. The point is that many functions don't belong to either object. Like, Python claims \"1 + 2\" belongs to the 1 as opposed to the 2, which is weird."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"98646271-f36e-4edc-bb1a-c9e4cb6eb5c5","type":"message","text":"&gt; With regards to discoverability, using methodswith  and @less is superior to tab-completing in OOP anyway\n\nSorry but that's just Stockholm syndrome. I agree having some functions belong to objects and others to modules is a mess, but in \"commited\" OOP languages like java the predictability and discoverability of completion after dot is awesome, and nothing in Julia comes close","user":"UMDEUKM29","ts":"1613904249.055900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Khd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> With regards to discoverability, using methodswith  and @less is superior to tab-completing in OOP anyway\n\nSorry but that's just Stockholm syndrome. I agree having some functions belong to objects and others to modules is a mess, but in \"commited\" OOP languages like java the predictability and discoverability of completion after dot is awesome, and nothing in Julia comes close"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP","reactions":[{"name":"point_up","users":["U6A936746","U85R3JJ8L","UBGJ599D3","UMY1LV01G","U6P4UPP9D","UDDUC4R1Q","U8T0YV7QC","UCNPT22MQ"],"count":8},{"name":"+1","users":["UDXST8ARK","UDDUC4R1Q"],"count":2}]},{"client_msg_id":"4f2d9e80-a947-4202-bdfc-98270a46a2b2","type":"message","text":"1. The fact that Python cannot add a join method to every iterable is probably because it doesn’t have traits/interfaces. But they could have defined a join function in the str module as join(iterable, separator), and you would call `str.join([1, 2], '+')`.\n2. Julia seems to insist persistently about mathematical operations. If Julia is not intended to program merely for calculators, it should consider other application areas. where the need for multiple dispatch is slim. ~In fact, vast number of sentences in natural languages have a subject-verb-object format, so OOP is very natural.~","user":"U01M24BJPTP","ts":"1613904354.056100","team":"T68168MUP","edited":{"user":"U01M24BJPTP","ts":"1613915546.000000"},"blocks":[{"type":"rich_text","block_id":"+lf","elements":[{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The fact that Python cannot add a join method to every iterable is probably because it doesn’t have traits/interfaces. But they could have defined a join function in the str module as join(iterable, separator), and you would call "},{"type":"text","text":"str.join([1, 2], '+')","style":{"code":true}},{"type":"text","text":"."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Julia seems to insist persistently about mathematical operations. If Julia is not intended to program merely for calculators, it should consider other application areas. where the need for multiple dispatch is slim. "},{"type":"text","text":"In fact, vast number of sentences in natural languages have a subject-verb-object format, so OOP is very natural.","style":{"strike":true}}]}],"style":"ordered","indent":0}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"1c69b539-f03a-4e50-9fb7-9fd37dec4cc1","type":"message","text":"This discussion is not going to be very productive, but OOP and MD both have advantages and drawbacks. Julia is MD, if you don't like it don't use julia","user":"UMDEUKM29","ts":"1613904580.056500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oazb6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This discussion is not going to be very productive, but OOP and MD both have advantages and drawbacks. Julia is MD, if you don't like it don't use julia"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP","reactions":[{"name":"point_up","users":["U6A936746","UDXST8ARK","UJ7DVTVQ8"],"count":3}]},{"client_msg_id":"fa64c0f8-86f4-4478-b5a0-780d9f1600c1","type":"message","text":"There's nothing more natural in OOP than in other paradigms, it's merely a function of your background and the way you're used to thinking. OOP is pretty normative and it's easy to think of it as *the* paradigm, but it's not","user":"UMDEUKM29","ts":"1613904686.056700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S1LbN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There's nothing more natural in OOP than in other paradigms, it's merely a function of your background and the way you're used to thinking. OOP is pretty normative and it's easy to think of it as "},{"type":"text","text":"the","style":{"bold":true}},{"type":"text","text":" paradigm, but it's not"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"8ffe80b7-be08-4c6b-8d15-bc2b787a6ad1","type":"message","text":"~I think most natural languages are subject-verb-object. Some are subject-object-verb. verb-subject-object seems very rare.~ [I don’t think this argument is convincing.]","user":"U01M24BJPTP","ts":"1613904870.056900","team":"T68168MUP","edited":{"user":"U01M24BJPTP","ts":"1613915563.000000"},"blocks":[{"type":"rich_text","block_id":"p6=q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think most natural languages are subject-verb-object. Some are subject-object-verb. verb-subject-object seems very rare.","style":{"strike":true}},{"type":"text","text":" [I don’t think this argument is convincing.]"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"3fb64b92-da3b-47d0-812a-67136b269978","type":"message","text":"<http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html>","user":"UMDEUKM29","ts":"1613904961.057100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sDtC3","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"b2400149-6151-4ebf-bbb3-258d6e79e5be","type":"message","text":"&gt; Sorry but that's just Stockholm syndrome\nCould be. Code paradigm Stockholm syndrome is real. Nonetheless, I don't think so here. Julia has discoverability issues, but it's because there is no neat keyboard shortcut to `methodswith` , and because `methodswith` doesn't play nice with unionall-types. But it does have clear advantages over Java/Python style, namely that it does not depend on argument order, nor whether its a method or a function","user":"U7HAYKY9X","ts":"1613905588.058900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5AD2","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Sorry but that's just Stockholm syndrome"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Could be. Code paradigm Stockholm syndrome is real. Nonetheless, I don't think so here. Julia has discoverability issues, but it's because there is no neat keyboard shortcut to "},{"type":"text","text":"methodswith","style":{"code":true}},{"type":"text","text":" , and because "},{"type":"text","text":"methodswith","style":{"code":true}},{"type":"text","text":" doesn't play nice with unionall-types. But it does have clear advantages over Java/Python style, namely that it does not depend on argument order, nor whether its a method or a function"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"fe4b1820-b508-4691-a9ef-fa6c2a213f71","type":"message","text":"&gt; But they could have defined a join function in the str module as join(iterable, separator), and you would call `str.join([1, 2], '+')`\nExactly, that would be a better solution. But it would be even better if they supported `join` for other types, e.g. BioSequences. So you would have to have \"duck\" typing on the arguments. And then perhaps, if they also made function with different type signatures not conflict in the namespace... :troll:\n&gt; Julia seems to insist persistently about mathematical operations\nIt's just because it's easy for demonstration purposes. Same reason both Julia and Python manual starts with how to use the language as a calculator","user":"U7HAYKY9X","ts":"1613905721.059300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/+l","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"But they could have defined a join function in the str module as join(iterable, separator), and you would call "},{"type":"text","text":"str.join([1, 2], '+')","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Exactly, that would be a better solution. But it would be even better if they supported "},{"type":"text","text":"join","style":{"code":true}},{"type":"text","text":" for other types, e.g. BioSequences. So you would have to have \"duck\" typing on the arguments. And then perhaps, if they also made function with different type signatures not conflict in the namespace... "},{"type":"emoji","name":"troll"},{"type":"text","text":"\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"Julia seems to insist persistently about mathematical operations"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It's just because it's easy for demonstration purposes. Same reason both Julia and Python manual starts with how to use the language as a calculator"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"86042150-3160-498a-afeb-620a1e53a849","type":"message","text":"&gt; I think most natural languages are subject-verb-object.\n&gt; \nWrong. Subject-object-verb is more common <https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object|https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object>","user":"UDB26738Q","ts":"1613908173.060300","team":"T68168MUP","attachments":[{"title":"Subject–verb–object","title_link":"https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object","from_url":"https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"In linguistic typology, subject–verb–object (SVO) is a sentence structure where the subject comes first, the verb second, and the object third. Languages may be classified according to the dominant sequence of these elements in unmarked sentences (i.e., sentences in which an unusual word order is not used for emphasis). The label is often used for ergative languages that do not have subjects, but have an agent–verb–object (AVO) order.  English is included in this group. An example is \"Sam ate oranges.\"\nSVO is the second-most common order by number of known languages, after SOV. Together, SVO and SOV account for more than 75% of the world's languages. It is also the most common order developed in Creole languages, suggesting that it may be somehow more initially \"obvious\" to human psychology.Languages regarded as SVO include: All Bantu languages, Albanian, Arabic dialects, Assyrian, Bosnian, Chinese, English, Estonian, Finnish (but see below), French, Greek, Hausa, Icelandic (with the V2 restriction), Igbo, Italian, Javanese, Khmer, Latvian, Macedonian, Malay (Malaysian, Indonesian), Modern Hebrew, Norwegian, Polish, Portuguese, Quiche, Reo Rapa, Romanian, Russian (but see below), Slovene, Spanish, Swahili, Swedish (with the V2 restriction), Thai and Lao, Ukrainian (but see below), Vietnamese and Yoruba.\nAncient Greek has free syntactic order, though Classical Greeks tended to favor SOV. Many famous phrases are SVO, however.","fallback":"wikipedia: Subject–verb–object","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object"}],"blocks":[{"type":"rich_text","block_id":"t6f","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"I think most natural languages are subject-verb-object.\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nWrong. Subject-object-verb is more common "},{"type":"link","url":"https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object","text":"https://en.wikipedia.org/wiki/Subject%E2%80%93verb%E2%80%93object"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"55519939-65ca-4be3-8ea5-6f5cad236a13","type":"message","text":"anyhoo I found a janky way to do this (with closures and customized constructors)\n```mutable struct Class\n    attr::Int\n    method::Function\n    Class(attr) = begin\n        self = new(attr)\n        self.method = (i::Int) -&gt; (self.attr += i; nothing)\n        self\n    end\nend\n\ninstance = Class(2)\ninstance.method(3)```","user":"U01M24BJPTP","ts":"1613910063.060600","team":"T68168MUP","edited":{"user":"U01M24BJPTP","ts":"1613910155.000000"},"blocks":[{"type":"rich_text","block_id":"8KyF2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"anyhoo I found a janky way to do this (with closures and customized constructors)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct Class\n    attr::Int\n    method::Function\n    Class(attr) = begin\n        self = new(attr)\n        self.method = (i::Int) -> (self.attr += i; nothing)\n        self\n    end\nend\n\ninstance = Class(2)\ninstance.method(3)"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"9744e8bc-5ad8-44b0-9025-de78f6747a3b","type":"message","text":"every access to `method` will incur dynamic lookups","user":"UH24GRBLL","ts":"1613911737.061600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yUy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"every access to "},{"type":"text","text":"method","style":{"code":true}},{"type":"text","text":" will incur dynamic lookups"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"292461de-4b42-4eda-9f2b-876fc4fc58d7","type":"message","text":"I wonder if you can generalise this by overloading getproperty","user":"U7HAYKY9X","ts":"1613911805.061800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FqN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wonder if you can generalise this by overloading getproperty"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"59b10752-b288-4670-8c8a-8edda417575f","type":"message","text":"you can, but again - dynamic lookup because of the Symbol that's used at runtime","user":"UH24GRBLL","ts":"1613911825.062100","team":"T68168MUP","edited":{"user":"UH24GRBLL","ts":"1613911849.000000"},"blocks":[{"type":"rich_text","block_id":"Cu/c3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you can, but again - dynamic lookup because of the Symbol that's used at runtime"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"d85ef243-09ac-4669-8ffe-3ea54ba1b3e1","type":"message","text":"That's similar to Jeff's OOP example","user":"UDB26738Q","ts":"1613911922.062500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"n7GzF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's similar to Jeff's OOP example"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"e08519a8-254d-497d-a649-5ad6cf4bc2cb","type":"message","text":"<https://stackoverflow.com/a/39150509/2442087|https://stackoverflow.com/a/39150509/2442087>","user":"UDB26738Q","ts":"1613912027.062700","team":"T68168MUP","attachments":[{"service_name":"Stack Overflow","title":"How to create a \"single dispatch, object-oriented Class\" in julia that behaves like a standard Java Class with public / private fields and methods","title_link":"https://stackoverflow.com/a/39150509/2442087","text":"I read in a book that \"you can't create traditional 'classes' in julia with single-dispatch-style methods like obj.myfunc()\" ... and I thought that sounded more like a challenge than a fact. So he...","fallback":"Stack Overflow: How to create a \"single dispatch, object-oriented Class\" in julia that behaves like a standard Java Class with public / private fields and methods","thumb_url":"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded","from_url":"https://stackoverflow.com/a/39150509/2442087","thumb_width":316,"thumb_height":316,"service_icon":"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a","id":1,"original_url":"https://stackoverflow.com/a/39150509/2442087"}],"blocks":[{"type":"rich_text","block_id":"hL/","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://stackoverflow.com/a/39150509/2442087","text":"https://stackoverflow.com/a/39150509/2442087"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"b2a70b09-5b4e-44e6-bf3c-cab5ffb2dcb6","type":"message","text":"yep - the difference being that in Jeff's example, everything is precisely defined and correctly typed since it's wrapped in a closure that captures it all","user":"UH24GRBLL","ts":"1613912222.063000","team":"T68168MUP","edited":{"user":"UH24GRBLL","ts":"1613912274.000000"},"blocks":[{"type":"rich_text","block_id":"Qop","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yep - the difference being that in Jeff's example, everything is precisely defined and correctly typed since it's wrapped in a closure that captures it all"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"4f9acc80-0785-46ed-997c-f9e4b83f7c43","type":"message","text":"the example by <@U01M24BJPTP> has `::Function`, so it won't specialize to the exact type of `method`, I think - not to mention the `mutable`, which means `method` may change exact type anyway","user":"UH24GRBLL","ts":"1613912252.063200","team":"T68168MUP","edited":{"user":"UH24GRBLL","ts":"1613912306.000000"},"blocks":[{"type":"rich_text","block_id":"bd=P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the example by "},{"type":"user","user_id":"U01M24BJPTP"},{"type":"text","text":" has "},{"type":"text","text":"::Function","style":{"code":true}},{"type":"text","text":", so it won't specialize to the exact type of "},{"type":"text","text":"method","style":{"code":true}},{"type":"text","text":", I think - not to mention the "},{"type":"text","text":"mutable","style":{"code":true}},{"type":"text","text":", which means "},{"type":"text","text":"method","style":{"code":true}},{"type":"text","text":" may change exact type anyway"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"1e0446f1-2b20-4715-b73c-a10b03e82a21","type":"message","text":"yes","user":"U69BL50BF","ts":"1613912298.063500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2XnT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"c79d3bf3-c508-47df-b5a6-4bb87a2531cc","type":"message","text":"you might as well just `::F` as a type parameter and then add the method at the time of construction in an inner constructor","user":"U69BL50BF","ts":"1613912323.063800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4fxu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you might as well just "},{"type":"text","text":"::F","style":{"code":true}},{"type":"text","text":" as a type parameter and then add the method at the time of construction in an inner constructor"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"8b1078cd-d847-42f9-8ac2-c50f4be4f58e","type":"message","text":"right, and that'd be fine as well, if you really want to do that to have the convenience of `a.B`","user":"UH24GRBLL","ts":"1613912355.064000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RAB53","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"right, and that'd be fine as well, if you really want to do that to have the convenience of "},{"type":"text","text":"a.B","style":{"code":true}}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"67976f4c-d2fb-4dd8-ac8f-ff07223b6762","type":"message","text":"that still won't give you the expected `c.B` if `c &lt;: a` (ignoring the subtyping impossibility for a moment)","user":"UH24GRBLL","ts":"1613912404.064200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vL+Fw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that still won't give you the expected "},{"type":"text","text":"c.B","style":{"code":true}},{"type":"text","text":" if "},{"type":"text","text":"c <: a","style":{"code":true}},{"type":"text","text":" (ignoring the subtyping impossibility for a moment)"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"2d9824ea-6d58-492f-9f69-72ea8ccca063","type":"message","text":"you'd also need a type parameter for each \"objectbound\" inner function","user":"UH24GRBLL","ts":"1613912492.064400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GHdi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you'd also need a type parameter for each \"objectbound\" inner function"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"c1324319-d223-481f-af68-95a11b412354","type":"message","text":"In any case, if you do decide to go this way, I'd be surprised if you didn't run into <https://github.com/JuliaLang/julia/issues/15276> left and right :grimacing:","user":"UH24GRBLL","ts":"1613912749.064600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ful","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In any case, if you do decide to go this way, I'd be surprised if you didn't run into "},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/15276"},{"type":"text","text":" left and right "},{"type":"emoji","name":"grimacing"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"9e9eb714-4c94-4d5d-9843-2dbb52d37376","type":"message","text":"Why even store the function in the struct? Why not just overload getindex to use getfield if the symbol is a field of the struct, and else return a function?","user":"U7HAYKY9X","ts":"1613914501.064900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"354","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why even store the function in the struct? Why not just overload getindex to use getfield if the symbol is a field of the struct, and else return a function?"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"3a565f51-e4c3-4602-893c-9d29a485083b","type":"message","text":"Something like:\n```struct Foo\n\tx::Int\nend\n\nBase.getproperty(x::Foo, s::Symbol) = s === :x ? getfield(x, s) : obj_dispatch(x, s)\nobj_dispatch(x, s) = args -&gt; getproperty(Main, s)(x, args...)```","user":"U7HAYKY9X","ts":"1613914898.065100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"V8u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Something like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Foo\n\tx::Int\nend\n\nBase.getproperty(x::Foo, s::Symbol) = s === :x ? getfield(x, s) : obj_dispatch(x, s)\nobj_dispatch(x, s) = args -> getproperty(Main, s)(x, args...)"}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"a44b9248-9444-4e46-a519-87cd65d5d17a","type":"message","text":"&gt; In fact, vast number of sentences in natural languages have a subject-verb-object format, so OOP is very natural.\nTrying to have a \"natural\" programming language and modeling it in analogy to the real world is misguided. The problem is that while they feel natural to us we do not really understand real world system of even moderate complexity (eg. natural language). Ease of reasonning about a language is not the same as it being natural (eg. mathematics), and there are definitely many benefits to emphasizing the former.","user":"U017LQ3A59U","ts":"1613915502.065300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JCy4","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"In fact, vast number of sentences in natural languages have a subject-verb-object format, so OOP is very natural."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Trying to have a \"natural\" programming language and modeling it in analogy to the real world is misguided. The problem is that while they feel natural to us we do not really understand real world system of even moderate complexity (eg. natural language). Ease of reasonning about a language is not the same as it being natural (eg. mathematics), and there are definitely many benefits to emphasizing the former."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"},{"client_msg_id":"45b4a9d6-3e0f-40ff-ab2b-56d27368746b","type":"message","text":"And as a side note about language: iirc all orders of subject/verb/object have been found in some language (iirc there is a south american native language using Yoda syntax object-subject-verb). Also the order may change on context (eg. German) or not be too strict (eg. Latin), and just to be confusing even English has a passive form that is really just about turning the syntax around.","user":"U017LQ3A59U","ts":"1613915757.065800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fWhyQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And as a side note about language: iirc all orders of subject/verb/object have been found in some language (iirc there is a south american native language using Yoda syntax object-subject-verb). Also the order may change on context (eg. German) or not be too strict (eg. Latin), and just to be confusing even English has a passive form that is really just about turning the syntax around."}]}]}],"thread_ts":"1613900066.051700","parent_user_id":"U01M24BJPTP"}]