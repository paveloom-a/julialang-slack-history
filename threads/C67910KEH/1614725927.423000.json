[{"client_msg_id":"d4293dad-fa85-4478-a44e-2f3dccc31215","type":"message","text":"Hi all, does there exist a way to make a base struct reference refer to a specific field?\nI want to be able to define a struct as:\n```mutable struct Foo\n    bar::Any\n    fiz::Any\nend\n\ninstance = Foo(3,\"buzz\")```\nAnd then default (similarly to overloading Base.getproperty/Base.setproperty!) such that any reference to `instance` is equivalent to `instance.bar`.","user":"U01AZ6UTY01","ts":"1614725927.423000","team":"T68168MUP","edited":{"user":"U01AZ6UTY01","ts":"1614726916.000000"},"blocks":[{"type":"rich_text","block_id":"+J0r2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi all, does there exist a way to make a base struct reference refer to a specific field?\nI want to be able to define a struct as:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct Foo\n    bar::Any\n    fiz::Any\nend\n\ninstance = Foo(3,\"buzz\")"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"And then default (similarly to overloading "},{"type":"text","text":"Base.getproperty/Base.setproperty!","style":{"unlink":true}},{"type":"text","text":") such that any reference to "},{"type":"text","text":"instance","style":{"code":true}},{"type":"text","text":" is equivalent to "},{"type":"text","text":"instance.bar","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1614725927.423000","reply_count":6,"reply_users_count":4,"latest_reply":"1614731731.425600","reply_users":["UB7JS9CHF","UH8A351DJ","U6A936746","U01AZ6UTY01"],"subscribed":false},{"client_msg_id":"12d09c39-1304-46bb-b249-1de30bf75eec","type":"message","text":"Remember to follow the Julia convention about using mixed case for struct/type names","user":"UB7JS9CHF","ts":"1614726718.423300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ubQNi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Remember to follow the Julia convention about using mixed case for struct/type names"}]}]}],"thread_ts":"1614725927.423000","parent_user_id":"U01AZ6UTY01"},{"client_msg_id":"37c118ad-5a36-43f7-aec0-fd1bfec755e5","type":"message","text":"<https://github.com/MikeInnes/Lazy.jl/blob/6705a0aa95b2d479e4ca5b5593313b0d6a857966/src/macros.jl#L276>\n\nshould help","user":"UH8A351DJ","ts":"1614727978.423600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Qm/0o","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/MikeInnes/Lazy.jl/blob/6705a0aa95b2d479e4ca5b5593313b0d6a857966/src/macros.jl#L276"},{"type":"text","text":"\n\nshould help"}]}]}],"thread_ts":"1614725927.423000","parent_user_id":"U01AZ6UTY01"},{"client_msg_id":"de156aa3-1e24-4dbe-a412-658512d995b3","type":"message","text":"The thing you want to do is not possible in Julia.\nInstead people overload methods to apply to the field \n\nThis is the delegation pattern.\nThere are bunch of macros for this.\nThe one in Lazy.jl has already been mentioned.\nAnother is <https://github.com/JeffreySarnoff/TypedDelegation.jl|https://github.com/JeffreySarnoff/TypedDelegation.jl>","user":"U6A936746","ts":"1614729182.423800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o47b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The thing you want to do is not possible in Julia.\nInstead people overload methods to apply to the field \n\nThis is the delegation pattern.\nThere are bunch of macros for this.\nThe one in Lazy.jl has already been mentioned.\nAnother is "},{"type":"link","url":"https://github.com/JeffreySarnoff/TypedDelegation.jl","text":"https://github.com/JeffreySarnoff/TypedDelegation.jl"}]}]}],"thread_ts":"1614725927.423000","parent_user_id":"U01AZ6UTY01"},{"client_msg_id":"9bb4189e-7229-4af2-9905-412a5bc4c787","type":"message","text":"In general I find that this is often (maybe 50-80% of the time) not actually what I want.\nAt first I  think that I \"just want it to act like it was that field\".\nBut then it turns out actually when  thinkimg about it i really want the result of a function on it to be rewrapped in the original type.\nOr i want it to just do that except actually it should run a check before each operation.\nEtc.\n\nFor that reason I write a lot of \nCode using `@eval` instead.\nBasic delegation is just\n```\nfor f in (:foo, :bar, :baz)\n    @eval $f(x::MyType) = $f(x.the_field)\nend\n```\nThe is just as fast as any macro.\nAnd it's directly extensible.\nAnd arguably clearer.\n\nSee e.g.  <https://www.github.com/invenia/NamedDims.jl/tree/master/src%2Ffunctions.jl|https://www.github.com/invenia/NamedDims.jl/tree/master/src%2Ffunctions.jl>","user":"U6A936746","ts":"1614729429.424000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sT1dH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In general I find that this is often (maybe 50-80% of the time) not actually what I want.\nAt first I  think that I \"just want it to act like it was that field\".\nBut then it turns out actually when  thinkimg about it i really want the result of a function on it to be rewrapped in the original type.\nOr i want it to just do that except actually it should run a check before each operation.\nEtc.\n\nFor that reason I write a lot of \nCode using "},{"type":"text","text":"@eval","style":{"code":true}},{"type":"text","text":" instead.\nBasic delegation is just\n```\nfor f in (:foo, :bar, :baz)\n    @eval $f(x::MyType) = $f(x.the_field)\nend\n```\nThe is just as fast as any macro.\nAnd it's directly extensible.\nAnd arguably clearer.\n\nSee e.g.  "},{"type":"link","url":"https://www.github.com/invenia/NamedDims.jl/tree/master/src%2Ffunctions.jl","text":"https://www.github.com/invenia/NamedDims.jl/tree/master/src%2Ffunctions.jl"}]}]}],"thread_ts":"1614725927.423000","parent_user_id":"U01AZ6UTY01"},{"client_msg_id":"3f3b34df-9e09-458e-9da8-3bc517cce327","type":"message","text":"Ah, these are helpful references. Thank you.\n\nFor further context, I am currently writing simulation code and have a variable struct like:\n```mutable struct Variable{T&lt;:Real}\n    value::T\n    prev_update::Float64\n    history::Union{History{T}, Nothing}\n    stats::Union{Stats{T}, Nothing}\n    . . .  \nend```\nWhenever the value is changed it updates the other fields accordingly.\n\nI only ever reference the other fields in the struct after a simulation to analyze the field’s state during runtime and wanted to avoid the mess of the dot operator if possible.","user":"U01AZ6UTY01","ts":"1614731435.424600","team":"T68168MUP","edited":{"user":"U01AZ6UTY01","ts":"1614731603.000000"},"blocks":[{"type":"rich_text","block_id":"Q7SgL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, these are helpful references. Thank you.\n\nFor further context, I am currently writing simulation code and have a variable struct like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct Variable{T<:Real}\n    value::T\n    prev_update::Float64\n    history::Union{History{T}, Nothing}\n    stats::Union{Stats{T}, Nothing}\n    . . .  \nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nWhenever the value is changed it updates the other fields accordingly.\n\nI only ever reference the other fields in the struct after a simulation to analyze the field’s state during runtime and wanted to avoid the mess of the dot operator if possible."}]}]}],"thread_ts":"1614725927.423000","parent_user_id":"U01AZ6UTY01"},{"client_msg_id":"94ad5e58-1646-4293-bfe1-4711a3c2554d","type":"message","text":"That method of delegation is pretty cool. I will have to emulate it.","user":"U01AZ6UTY01","ts":"1614731731.425600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qMK9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That method of delegation is pretty cool. I will have to emulate it."}]}]}],"thread_ts":"1614725927.423000","parent_user_id":"U01AZ6UTY01"}]