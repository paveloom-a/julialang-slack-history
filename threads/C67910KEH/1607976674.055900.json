[{"client_msg_id":"d9bdca1c-9848-4a8a-b23a-c605b3e8390b","type":"message","text":"Is there a package like [SaferIntegers](<https://github.com/JeffreySarnoff/SaferIntegers.jl>)\nfor floats?\nLike something that throws an error when you divide by zero?\n(rather than NaN)","user":"U6A936746","ts":"1607976674.055900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1607976679.000000"},"blocks":[{"type":"rich_text","block_id":"drLO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a package like [SaferIntegers]("},{"type":"link","url":"https://github.com/JeffreySarnoff/SaferIntegers.jl"},{"type":"text","text":")\nfor floats?\nLike something that throws an error when you divide by zero?\n(rather than NaN)"}]}]}],"thread_ts":"1607976674.055900","reply_count":13,"reply_users_count":7,"latest_reply":"1608356923.187800","reply_users":["U68QW0PUZ","U6A936746","UM30MT6RF","U68UUUFPS","U6795JH6H","U6C937ENB","U93BUBZP0"],"subscribed":false,"reactions":[{"name":"+1","users":["U7THT3TM3"],"count":1}]},{"client_msg_id":"afea0cef-d75d-43ad-b247-33fb1c35074c","type":"message","text":"No. There could be.  How compelling is the use case -- is this something of value to many?  Is generating `Inf` ok or not (because finite/Inf is reasonably 0)..","user":"U68QW0PUZ","ts":"1607977223.056100","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1607977375.000000"},"blocks":[{"type":"rich_text","block_id":"7bno","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No. There could be.  How compelling is the use case -- is this something of value to many?  Is generating "},{"type":"text","text":"Inf","style":{"code":true}},{"type":"text","text":" ok or not (because finite/Inf is reasonably 0).."}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"},{"client_msg_id":"8811aa37-a215-4d2b-9604-335f2a463d2a","type":"message","text":"Note that throwing errors, even contingently (at least it had been so), has runtime overhead with the current exception handling.","user":"U68QW0PUZ","ts":"1607977303.056300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WX=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Note that throwing errors, even contingently (at least it had been so), has runtime overhead with the current exception handling."}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746","reactions":[{"name":"+1","users":["U7THT3TM3"],"count":1}]},{"client_msg_id":"cfbab8c0-1640-48e2-b0d5-0de699d3d8d5","type":"message","text":"Not really compelling at all, I wanted it for an example I was write of how to test things.\nI wanted to check that `mean(SafeFloat[])`  threw an error","user":"U6A936746","ts":"1607977399.057500","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1607977403.000000"},"blocks":[{"type":"rich_text","block_id":"U2/cu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not really compelling at all, I wanted it for an example I was write of how to test things.\nI wanted to check that "},{"type":"text","text":"mean(SafeFloat[])","style":{"code":true}},{"type":"text","text":"  threw an error"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"},{"client_msg_id":"81cda857-1a25-4026-9ae2-5653e3cd5515","type":"message","text":"I wonder whether a Cassette/IRTools pass might be an easier solution for this","user":"UM30MT6RF","ts":"1607977488.058500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oEsN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wonder whether a Cassette/IRTools pass might be an easier solution for this"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"},{"client_msg_id":"e6211536-df2c-4887-b2bb-3516ac14c756","type":"message","text":"I would _love_ that. Sometimes we have some very large codebase, and at the end of it all we get a `NaN`. Almost impossible to figure out where things go south in that case, if the place where one of these values appeared first would throw an error, it would make finding the root cause of this sooo much easier.","user":"U68UUUFPS","ts":"1607977586.058700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lExb/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would "},{"type":"text","text":"love","style":{"italic":true}},{"type":"text","text":" that. Sometimes we have some very large codebase, and at the end of it all we get a "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":". Almost impossible to figure out where things go south in that case, if the place where one of these values appeared first would throw an error, it would make finding the root cause of this sooo much easier."}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746","reactions":[{"name":"+1","users":["U7THT3TM3","U9769MVA7","U73KWSUGN","U93BUBZP0"],"count":4}]},{"client_msg_id":"6dfcb44c-e5fe-4636-966f-4c707adebabf","type":"message","text":"if only hardware makers hadn’t decided to not really support signaling NaNs properly and compiler makers hadn’t decided to not really support quiet propagating NaNs","user":"U6795JH6H","ts":"1607977717.059000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+ub","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if only hardware makers hadn’t decided to not really support signaling NaNs properly and compiler makers hadn’t decided to not really support quiet propagating NaNs"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746","reactions":[{"name":"klingon_empire","users":["U68QW0PUZ"],"count":1},{"name":"heavy_check_mark","users":["UGU761DU2"],"count":1}]},{"client_msg_id":"dae466a0-1116-4d9b-9e29-bebad3d518fb","type":"message","text":"leaving us with no good way of figuring out where a NaN came from despite there theoretically being two different ways to do it","user":"U6795JH6H","ts":"1607977742.059200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+miM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"leaving us with no good way of figuring out where a NaN came from despite there theoretically being two different ways to do it"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746","reactions":[{"name":"sob","users":["U68UUUFPS","U6A936746","U6QGE7S86","UM30MT6RF","U68QW0PUZ","U7THT3TM3","U677NAWV8"],"count":7}]},{"client_msg_id":"c6b1492f-49cc-4997-9e42-f6d237eee44f","type":"message","text":"Something like this should do the trick:\n```julia&gt; using IRTools: @dynamo, IR, recurse!\n\njulia&gt; @dynamo function foo(x...)\n           ir = IR(x...)\n           ir === nothing &amp;&amp; return\n           recurse!(ir)\n           return ir\n       end\n\njulia&gt; foo(::typeof(/), x::AbstractFloat, y::AbstractFloat) = iszero(y) ? error(\"division by zero: $x / $y\") : x / y\nfoo (generic function with 2 methods)\n\njulia&gt; foo() do\n           1.0 / 0.0\n       end\nERROR: division by zero: 1.0 / 0.0\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] foo(::typeof(/), ::Float64, ::Float64) at ./REPL[8]:1\n [3] #7 at ./REPL[9]:2 [inlined]\n [4] foo(::var\"#7#8\") at /home/simeon/.julia/packages/IRTools/aSVI5/src/reflection/dynamo.jl:0\n [5] top-level scope at REPL[9]:1```","user":"UM30MT6RF","ts":"1607977802.059500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KTyT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Something like this should do the trick:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using IRTools: @dynamo, IR, recurse!\n\njulia> @dynamo function foo(x...)\n           ir = IR(x...)\n           ir === nothing && return\n           recurse!(ir)\n           return ir\n       end\n\njulia> foo(::typeof(/), x::AbstractFloat, y::AbstractFloat) = iszero(y) ? error(\"division by zero: $x / $y\") : x / y\nfoo (generic function with 2 methods)\n\njulia> foo() do\n           1.0 / 0.0\n       end\nERROR: division by zero: 1.0 / 0.0\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] foo(::typeof(/), ::Float64, ::Float64) at ./REPL[8]:1\n [3] #7 at ./REPL[9]:2 [inlined]\n [4] foo(::var\"#7#8\") at /home/simeon/.julia/packages/IRTools/aSVI5/src/reflection/dynamo.jl:0\n [5] top-level scope at REPL[9]:1"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"},{"client_msg_id":"88c9910c-501d-4e87-ba9e-55c8f6b380af","type":"message","text":"&gt;  I would _love_ that. Sometimes we have some very large codebase, and at the end of it all we get a `NaN`. Almost impossible to figure out where things go south in that case\nIt’s a good point. This shows up a lot in ML code.\nE.g. super high gradients in deep learning, or other mistakes.\nIts very easy to get a overflow or underflow if you are not careful when working with probabilities.\n\nSwapping in a checked float for debugging purpose to track down where it came from would be great","user":"U6A936746","ts":"1607978311.061400","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1607979369.000000"},"blocks":[{"type":"rich_text","block_id":"AKcT","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" I would "},{"type":"text","text":"love","style":{"italic":true}},{"type":"text","text":" that. Sometimes we have some very large codebase, and at the end of it all we get a "},{"type":"text","text":"NaN","style":{"code":true}},{"type":"text","text":". Almost impossible to figure out where things go south in that case"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nIt’s a good point. This shows up a lot in ML code.\nE.g. super high gradients in deep learning, or other mistakes.\nIts very easy to get a overflow or underflow if you are not careful when working with probabilities.\n\nSwapping in a checked float for debugging purpose to track down where it came from would be great"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746","reactions":[{"name":"+1","users":["U68UUUFPS","U7THT3TM3","U73KWSUGN"],"count":3}]},{"client_msg_id":"29D90D21-8792-4812-811D-0894E8E2A2DA","type":"message","text":"Yeah, some innocent looking thing like `norm(x)^2` somewhere, have fun tracking it down","user":"U6C937ENB","ts":"1607979573.066200","team":"T68168MUP","edited":{"user":"U6C937ENB","ts":"1607979623.000000"},"blocks":[{"type":"rich_text","block_id":"IR9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, some innocent looking thing like "},{"type":"text","text":"norm(x)^2","style":{"code":true}},{"type":"text","text":" somewhere, have fun tracking it down"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"},{"client_msg_id":"a8d36c8b-80f3-44e9-b984-83ac86fbb7b8","type":"message","text":"These expressions generate NaN\n1. NaN, op(NaN, NaN)\n2. `Inf - Inf`, `(-Inf) + Inf`\n3. `±0.0 *  ±Inf,  ±Inf *  ±0.0`\n4. `±0.0 / ±0.0`,  `±Inf / ±Inf`\n5. `rem(Inf, nonNaN), rem(nonNaN, 0.0)` \n6. _op(NaN, nonNaN), op(nonNaN, NaN)_\n        _with a few exceptions,_ see <https://www.agner.org/optimize/nan_propagation.pdf|NaN Propagation (pp5-6)>","user":"U68QW0PUZ","ts":"1607980065.067200","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1607980442.000000"},"blocks":[{"type":"rich_text","block_id":"wOj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"These expressions generate NaN\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"NaN, op(NaN, NaN)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Inf - Inf","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"(-Inf) + Inf","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"±0.0 *  ±Inf,  ±Inf *  ±0.0","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"±0.0 / ±0.0","style":{"code":true}},{"type":"text","text":",  "},{"type":"text","text":"±Inf / ±Inf","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"rem(Inf, nonNaN), rem(nonNaN, 0.0)","style":{"code":true}},{"type":"text","text":" "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"op(NaN, nonNaN), op(nonNaN, NaN)","style":{"italic":true}}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"        with a few exceptions, ","style":{"italic":true}},{"type":"text","text":"see "},{"type":"link","url":"https://www.agner.org/optimize/nan_propagation.pdf","text":"NaN Propagation (pp5-6)"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"408fdbda-5c61-4d3f-a1c0-9074c6578bbb","type":"message","text":"When I first wrote LambertW.jl I included a macro so you could choose between NaN and error at one place at the top of the file. Someone made me remove it in order to register it. So I chose NaN.  Maybe it's possible to make a convenient system using macros (or a flag represented by a type so that there is no runtime penalty) so that it's easy to provide both versions.  Like `MyMod.mathfunc` and `Mymod.noNaN.mathfunc` or something like that.","user":"U93BUBZP0","ts":"1607992380.076300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XYW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When I first wrote LambertW.jl I included a macro so you could choose between NaN and error at one place at the top of the file. Someone made me remove it in order to register it. So I chose NaN.  Maybe it's possible to make a convenient system using macros (or a flag represented by a type so that there is no runtime penalty) so that it's easy to provide both versions.  Like "},{"type":"text","text":"MyMod.mathfunc","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Mymod.noNaN.mathfunc","style":{"code":true}},{"type":"text","text":" or something like that."}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"},{"client_msg_id":"b436ceb7-2e5d-452a-9428-870d3d663b3d","type":"message","text":"<@U6A936746> There has been some interest in code that will trap a NaN as it is generated and give some call chain info.  It turns out this is possible with the current versions of Julia, working with the REPL, if and only if there is nothing `print`ed or otherwise `show`n within the NaN trapping or NaN trap handling code.  It would be great to have that restriction eliminated (Julia goes somewhat bonkers, specifics depend on how it is caused, and often, eventually, closes itself) -- it appears to be caused either by some interaction within Ryu or by some interaction in the code that outputs to the screen thereafter), idk what though. Here is some code with an example: <https://gist.github.com/JeffreySarnoff/db217673bc220360dc388136ab170e76|nancatcher.jl>","user":"U68QW0PUZ","ts":"1608356923.187800","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1608357233.000000"},"blocks":[{"type":"rich_text","block_id":"mtJ","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6A936746"},{"type":"text","text":" There has been some interest in code that will trap a NaN as it is generated and give some call chain info.  It turns out this is possible with the current versions of Julia, working with the REPL, if and only if there is nothing "},{"type":"text","text":"print","style":{"code":true}},{"type":"text","text":"ed or otherwise "},{"type":"text","text":"show","style":{"code":true}},{"type":"text","text":"n within the NaN trapping or NaN trap handling code.  It would be great to have that restriction eliminated (Julia goes somewhat bonkers, specifics depend on how it is caused, and often, eventually, closes itself) -- it appears to be caused either by some interaction within Ryu or by some interaction in the code that outputs to the screen thereafter), idk what though. Here is some code with an example: "},{"type":"link","url":"https://gist.github.com/JeffreySarnoff/db217673bc220360dc388136ab170e76","text":"nancatcher.jl"}]}]}],"thread_ts":"1607976674.055900","parent_user_id":"U6A936746"}]