[{"client_msg_id":"5d9b7a92-4337-40e2-89a6-6199f13a7d13","type":"message","text":"How do custom allocators in Julia like <https://github.com/FluxML/Alloc.jl> interact with the GC? For example, is it possible that the GC could walk the stack and follow pointers to structs in the bump-allocated arena while the function is running? I would think that could cause problems. And, if that somehow works, what about references from arena-allocated structs to structs on the main heap, would those main heap structs be properly marked?","user":"UQZSRDE4E","ts":"1615185032.203700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5mp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How do custom allocators in Julia like "},{"type":"link","url":"https://github.com/FluxML/Alloc.jl"},{"type":"text","text":" interact with the GC? For example, is it possible that the GC could walk the stack and follow pointers to structs in the bump-allocated arena while the function is running? I would think that could cause problems. And, if that somehow works, what about references from arena-allocated structs to structs on the main heap, would those main heap structs be properly marked?"}]}]}],"thread_ts":"1615185032.203700","reply_count":9,"reply_users_count":3,"latest_reply":"1615262431.009100","reply_users":["U012FH66MFW","UQZSRDE4E","UD0NS8PDF"],"subscribed":false,"reactions":[{"name":"point_up","users":["U66QZ3QF3","U0179G7FG4F"],"count":2}]},{"client_msg_id":"0a507c40-b438-46cf-8f2a-299e27651083","type":"message","text":"What other \"custom allocators\" do you have in mind \"like\" Alloc.jl?","user":"U012FH66MFW","ts":"1615250133.000100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tj9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What other \"custom allocators\" do you have in mind \"like\" Alloc.jl?"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"8dd452ac-f647-4526-801f-00e15b5b6486","type":"message","text":"I don't really know Alloc.jl, but from having a quick look at it, it doesn't seem to interact with the GC at all; rather it modifies the instruction stream of some selected code, replacing all regular allocations by bump allocations in a fixed size buffer, thus avoiding the new for garbage collection while that particular bit of code is running.","user":"U012FH66MFW","ts":"1615250207.000300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"u+eI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't really know Alloc.jl, but from having a quick look at it, it doesn't seem to interact with the GC at all; rather it modifies the instruction stream of some selected code, replacing all regular allocations by bump allocations in a fixed size buffer, thus avoiding the new for garbage collection while that particular bit of code is running."}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"c283c283-4ec7-4280-b837-fe2565767c60","type":"message","text":"(I may be way off with this, though -- if someone knows better, I'd appreciate a correction!!)","user":"U012FH66MFW","ts":"1615250321.001200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HB2we","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(I may be way off with this, though -- if someone knows better, I'd appreciate a correction!!)"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"e4aca1ad-a56a-463e-87d3-a61595a880a5","type":"message","text":"Anyway, that's some very clever and cool code, but also seems somewhat limited to me overall (though I am guessing it has major payoff for the intended applications!)","user":"U012FH66MFW","ts":"1615250359.001800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XRF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyway, that's some very clever and cool code, but also seems somewhat limited to me overall (though I am guessing it has major payoff for the intended applications!)"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"a3b5f965-66f7-4bab-ba34-86cbbcce1505","type":"message","text":"when it comes to \"truly\" interacting with the Julia GC: we implemented an extension API for the Julia GC (added in Julia 1.1) for use in GAP.jl, so that we could integrate our legacy C code tightly with Julia, replacing its own GC with the Julia GC, thus allowing seamless interaction, at least on the memory allocation level. However, it really only works because the existing C code already was written with a GC in mind, and so e.g. marking functions for all allocations already existed and could be used","user":"U012FH66MFW","ts":"1615250461.002100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"doft","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"when it comes to \"truly\" interacting with the Julia GC: we implemented an extension API for the Julia GC (added in Julia 1.1) for use in GAP.jl, so that we could integrate our legacy C code tightly with Julia, replacing its own GC with the Julia GC, thus allowing seamless interaction, at least on the memory allocation level. However, it really only works because the existing C code already was written with a GC in mind, and so e.g. marking functions for all allocations already existed and could be used"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"246cb279-0651-40d7-9fdd-f90b04c9865d","type":"message","text":"(regarding Alloc.jl, I think it sidesteps all the things you ask about by simply avoiding any \"regular\" allocations, and hence any garbage collection, while the modified code is being executed (not sure what'll happen when this run in multi threaded code, though?)","user":"U012FH66MFW","ts":"1615250630.004200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rKV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(regarding Alloc.jl, I think it sidesteps all the things you ask about by simply avoiding any \"regular\" allocations, and hence any garbage collection, while the modified code is being executed (not sure what'll happen when this run in multi threaded code, though?)"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"fb4b1d36-80f0-4655-ade4-408020e9b980","type":"message","text":"I saw one as part of another package when I was searching around, I'll have to look for it again","user":"UQZSRDE4E","ts":"1615255907.007600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f72s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I saw one as part of another package when I was searching around, I'll have to look for it again"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"48cb5a34-4d90-4f32-b45b-12b7b5b79fa7","type":"message","text":"I think you're right about Alloc.jl, it uses IRTools.jl to somehow rewrite the allocations to happen in an arena.. I was just wondering if there was some way that the GC could be aware of that, like a bit in the object header that is flipped when it's on-heap","user":"UQZSRDE4E","ts":"1615255978.007800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kSg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think you're right about Alloc.jl, it uses IRTools.jl to somehow rewrite the allocations to happen in an arena.. I was just wondering if there was some way that the GC could be aware of that, like a bit in the object header that is flipped when it's on-heap"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"},{"client_msg_id":"73FB3DB4-15B9-479F-9D65-D0815F5008FA","type":"message","text":"<https://github.com/oxinabox/AutoPreallocation.jl|https://github.com/oxinabox/AutoPreallocation.jl> might be the other, similar, package?","user":"UD0NS8PDF","ts":"1615262431.009100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L/R","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/oxinabox/AutoPreallocation.jl","text":"https://github.com/oxinabox/AutoPreallocation.jl"},{"type":"text","text":" might be the other, similar, package?"}]}]}],"thread_ts":"1615185032.203700","parent_user_id":"UQZSRDE4E"}]