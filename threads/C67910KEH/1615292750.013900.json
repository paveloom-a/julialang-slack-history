[{"client_msg_id":"d8087d16-4624-487a-96ed-61a47dddc312","type":"message","text":"Theoretically, is it possible to fill Dict/Set in such a way that the worst-case scenario for time complexity is filled (all entries are inserted into the same bucket)? Let's say I want to make a set with 10 carefully chosen integers such a way that checking the existence of some value v is done in O(n) time?","user":"UAGBT2X1A","ts":"1615292750.013900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v=iv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Theoretically, is it possible to fill Dict/Set in such a way that the worst-case scenario for time complexity is filled (all entries are inserted into the same bucket)? Let's say I want to make a set with 10 carefully chosen integers such a way that checking the existence of some value v is done in O(n) time?"}]}]}],"thread_ts":"1615292750.013900","reply_count":3,"reply_users_count":2,"latest_reply":"1615299073.015100","reply_users":["U7HAYKY9X","U6A936746"],"subscribed":false},{"client_msg_id":"03ad13e4-dc3d-4312-9b91-5b399372541a","type":"message","text":"That's hard to do, I think. It's easy to find a sequence of intergers with O(n) insert time, but once you've put in a few of those, the dict will re-hash, and then there are no more slots with O(n) insert time.\nIf you have a very large dict, it can take long before it re-hashes, though","user":"U7HAYKY9X","ts":"1615293807.014300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GZKZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's hard to do, I think. It's easy to find a sequence of intergers with O(n) insert time, but once you've put in a few of those, the dict will re-hash, and then there are no more slots with O(n) insert time.\nIf you have a very large dict, it can take long before it re-hashes, though"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"0c344060-d53e-48c6-a319-1906396f299d","type":"message","text":"If you are allowed to use your own type it is easy.\n```Base.hash(::MyType, seed::UInt) = seed```\n","user":"U6A936746","ts":"1615298649.014700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e5t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you are allowed to use your own type it is easy.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Base.hash(::MyType, seed::UInt) = seed"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"eb05a111-2f52-4e27-8661-97efeb1b05fd","type":"message","text":"For any type that has 10x more possible values than an `UInt` , e.g. `NTuple{10, UInt}`  it is certain to be possible to find 10 collisions that apply no matter the size of the Dict.\nand in general it is probably possible much earlier, because many `hash` functions are not perfect.\n*and nor should they be*, it is cheaper to have them be fast and then add a few `isequal` checks when collisions occur, than to make them slow but perfect.\n`OrderedCollections.LittleDict`  is in effect a dictionary with 1 bucket (i.e. that always collides) and it is faster for a lot of types than a `Dict` if you don’t have more than a few dozen elements, because `hash` is expensive","user":"U6A936746","ts":"1615299073.015100","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615299098.000000"},"blocks":[{"type":"rich_text","block_id":"KVvaa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For any type that has 10x more possible values than an "},{"type":"text","text":"UInt","style":{"code":true}},{"type":"text","text":" , e.g. "},{"type":"text","text":"NTuple{10, UInt}","style":{"code":true}},{"type":"text","text":"  it is certain to be possible to find 10 collisions that apply no matter the size of the Dict.\nand in general it is probably possible much earlier, because many "},{"type":"text","text":"hash","style":{"code":true}},{"type":"text","text":" functions are not perfect.\n"},{"type":"text","text":"and nor should they be","style":{"bold":true}},{"type":"text","text":", it is cheaper to have them be fast and then add a few "},{"type":"text","text":"isequal","style":{"code":true}},{"type":"text","text":" checks when collisions occur, than to make them slow but perfect.\n"},{"type":"text","text":"OrderedCollections.LittleDict","style":{"code":true}},{"type":"text","text":"  is in effect a dictionary with 1 bucket (i.e. that always collides) and it is faster for a lot of types than a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" if you don’t have more than a few dozen elements, because "},{"type":"text","text":"hash","style":{"code":true}},{"type":"text","text":" is expensive"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"}]