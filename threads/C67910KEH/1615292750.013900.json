[{"client_msg_id":"d8087d16-4624-487a-96ed-61a47dddc312","type":"message","text":"Theoretically, is it possible to fill Dict/Set in such a way that the worst-case scenario for time complexity is filled (all entries are inserted into the same bucket)? Let's say I want to make a set with 10 carefully chosen integers such a way that checking the existence of some value v is done in O(n) time?","user":"UAGBT2X1A","ts":"1615292750.013900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v=iv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Theoretically, is it possible to fill Dict/Set in such a way that the worst-case scenario for time complexity is filled (all entries are inserted into the same bucket)? Let's say I want to make a set with 10 carefully chosen integers such a way that checking the existence of some value v is done in O(n) time?"}]}]}],"thread_ts":"1615292750.013900","reply_count":57,"reply_users_count":5,"latest_reply":"1615326809.044800","reply_users":["U7HAYKY9X","U6A936746","UAGBT2X1A","UDHCV0BHD","U01M655G9AR"],"subscribed":false},{"client_msg_id":"03ad13e4-dc3d-4312-9b91-5b399372541a","type":"message","text":"That's hard to do, I think. It's easy to find a sequence of intergers with O(n) insert time, but once you've put in a few of those, the dict will re-hash, and then there are no more slots with O(n) insert time.\nIf you have a very large dict, it can take long before it re-hashes, though","user":"U7HAYKY9X","ts":"1615293807.014300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GZKZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's hard to do, I think. It's easy to find a sequence of intergers with O(n) insert time, but once you've put in a few of those, the dict will re-hash, and then there are no more slots with O(n) insert time.\nIf you have a very large dict, it can take long before it re-hashes, though"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"0c344060-d53e-48c6-a319-1906396f299d","type":"message","text":"If you are allowed to use your own type it is easy.\n```Base.hash(::MyType, seed::UInt) = seed```\n","user":"U6A936746","ts":"1615298649.014700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e5t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you are allowed to use your own type it is easy.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Base.hash(::MyType, seed::UInt) = seed"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"eb05a111-2f52-4e27-8661-97efeb1b05fd","type":"message","text":"For any type that has 10x more possible values than an `UInt` , e.g. `NTuple{10, UInt}`  it is certain to be possible to find 10 collisions that apply no matter the size of the Dict.\nand in general it is probably possible much earlier, because many `hash` functions are not perfect.\n*and nor should they be*, it is cheaper to have them be fast and then add a few `isequal` checks when collisions occur, than to make them slow but perfect.\n`OrderedCollections.LittleDict`  is in effect a dictionary with 1 bucket (i.e. that always collides) and it is faster for a lot of types than a `Dict` if you don’t have more than a few dozen elements, because `hash` is expensive","user":"U6A936746","ts":"1615299073.015100","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615299098.000000"},"blocks":[{"type":"rich_text","block_id":"KVvaa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For any type that has 10x more possible values than an "},{"type":"text","text":"UInt","style":{"code":true}},{"type":"text","text":" , e.g. "},{"type":"text","text":"NTuple{10, UInt}","style":{"code":true}},{"type":"text","text":"  it is certain to be possible to find 10 collisions that apply no matter the size of the Dict.\nand in general it is probably possible much earlier, because many "},{"type":"text","text":"hash","style":{"code":true}},{"type":"text","text":" functions are not perfect.\n"},{"type":"text","text":"and nor should they be","style":{"bold":true}},{"type":"text","text":", it is cheaper to have them be fast and then add a few "},{"type":"text","text":"isequal","style":{"code":true}},{"type":"text","text":" checks when collisions occur, than to make them slow but perfect.\n"},{"type":"text","text":"OrderedCollections.LittleDict","style":{"code":true}},{"type":"text","text":"  is in effect a dictionary with 1 bucket (i.e. that always collides) and it is faster for a lot of types than a "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" if you don’t have more than a few dozen elements, because "},{"type":"text","text":"hash","style":{"code":true}},{"type":"text","text":" is expensive"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"6a8bb082-2eb0-43f5-8459-c155504ed029","type":"message","text":"The reason why I'm wondering is that I was asked an algorithm with no worse complexity than O(n log n) of finding a number from a list that also has its double in that same list. So if there's e.g. list `[3, 22, 7, 5, 11, 5]`, the correct number is 11 because there's also 22. My initial solution is using a set:\n\n```function ratk5(T)\n    V = Set(T)\n    for t ∈ V\n        2*t ∈ V &amp;&amp; return t\n    end\n    return -1\nend```\nBut the initial comments was that checking if `2t in V` can be O(n) in the worst case, making this O(n^2) in the worst-case scenario. Yes, it's true that if all numbers are in one bucket due to some clever choice of numbers in T, it could be O(n^2) but I still think could this be possible if Set is implemented in the right way.","user":"UAGBT2X1A","ts":"1615308403.020100","team":"T68168MUP","edited":{"user":"UAGBT2X1A","ts":"1615308435.000000"},"blocks":[{"type":"rich_text","block_id":"BXh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The reason why I'm wondering is that I was asked an algorithm with no worse complexity than O(n log n) of finding a number from a list that also has its double in that same list. So if there's e.g. list "},{"type":"text","text":"[3, 22, 7, 5, 11, 5]","style":{"code":true}},{"type":"text","text":", the correct number is 11 because there's also 22. My initial solution is using a set:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function ratk5(T)\n    V = Set(T)\n    for t ∈ V\n        2*t ∈ V && return t\n    end\n    return -1\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"But the initial comments was that checking if "},{"type":"text","text":"2t in V","style":{"code":true}},{"type":"text","text":" can be O(n) in the worst case, making this O(n^2) in the worst-case scenario. Yes, it's true that if all numbers are in one bucket due to some clever choice of numbers in T, it could be O(n^2) but I still think could this be possible if Set is implemented in the right way."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"982d5a83-a47c-4d01-9871-909cb54c4c0c","type":"message","text":"In general people often lie and say that big O for dictionaries is `O(1)`","user":"U6A936746","ts":"1615309063.020400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"h95xS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In general people often lie and say that big O for dictionaries is "},{"type":"text","text":"O(1)","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"033c72e6-565b-45d2-bcf2-58de7ecc4460","type":"message","text":"Yes, but do they equally lie when telling that the worst case is O(n) if there's no theoretical proof that when properly implemented, it's impossible to make is O(n)?","user":"UAGBT2X1A","ts":"1615309137.020600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nL6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, but do they equally lie when telling that the worst case is O(n) if there's no theoretical proof that when properly implemented, it's impossible to make is O(n)?"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"fff3e62f-98b8-41de-adbf-9a34abb8dd67","type":"message","text":"If you know bounds on the range of values that can occur in the list. then from a theoretical perspective you can just have a bit set.\nWhich is O(1) check and set for certain.","user":"U6A936746","ts":"1615309211.020800","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615309223.000000"},"blocks":[{"type":"rich_text","block_id":"0Ow","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you know bounds on the range of values that can occur in the list. then from a theoretical perspective you can just have a bit set.\nWhich is O(1) check and set for certain."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"6ecafbbd-e794-41a0-adc5-d0eab8bda4bd","type":"message","text":"If you take a binary tree for `V` your code should do. See for example <https://juliacollections.github.io/DataStructures.jl/latest/red_black_tree/>","user":"UDHCV0BHD","ts":"1615312330.021700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mqi8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you take a binary tree for "},{"type":"text","text":"V","style":{"code":true}},{"type":"text","text":" your code should do. See for example "},{"type":"link","url":"https://juliacollections.github.io/DataStructures.jl/latest/red_black_tree/"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"3c45aa62-8b67-44bb-b706-db5c911c1bb0","type":"message","text":"Yes, binary trees are indeed the right solution (and there's one more based on merge sort). Theoretical judgment would be easier. But in reality, I'm quite confident that my solution is in real life faster as checking existence from a set is by average O(1). I'm talking about practice. I think my solution is the fastest one. Could we find a counterexample where it's actually slower?","user":"UAGBT2X1A","ts":"1615313518.022000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T8s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, binary trees are indeed the right solution (and there's one more based on merge sort). Theoretical judgment would be easier. But in reality, I'm quite confident that my solution is in real life faster as checking existence from a set is by average O(1). I'm talking about practice. I think my solution is the fastest one. Could we find a counterexample where it's actually slower?"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"c8cc2de9-d83d-4d71-aa9c-cfc1d3eda0dc","type":"message","text":"you could just sort all elements and scan the list with two pointers. Could probably be written more elegantly, but you get the idea.:\n```function finddouble(x)\n   x = sort(x)\n   j = 1\n   n = length(x)\n   for i=1:n\n       while x[j] &lt; 2x[i] &amp;&amp; j &lt; n\n           j += 1\n       end\n       if x[j] == 2x[i]\n           return x[i],x[j]\n       end\n   end\nend```\n","user":"U01M655G9AR","ts":"1615314116.022300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"G57","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you could just sort all elements and scan the list with two pointers. Could probably be written more elegantly, but you get the idea.:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function finddouble(x)\n   x = sort(x)\n   j = 1\n   n = length(x)\n   for i=1:n\n       while x[j] < 2x[i] && j < n\n           j += 1\n       end\n       if x[j] == 2x[i]\n           return x[i],x[j]\n       end\n   end\nend"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"d5eeb5ec-2e7d-4b9f-b93f-b8c4350647a6","type":"message","text":"Because of that sort, it's definitely O(n log n). What is left is to make experiments with bigger data.","user":"UAGBT2X1A","ts":"1615314279.022500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fkZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Because of that sort, it's definitely O(n log n). What is left is to make experiments with bigger data."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"d646e59b-1521-47ca-8b25-9fcbbb6e4036","type":"message","text":"```function test()\n    T = Random.shuffle(1:10000)\n    @btime ratk5($T)\n    @btime finddouble($T)\nend\n\n  144.767 μs (7 allocations: 144.66 KiB)\n  371.294 μs (2 allocations: 78.20 KiB)```\n","user":"UAGBT2X1A","ts":"1615314523.022700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5lw","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function test()\n    T = Random.shuffle(1:10000)\n    @btime ratk5($T)\n    @btime finddouble($T)\nend\n\n  144.767 μs (7 allocations: 144.66 KiB)\n  371.294 μs (2 allocations: 78.20 KiB)"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"65c9fd1c-13a2-4ea4-881d-d71f42225347","type":"message","text":"dang! :slightly_smiling_face: probably you can get some gain by using inplace sorting (i.e. `sort!(x)`  instead of `x=sort(x)` .","user":"U01M655G9AR","ts":"1615315425.023100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vtgg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"dang! "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":" probably you can get some gain by using inplace sorting (i.e. "},{"type":"text","text":"sort!(x)","style":{"code":true}},{"type":"text","text":"  instead of "},{"type":"text","text":"x=sort(x)","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"d492ffd7-fe1b-4f4f-8177-b860c9e31265","type":"message","text":"My solution _should_ be O(n) when data is somehow \"normal\", but it's unclear for me how to manipulate data such a way that things turn around","user":"UAGBT2X1A","ts":"1615315646.023300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RSszQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My solution "},{"type":"text","text":"should","style":{"italic":true}},{"type":"text","text":" be O(n) when data is somehow \"normal\", but it's unclear for me how to manipulate data such a way that things turn around"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"e2f0e3dd-92d6-456e-93f2-79c6c5acaaa9","type":"message","text":"But your solution _cannot_ be faster than O(n log n) because of that sort","user":"UAGBT2X1A","ts":"1615316008.023500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lzM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But your solution "},{"type":"text","text":"cannot","style":{"italic":true}},{"type":"text","text":" be faster than O(n log n) because of that sort"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"41a3bb7b-f943-4bc5-a6ee-fdf17661b19b","type":"message","text":"In a worst-case, my solution _could_ be O(n^2) if T is chosen such a way that Set(T) is not working at all, but I'm quite suspicious of that kind of T, even if we harmfully try to figure out some T that is trying to maximize hash collisions.","user":"UAGBT2X1A","ts":"1615316128.023700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vFdq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In a worst-case, my solution "},{"type":"text","text":"could","style":{"italic":true}},{"type":"text","text":" be O(n^2) if T is chosen such a way that Set(T) is not working at all, but I'm quite suspicious of that kind of T, even if we harmfully try to figure out some T that is trying to maximize hash collisions."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"d1e628fc-88f2-4300-aaa5-66505d81f3b6","type":"message","text":"Your solution is O(n log n) as well. But the difference here is just a small constant, and is probably dominated by allocation/copy time...","user":"U01M655G9AR","ts":"1615319506.028100","team":"T68168MUP","edited":{"user":"U01M655G9AR","ts":"1615319518.000000"},"blocks":[{"type":"rich_text","block_id":"PEg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Your solution is O(n log n) as well. But the difference here is just a small constant, and is probably dominated by allocation/copy time..."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"31e3327a-40ac-4c0e-a216-ff60aa1bca33","type":"message","text":"How's that?","user":"UAGBT2X1A","ts":"1615319579.030200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P6NY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How's that?"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"37957bbb-af45-4bbd-81e9-de48be359bfd","type":"message","text":"Oh, extrema is in `O(n)`\nThus the bitset solution is always available and `O(n)`.\nCos 1 pass to get get `extrema`\nAnd then `sizehint!`\nNow your search needs 2 more passed through the array 1 to fill and one to check.\nThis `O(n)`\n\nAlthough the memory used will be potentially large.\n\nIt's also amortized `O(n)` if you skip the size hint. And just stick things straight in. (As to be fair us `Set)`","user":"U6A936746","ts":"1615320158.032000","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615320182.000000"},"blocks":[{"type":"rich_text","block_id":"OCV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, extrema is in "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":"\nThus the bitset solution is always available and "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":".\nCos 1 pass to get get `extrema`\nAnd then "},{"type":"text","text":"sizehint!\n","style":{"code":true}},{"type":"text","text":"Now your search needs 2 more passed through the array 1 to fill and one to check.\nThis `O(n)`\n\nAlthough the memory used will be potentially large.\n\nIt's also amortized "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":" if you skip the size hint. And just stick things straight in. (As to be fair us "},{"type":"text","text":"Set)","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"f9732ec4-020a-4b51-aaa9-06e9958f9936","type":"message","text":"DataStructures.jl's SparseIntSet is also O(1) check and insert (though probably 3-10 times slower that BitSet's, still very fast though).\nAnd it doesn't use arbitrarily large amounts of memory.\nAnd still gives amortized O(n)","user":"U6A936746","ts":"1615320441.032300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BPYMw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataStructures.jl's SparseIntSet is also O(1) check and insert (though probably 3-10 times slower that BitSet's, still very fast though).\nAnd it doesn't use arbitrarily large amounts of memory.\nAnd still gives amortized O(n)"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"04674c06-947f-4d4a-8374-f8a75c759a66","type":"message","text":"if you cannot assume that the maximum is an a priori constant, then the time complexity of the bitset solution would depend on this maximum, no? This seems potentially worse, theoretically speaking.  Or maybe I'm not understanding your proposal.","user":"U01M655G9AR","ts":"1615321388.032800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OTuF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you cannot assume that the maximum is an a priori constant, then the time complexity of the bitset solution would depend on this maximum, no? This seems potentially worse, theoretically speaking.  Or maybe I'm not understanding your proposal."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"352a9bd8-a0bf-49ab-9c13-95be7b0dc4af","type":"message","text":"No? Why would it? You can find it our in `O(n)` and then\nMemory is `O(1)` to allocate\n\n(Or find it out as you go and it is amortizes away)","user":"U6A936746","ts":"1615321514.033000","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615321562.000000"},"blocks":[{"type":"rich_text","block_id":"PUfz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No? Why would it? You can find it our in "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":" and then\nMemory is "},{"type":"text","text":"O(1)","style":{"code":true}},{"type":"text","text":" to allocate\n\n(Or find it out as you go and it is amortizes away)"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"6a1b6545-ba52-49db-9b43-5350266b7919","type":"message","text":"you need to zero it no?","user":"U01M655G9AR","ts":"1615321531.033200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lvfB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you need to zero it no?"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"04490e95-1778-41c6-9d3d-af2ed6c82368","type":"message","text":"Fair point","user":"U6A936746","ts":"1615321589.033500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0dEBy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fair point"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"8a9def64-a2a4-4245-a8c5-c1f7aa53c880","type":"message","text":"in any case this is  'fake' `O(n)`  IMO in the sense that for integers with `k` bits you'd need at least order `k` time for access, leaving you again with n log n I think...","user":"U01M655G9AR","ts":"1615321735.033800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CtUB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"in any case this is  'fake' "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":"  IMO in the sense that for integers with "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" bits you'd need at least order "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" time for access, leaving you again with n log n I think..."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"8db0fae4-c0a4-4a36-baca-5ddbb75ad8e3","type":"message","text":"I cannot find the theoretical guarantees of `SparseIntSet` , can you give me some pointer? Seems a bit fishy to me.","user":"U01M655G9AR","ts":"1615321830.034000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R5m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I cannot find the theoretical guarantees of "},{"type":"text","text":"SparseIntSet","style":{"code":true}},{"type":"text","text":" , can you give me some pointer? Seems a bit fishy to me."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"5b900cfb-0583-4e9a-9f44-3c907c4e59e9","type":"message","text":"Just read the source. It seems pretty straight forward  to see it has only constant time operations.\nIt's just an BitSet that doesn't allocate the whole thing at once. It allocates a page at a time. Leaving other no present pages as containing nothing","user":"U6A936746","ts":"1615321934.034200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F0I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just read the source. It seems pretty straight forward  to see it has only constant time operations.\nIt's just an BitSet that doesn't allocate the whole thing at once. It allocates a page at a time. Leaving other no present pages as containing nothing"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"3b446c98-3809-416d-a9e0-1fa705c27417","type":"message","text":"<@UAGBT2X1A> I just mean that the sorting solution with `sort!`  seems faster here","user":"U01M655G9AR","ts":"1615321936.034400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ass/","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UAGBT2X1A"},{"type":"text","text":" I just mean that the sorting solution with "},{"type":"text","text":"sort!","style":{"code":true}},{"type":"text","text":"  seems faster here"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"d5932299-b43b-4c8b-867e-6ad9f2bb7fe2","type":"message","text":"&gt; in any case this is  'fake' O(n)  IMO in the sense that for integers with k bits you'd need at least order k time for access, leaving you again with n log n I think...\n\nNo?\nBecause 1, `k` here is a constant it is 64. Things that don't change with you input don't go in Big O\n\nAnd more over 2. You need a constant  number of operations. It's a like 2 or 3\nBitshifts + masking.\nRegardless of the value of `k`","user":"U6A936746","ts":"1615322206.034600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1hvp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> in any case this is  'fake' O(n)  IMO in the sense that for integers with k bits you'd need at least order k time for access, leaving you again with n log n I think...\n\nNo?\nBecause 1, "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" here is a constant it is 64. Things that don't change with you input don't go in Big O\n\nAnd more over 2. You need a constant  number of operations. It's a like 2 or 3\nBitshifts + masking.\nRegardless of the value of "},{"type":"text","text":"k","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"c805cb7f-b512-4f35-aab7-d36609f215c6","type":"message","text":"Yes sure, this is what I meant when I said that \"if you can't assume that the maximum is an a priori constant\" (meant bounded by an a priori constant). If this is only for `Int64`, then that constant is e.g. `2^64`.","user":"U01M655G9AR","ts":"1615322528.036800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R3G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes sure, this is what I meant when I said that \"if you can't assume that the maximum is an a priori constant\" (meant bounded by an a priori constant). If this is only for "},{"type":"text","text":"Int64","style":{"code":true}},{"type":"text","text":", then that constant is e.g. "},{"type":"text","text":"2^64","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"c38ca510-7bd1-4060-98be-0cb57d7a8948","type":"message","text":"If we needed to consider arbitrarily sized integers like BigInt then `==` , and `&lt;` are `O(n)` and so you are never doing better than `O(n^2)`\n","user":"U6A936746","ts":"1615322615.037000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iV2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If we needed to consider arbitrarily sized integers like BigInt then "},{"type":"text","text":"==","style":{"code":true}},{"type":"text","text":" , and `<` are `O(n)` and so you are never doing better than "},{"type":"text","text":"O(n^2)\n","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"a3a2fb13-a96e-4f7c-93d3-29e7424df023","type":"message","text":"Ah I thought you ment the maximum of the given array.\nI maintain that considering integer types that don't have `O(1)` equality is out of scope for any point on complexity unless specifically mentioned.\nBecause this path leads to madness","user":"U6A936746","ts":"1615322719.037200","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615322731.000000"},"blocks":[{"type":"rich_text","block_id":"4g+8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah I thought you ment the maximum of the given array.\nI maintain that considering integer types that don't have "},{"type":"text","text":"O(1)","style":{"code":true}},{"type":"text","text":" equality is out of scope for any point on complexity unless specifically mentioned.\nBecause this path leads to madness"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"f656f1e6-1196-4db4-99e5-f3a5e8037dea","type":"message","text":"it doesn't make complete sense to discuss about asymptotics if your integers are bounded. For instance, sorting is \"theoretically\" `O(n)` for numbers bounded by `2^64`  ;-)","user":"U01M655G9AR","ts":"1615322828.037500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xOP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it doesn't make complete sense to discuss about asymptotics if your integers are bounded. For instance, sorting is \"theoretically\" "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":" for numbers bounded by "},{"type":"text","text":"2^64","style":{"code":true}},{"type":"text","text":"  ;-)"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"3a82f3d1-27b3-4dbb-a509-a3fbca1e971b","type":"message","text":"you could do `2^64` (i.e. a constant number of) passes, counting how many 0,1,2 etc you have in your sequence","user":"U01M655G9AR","ts":"1615323005.037700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z3AA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you could do "},{"type":"text","text":"2^64","style":{"code":true}},{"type":"text","text":" (i.e. a constant number of) passes, counting how many 0,1,2 etc you have in your sequence"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"127e6239-f4df-41e0-a339-15ae904e5ffc","type":"message","text":"My understanding was the practice of people doing this seriously is to declare which primative operations are O(1).\nSo I would declare equality, Hash, Comparisons, Bitwise operations on integers as as O(1). As well as allocations. Settings elements by index.\n\n\nI think that leads to a place where you can have interesting conversations.\nWithout falling into the tarpit of \"computers are actually finite state machines, not turning machines, as the universe has a finite amount of mass/energy\"","user":"U6A936746","ts":"1615323118.037900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2u0L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My understanding was the practice of people doing this seriously is to declare which primative operations are O(1).\nSo I would declare equality, Hash, Comparisons, Bitwise operations on integers as as O(1). As well as allocations. Settings elements by index.\n\n\nI think that leads to a place where you can have interesting conversations.\nWithout falling into the tarpit of \"computers are actually finite state machines, not turning machines, as the universe has a finite amount of mass/energy\""}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A","reactions":[{"name":"thumbsup_all","users":["U01M655G9AR"],"count":1}]},{"client_msg_id":"754fe0a3-e535-481f-85ae-1abdd0e0ab5f","type":"message","text":"I agree with you though, it is also useful compare algorithms in terms of number of comparisons `==` / `&lt;` without entering too much in detail.","user":"U01M655G9AR","ts":"1615323124.038100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BnZ9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree with you though, it is also useful compare algorithms in terms of number of comparisons "},{"type":"text","text":"==","style":{"code":true}},{"type":"text","text":" / "},{"type":"text","text":"<","style":{"code":true}},{"type":"text","text":" without entering too much in detail."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"9cdccac5-2aeb-4d77-9ef8-3f9848de3e7f","type":"message","text":"Practically: someone should benchmark BitSet and SparseBitSet. It would be interesting","user":"U6A936746","ts":"1615323213.038400","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615323229.000000"},"blocks":[{"type":"rich_text","block_id":"pR98r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Practically: someone should benchmark BitSet and SparseBitSet. It would be interesting"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"efef0cd6-ebcc-485c-aa25-7280b991cd0f","type":"message","text":"yes, but do you agree that the dense bitset solution is cheating, not really `O(n)`","user":"U01M655G9AR","ts":"1615323223.038700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Wi1K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, but do you agree that the dense bitset solution is cheating, not really "},{"type":"text","text":"O(n)","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"9fc64bf1-c289-4879-8342-daf5a94fe8dd","type":"message","text":"Hey, this was just a quite clear school exercise, just the question of how to effectively find is there a number y in a list so that there's x so that 2x = y or so ...:slightly_smiling_face:","user":"UAGBT2X1A","ts":"1615323226.038900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aQf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey, this was just a quite clear school exercise, just the question of how to effectively find is there a number y in a list so that there's x so that 2x = y or so ..."},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"f96dc8bc-34cf-4d1d-9574-9a163027fabc","type":"message","text":"<@U6A936746> I mean that you'd saturate the memory with this input `[1,2^60]`","user":"U01M655G9AR","ts":"1615323373.039200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tjw","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6A936746"},{"type":"text","text":" I mean that you'd saturate the memory with this input "},{"type":"text","text":"[1,2^60]","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"7b9cdcea-5f41-4b19-b5f2-96e1a96606d0","type":"message","text":"Indeed\nIf the actual input is not bounded to something sensible dense BitSet is impractical.\n\nAnd yes, theoretically\nDenseBitSet is `O(n+m)` where m is  the difference between extema in array.\nUnless I can have calloc as O(1).","user":"U6A936746","ts":"1615323457.039500","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1615323465.000000"},"blocks":[{"type":"rich_text","block_id":"yIxB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Indeed\nIf the actual input is not bounded to something sensible dense BitSet is impractical.\n\nAnd yes, theoretically\nDenseBitSet is `O(n+m)` where m is  the difference between extema in array.\nUnless I can have calloc as O(1)."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"f429d138-61be-4d74-ad9d-98bf4123d13e","type":"message","text":"SparseBitSet should be practical though. At worse you allocate 1 page per input array element.","user":"U6A936746","ts":"1615323596.039900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7pq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"SparseBitSet should be practical though. At worse you allocate 1 page per input array element."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"5e16ac69-fe9d-48c1-b91d-7297ae8011ff","type":"message","text":"<@UAGBT2X1A> what do you mean: this is important research: I just devised an `O(n)`  sorting algorithm: `constantsort(x::Vector{UInt32})=vcat((fill(i, sum(x.==i)) for i=0:2^32)...)`","user":"U01M655G9AR","ts":"1615323958.040100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gaH","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UAGBT2X1A"},{"type":"text","text":" what do you mean: this is important research: I just devised an "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":"  sorting algorithm: "},{"type":"text","text":"constantsort(x::Vector{UInt32})=vcat((fill(i, sum(x.==i)) for i=0:2^32)...)","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"1df12225-866b-4c9e-8ca6-519e4f1f871d","type":"message","text":"<@U6A936746> right but this can be pretty expensive. For `rand(Int64,n)`  you'd typically allocate `n` pages. This is about 512 times the memory of the input for a page of 4096 bytes...","user":"U01M655G9AR","ts":"1615324362.040300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tRKMe","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6A936746"},{"type":"text","text":" right but this can be pretty expensive. For "},{"type":"text","text":"rand(Int64,n)","style":{"code":true}},{"type":"text","text":"  you'd typically allocate "},{"type":"text","text":"n","style":{"code":true}},{"type":"text","text":" pages. This is about 512 times the memory of the input for a page of 4096 bytes..."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"99958fb1-3fc5-44dd-aa9b-62632211076d","type":"message","text":"The lower bound of sortable things is O(n log n), without any better knowledge.","user":"UAGBT2X1A","ts":"1615324365.040500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8srW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The lower bound of sortable things is O(n log n), without any better knowledge."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"2b17f79b-d125-419e-b674-2b26d4c93d27","type":"message","text":"yes","user":"U01M655G9AR","ts":"1615324386.040700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m8kSj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"79b9d00a-9a58-4609-8edf-6e2b5322c036","type":"message","text":"If you know something about the data, like that it's between A-Z, then you can go O(n)","user":"UAGBT2X1A","ts":"1615324548.040900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D/VFC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you know something about the data, like that it's between A-Z, then you can go O(n)"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"fbf30cff-e5a0-422c-8f0a-e12954d82eff","type":"message","text":"Or as far as I know","user":"UAGBT2X1A","ts":"1615324592.041100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kdWB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or as far as I know"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"6ee2ac98-ad4d-4e80-aaa2-588011a5d2f4","type":"message","text":"I just invented this algorithm!","user":"U01M655G9AR","ts":"1615324603.041300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hfpOL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just invented this algorithm!"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"893bba40-a0b8-4a74-9917-ca6916daa080","type":"message","text":"are you trying to steal it from me?","user":"U01M655G9AR","ts":"1615324622.041500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W1++","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"are you trying to steal it from me?"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"6289027d-01be-4883-9fd8-9ff587142bf0","type":"message","text":"Heh, no, you can have it","user":"UAGBT2X1A","ts":"1615324636.041700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3Fp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Heh, no, you can have it"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"58879b36-fbae-4793-8d0e-2c2a775ba645","type":"message","text":"phew","user":"U01M655G9AR","ts":"1615324659.041900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b12Yk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"phew"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"0f0fa6bf-d587-46e3-887c-88319617ac63","type":"message","text":"by the way, my algorithm does not even use `&lt;`","user":"U01M655G9AR","ts":"1615324890.042100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AtsHY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"by the way, my algorithm does not even use "},{"type":"text","text":"<","style":{"code":true}}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"d3cf68ed-c44e-4f37-b61a-3efd23b48b72","type":"message","text":"So what's left, is some mysterious O(n) operation making dictionary basically unusable in fast algorithms, without any explanation how it can be like that.","user":"UAGBT2X1A","ts":"1615324928.042300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"y6N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So what's left, is some mysterious O(n) operation making dictionary basically unusable in fast algorithms, without any explanation how it can be like that."}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"79be3797-4cfa-45d3-af29-3d4735955b6f","type":"message","text":"\"hash values could be distributed like that because\"","user":"UAGBT2X1A","ts":"1615324963.042500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4ME","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"\"hash values could be distributed like that because\""}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"5728897f-4640-4f9a-8db0-a57f9e09d815","type":"message","text":"I don't think that hashsets or dictionaries can really be `O(1)`... It's just that `n` is always smaller in practice than `2^64`, so `log2(n) &lt; 64` and you can perform comparisons of `log2(n)`  bits using a single `Int64`  operation.  So with respect to guarantees, you still get `n log n`  (unless numbers are bounded, then `O(n)` )","user":"U01M655G9AR","ts":"1615325756.044000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bcii5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think that hashsets or dictionaries can really be "},{"type":"text","text":"O(1)","style":{"code":true}},{"type":"text","text":"... It's just that "},{"type":"text","text":"n","style":{"code":true}},{"type":"text","text":" is always smaller in practice than "},{"type":"text","text":"2^64","style":{"code":true}},{"type":"text","text":", so "},{"type":"text","text":"log2(n) < 64","style":{"code":true}},{"type":"text","text":" and you can perform comparisons of "},{"type":"text","text":"log2(n)","style":{"code":true}},{"type":"text","text":"  bits using a single "},{"type":"text","text":"Int64","style":{"code":true}},{"type":"text","text":"  operation.  So with respect to guarantees, you still get "},{"type":"text","text":"n log n","style":{"code":true}},{"type":"text","text":"  (unless numbers are bounded, then "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":" )"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"0a857dcb-8c28-4be4-8f4f-9e91cfcf320c","type":"message","text":"&gt;  My understanding was the practice of people doing this seriously is to declare which primative operations are O(1).\n&gt; So I would declare equality [...]\nAlthough I generally agree, note that this can be a slippery slope :wink: [1]\n\n[1] <https://arxiv.org/abs/1110.1658v1>","user":"U01M655G9AR","ts":"1615326809.044800","team":"T68168MUP","attachments":[{"service_name":"arXiv.org","title":"Algorithm that Solves 3-SAT in Polynomial Time","title_link":"https://arxiv.org/abs/1110.1658v1","text":"The question of whether the complexity class P is equal to the complexity class NP has been a seemingly intractable problem for over 4 decades. It has been clear that if an algorithm existed that...","fallback":"arXiv.org: Algorithm that Solves 3-SAT in Polynomial Time","from_url":"https://arxiv.org/abs/1110.1658v1","service_icon":"https://static.arxiv.org/static/browse/0.3.2.6/images/icons/favicon.ico","id":1,"original_url":"https://arxiv.org/abs/1110.1658v1"}],"blocks":[{"type":"rich_text","block_id":"ZUe","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" My understanding was the practice of people doing this seriously is to declare which primative operations are O(1).\nSo I would declare equality [...]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Although I generally agree, note that this can be a slippery slope "},{"type":"emoji","name":"wink"},{"type":"text","text":" [1]\n\n[1] "},{"type":"link","url":"https://arxiv.org/abs/1110.1658v1"}]}]}],"thread_ts":"1615292750.013900","parent_user_id":"UAGBT2X1A"}]