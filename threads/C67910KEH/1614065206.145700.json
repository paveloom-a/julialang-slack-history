[{"client_msg_id":"c7a20c9e-5c4f-4ee1-b6eb-9f7b9ecad41a","type":"message","text":"Hi! So I was trying out code samples from \"Julia High Performance\", and I came across this code snippet `julia&gt; @btime arr_sumsqr($a)` where `a::Array{Int64,1}` and `arr_sumsqr()` was basically calculating the sum of squares of elements in `a`. I couldn't understand the concept of passing `$a` to the function, instead of the original array `a` itself. However, doing so gave an almost 2x speedup.\n```julia&gt; a = Int64[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\njulia&gt; @btime arr_sumsqr($a)\n  6.617 ns (0 allocations: 0 bytes)\n385\n\njulia&gt; @btime arr_sumsqr(a)\n  17.054 ns (0 allocations: 0 bytes)\n385```\n`BenchmarkTools.jl`'s documentation says that it is good practice to explicitly interpolate external variables into the benchmark expression.  What does external variable mean here? Up until now, I've only seen examples where interpolation is used in strings for concatenation or evaluating expressions inside strings. How does interpolation work in the context of `@btime`? Why do these speedups occur?\nApologies in advance if these are newb questions, I couldn't understand what the docs meant.","user":"U017D621ELC","ts":"1614065206.145700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f8n8J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi! So I was trying out code samples from \"Julia High Performance\", and I came across this code snippet "},{"type":"text","text":"julia> @btime arr_sumsqr($a)","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":"a::Array{Int64,1}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"arr_sumsqr() ","style":{"code":true}},{"type":"text","text":"was basically calculating the sum of squares of elements in "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":". I couldn't understand the concept of passing "},{"type":"text","text":"$a ","style":{"code":true}},{"type":"text","text":"to the function, instead of the original array "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" itself. However, doing so gave an almost 2x speedup.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> a = Int64[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\njulia> @btime arr_sumsqr($a)\n  6.617 ns (0 allocations: 0 bytes)\n385\n\njulia> @btime arr_sumsqr(a)\n  17.054 ns (0 allocations: 0 bytes)\n385"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"BenchmarkTools.jl","style":{"code":true}},{"type":"text","text":"'s documentation says that it is good practice to explicitly interpolate external variables into the benchmark expression.  What does external variable mean here? Up until now, I've only seen examples where interpolation is used in strings for concatenation or evaluating expressions inside strings. How does interpolation work in the context of "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":"? Why do these speedups occur?\nApologies in advance if these are newb questions, I couldn't understand what the docs meant."}]}]}],"thread_ts":"1614065206.145700","reply_count":6,"reply_users_count":3,"latest_reply":"1614068573.151200","reply_users":["U7HAYKY9X","U67D54KS8","U017D621ELC"],"subscribed":false},{"client_msg_id":"1726aa6d-3ddc-43c6-b2c4-fb3e981ffb10","type":"message","text":"It's not really a newbie question, but actually rather complicated. `@btime` times not an function, but an expression. If you don't interpolates, the expression it times is\n`arr_sumsqr(a)` , and if you do interpolates, it times\n`arr_sumsqr(Int64[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` , i.e. it interpolates the array directly into the expression being timed.","user":"U7HAYKY9X","ts":"1614065433.147200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1aHq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's not really a newbie question, but actually rather complicated. "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" times not an function, but an expression. If you don't interpolates, the expression it times is\n"},{"type":"text","text":"arr_sumsqr(a)","style":{"code":true}},{"type":"text","text":" , and if you do interpolates, it times\n"},{"type":"text","text":"arr_sumsqr(Int64[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])","style":{"code":true}},{"type":"text","text":" , i.e. it interpolates the array directly into the expression being timed."}]}]}],"thread_ts":"1614065206.145700","parent_user_id":"U017D621ELC"},{"client_msg_id":"3defee76-745b-4894-b773-c3a624e78295","type":"message","text":"External variable pretty much mean a non const global. The interpolation in `@btime` is completely handled by the macro, it is not a Julia feature, it is a BenchmarkTools feature. What it does is that it basically takes the object that the variable is bound to and wraps it inside a function (where the benchmarking takes place) so that from the Julia compilers point of view, it is not a global.","user":"U67D54KS8","ts":"1614065483.148100","team":"T68168MUP","edited":{"user":"U67D54KS8","ts":"1614065503.000000"},"blocks":[{"type":"rich_text","block_id":"WZJm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"External variable pretty much mean a non const global. The interpolation in "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" is completely handled by the macro, it is not a Julia feature, it is a BenchmarkTools feature. What it does is that it basically takes the object that the variable is bound to and wraps it inside a function (where the benchmarking takes place) so that from the Julia compilers point of view, it is not a global."}]}]}],"thread_ts":"1614065206.145700","parent_user_id":"U017D621ELC","reactions":[{"name":"+1","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"ffff0277-1879-43f4-af25-ed7ee1ba25b1","type":"message","text":"<@U67D54KS8> Just out of curiosity, isn't there a risk with interpolation that the compiler figures out that the array is a \"compile time constant\" and just returns the constant result? Similar to\n```julia&gt; a = (1,2,3)\n(1, 2, 3)\n\njulia&gt; @btime sum(a)\n  19.239 ns (0 allocations: 0 bytes)\n6\n\njulia&gt; @btime sum($a)\n  0.047 ns (0 allocations: 0 bytes)```","user":"U7HAYKY9X","ts":"1614065608.148400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1UWK","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67D54KS8"},{"type":"text","text":" Just out of curiosity, isn't there a risk with interpolation that the compiler figures out that the array is a \"compile time constant\" and just returns the constant result? Similar to\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> a = (1,2,3)\n(1, 2, 3)\n\njulia> @btime sum(a)\n  19.239 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime sum($a)\n  0.047 ns (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1614065206.145700","parent_user_id":"U017D621ELC","reactions":[{"name":"hushed","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"54c1de31-610e-43fa-b932-2dade5dd0e5b","type":"message","text":"Yeah, but note that this is also what would happen if you had `a = (1,2,3)` inside a function and computed the sum of it there. But you can do a bit of a trick to prevent constant propagation:\n\n```julia&gt; @btime sum($(Ref(a))[])\n  1.055 ns (0 allocations: 0 bytes)\n6```\n","user":"U67D54KS8","ts":"1614065695.148600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DfPrU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, but note that this is also what would happen if you had "},{"type":"text","text":"a = (1,2,3)","style":{"code":true}},{"type":"text","text":" inside a function and computed the sum of it there. But you can do a bit of a trick to prevent constant propagation:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime sum($(Ref(a))[])\n  1.055 ns (0 allocations: 0 bytes)\n6"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1614065206.145700","parent_user_id":"U017D621ELC","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1},{"name":"thankyou","users":["U7HAYKY9X","U017D621ELC"],"count":2}]},{"client_msg_id":"566a5238-2773-4939-8998-50e0dc245b9b","type":"message","text":"<@U67D54KS8> <@U7HAYKY9X> Thank you for the replies. Just out of curiosity,   <https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables|Performance tips> in Julia's manual recommends to avoid global variables, since it's values and type might change at any point. Is that why `@btime` wraps global variables, thus giving speedups? If all that `@btime` does is to access the object the variable is bound to, then can't the compiler make do by using just the name of the variable `a` , instead of users prepending a `$` ?  Also, can't values and types of variables change inside a local scope too?","user":"U017D621ELC","ts":"1614067207.150300","team":"T68168MUP","edited":{"user":"U017D621ELC","ts":"1614067312.000000"},"blocks":[{"type":"rich_text","block_id":"EfzpN","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67D54KS8"},{"type":"text","text":" "},{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" Thank you for the replies. Just out of curiosity,   "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables","text":"Performance tips"},{"type":"text","text":" in Julia's manual recommends to avoid global variables, since it's values and type might change at any point. Is that why "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" wraps global variables, thus giving speedups? If all that "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" does is to access the object the variable is bound to, then can't the compiler make do by using just the name of the variable "},{"type":"text","text":"a ","style":{"code":true}},{"type":"text","text":", instead of users prepending a "},{"type":"text","text":"$ ","style":{"code":true}},{"type":"text","text":"?  Also, can't values and types of variables change inside a local scope too?"}]}]}],"thread_ts":"1614065206.145700","parent_user_id":"U017D621ELC"},{"client_msg_id":"ec805b2b-ea12-49e4-bd12-2e2e4a67b922","type":"message","text":"&gt; Is that why `@btime` wraps global variables, thus giving speedups\nYes\n&gt; can't the compiler make do by using just the name of the variable `a` , instead of users prepending a `$` ?\nNot sure what you mean. In global scope, the compiler can't make assumptions about what types or values a variable is bound to, it has to check. I think BenchmarkTools could be written such that it automatically interpolates the values into a new closure and times that. I think it's probably intentional that it doesn't, so that it's possible to time expressions where the compiler doesn't know the type and value of a variable.\n&gt; can't values and types of variables change inside a local scope too?\nIf the function is compiled, and the compiler sees that some local variable is in fact of type `Foo` , then that can't change unless the function is re-defined. E.g. in this function:\n```function length_plus_one(x::Vector)\n    len = length(x)\n    len + 1\nend```\n`len` is always an `Int` , that can't possibly change.","user":"U7HAYKY9X","ts":"1614068573.151200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lyc","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Is that why "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" wraps global variables, thus giving speedups"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Yes\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"can't the compiler make do by using just the name of the variable "},{"type":"text","text":"a ","style":{"code":true}},{"type":"text","text":", instead of users prepending a "},{"type":"text","text":"$ ","style":{"code":true}},{"type":"text","text":"?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Not sure what you mean. In global scope, the compiler can't make assumptions about what types or values a variable is bound to, it has to check. I think BenchmarkTools could be written such that it automatically interpolates the values into a new closure and times that. I think it's probably intentional that it doesn't, so that it's possible to time expressions where the compiler doesn't know the type and value of a variable.\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"can't values and types of variables change inside a local scope too?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"If the function is compiled, and the compiler sees that some local variable is in fact of type "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" , then that can't change unless the function is re-defined. E.g. in this function:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function length_plus_one(x::Vector)\n    len = length(x)\n    len + 1\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"len","style":{"code":true}},{"type":"text","text":" is always an "},{"type":"text","text":"Int","style":{"code":true}},{"type":"text","text":" , that can't possibly change."}]}]}],"thread_ts":"1614065206.145700","parent_user_id":"U017D621ELC"}]