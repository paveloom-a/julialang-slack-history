[{"client_msg_id":"B4837DC6-CEC1-4012-BD75-2246B7FB30E5","type":"message","text":"Is it possible to invoke a specific method stored in a vector of methods directly without overhead? I'm thinking of a scenario where a number of different methods are stored and given an index the respective method is called on some input arguments that are always the same, and the outputs would also be the same for all. This would be to avoid dynamic dispatch in a situation where there are different types being fed to a function and I want to call those methods more like c functions ","user":"UK1BNFHFV","ts":"1608914351.480500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v4nR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it possible to invoke a specific method stored in a vector of methods directly without overhead? I'm thinking of a scenario where a number of different methods are stored and given an index the respective method is called on some input arguments that are always the same, and the outputs would also be the same for all. This would be to avoid dynamic dispatch in a situation where there are different types being fed to a function and I want to call those methods more like c functions "}]}]}],"thread_ts":"1608914351.480500","reply_count":17,"reply_users_count":6,"latest_reply":"1608975271.001000","reply_users":["U6A936746","UK1BNFHFV","USU9FRPEU","U67BJLYCS","U8D9768Q6","U85R3JJ8L"],"subscribed":false},{"client_msg_id":"a636a79f-b699-4657-a611-649fbce8d011","type":"message","text":"Not using the `Method` object AFAIK.\nYou can invoke a method via `invoke` which takes a signature Tuple type, but this is mostly to invoke a more general method rather than the most specialised on the Julia dispatch normally would do","user":"U6A936746","ts":"1608919307.480600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4Aq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not using the "},{"type":"text","text":"Method ","style":{"code":true}},{"type":"text","text":"object AFAIK.\nYou can invoke a method via "},{"type":"text","text":"invoke ","style":{"code":true}},{"type":"text","text":"which takes a signature Tuple type, but this is mostly to invoke a more general method rather than the most specialised on the Julia dispatch normally would do"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"ED631BA9-2558-4A68-A246-25947A74FD5D","type":"message","text":"I saw that the FunctionWrappers package goes into the direction that I thought about. Where input and output types are fixed and different functions can therefore be called with minimal overhead at runtime. Isn't that a bit of a gap in Julia that you can't force input output signatures for function like objects?","user":"UK1BNFHFV","ts":"1608919763.484600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5fy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I saw that the FunctionWrappers package goes into the direction that I thought about. Where input and output types are fixed and different functions can therefore be called with minimal overhead at runtime. Isn't that a bit of a gap in Julia that you can't force input output signatures for function like objects?"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"df9ea9c0-7e52-4082-b65e-2cd2c54dabe0","type":"message","text":"Well at runtime there would be minimal overhead... although you might incur some initial compilation the first time you run things.","user":"USU9FRPEU","ts":"1608924693.484900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"igd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well at runtime there would be minimal overhead... although you might incur some initial compilation the first time you run things."}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"4f8190ac-9849-4fb6-adf3-86f90921e4d2","type":"message","text":"```julia&gt; struct StrictFunction{In,Out}\n           f::Function\n       end\n\njulia&gt; (strictf::StrictFunction{I,O})(input::I) where {I,O} = strictf.f(input)::O\n\njulia&gt; sf = StrictFunction{Int,Int}( identity )\nStrictFunction{Int64,Int64}(identity)\n\njulia&gt; sf(5)\n5\n\njulia&gt; sf(5.0)\nERROR: MethodError: no method matching (::StrictFunction{Int64,Int64})(::Float64)\nClosest candidates are:\n  Any(::I) where {I, O} at REPL[42]:1\nStacktrace:\n [1] top-level scope at REPL[45]:1```\n","user":"USU9FRPEU","ts":"1608925457.485200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4Ub=p","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct StrictFunction{In,Out}\n           f::Function\n       end\n\njulia> (strictf::StrictFunction{I,O})(input::I) where {I,O} = strictf.f(input)::O\n\njulia> sf = StrictFunction{Int,Int}( identity )\nStrictFunction{Int64,Int64}(identity)\n\njulia> sf(5)\n5\n\njulia> sf(5.0)\nERROR: MethodError: no method matching (::StrictFunction{Int64,Int64})(::Float64)\nClosest candidates are:\n  Any(::I) where {I, O} at REPL[42]:1\nStacktrace:\n [1] top-level scope at REPL[45]:1"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"56d164ac-968d-4290-8e02-64c5a740eab2","type":"message","text":"Here we made a callable struct. First the callable struct will only match input of type `In` . It calls `f` and asserts the output should be of type `O` . Otherwise, an error will occur.\n\n```julia&gt; @code_warntype sf(5)\nVariables\n  strictf::StrictFunction{Int64,Int64}\n  input::Int64\n\nBody::Int64\n1 ─ %1 = Base.getproperty(strictf, :f)::Function\n│   %2 = (%1)(input)::Any\n│   %3 = Core.typeassert(%2, $(Expr(:static_parameter, 2)))::Int64\n└──      return %3```\n","user":"USU9FRPEU","ts":"1608925693.485400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8hokV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here we made a callable struct. First the callable struct will only match input of type "},{"type":"text","text":"In","style":{"code":true}},{"type":"text","text":" . It calls "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" and asserts the output should be of type "},{"type":"text","text":"O","style":{"code":true}},{"type":"text","text":" . Otherwise, an error will occur.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @code_warntype sf(5)\nVariables\n  strictf::StrictFunction{Int64,Int64}\n  input::Int64\n\nBody::Int64\n1 ─ %1 = Base.getproperty(strictf, :f)::Function\n│   %2 = (%1)(input)::Any\n│   %3 = Core.typeassert(%2, $(Expr(:static_parameter, 2)))::Int64\n└──      return %3"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"e7bf4493-7d01-4b19-aa20-1d41f569a6a7","type":"message","text":"<https://github.com/yuyichao/FunctionWrappers.jl|https://github.com/yuyichao/FunctionWrappers.jl>","user":"U67BJLYCS","ts":"1608928269.486500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CkL0","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/yuyichao/FunctionWrappers.jl","text":"https://github.com/yuyichao/FunctionWrappers.jl"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"5545b98c-039a-4d25-8fda-ccb275ccd549","type":"message","text":"I'm a bit confused about that package. It seems to have more to do with `ccall` than Julia functions and methods.","user":"USU9FRPEU","ts":"1608928411.486700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YmpQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm a bit confused about that package. It seems to have more to do with "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" than Julia functions and methods."}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"98952630-fedc-4473-90c1-79bb85de54c0","type":"message","text":"You can also use it to precalculate the dispatch","user":"U67BJLYCS","ts":"1608929337.487000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9VVY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can also use it to precalculate the dispatch"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"a88398fe-c9c8-4ac6-9782-91b7e0b71568","type":"message","text":"I'm currently trying something like this, although it doesn't work yet\n```using FunctionWrappers: FunctionWrapper\nusing BenchmarkTools\n\nfuncs = rand([sin, cos, tan], 100_000)\n\nwrappedfuncs = rand(FunctionWrapper{Float64,Tuple{Float64}}.([sin, cos, tan]), 100_000)\n\nftest(fs) = [f(1.0) for f in fs]\n\n@btime ftest($funcs);\n@btime ftest($wrappedfuncs);```","user":"UK1BNFHFV","ts":"1608929751.487200","team":"T68168MUP","edited":{"user":"UK1BNFHFV","ts":"1608929769.000000"},"blocks":[{"type":"rich_text","block_id":"xsVF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm currently trying something like this, although it doesn't work yet\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using FunctionWrappers: FunctionWrapper\nusing BenchmarkTools\n\nfuncs = rand([sin, cos, tan], 100_000)\n\nwrappedfuncs = rand(FunctionWrapper{Float64,Tuple{Float64}}.([sin, cos, tan]), 100_000)\n\nftest(fs) = [f(1.0) for f in fs]\n\n@btime ftest($funcs);\n@btime ftest($wrappedfuncs);"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"5591c7db-3750-4860-beed-a9d0ec45e625","type":"message","text":"the point being that the second one should be relatively fast because even if the function isn't known at compile time, it's known that they all do Float64 -&gt; Float64","user":"UK1BNFHFV","ts":"1608929836.487500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QA0ge","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the point being that the second one should be relatively fast because even if the function isn't known at compile time, it's known that they all do Float64 -> Float64"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"c440b9b4-7db4-4027-845f-ab68d3f5bde0","type":"message","text":"ah it was an 1.6 issue, fixed on FunctionWrappers#master. So with that I get\n```3.378 ms (100003 allocations: 2.29 MiB)\n2.325 ms (2 allocations: 781.33 KiB)```\nI thought the difference would be bigger, but at least it doesn't allocate so much","user":"UK1BNFHFV","ts":"1608930103.487700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jkf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah it was an 1.6 issue, fixed on FunctionWrappers#master. So with that I get\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"3.378 ms (100003 allocations: 2.29 MiB)\n2.325 ms (2 allocations: 781.33 KiB)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I thought the difference would be bigger, but at least it doesn't allocate so much"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"2e945827-fc75-4ef7-b398-78846eab1e0a","type":"message","text":"```julia&gt; trig = Union{typeof(sin),typeof(cos),typeof(tan)}\nUnion{typeof(cos), typeof(sin), typeof(tan)}\n\njulia&gt; funcs = rand(Array{trig}([sin,cos,tan]), 100_000);\n\njulia&gt; @benchmark ftest(funcs)\nBenchmarkTools.Trial:\n  memory estimate:  781.33 KiB\n  allocs estimate:  2\n  --------------\n  minimum time:     885.700 μs (0.00% GC)\n  median time:      936.300 μs (0.00% GC)\n  mean time:        961.156 μs (0.67% GC)\n  maximum time:     3.970 ms (75.64% GC)\n  --------------\n  samples:          5197\n  evals/sample:     1```\n","user":"USU9FRPEU","ts":"1608931155.487900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v8b","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> trig = Union{typeof(sin),typeof(cos),typeof(tan)}\nUnion{typeof(cos), typeof(sin), typeof(tan)}\n\njulia> funcs = rand(Array{trig}([sin,cos,tan]), 100_000);\n\njulia> @benchmark ftest(funcs)\nBenchmarkTools.Trial:\n  memory estimate:  781.33 KiB\n  allocs estimate:  2\n  --------------\n  minimum time:     885.700 μs (0.00% GC)\n  median time:      936.300 μs (0.00% GC)\n  mean time:        961.156 μs (0.67% GC)\n  maximum time:     3.970 ms (75.64% GC)\n  --------------\n  samples:          5197\n  evals/sample:     1"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"ff593936-ec4e-428f-8a01-8c7bd22ab9ab","type":"message","text":"yes if you had only these three, of course there are faster solutions. but these things are about unknown sets of functions that behave the same","user":"UK1BNFHFV","ts":"1608931261.488100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iQp3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes if you had only these three, of course there are faster solutions. but these things are about unknown sets of functions that behave the same"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"caa953a4-b89c-41c5-a211-f0336b5c8ab4","type":"message","text":"I was thinking about some discourse post about ray tracers where you have potentially infinite numbers of materials etc","user":"UK1BNFHFV","ts":"1608931313.488300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hTGAK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was thinking about some discourse post about ray tracers where you have potentially infinite numbers of materials etc"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"a2da06e5-19a5-496c-b84a-2901c310fecf","type":"message","text":"but if a material is not a struct but simply a function ray_in -&gt; ray_out then it could be type-stable to define these with FunctionWrappers","user":"UK1BNFHFV","ts":"1608931357.488500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wvciR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but if a material is not a struct but simply a function ray_in -> ray_out then it could be type-stable to define these with FunctionWrappers"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"4e1d789b-6386-4e02-b852-74765dd1f0b7","type":"message","text":"I really with FunctionWrappers had some documentation","user":"U8D9768Q6","ts":"1608936170.488700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sPh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I really with FunctionWrappers had some documentation"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"},{"client_msg_id":"b7631065-4ff3-4886-84eb-ec5f7e4ac894","type":"message","text":"FunctionWrappers are getting slower and slower <https://github.com/JuliaLang/julia/issues/36977> :disappointed:","user":"U85R3JJ8L","ts":"1608975271.001000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Y0uRi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"FunctionWrappers are getting slower and slower "},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/36977"},{"type":"text","text":" "},{"type":"emoji","name":"disappointed"}]}]}],"thread_ts":"1608914351.480500","parent_user_id":"UK1BNFHFV"}]