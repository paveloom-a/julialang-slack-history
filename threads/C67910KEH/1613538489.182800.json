[{"client_msg_id":"5da2c972-68c2-4a1f-a1d9-bddd24cb950a","type":"message","text":"Probably a basic question but I am from a stat (non CS) background trying to wrap my head around KD-Trees and I have the following:\n``` \n struct KdNode\n     point::Tuple\n     left::KdNode\n     right::KdNode\n     level::Int64\n     KdNode() = (x=new();x.left=x;x.right=x)\n end\n\n KdNode((3,5,7),nothing,nothing,2) #error no method matching..\n     ```\nHow do I initialize the first instance here in Julia? I tried stuff from <https://docs.julialang.org/en/v1/manual/constructors/#Incomplete-Initialization> but I don't think I am doing it right.","user":"U01EF0QVAB0","ts":"1613538489.182800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2NmGQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Probably a basic question but I am from a stat (non CS) background trying to wrap my head around KD-Trees and I have the following:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":" \n struct KdNode\n     point::Tuple\n     left::KdNode\n     right::KdNode\n     level::Int64\n     KdNode() = (x=new();x.left=x;x.right=x)\n end\n\n KdNode((3,5,7),nothing,nothing,2) #error no method matching..\n     "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"How do I initialize the first instance here in Julia? I tried stuff from "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/constructors/#Incomplete-Initialization"},{"type":"text","text":" but I don't think I am doing it right."}]}]}],"thread_ts":"1613538489.182800","reply_count":19,"reply_users_count":3,"latest_reply":"1613712529.248700","reply_users":["U0179G7FG4F","U01EF0QVAB0","U01FKQQ7J0J"],"subscribed":false},{"client_msg_id":"9be5087c-2177-4a5f-a048-a7e3bf5f0c1f","type":"message","text":"The key is `left::Union{KdNode,Nothing}`","user":"U0179G7FG4F","ts":"1613538627.182900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tUHhm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The key is "},{"type":"text","text":"left::Union{KdNode,Nothing}","style":{"code":true}}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0","reactions":[{"name":"+1","users":["U01EF0QVAB0"],"count":1}]},{"client_msg_id":"90ef0ec8-6534-43e0-b502-453ccd5c273d","type":"message","text":"(and the same with `right`)","user":"U0179G7FG4F","ts":"1613538634.183100","team":"T68168MUP","edited":{"user":"U0179G7FG4F","ts":"1613538647.000000"},"blocks":[{"type":"rich_text","block_id":"trjG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(and the same with "},{"type":"text","text":"right","style":{"code":true}},{"type":"text","text":")"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"a16b0ab2-eb9a-4430-a9ed-7cc4214385c3","type":"message","text":"Oh wow thanks! That was much simpler than I expected, no need for that weird last line in the struct anymore too","user":"U01EF0QVAB0","ts":"1613538824.183500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6xXP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh wow thanks! That was much simpler than I expected, no need for that weird last line in the struct anymore too"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"20763bba-6375-4dd6-a162-90873bebf6ff","type":"message","text":"You could also define inner constructor `KDNode(point::Tuple, level::Int64) = (x=new(); x.point=point; x.left=x; x.right=x; x.level=level)`.  Then I think `KdNode((3,5,7), 2)` would work.  This would avoid having to check for `nothing`, which may or may not make it easier to work with KdNode instances depending on how you use them.","user":"U01FKQQ7J0J","ts":"1613539522.184100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fN2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could also define inner constructor "},{"type":"text","text":"KDNode(point::Tuple, level::Int64) = (x=new(); x.point=point; x.left=x; x.right=x; x.level=level)","style":{"code":true}},{"type":"text","text":".  Then I think "},{"type":"text","text":"KdNode((3,5,7), 2)","style":{"code":true}},{"type":"text","text":" would work.  This would avoid having to check for "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":", which may or may not make it easier to work with KdNode instances depending on how you use them."}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"6afb5229-ed9a-479a-946f-1856f50753a8","type":"message","text":"Thanks, that doesn't give an error but when I do `a=KdNode((3,57),2)` I just get a=2. I am going to be using the KdTree for learning the kNN efficient implementation, so I think I need Nothing since that provides a way to check once you get to the end of the tree?","user":"U01EF0QVAB0","ts":"1613540919.184400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"x5K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, that doesn't give an error but when I do "},{"type":"text","text":"a=KdNode((3,57),2)","style":{"code":true}},{"type":"text","text":" I just get a=2. I am going to be using the KdTree for learning the kNN efficient implementation, so I think I need Nothing since that provides a way to check once you get to the end of the tree?"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"705564f7-5311-4aee-81c2-df26fbcc7fad","type":"message","text":"Ah, I guess the inner constructor needs to actually return the constructed instance!\n```KDNode(point::Tuple, level::Int64) = (x=new(); x.point=point; x.left=x; x.right=x; x.level=level; x)```","user":"U01FKQQ7J0J","ts":"1613541056.184700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zYFhi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, I guess the inner constructor needs to actually return the constructed instance!\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"KDNode(point::Tuple, level::Int64) = (x=new(); x.point=point; x.left=x; x.right=x; x.level=level; x)"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"2c262f5f-48a3-416d-9608-e8030cbc1fe4","type":"message","text":"To check the \" left edge\" case, you could check either `kd.left == kd` or, for the `nothing` case, `kd.left == nothing` or `isnothing(kd.left)`.  I'm not sure about the pros and cons of the two `nothing` checks. Avoiding `Union{Nothing, KdNode}` seems to keep thing simpler (assuming self-reference can only occur at \"edges\"), but maybe that's ultimately short sighted.  You'll probably know after you've picked one way and then written half the code :stuck_out_tongue_winking_eye:.","user":"U01FKQQ7J0J","ts":"1613541662.185000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"u2/K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To check the \" left edge\" case, you could check either "},{"type":"text","text":"kd.left == kd","style":{"code":true}},{"type":"text","text":" or, for the "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" case, "},{"type":"text","text":"kd.left == nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"isnothing(kd.left)","style":{"code":true}},{"type":"text","text":".  I'm not sure about the pros and cons of the two "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" checks. Avoiding "},{"type":"text","text":"Union{Nothing, KdNode}","style":{"code":true}},{"type":"text","text":" seems to keep thing simpler (assuming self-reference can only occur at \"edges\"), but maybe that's ultimately short sighted.  You'll probably know after you've picked one way and then written half the code "},{"type":"emoji","name":"stuck_out_tongue_winking_eye"},{"type":"text","text":"."}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"87443c48-063b-4590-a92a-724c6a23b800","type":"message","text":"That trick is briliant. I think it might be evil, but I kind of love it!","user":"U0179G7FG4F","ts":"1613542565.185300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fL6S+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That trick is briliant. I think it might be evil, but I kind of love it!"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"a37cad38-633a-4f8f-96d1-88599b17e7a8","type":"message","text":"I think whether it's brilliant and/or evil really depends on usage patterns (but, thanks, I'll take brilliant!).  Using the \"self-reference\" trick makes recursion a little trickier as the check for self-reference needs to be done inside the recursive function (to avoid infinite recursion).  The  `Union{Nothing, KdNode}` approach allows one to use multiple dispatch to avoid infinite recursion by providing two versions of the recursive function: one that  accepts `KdNode` (and does whatever the recursive function does) and one that accepts `Nothing` (and does nothing).  Adding the checks internally isn't too big a deal lexicographically, but I don't know what the performance implications might be (if any).","user":"U01FKQQ7J0J","ts":"1613543689.185800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Qjo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think whether it's brilliant and/or evil really depends on usage patterns (but, thanks, I'll take brilliant!).  Using the \"self-reference\" trick makes recursion a little trickier as the check for self-reference needs to be done inside the recursive function (to avoid infinite recursion).  The  "},{"type":"text","text":"Union{Nothing, KdNode}","style":{"code":true}},{"type":"text","text":" approach allows one to use multiple dispatch to avoid infinite recursion by providing two versions of the recursive function: one that  accepts "},{"type":"text","text":"KdNode","style":{"code":true}},{"type":"text","text":" (and does whatever the recursive function does) and one that accepts "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" (and does nothing).  Adding the checks internally isn't too big a deal lexicographically, but I don't know what the performance implications might be (if any)."}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"df6b6852-b130-4475-8339-4bdd870e78b3","type":"message","text":"This is a case where multiple dispatch would be really bad anyway since it will be type unstable. Your approach just saves 1 bit for the union per node.","user":"U0179G7FG4F","ts":"1613544596.186000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C9Qx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is a case where multiple dispatch would be really bad anyway since it will be type unstable. Your approach just saves 1 bit for the union per node."}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"0b842f2a-d68c-4809-bed6-923215e7f835","type":"message","text":"I'm still trying to understand what \"type stability\" means (more precisely than \"all types are known a priori\"), but I would have thought that this is a classic example of when you would want multiple dispatch.  I guess if the two recursive methods return different types, then I could see it being type unstable, but if both recursive methods return the same type, would that still be type unstable?","user":"U01FKQQ7J0J","ts":"1613545875.186200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b/m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm still trying to understand what \"type stability\" means (more precisely than \"all types are known a priori\"), but I would have thought that this is a classic example of when you would want multiple dispatch.  I guess if the two recursive methods return different types, then I could see it being type unstable, but if both recursive methods return the same type, would that still be type unstable?"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"e614c1c7-a554-4956-9b25-8347268e6a43","type":"message","text":"I think the best way to think about it is that in Julia you are always semantically calling functions. This is really slow because dispatch is complicated. However, if the compiler can figure out which method will be called, then it doesn't have to do dispatch at runtime. With the tree example, since figuring out whether a child is nothing can only happen at runtime, the compiler will have to dynamically run dispatch when you operate on the children","user":"U0179G7FG4F","ts":"1613592597.211800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AalGL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the best way to think about it is that in Julia you are always semantically calling functions. This is really slow because dispatch is complicated. However, if the compiler can figure out which method will be called, then it doesn't have to do dispatch at runtime. With the tree example, since figuring out whether a child is nothing can only happen at runtime, the compiler will have to dynamically run dispatch when you operate on the children"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"afcac833-71a1-4760-ba6b-d04553f2c4b9","type":"message","text":"Hmm so the one with the self-reference would be faster? I like the Union{Nothing,KdNode} approach at least in terms of syntax and because it seems more straightforward being a stats person (no recursion to think about-'nothing' is  how  it looks on paper too)","user":"U01EF0QVAB0","ts":"1613620839.217200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bOm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm so the one with the self-reference would be faster? I like the Union{Nothing,KdNode} approach at least in terms of syntax and because it seems more straightforward being a stats person (no recursion to think about-'nothing' is  how  it looks on paper too)"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"cc9ea395-8ca4-47ac-be4b-d60f4e0fded1","type":"message","text":"Neither way is inherently \"wrong\", so I'd suggest starting with whatever feels the most natural to you.  If you wanted to really get into it, you could create an `AbstractKdNode` abstract type and then `SelfRefEdgeKdNode` and `NothingEdgeKdNode` structs as subtypes (one for each approach).  You'd probably learn a lot about Julia, but it might distract from your statistics work :sweat_smile:","user":"U01FKQQ7J0J","ts":"1613625789.218500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kz3L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Neither way is inherently \"wrong\", so I'd suggest starting with whatever feels the most natural to you.  If you wanted to really get into it, you could create an "},{"type":"text","text":"AbstractKdNode","style":{"code":true}},{"type":"text","text":" abstract type and then "},{"type":"text","text":"SelfRefEdgeKdNode","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"NothingEdgeKdNode","style":{"code":true}},{"type":"text","text":" structs as subtypes (one for each approach).  You'd probably learn a lot about Julia, but it might distract from your statistics work "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"a4524e27-4d4c-49c7-a75f-0388c6cce687","type":"message","text":"Thanks for the type instability explanation <@U0179G7FG4F>.  It helps, though I still have a ways to go to feel confident in my understanding of it.","user":"U01FKQQ7J0J","ts":"1613625996.218700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z9QUV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the type instability explanation "},{"type":"user","user_id":"U0179G7FG4F"},{"type":"text","text":".  It helps, though I still have a ways to go to feel confident in my understanding of it."}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"6c619e94-3e7e-4461-91ec-4f8633ac9160","type":"message","text":"Haha I am actually trying to learn data structures and algs as that is a big hole for me I feel. I have to say this CS stuff is much much harder for me than anything I have seen in stats (or statistical ML). But could just be my background. Some CS people are actually surprised that you can do ML without this lol, its always funny how that field consider it more fundamental while stats doesn't. But I had no idea that these things are under the surface of making stuff like kNN,K Means, DBSCAN a lot faster as in stats we only learn the naive implementation.","user":"U01EF0QVAB0","ts":"1613712189.248100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NhC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Haha I am actually trying to learn data structures and algs as that is a big hole for me I feel. I have to say this CS stuff is much much harder for me than anything I have seen in stats (or statistical ML). But could just be my background. Some CS people are actually surprised that you can do ML without this lol, its always funny how that field consider it more fundamental while stats doesn't. But I had no idea that these things are under the surface of making stuff like kNN,K Means, DBSCAN a lot faster as in stats we only learn the naive implementation."}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"1158ada6-d2c3-4b22-990a-ba881fd4baf2","type":"message","text":"every field is a rabbit hole entire to itself. Enjoy the forest of all knowledge :slightly_smiling_face:","user":"U0179G7FG4F","ts":"1613712416.248300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eyQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"every field is a rabbit hole entire to itself. Enjoy the forest of all knowledge "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"cc1140ee-911a-4e85-8339-9ab77368a04d","type":"message","text":"Yeah, I think it's fairly common for people to learn just enough about fields adjacent to their own to be dangerous","user":"U01FKQQ7J0J","ts":"1613712445.248500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b4LY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I think it's fairly common for people to learn just enough about fields adjacent to their own to be dangerous"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"1e50a46b-5707-4492-93e0-0bf08c7961dc","type":"message","text":"I'm sure stats people shudder when CS people start throwing around stats :grimacing:","user":"U01FKQQ7J0J","ts":"1613712529.248700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OKpW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm sure stats people shudder when CS people start throwing around stats "},{"type":"emoji","name":"grimacing"}]}]}],"thread_ts":"1613538489.182800","parent_user_id":"U01EF0QVAB0"}]