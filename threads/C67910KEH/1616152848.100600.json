[{"client_msg_id":"58cd9231-dfcf-4d6d-aced-11601a15f046","type":"message","text":"Is it possible to \"pin\" an artifact version using artifacts/Overrides.toml?","user":"U756M0EB0","ts":"1616152848.100600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8OS4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it possible to \"pin\" an artifact version using artifacts/Overrides.toml?"}]}]}],"thread_ts":"1616152848.100600","reply_count":24,"reply_users_count":3,"latest_reply":"1616358384.210000","reply_users":["UDB26738Q","U756M0EB0","U68A3ASP9"],"subscribed":false},{"client_msg_id":"a51e0231-5cef-4dbe-a801-42ba7d5946cd","type":"message","text":"not sure what you mean :thinking_face:","user":"UDB26738Q","ts":"1616152944.100700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sEqLj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"not sure what you mean "},{"type":"emoji","name":"thinking_face"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"23abd2c8-6909-4409-8da3-a3cfb9416762","type":"message","text":"I mean, let prevent an artifact from updating. For example to include something like the CUDA artifacts in a software container, but preventing Jula from suddenly installing a never CUDA version in everyone's home directory when CUDA.jll is updated.","user":"U756M0EB0","ts":"1616153051.100900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9dvU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, let prevent an artifact from updating. For example to include something like the CUDA artifacts in a software container, but preventing Jula from suddenly installing a never CUDA version in everyone's home directory when CUDA.jll is updated."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"3f9b6c9d-ea6a-4f4f-b859-bb7f9776afa0","type":"message","text":"I guess you can point the artifact dir to another artifact dir: <https://docs.binarybuilder.org/dev/jll/#Non-dev'ed-JLL-packages> just note that the \"old\" artifact dir may be cleaned out by `]gc`","user":"UDB26738Q","ts":"1616153136.101100","team":"T68168MUP","edited":{"user":"UDB26738Q","ts":"1616153268.000000"},"blocks":[{"type":"rich_text","block_id":"=OQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess you can point the artifact dir to another artifact dir: "},{"type":"link","url":"https://docs.binarybuilder.org/dev/jll/#Non-dev'ed-JLL-packages"},{"type":"text","text":" just note that the \"old\" artifact dir may be cleaned out by "},{"type":"text","text":"]gc","style":{"code":true}}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"4aaf2928-b9b7-4b09-b4df-86d8c7a902d2","type":"message","text":"(I believe `CUDA.jl` doesn't use JLLs, but the instructions there apply to any package, JLLs are no special)","user":"UDB26738Q","ts":"1616153174.101300","team":"T68168MUP","edited":{"user":"UDB26738Q","ts":"1616153204.000000"},"blocks":[{"type":"rich_text","block_id":"b93","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(I believe "},{"type":"text","text":"CUDA.jl","style":{"code":true}},{"type":"text","text":" doesn't use JLLs, but the instructions there apply to any package, JLLs are no special)"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"d018d2e8-9f36-4a47-b8a7-56dce2966f92","type":"message","text":"Hm, those artifacts would be in julia/local/share, which would not be on the user's JULIA_DEPOT_PATH, so I hope gc would stay away from it ...","user":"U756M0EB0","ts":"1616153309.101700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6zr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hm, those artifacts would be in julia/local/share, which would not be on the user's JULIA_DEPOT_PATH, so I hope gc would stay away from it ..."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"5ee51362-69bc-43b2-bd2c-176acb1017da","type":"message","text":"CUDA does use .jlls now (if you don't set `JULIA_CUDA_USE_BINARYBUILDER=\"false\"`)","user":"U756M0EB0","ts":"1616153370.101900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pI1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"CUDA does use .jlls now (if you don't set "},{"type":"text","text":"JULIA_CUDA_USE_BINARYBUILDER=\"false\"","style":{"code":true}},{"type":"text","text":")"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"f1fbfda1-6263-4f94-b9c9-9716607d647a","type":"message","text":"I don't think so.  it has its own `Artifacts.toml`: <https://github.com/JuliaGPU/CUDA.jl/blob/451a338789439b5fad5dcc76ab72c143a113ade2/Artifacts.toml>","user":"UDB26738Q","ts":"1616153438.102100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+a1Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think so.  it has its own "},{"type":"text","text":"Artifacts.toml","style":{"code":true}},{"type":"text","text":": "},{"type":"link","url":"https://github.com/JuliaGPU/CUDA.jl/blob/451a338789439b5fad5dcc76ab72c143a113ade2/Artifacts.toml"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"c98ea2f8-6e17-4763-b404-38c5d833de67","type":"message","text":"Ah, yes - it installs them later, on the fly, then the first CuArray is instantiated.","user":"U756M0EB0","ts":"1616153511.102300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yTJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, yes - it installs them later, on the fly, then the first CuArray is instantiated."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"7bae903b-9f1c-4e50-87ac-6b60733dd832","type":"message","text":"But it's still .jll artifacts, from what I understand.","user":"U756M0EB0","ts":"1616153635.102500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wqK88","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it's still .jll artifacts, from what I understand."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"1b78c263-9ff2-47cd-8666-566124b7be61","type":"message","text":"it's a tarball generated in Yggdrasil, if that's what you mean :slightly_smiling_face:","user":"UDB26738Q","ts":"1616154373.102900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EZcu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it's a tarball generated in Yggdrasil, if that's what you mean "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"153394ca-296c-4585-8b47-a67e93811635","type":"message","text":"just not a \"standard JLL package\"","user":"UDB26738Q","ts":"1616154393.103100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xS2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"just not a \"standard JLL package\""}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"8abcb8b5-6620-4216-831d-7430290a041b","type":"message","text":"But you can actually make a Project.toml with\n\n```[deps]\nCUDA_jll = \"e9e359dc-d701-5aa8-82ae-09bbf812ea83\"\n\n[compat]\nCUDA_jll = \"11.2.2\"```\nwhich, when instantiated,  will install CUDA.jll in artifacts.","user":"U756M0EB0","ts":"1616154471.103300","team":"T68168MUP","edited":{"user":"U756M0EB0","ts":"1616154490.000000"},"blocks":[{"type":"rich_text","block_id":"3z5x8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But you can actually make a Project.toml with\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"[deps]\nCUDA_jll = \"e9e359dc-d701-5aa8-82ae-09bbf812ea83\"\n\n[compat]\nCUDA_jll = \"11.2.2\""}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which, when instantiated,  will install CUDA.jll in artifacts."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"2f787bc7-a276-4f7f-b279-ecb3c50264c7","type":"message","text":"But I think you're right, of course, with CUDA, and Overrides.toml would probably not be a good solution.","user":"U756M0EB0","ts":"1616154834.103600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Eqp4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I think you're right, of course, with CUDA, and Overrides.toml would probably not be a good solution."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"4f3e7f5c-2e7e-49ff-8365-02312ebfa0ca","type":"message","text":"no wait, it should work also for `CUDA.jl`.  as I said, JLLs are no special","user":"UDB26738Q","ts":"1616155431.103900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7KQmf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no wait, it should work also for "},{"type":"text","text":"CUDA.jl","style":{"code":true}},{"type":"text","text":".  as I said, JLLs are no special"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"7f5ba196-9ecd-44d5-8edb-c6f79f87aa3a","type":"message","text":"Yes, but since CUDA loads them on the fly, it may ask for a completely different package than the one I have in overrides (e.g. for CUDNN_CUDA111_jll, but I have CUDNN_CUDA112_jll installed). So for CUDA, I probably have to use CUDA.jl's own override mechanism.\n\nBut for other things like HDF5, Cuba, etc. your way just work, right?","user":"U756M0EB0","ts":"1616155680.104100","team":"T68168MUP","edited":{"user":"U756M0EB0","ts":"1616155706.000000"},"blocks":[{"type":"rich_text","block_id":"Vk4jp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, but since CUDA loads them on the fly, it may ask for a completely different package than the one I have in overrides (e.g. for CUDNN_CUDA111_jll, but I have CUDNN_CUDA112_jll installed). So for CUDA, I probably have to use CUDA.jl's own override mechanism.\n\nBut for other things like HDF5, Cuba, etc. your way just work, right?"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"f55fd80d-91c9-4b13-b1b4-c248d7725585","type":"message","text":"yes, it should,  but for JLLs you can also pin a version in the Manifest (if you have a manifest)","user":"UDB26738Q","ts":"1616155805.104400","team":"T68168MUP","edited":{"user":"UDB26738Q","ts":"1616155814.000000"},"blocks":[{"type":"rich_text","block_id":"Oa3W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, it should,  but for JLLs you can also pin a version in the Manifest (if you have a manifest)"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"0fbba19c-c4b4-4bf5-98df-f2e3b5823a1d","type":"message","text":"Yes, but the users may their own manifests with additional packages, that's why I want to pin globally (as far as the container is concerned).","user":"U756M0EB0","ts":"1616156081.104700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FbY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, but the users may their own manifests with additional packages, that's why I want to pin globally (as far as the container is concerned)."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0","reactions":[{"name":"+1","users":["UDB26738Q"],"count":1}]},{"client_msg_id":"eb404deb-209c-4c30-a16a-e095a572e334","type":"message","text":"I guess CUDA.jl should support the \"bound artifact name\" override mechanism as documented in <https://pkgdocs.julialang.org/v1/artifacts/#Overriding-artifact-locations>, but I'm not sure how that works; I assume that's taken care of by the generated JLL wrapper (which we don't use)","user":"U68A3ASP9","ts":"1616190241.125800","team":"T68168MUP","edited":{"user":"U68A3ASP9","ts":"1616190249.000000"},"blocks":[{"type":"rich_text","block_id":"O4ku","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess CUDA.jl should support the \"bound artifact name\" override mechanism as documented in "},{"type":"link","url":"https://pkgdocs.julialang.org/v1/artifacts/#Overriding-artifact-locations"},{"type":"text","text":", but I'm not sure how that works; I assume that's taken care of by the generated JLL wrapper (which we don't use)"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"f7e10b9e-beef-429a-8ec3-5e259339bb21","type":"message","text":"No, that's a generic Pkg mechanism. Again, JLLs are no special :slightly_smiling_face:","user":"UDB26738Q","ts":"1616191361.126200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1lQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, that's a generic Pkg mechanism. Again, JLLs are no special "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"570673fb-346a-4334-9ee5-cd77710c4790","type":"message","text":"I think I can work with `JULIA_CUDA_USE_BINARYBUILDER` and `CUDA_PATH`, though. <@U68A3ASP9>, is it possible to specifiy separates paths for CUDA, CuDNN, and CuTENSOR?","user":"U756M0EB0","ts":"1616234393.136900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dpC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think I can work with "},{"type":"text","text":"JULIA_CUDA_USE_BINARYBUILDER","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"CUDA_PATH","style":{"code":true}},{"type":"text","text":", though. "},{"type":"user","user_id":"U68A3ASP9"},{"type":"text","text":", is it possible to specifiy separates paths for CUDA, CuDNN, and CuTENSOR?"}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"a0f82d0d-dc7c-45d5-ba1f-a1e596c4e79f","type":"message","text":"Or can I tell CUDA.jl which versions of these I want? Then I could install the jll's system-wide (resp. container-image-wide) and be sure that a new release of CUDA.jl doesn't suddenly try to pull in different versions.","user":"U756M0EB0","ts":"1616234559.137100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0E2CL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or can I tell CUDA.jl which versions of these I want? Then I could install the jll's system-wide (resp. container-image-wide) and be sure that a new release of CUDA.jl doesn't suddenly try to pull in different versions."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"efdbbc42-20db-4d87-9a05-b5eb09881bfb","type":"message","text":"I'm actually hoping to get rid of all this system library detection mess, as it's really complicated to use; Overrides would then be the mechanism to select a system CUDA. so no, it's not possible to do that with fine-grained paths like that. the detection does however always fall back to looking in system libraries (i.e. what's confiured in `/etc/ld.so.conf`), so you can always add paths there.","user":"U68A3ASP9","ts":"1616267985.154900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xa47","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm actually hoping to get rid of all this system library detection mess, as it's really complicated to use; Overrides would then be the mechanism to select a system CUDA. so no, it's not possible to do that with fine-grained paths like that. the detection does however always fall back to looking in system libraries (i.e. what's confiured in "},{"type":"text","text":"/etc/ld.so.conf","style":{"code":true}},{"type":"text","text":"), so you can always add paths there."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"64596c93-c3f6-4ed9-b4ff-45c4079d4090","type":"message","text":"Thanks for the info! For now, I just build my containers with system CUDA libs anyhow, which works fine. Using Julia-provided libs might be interesting,  long-term, though.","user":"U756M0EB0","ts":"1616323091.181800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5/8r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the info! For now, I just build my containers with system CUDA libs anyhow, which works fine. Using Julia-provided libs might be interesting,  long-term, though."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"},{"client_msg_id":"4844ba4b-42b9-4c35-bcc1-5c5aaef83b73","type":"message","text":"it ensures the specific combination is somewhat better tested, but I get that it isn't an option on all hardware platforms.","user":"U68A3ASP9","ts":"1616358384.210000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Yz7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it ensures the specific combination is somewhat better tested, but I get that it isn't an option on all hardware platforms."}]}]}],"thread_ts":"1616152848.100600","parent_user_id":"U756M0EB0"}]