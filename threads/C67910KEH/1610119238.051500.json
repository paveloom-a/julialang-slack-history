[{"client_msg_id":"f41f1579-7ab2-4d6f-bff5-2814414e2ff5","type":"message","text":"\"just standard dispatch\": so have one method for each of `Union{Int8, UInt8, Int16, UInt16, ... }` (where the list goes either up to Int32 or Int64, depending on whether the system is 32 or 64 bit) ? Yeah, I have that right now, but the thing is that this doesn't deal with other integer types, though, such as <https://github.com/JeffreySarnoff/SaferIntegers.jl|SaferIntegers>? Checking `sizeof(x)` would of course work for bit types -- but not necessarily for custom types... I also thought about `typemax` / `typemin` as in `typemin(Int) &lt;= typemin(T) &amp;&amp; typemax(T) &lt;= typemax(Int)` but those are not available for BigInt ...","user":"U012FH66MFW","ts":"1610119238.051500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IzP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"\"just standard dispatch\": so have one method for each of "},{"type":"text","text":"Union{Int8, UInt8, Int16, UInt16, ... }","style":{"code":true}},{"type":"text","text":" (where the list goes either up to Int32 or Int64, depending on whether the system is 32 or 64 bit) ? Yeah, I have that right now, but the thing is that this doesn't deal with other integer types, though, such as "},{"type":"link","url":"https://github.com/JeffreySarnoff/SaferIntegers.jl","text":"SaferIntegers"},{"type":"text","text":"? Checking "},{"type":"text","text":"sizeof(x)","style":{"code":true}},{"type":"text","text":" would of course work for bit types -- but not necessarily for custom types... I also thought about "},{"type":"text","text":"typemax","style":{"code":true}},{"type":"text","text":" / "},{"type":"text","text":"typemin","style":{"code":true}},{"type":"text","text":" as in "},{"type":"text","text":"typemin(Int) <= typemin(T) && typemax(T) <= typemax(Int)","style":{"code":true}},{"type":"text","text":" but those are not available for BigInt ..."}]}]}],"thread_ts":"1610119238.051500","reply_count":32,"reply_users_count":7,"latest_reply":"1610212591.139200","reply_users":["UD0NS8PDF","U67D54KS8","U012FH66MFW","UH24GRBLL","U6QPTG69E","U67BJLYCS","U68QW0PUZ"],"subscribed":false},{"client_msg_id":"ce74aa10-aacb-4b58-99e8-6bc174531c71","type":"message","text":"There is `Base.HWReal`, perhaps reject floats afterwards. Would your C function accept things not on that list, like custom integer types?","user":"UD0NS8PDF","ts":"1610119379.052200","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1610119477.000000"},"blocks":[{"type":"rich_text","block_id":"/EQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is "},{"type":"text","text":"Base.HWReal","style":{"code":true}},{"type":"text","text":", perhaps reject floats afterwards. Would your C function accept things not on that list, like custom integer types?"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"8b37ec4d-057b-43b5-be8b-9b3b0bb18d00","type":"message","text":"Well, you need to be able to write down unambigously a criteria for what type you want to dispatch to what specific c function.","user":"U67D54KS8","ts":"1610119545.052500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W12xM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well, you need to be able to write down unambigously a criteria for what type you want to dispatch to what specific c function."}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"8f4bbb62-bad2-40a8-813a-f4309f6e44a4","type":"message","text":"no, the idea is that anything that fits into an `Int` is converted to `Int` and then passed to the first C function; everything else is converted to `BigInt` and passed to the second C function. Of course if an integer type does not provide the relevant conversion, it won't work either, but yeah, there's only so far I can go :wink:","user":"U012FH66MFW","ts":"1610119555.052700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HMZt0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no, the idea is that anything that fits into an "},{"type":"text","text":"Int","style":{"code":true}},{"type":"text","text":" is converted to "},{"type":"text","text":"Int","style":{"code":true}},{"type":"text","text":" and then passed to the first C function; everything else is converted to "},{"type":"text","text":"BigInt","style":{"code":true}},{"type":"text","text":" and passed to the second C function. Of course if an integer type does not provide the relevant conversion, it won't work either, but yeah, there's only so far I can go "},{"type":"emoji","name":"wink"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"a535eb2a-ea8f-4fdf-9604-edc73d3c8bae","type":"message","text":"I was thinking more like `f(::BigInt)` and `f(::Integer)`","user":"UH24GRBLL","ts":"1610119556.052900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"807yw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was thinking more like "},{"type":"text","text":"f(::BigInt)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"f(::Integer)","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"6d3490cf-ccd7-4108-9974-815fa46f3b95","type":"message","text":"right now, I have `f(::Int)` and `f(::BigInt)`, and `f(x::Integer) = f(BigInt(x))`","user":"U012FH66MFW","ts":"1610119593.053100","team":"T68168MUP","edited":{"user":"U012FH66MFW","ts":"1610119603.000000"},"blocks":[{"type":"rich_text","block_id":"AjKf6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"right now, I have "},{"type":"text","text":"f(::Int)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"f(::BigInt)","style":{"code":true}},{"type":"text","text":", and "},{"type":"text","text":"f(x::Integer) = f(BigInt(x))","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"cac06e0a-a467-4e65-864c-ddccf389d378","type":"message","text":"but that leaves performance on the table for e.g. `f(Int16(0))`","user":"U012FH66MFW","ts":"1610119621.053400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j10l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but that leaves performance on the table for e.g. "},{"type":"text","text":"f(Int16(0))","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"45507617-4083-4199-ae95-682ae1ffc77b","type":"message","text":"why not `f(x::Integer) = f(Int(x))`?","user":"UH24GRBLL","ts":"1610119690.053700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nIoL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"why not "},{"type":"text","text":"f(x::Integer) = f(Int(x))","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"62acb864-7db8-4f1d-823c-57c191468ae6","type":"message","text":"of course I can add `f(::Int8)` etc. -- or rather, `f(::Union{Int8, UInt8, ... Int32, UInt32}) = f(Int(x))` (assuming a 64bit system)","user":"U012FH66MFW","ts":"1610119694.053900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YFLY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"of course I can add "},{"type":"text","text":"f(::Int8)","style":{"code":true}},{"type":"text","text":" etc. -- or rather, "},{"type":"text","text":"f(::Union{Int8, UInt8, ... Int32, UInt32}) = f(Int(x))","style":{"code":true}},{"type":"text","text":" (assuming a 64bit system)"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"cfcf99cf-47e2-49cf-a609-a3c3b082a193","type":"message","text":"&gt; so have one method for each of Union{Int8, UInt8, Int16, UInt16, ... }\nNote that `ccall` will take care of conversion, e.g. only one method taking this `Union` is enough, provided they can be converted to the type declared in the `ccall`, e.g. in \"base/gmp.jl\":\n`*(x::BigInt, c::ClongMax) = MPZ.mul_si(x, c)`","user":"U6QPTG69E","ts":"1610119698.054100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ozZu","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"so have one method for each of Union{Int8, UInt8, Int16, UInt16, ... }"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nNote that "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" will take care of conversion, e.g. only one method taking this "},{"type":"text","text":"Union","style":{"code":true}},{"type":"text","text":" is enough, provided they can be converted to the type declared in the "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":", e.g. in \"base/gmp.jl\":\n"},{"type":"text","text":"*(x::BigInt, c::ClongMax) = MPZ.mul_si(x, c)","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"82457cf6-55ed-4d82-baab-f4414724e6b0","type":"message","text":"imo you'll have to special case SaferIntegers anyway, since they're not `&lt;: Signed` and `&lt;: Unsigned` but just `&lt;: Integer`","user":"UH24GRBLL","ts":"1610119774.054300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"unoU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"imo you'll have to special case SaferIntegers anyway, since they're not "},{"type":"text","text":"<: Signed","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"<: Unsigned","style":{"code":true}},{"type":"text","text":" but just "},{"type":"text","text":"<: Integer","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"dcff3b60-e712-471e-8ea3-19553b0fbcc3","type":"message","text":"<@UH24GRBLL> that would either loose bits or throw an exception? Of course I could catch that exception, but that'd defeat the idea of optimizing things?","user":"U012FH66MFW","ts":"1610119780.054500","team":"T68168MUP","edited":{"user":"U012FH66MFW","ts":"1610120010.000000"},"blocks":[{"type":"rich_text","block_id":"e6s4R","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UH24GRBLL"},{"type":"text","text":" that would either loose bits or throw an exception? Of course I could catch that exception, but that'd defeat the idea of optimizing things?"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"263f9b0c-1207-4da7-8f55-1f4ae90beae4","type":"message","text":"&gt; but those are not available for BigInt ...\nThere is an unexported trait which can help in these situtations: `Base.hastypemax`","user":"U6QPTG69E","ts":"1610119782.054700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mZbJN","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"but those are not available for BigInt ..."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThere is an unexported trait which can help in these situtations: "},{"type":"text","text":"Base.hastypemax","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"be94322e-28c4-4ee6-a768-d16ac2012356","type":"message","text":"<@U6QPTG69E> that misses the point, though -- I want to convert to `Int` whenever I can (= when the data fits) and then `ccall` one function. If this is not possible, I instead convert to `BigInt` (as any integer should fit there) and call a different C function","user":"U012FH66MFW","ts":"1610119826.054900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Is1/","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6QPTG69E"},{"type":"text","text":" that misses the point, though -- I want to convert to "},{"type":"text","text":"Int","style":{"code":true}},{"type":"text","text":" whenever I can (= when the data fits) and then "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" one function. If this is not possible, I instead convert to "},{"type":"text","text":"BigInt","style":{"code":true}},{"type":"text","text":" (as any integer should fit there) and call a different C function"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"3bc1593b-83db-4022-8cd0-9ff79da48c59","type":"message","text":"I guess what I really need is something like a `typesup` / `typeinf` to return the supremum / infimum of what a type can store, then for `BigInt` those could return +/- infinity :slightly_smiling_face:","user":"U012FH66MFW","ts":"1610119931.055100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4wID","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess what I really need is something like a "},{"type":"text","text":"typesup","style":{"code":true}},{"type":"text","text":" / "},{"type":"text","text":"typeinf","style":{"code":true}},{"type":"text","text":" to return the supremum / infimum of what a type can store, then for "},{"type":"text","text":"BigInt","style":{"code":true}},{"type":"text","text":" those could return +/- infinity "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"f8f1d8fd-c6b7-4c01-85b0-706cf1159032","type":"message","text":"<@UH24GRBLL> =|= <@U67BJLYCS>","user":"U67BJLYCS","ts":"1610119972.055500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jbj","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UH24GRBLL"},{"type":"text","text":" =|= "},{"type":"user","user_id":"U67BJLYCS"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW","reactions":[{"name":"man-bowing","users":["U012FH66MFW"],"count":1}]},{"client_msg_id":"677f79a8-3748-4072-94b2-b455de08c426","type":"message","text":"I was just responding to specific points. But I think I would do smthg like `f(x::T) where {T&lt;:Integer} = hastypemax(T) &amp;&amp; typemin(Int) &lt;= typemin(T) &amp;&amp; typemax(Int) &gt;= typemax(T) ? f(Int(x)) : f(BigInt(x))`","user":"U6QPTG69E","ts":"1610119984.055700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KTU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was just responding to specific points. But I think I would do smthg like "},{"type":"text","text":"f(x::T) where {T<:Integer} = hastypemax(T) && typemin(Int) <= typemin(T) && typemax(Int) >= typemax(T) ? f(Int(x)) : f(BigInt(x))","style":{"code":true}}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"833c8f9f-d283-4e58-a454-a139e839f396","type":"message","text":"yeah, that would then at least be extensible from the outside","user":"U012FH66MFW","ts":"1610120051.056100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kmvPc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, that would then at least be extensible from the outside"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"42cb4bd1-8605-47f8-9f10-ce9ced2c2b1a","type":"message","text":"I am always a bit wary to use undocumented features, though -- they tend to break or go away... :slightly_smiling_face:","user":"U012FH66MFW","ts":"1610120078.056300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M16tV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am always a bit wary to use undocumented features, though -- they tend to break or go away... "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"974d7c29-2faf-4fac-a6e5-a9bbdf54927d","type":"message","text":"Absolutely! But at least here `hastypemax` is fairly simple to implement oneself if it goes away from `Base`.","user":"U6QPTG69E","ts":"1610120162.057000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q6jSa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Absolutely! But at least here "},{"type":"text","text":"hastypemax","style":{"code":true}},{"type":"text","text":" is fairly simple to implement oneself if it goes away from "},{"type":"text","text":"Base","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"18bb02a7-e982-4389-8174-25ab0bc494df","type":"message","text":"then I think your problem is underspecified - are large UInts also supposed to be converted to BigInt?","user":"UH24GRBLL","ts":"1610120179.057200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9O+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"then I think your problem is underspecified - are large UInts also supposed to be converted to BigInt?"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"a32a5d5c-384e-42ae-9880-d12ce15ac36b","type":"message","text":"yes. I do think it is well-specified, though, <@U6QPTG69E> just wrote down a nice solution","user":"U012FH66MFW","ts":"1610120207.057400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nNbxm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes. I do think it is well-specified, though, "},{"type":"user","user_id":"U6QPTG69E"},{"type":"text","text":" just wrote down a nice solution"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"7a696391-8239-42de-b267-aae7cd105dd7","type":"message","text":"<@U6QPTG69E> sure! And I can always try to petition for it to be made official :wink:","user":"U012FH66MFW","ts":"1610120226.057600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7+A","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6QPTG69E"},{"type":"text","text":" sure! And I can always try to petition for it to be made official "},{"type":"emoji","name":"wink"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"ea40c4bd-4171-49d2-9b7d-d550db0109a2","type":"message","text":"yeah, if that's the case there's no getting around checking the value","user":"UH24GRBLL","ts":"1610120234.057800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=9LP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, if that's the case there's no getting around checking the value"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"8c251bb5-abfd-4915-ab8b-bc4d07ce5d7f","type":"message","text":"no","user":"U012FH66MFW","ts":"1610120240.058000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1hC7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"acbce88b-2124-41a2-a557-5510c5d32c34","type":"message","text":"ah, misunderstood, any UInt should be BigInt as well","user":"UH24GRBLL","ts":"1610120260.058200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SfRs=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah, misunderstood, any UInt should be BigInt as well"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"d095f7f1-cf57-42a1-a1b1-241634210122","type":"message","text":"the value is not checked, the type is checked; using typemin/typemax ; for UInt, that would yield that it does *not* fit into an Int","user":"U012FH66MFW","ts":"1610120261.058400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1WLy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the value is not checked, the type is checked; using typemin/typemax ; for UInt, that would yield that it does "},{"type":"text","text":"not","style":{"bold":true}},{"type":"text","text":" fit into an Int"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"ec99622c-3390-475e-8d69-e0738e398dbb","type":"message","text":"I am now doing this, and it seems to work fine:\n```issmallinttype(::Any) = false\nissmallinttype(::Type{T}) where {T&lt;:Integer} = Base.hastypemax(T) &amp;&amp; typemin(Int) &lt;= typemin(T) &amp;&amp; typemax(Int) &gt;= typemax(T)```","user":"U012FH66MFW","ts":"1610120409.058600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nrd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am now doing this, and it seems to work fine:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"issmallinttype(::Any) = false\nissmallinttype(::Type{T}) where {T<:Integer} = Base.hastypemax(T) && typemin(Int) <= typemin(T) && typemax(Int) >= typemax(T)"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"7fde7b80-045b-4758-afbc-f13fb7e7c477","type":"message","text":"can your Int C-function also handle 64-bit integers on 32-bit systems?","user":"UH24GRBLL","ts":"1610120454.058800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BoA+k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"can your Int C-function also handle 64-bit integers on 32-bit systems?"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"c9513d57-9898-43af-8f99-780696a344a4","type":"message","text":"if I read it correctly, that will cause 64-bit integers on 32-bit systems to be converted to BigInt","user":"UH24GRBLL","ts":"1610120493.059000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FC6LO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if I read it correctly, that will cause 64-bit integers on 32-bit systems to be converted to BigInt"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"708e33c5-3f07-438d-8d43-95d9503efdd1","type":"message","text":"don't know if that's what you want though","user":"UH24GRBLL","ts":"1610120532.059300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fS5a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"don't know if that's what you want though"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"ACAEFA20-307C-4BAE-AB1E-FE9959A0D845","type":"message","text":"It is what I want :-). It'd be of course trivial to adjust it either way (eg I could compare to Int64 instead of Int)","user":"U012FH66MFW","ts":"1610122930.065800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pk+v0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It is what I want :-). It'd be of course trivial to adjust it either way (eg I could compare to Int64 instead of Int)"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"},{"client_msg_id":"c3460c8a-978d-484a-af23-90e74095a3b0","type":"message","text":"currently SaferIntegers has\n```abstract type SafeInteger  &lt;: Integer     end\nabstract type SafeUnsigned &lt;: SafeInteger end\nabstract type SafeSigned   &lt;: SafeInteger end```\nI could change this to\n```abstract type SafeUnsigned &lt;: Unsigned end\nabstract type SafeSigned   &lt;: Signed end```\nwhich may indeed be a better approach","user":"U68QW0PUZ","ts":"1610212591.139200","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1610212706.000000"},"blocks":[{"type":"rich_text","block_id":"1tRoL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"currently SaferIntegers has\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"abstract type SafeInteger  <: Integer     end\nabstract type SafeUnsigned <: SafeInteger end\nabstract type SafeSigned   <: SafeInteger end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I could change this to\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"abstract type SafeUnsigned <: Unsigned end\nabstract type SafeSigned   <: Signed end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which may indeed be a better approach"}]}]}],"thread_ts":"1610119238.051500","parent_user_id":"U012FH66MFW"}]