[{"client_msg_id":"3dfcf663-292e-4a31-a0f0-7ecb4c05a6e5","type":"message","text":"Hi, not sure if this is the right place to post, but just published a blogpost comparing Julia with R and Python and would like to share it with you. Any feedback is welcome. Thanks! (open access) <https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab>","user":"ULZCQ1RPB","ts":"1616504538.253500","team":"T68168MUP","attachments":[{"service_name":"Medium","title":"R vs. Python vs. Julia","title_link":"https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab","text":"How easy it is to write efficient code?","fallback":"Medium: R vs. Python vs. Julia","image_url":"https://miro.medium.com/max/1200/1*iu6-cGb4KpEzyd7djVI3lw.jpeg","fields":[{"title":"Reading time","value":"6 min read","short":true}],"ts":1616502636,"from_url":"https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab","image_width":381,"image_height":250,"image_bytes":355657,"service_icon":"https://miro.medium.com/fit/c/152/152/1*sHhtYhaCe2Uc3IU0IgKwIQ.png","id":1,"original_url":"https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab"}],"blocks":[{"type":"rich_text","block_id":"E3vxl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi, not sure if this is the right place to post, but just published a blogpost comparing Julia with R and Python and would like to share it with you. Any feedback is welcome. Thanks! (open access) "},{"type":"link","url":"https://towardsdatascience.com/r-vs-python-vs-julia-90456a2bcbab"}]}]}],"thread_ts":"1616504538.253500","reply_count":20,"reply_users_count":5,"latest_reply":"1616522481.268200","reply_users":["UDB26738Q","U7HAYKY9X","UH24GRBLL","ULZCQ1RPB","UH8A351DJ"],"subscribed":false,"reactions":[{"name":"+1","users":["UGU761DU2","UR75SQMCZ","U013V2CFZAN","ULP7K652M","UCAFZ51L3"],"count":5},{"name":"+1::skin-tone-5","users":["U6QGE7S86"],"count":1}]},{"client_msg_id":"d4562531-3fb7-4fa9-8dbd-bc119a2f7e88","type":"message","text":"&gt; Still, you need to know what you are doing. \ncouldn't agree more!  nice article overall!","user":"UDB26738Q","ts":"1616504925.253700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aAK","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Still, you need to know what you are doing. "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\ncouldn't agree more!  nice article overall!"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB","reactions":[{"name":"smile","users":["ULZCQ1RPB"],"count":1}]},{"client_msg_id":"76ec501f-d6bc-4080-92da-23aab76c85e2","type":"message","text":"Nice article. Minor comment: `vec_search(vec, x) = any(vec .== x)` is better implemented as `vec_search(vec, x) = any(==(x), vec)` . That should bring it in line with the other approaches","user":"U7HAYKY9X","ts":"1616505372.254000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+z7b/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Nice article. Minor comment: "},{"type":"text","text":"vec_search(vec, x) = any(vec .== x)","style":{"code":true}},{"type":"text","text":" is better implemented as "},{"type":"text","text":"vec_search(vec, x) = any(==(x), vec)","style":{"code":true}},{"type":"text","text":" . That should bring it in line with the other approaches"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB","reactions":[{"name":"+1","users":["UDB26738Q","UB7JS9CHF"],"count":2}]},{"client_msg_id":"87c37606-3e86-4d1d-93fb-80e647932147","type":"message","text":"This seems like something the autovectorizer *should* be able to vectorize. I get why it doesn't - you ask to break the loop at the exact position where you find the first match. I wonder if there is any way to communicate to the compiler: \"You can actually load more values after you've found the right one, as long as you don't go OOB of the array\", without manually unrolling the loop","user":"U7HAYKY9X","ts":"1616507060.254600","team":"T68168MUP","edited":{"user":"U7HAYKY9X","ts":"1616507069.000000"},"blocks":[{"type":"rich_text","block_id":"lOT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This seems like something the autovectorizer "},{"type":"text","text":"should","style":{"bold":true}},{"type":"text","text":" be able to vectorize. I get why it doesn't - you ask to break the loop at the exact position where you find the first match. I wonder if there is any way to communicate to the compiler: \"You can actually load more values after you've found the right one, as long as you don't go OOB of the array\", without manually unrolling the loop"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"2a5ec37d-29c0-4371-8920-ce699e5c844d","type":"message","text":"only if you manage to teach it that the `materialize` call should be moved outside of `any`","user":"UH24GRBLL","ts":"1616507518.255000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JAM=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"only if you manage to teach it that the "},{"type":"text","text":"materialize","style":{"code":true}},{"type":"text","text":" call should be moved outside of "},{"type":"text","text":"any","style":{"code":true}}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"cfd1942c-1223-4824-88b7-4a20b0776901","type":"message","text":"i.e. make it aware that `any` is a sort of reduction step","user":"UH24GRBLL","ts":"1616507542.255200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1TJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"i.e. make it aware that "},{"type":"text","text":"any","style":{"code":true}},{"type":"text","text":" is a sort of reduction step"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"04ee0c3e-5ae8-4fef-8eda-5a273f2fff61","type":"message","text":"Ah yeah, `mapreduce` on my computer actually does vectorize, just badly","user":"U7HAYKY9X","ts":"1616507773.255400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M6xKi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah yeah, "},{"type":"text","text":"mapreduce","style":{"code":true}},{"type":"text","text":" on my computer actually does vectorize, just badly"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"cb7f8f95-48c1-433e-9e5c-8f49a87d3af7","type":"message","text":"it likely won't  ever be perfect, simply because it kind of has to check often whether it should stop or not","user":"UH24GRBLL","ts":"1616507856.255600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pq6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it likely won't  ever be perfect, simply because it kind of has to check often whether it should stop or not"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"cb99b691-2684-4635-82ab-920a019a89ff","type":"message","text":"thank you <@U7HAYKY9X>! Yes, you are right :slightly_smiling_face:","user":"ULZCQ1RPB","ts":"1616514674.264300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zF9/j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thank you "},{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":"! Yes, you are right "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"6ba69975-032d-4235-a57f-388475bec60e","type":"message","text":"the `any(vec .== x)` syntax is much closer to R and Matlab, two languages where I have several years of experience","user":"ULZCQ1RPB","ts":"1616514814.264600","team":"T68168MUP","edited":{"user":"ULZCQ1RPB","ts":"1616514830.000000"},"blocks":[{"type":"rich_text","block_id":"z4yhH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the "},{"type":"text","text":"any(vec .== x)","style":{"code":true}},{"type":"text","text":" syntax is much closer to R and Matlab, two languages where I have several years of experience"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"1f366ed2-b647-4479-b235-922a8f9055c2","type":"message","text":"I would argue that `any(==(x), vec)` is not vectorized code… we are simply calling a function","user":"ULZCQ1RPB","ts":"1616515511.264900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yxY8W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would argue that "},{"type":"text","text":"any(==(x), vec)","style":{"code":true}},{"type":"text","text":" is not vectorized code… we are simply calling a function"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"98bc2359-6e72-4046-b66d-1c4a91d5a06a","type":"message","text":"That's fair, but the distinction between vectorized and non-vectorized code is a little blurry. After all, is Numpy's  `np.sin(my_arr)` vectorized? I'd say it is, even though that's also just applying a function to an array. And so is `any(arr ==. x)`  - that's just applying `any` to a different array.\nAlso not that Valentin and I are (confusingly) talking about <https://arcb.csc.ncsu.edu/~mueller/cluster/ps3/SDK3.0/docs/accessibility/sdkpt/cbet_1simdvector.html|SIMD \"vectorization\"> , which is different from the \"vectorization\" of Numpy and R","user":"U7HAYKY9X","ts":"1616517757.265400","team":"T68168MUP","attachments":[{"title":"SIMD vectorization","title_link":"https://arcb.csc.ncsu.edu/~mueller/cluster/ps3/SDK3.0/docs/accessibility/sdkpt/cbet_1simdvector.html","text":"A vector is an instruction operand containing a set of data elements packed into a one-dimensional array. The elements can be integer or floating-point values. Most Vector/SIMD Multimedia Extension and SPU instructions operate on vector operands. Vectors are also called SIMD operands or packed operands.","fallback":"SIMD vectorization","from_url":"https://arcb.csc.ncsu.edu/~mueller/cluster/ps3/SDK3.0/docs/accessibility/sdkpt/cbet_1simdvector.html","service_name":"arcb.csc.ncsu.edu","id":1,"original_url":"https://arcb.csc.ncsu.edu/~mueller/cluster/ps3/SDK3.0/docs/accessibility/sdkpt/cbet_1simdvector.html"}],"blocks":[{"type":"rich_text","block_id":"g/=J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's fair, but the distinction between vectorized and non-vectorized code is a little blurry. After all, is Numpy's  "},{"type":"text","text":"np.sin(my_arr)","style":{"code":true}},{"type":"text","text":" vectorized? I'd say it is, even though that's also just applying a function to an array. And so is "},{"type":"text","text":"any(arr ==. x)","style":{"code":true}},{"type":"text","text":"  - that's just applying "},{"type":"text","text":"any","style":{"code":true}},{"type":"text","text":" to a different array.\nAlso not that Valentin and I are (confusingly) talking about "},{"type":"link","url":"https://arcb.csc.ncsu.edu/~mueller/cluster/ps3/SDK3.0/docs/accessibility/sdkpt/cbet_1simdvector.html","text":"SIMD \"vectorization\""},{"type":"text","text":" , which is different from the \"vectorization\" of Numpy and R"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"a3d07e04-9c70-4c50-86bc-26bef7718d59","type":"message","text":"I still don't understand what R/Numpy mean by \"vectorization\"","user":"UDB26738Q","ts":"1616517834.265700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vZP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I still don't understand what R/Numpy mean by \"vectorization\""}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"4ac9fd5c-bd70-49c8-bef4-aa2eb3417fc5","type":"message","text":"For me, vectorized code is when one or more of the variables in an algebraic operation  is a vector or a matrix. The most intuitive example I can think of is something like:\n```&gt; [1 2 3] + 1 \n[2 3 4]```","user":"ULZCQ1RPB","ts":"1616518044.265900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9y9I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For me, vectorized code is when one or more of the variables in an algebraic operation  is a vector or a matrix. The most intuitive example I can think of is something like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"> [1 2 3] + 1 \n[2 3 4]"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"6a6b012e-da78-455b-a0bb-af01fff3c5f0","type":"message","text":"but I agree this can get blurry :slightly_smiling_face:","user":"ULZCQ1RPB","ts":"1616518060.266100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RqUU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but I agree this can get blurry "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"57b3ad75-8738-4285-b28e-a7055a00c966","type":"message","text":"another example of vectorized code:\n```&gt; [1 2 3] == 2\n[false true false]```","user":"ULZCQ1RPB","ts":"1616518149.266300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wsWmO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"another example of vectorized code:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"> [1 2 3] == 2\n[false true false]"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"6f32a7f7-6b8c-4f24-8ea1-af77d088d89f","type":"message","text":"<@UDB26738Q> It refers to writing or re-writing your code to use broadcasting, such that all operations become array operations. The point is that it \"pushes\" all the computation down into the C implementation, which makes it fast (i.e. if you do the equivalent of `a .+= b`  in Python, it just calls a single time into C, where all the computation happens)","user":"U7HAYKY9X","ts":"1616518250.266500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+cp","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDB26738Q"},{"type":"text","text":" It refers to writing or re-writing your code to use broadcasting, such that all operations become array operations. The point is that it \"pushes\" all the computation down into the C implementation, which makes it fast (i.e. if you do the equivalent of "},{"type":"text","text":"a .+= b","style":{"code":true}},{"type":"text","text":"  in Python, it just calls a single time into C, where all the computation happens)"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB","reactions":[{"name":"+1","users":["ULZCQ1RPB","UDB26738Q"],"count":2}]},{"client_msg_id":"57edc6c9-62e9-4aae-8589-e1dc14db58b9","type":"message","text":"yep, an important trick for interpreted languages","user":"ULZCQ1RPB","ts":"1616518350.266900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4Z34","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yep, an important trick for interpreted languages"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"},{"client_msg_id":"e4272a38-66f0-40f7-8ccd-728125555cbc","type":"message","text":"It's basically the same concept as SIMD vectorization, except SIMD pushes the \"loop\" down into hardware instead of into C","user":"U7HAYKY9X","ts":"1616518375.267100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PEsa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's basically the same concept as SIMD vectorization, except SIMD pushes the \"loop\" down into hardware instead of into C"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB","reactions":[{"name":"+1","users":["U6A936746"],"count":1}]},{"client_msg_id":"5b441e72-e99a-4dac-bbc5-28362c97876a","type":"message","text":"luckily, julia isn't interpreted :)","user":"UH24GRBLL","ts":"1616519125.267400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"p8/Q6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"luckily, julia isn't interpreted :)"}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB","reactions":[{"name":"laughing","users":["ULZCQ1RPB"],"count":1}]},{"client_msg_id":"3216fb52-abb5-4aee-a8c3-ac80e5e01634","type":"message","text":"the numpy/R \"vectorization\" for this application is doing more harm than help, not only does it prevent the early-stop of `any()`, it also allocates unnecessarily ~O(n).","user":"UH8A351DJ","ts":"1616522481.268200","team":"T68168MUP","edited":{"user":"UH8A351DJ","ts":"1616522493.000000"},"blocks":[{"type":"rich_text","block_id":"p7dyS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the numpy/R \"vectorization\" for this application is doing more harm than help, not only does it prevent the early-stop of "},{"type":"text","text":"any()","style":{"code":true}},{"type":"text","text":", it also allocates unnecessarily ~O(n)."}]}]}],"thread_ts":"1616504538.253500","parent_user_id":"ULZCQ1RPB"}]