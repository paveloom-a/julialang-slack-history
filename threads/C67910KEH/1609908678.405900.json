[{"client_msg_id":"AA2E635C-EA2E-4150-8A39-381DBF95DC72","type":"message","text":"Very cool! Does this have more exponent range than Float64, or just predictor digits?","user":"U8D9768Q6","ts":"1609908678.405900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9bk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Very cool! Does this have more exponent range than Float64, or just predictor digits?"}]}]}],"thread_ts":"1609908678.405900","reply_count":18,"reply_users_count":3,"latest_reply":"1609999647.466100","reply_users":["UPKUR1KHB","U8D9768Q6","U67G3QRJM"],"subscribed":false},{"client_msg_id":"771e3471-a331-4b76-bc5a-c39fcc3d94e8","type":"message","text":"Good question! It has exactly the same exponent range as Float64, so you need to be careful about using MultiFloats with very small numbers -- anything past 2^-1022 will be lost","user":"UPKUR1KHB","ts":"1609908886.406000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/jj5K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Good question! It has exactly the same exponent range as Float64, so you need to be careful about using MultiFloats with very small numbers -- anything past 2^-1022 will be lost"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"9C109D5C-F518-48FE-A9AD-71584DB00FD7","type":"message","text":"Makes sense, thanks. ","user":"U8D9768Q6","ts":"1609909565.406600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tc0Qx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Makes sense, thanks. "}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"284d365b-9a2f-42ba-98e4-bbf15215a15a","type":"message","text":"Can you say anything about accuracy of operations on multi-floats? E.g. are they faithfully rounded?","user":"U67G3QRJM","ts":"1609973568.460100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jP8U","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can you say anything about accuracy of operations on multi-floats? E.g. are they faithfully rounded?"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"ce1992c6-4451-4b1c-a919-39ae39d64082","type":"message","text":"The package looks fantastic, by the way, congrats!","user":"U67G3QRJM","ts":"1609973580.460300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"El3W4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The package looks fantastic, by the way, congrats!"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"14474ef2-2b38-4e8f-ab0c-3ae77ab6f86f","type":"message","text":"<@U67G3QRJM> You get to decide! MultiFloats.jl provides three user-selectable precision modes that you can switch between by calling:\n```MultiFloats.use_clean_multifloat_arithmetic()\nMultiFloats.use_standard_multifloat_arithmetic() [default]\nMultiFloats.use_sloppy_multifloat_arithmetic()```","user":"UPKUR1KHB","ts":"1609984391.462600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X6U","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":" You get to decide! MultiFloats.jl provides three user-selectable precision modes that you can switch between by calling:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"MultiFloats.use_clean_multifloat_arithmetic()\nMultiFloats.use_standard_multifloat_arithmetic() [default]\nMultiFloats.use_sloppy_multifloat_arithmetic()"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"1c9ae134-e71a-44dc-a25f-1f21a60eab56","type":"message","text":"In standard mode, addition and subtraction are faithfully rounded, while multiplication and division are allowed to get the last few bits wrong (the last ~3% of bits for multiplication, and the last ~4% for division). I find this to be the most reasonable compromise between safety and speed","user":"UPKUR1KHB","ts":"1609984477.462900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xmi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In standard mode, addition and subtraction are faithfully rounded, while multiplication and division are allowed to get the last few bits wrong (the last ~3% of bits for multiplication, and the last ~4% for division). I find this to be the most reasonable compromise between safety and speed"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"9b3d4b35-d844-4944-8170-2c08c3a9bdb1","type":"message","text":"In clean mode, everything is faithfully rounded (except transcendentals, which are at most one or two bits off). In sloppy mode, nothing is faithful, and we are extra fast and loose about renormalization","user":"UPKUR1KHB","ts":"1609984527.463100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q10C","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In clean mode, everything is faithfully rounded (except transcendentals, which are at most one or two bits off). In sloppy mode, nothing is faithful, and we are extra fast and loose about renormalization"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"518ad7b5-c5d4-4f44-bde0-fd73443bb9ac","type":"message","text":"(note: there's currently a bug where clean mode gets the final bit of division wrong sometimes. still looking into this at the moment)","user":"UPKUR1KHB","ts":"1609984579.463300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=X0l0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(note: there's currently a bug where clean mode gets the final bit of division wrong sometimes. still looking into this at the moment)"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"ec3eb5be-a478-4bb2-91ab-022b724bce7e","type":"message","text":"A detailed table of relative precision for each arithmetic operation is provided in the README: <https://github.com/dzhang314/MultiFloats.jl#precision-modes>","user":"UPKUR1KHB","ts":"1609984615.463600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mVJQ7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A detailed table of relative precision for each arithmetic operation is provided in the README: "},{"type":"link","url":"https://github.com/dzhang314/MultiFloats.jl#precision-modes"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"f913ad6a-ad63-415e-97ef-e5935452f77a","type":"message","text":"Sounds great, thanks!","user":"U67G3QRJM","ts":"1609984617.463800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5jyG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sounds great, thanks!"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"9ec223c9-f798-4af0-8371-9254fef6a266","type":"message","text":"The docs don't actually specify the accuracy though.","user":"U67G3QRJM","ts":"1609984641.464000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5/g3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The docs don't actually specify the accuracy though."}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"6f459d82-78f1-4d0b-a3c7-f61a1457a7d0","type":"message","text":"Basically to be able to use this with IntervalArithmetic.jl, I need to know that eg `nextfloat(a + b) ` rigorously is greater than or equal to the true result of a + b","user":"U67G3QRJM","ts":"1609984716.464200","team":"T68168MUP","edited":{"user":"U67G3QRJM","ts":"1609984734.000000"},"blocks":[{"type":"rich_text","block_id":"tWB1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Basically to be able to use this with IntervalArithmetic.jl, I need to know that eg `nextfloat(a + b) ` rigorously is greater than or equal to the true result of a + b"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"09420902-bf92-4cc1-91ff-328398f31c97","type":"message","text":"*b","user":"U67G3QRJM","ts":"1609984719.464400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7Y2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"*b"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"ae651891-78af-437d-ab68-48b436987595","type":"message","text":"Oh I see! No, we don't make that type of guarantee at all, because `nextfloat` has very different semantics for MultiFloat types than it does for standard floating-point types. For example, the next representable Float64x2 after `(1.4142135623730951, -9.667293313452913e-17)` is `(1.4142135623730951, -9.667293313452912e-17)`, which is an increment on the order of `1.0e-32`. However, the next representable Float64x2 `(1.0, 0.0)` is `(1.0, 2.2250738585072014e-308)`, an increment on the order of `1.0e-308` There can be huge gaps between the exponent of one limb and the next","user":"UPKUR1KHB","ts":"1609984905.464700","team":"T68168MUP","edited":{"user":"UPKUR1KHB","ts":"1609985355.000000"},"blocks":[{"type":"rich_text","block_id":"ij1AR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh I see! No, we don't make that type of guarantee at all, because "},{"type":"text","text":"nextfloat","style":{"code":true}},{"type":"text","text":" has very different semantics for MultiFloat types than it does for standard floating-point types. For example, the next representable Float64x2 after "},{"type":"text","text":"(1.4142135623730951, -9.667293313452913e-17)","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"(1.4142135623730951, -9.667293313452912e-17)","style":{"code":true}},{"type":"text","text":", which is an increment on the order of "},{"type":"text","text":"1.0e-32","style":{"code":true}},{"type":"text","text":". However, the next representable Float64x2 "},{"type":"text","text":"(1.0, 0.0)","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"(1.0, 2.2250738585072014e-308)","style":{"code":true}},{"type":"text","text":", an increment on the order of "},{"type":"text","text":"1.0e-308","style":{"code":true}},{"type":"text","text":" There can be huge gaps between the exponent of one limb and the next"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"a6404c7a-7d09-4564-917f-67bb5d472276","type":"message","text":"There are multiple \"floating decimal points\" within a single Float64xN, so to speak, which makes MultiFloats.jl unsuitable for interval arithmetic. Thanks for pointing this out, I'll add a note about this to the README","user":"UPKUR1KHB","ts":"1609985193.464900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A6C0e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are multiple \"floating decimal points\" within a single Float64xN, so to speak, which makes MultiFloats.jl unsuitable for interval arithmetic. Thanks for pointing this out, I'll add a note about this to the README"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"e94de53f-a977-4326-b6eb-f90dc4324c5d","type":"message","text":"I don’t think they’re “unsuitable for interval arithmetic” — we just need to work out how to use them appropriately! :wink:","user":"U67G3QRJM","ts":"1609999558.465700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O4c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t think they’re “unsuitable for interval arithmetic” — we just need to work out how to use them appropriately! "},{"type":"emoji","name":"wink"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"dfbec84d-6b60-46ee-8401-a4b99e27f9e1","type":"message","text":"Basically we just need *some* kind of guarantee of the form “given the multifloat result of a + b, I guarantee that the true result is f(a + b)” for some easily-calculable function f.","user":"U67G3QRJM","ts":"1609999605.465900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L8c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Basically we just need "},{"type":"text","text":"some","style":{"bold":true}},{"type":"text","text":" kind of guarantee of the form “given the multifloat result of a + b, I guarantee that the true result is f(a + b)” for some easily-calculable function f."}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"},{"client_msg_id":"41ce211a-0fe0-4993-8c1a-db035097389d","type":"message","text":"for Float64, `nextfloat` works for `f(x)`. For Multifloat it might be `nextfloat(x, 1000)` or whatever","user":"U67G3QRJM","ts":"1609999647.466100","team":"T68168MUP","edited":{"user":"U67G3QRJM","ts":"1609999667.000000"},"blocks":[{"type":"rich_text","block_id":"hrhQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for Float64, "},{"type":"text","text":"nextfloat","style":{"code":true}},{"type":"text","text":" works for "},{"type":"text","text":"f(x)","style":{"code":true}},{"type":"text","text":". For Multifloat it might be "},{"type":"text","text":"nextfloat(x, 1000)","style":{"code":true}},{"type":"text","text":" or whatever"}]}]}],"thread_ts":"1609908678.405900","parent_user_id":"U8D9768Q6"}]