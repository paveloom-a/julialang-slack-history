[{"client_msg_id":"8bb9704f-7800-4cd3-b323-2866116168aa","type":"message","text":"I do like how some languages encourage or force you to explicitly handle errors, but I'm not sure that that fits into Julia v1 when we already have exception handling and we're generally happy to fail at runtime.\n\nI think it's also relevant that languages that do this usually provide syntax shortcuts for the common case that you just want to error or panic if the called functions error (rust has `?`, zig has `try`).\n\nI'm not sure about having lots more `Union{T, Nothing}`s, either. We have a few of those already and it's quite easy to write code without realising that you should be checking for error values, it will also be inconsistent because some functions would need `Union{Some{T}, Nothing}` and misses out on a bunch of the power of Errors in Rust or Zig because we can't transmit messages or have different kinds of errors.\n\nFor reductions, users can already specify `init` or check with `isempty` (tho that has some problems as referenced in my PR).","user":"UAUCGGD6C","ts":"1614952382.061700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ogz0n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do like how some languages encourage or force you to explicitly handle errors, but I'm not sure that that fits into Julia v1 when we already have exception handling and we're generally happy to fail at runtime.\n\nI think it's also relevant that languages that do this usually provide syntax shortcuts for the common case that you just want to error or panic if the called functions error (rust has "},{"type":"text","text":"?","style":{"code":true}},{"type":"text","text":", zig has "},{"type":"text","text":"try","style":{"code":true}},{"type":"text","text":").\n\nI'm not sure about having lots more "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":"s, either. We have a few of those already and it's quite easy to write code without realising that you should be checking for error values, it will also be inconsistent because some functions would need "},{"type":"text","text":"Union{Some{T}, Nothing}","style":{"code":true}},{"type":"text","text":" and misses out on a bunch of the power of Errors in Rust or Zig because we can't transmit messages or have different kinds of errors.\n\nFor reductions, users can already specify "},{"type":"text","text":"init","style":{"code":true}},{"type":"text","text":" or check with "},{"type":"text","text":"isempty","style":{"code":true}},{"type":"text","text":" (tho that has some problems as referenced in my PR)."}]}]}],"thread_ts":"1614952382.061700","reply_count":8,"reply_users_count":3,"latest_reply":"1615104283.063700","reply_users":["U7HAYKY9X","UAUCGGD6C","U66QZ3QF3"],"subscribed":false},{"client_msg_id":"985afcd0-fa99-4095-a818-2fdc6f7f63b7","type":"message","text":"Sure, we could have different error types? E.g. a function could return `Union{T, Foo, Bar}` for error states Foo and Bar.\nI'm curious, why do you think it's harder to remember checking for `nothing` than remembering to look before you leap in case of a function that throws an error? Isn't the former strictly easier, because type inference will help you?","user":"U7HAYKY9X","ts":"1614952725.061800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Oum","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sure, we could have different error types? E.g. a function could return "},{"type":"text","text":"Union{T, Foo, Bar}","style":{"code":true}},{"type":"text","text":" for error states Foo and Bar.\nI'm curious, why do you think it's harder to remember checking for "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" than remembering to look before you leap in case of a function that throws an error? Isn't the former strictly easier, because type inference will help you?"}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C"},{"client_msg_id":"3033427d-25ef-476b-8b2f-6393254a5fa5","type":"message","text":"I think that it's just as easy to forget to use `try` or to look before you leap, but if you do forget you get a runtime error and stacktrace at the location.\n\nWhereas with Union{T, Nothing} you can pass the `nothing` around for a while before it explodes.","user":"UAUCGGD6C","ts":"1614952912.062000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QzcX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think that it's just as easy to forget to use "},{"type":"text","text":"try","style":{"code":true}},{"type":"text","text":" or to look before you leap, but if you do forget you get a runtime error and stacktrace at the location.\n\nWhereas with Union{T, Nothing} you can pass the "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" around for a while before it explodes."}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C"},{"client_msg_id":"7494520c-b1b7-4134-af9c-ba1dd38e01ae","type":"message","text":"Ah, you mean, the problem is that the Nothing may be caught several functions down the line? Yeah, that's true.","user":"U7HAYKY9X","ts":"1614953067.062200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+cx/m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, you mean, the problem is that the Nothing may be caught several functions down the line? Yeah, that's true."}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C","reactions":[{"name":"100","users":["UAUCGGD6C"],"count":1}]},{"client_msg_id":"da8d585e-3474-4f4e-9b15-e54ba62ce2c3","type":"message","text":"`Union{Some{T}, Err1, Err2, ...}` would be fine, it's just a bit alien from what Julia v1 normally does and it's a bit strange to have both exceptions and proper error types in the same program.","user":"UAUCGGD6C","ts":"1614953071.062400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"g/Ym","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Union{Some{T}, Err1, Err2, ...}","style":{"code":true}},{"type":"text","text":" would be fine, it's just a bit alien from what Julia v1 normally does and it's a bit strange to have both exceptions and proper error types in the same program."}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C"},{"client_msg_id":"7cbbbd96-bbb0-4daa-bdd4-73a9f8c3f3fb","type":"message","text":"Well, I think it's a bit strange. Opinions may differ :slightly_smiling_face:","user":"UAUCGGD6C","ts":"1614953104.062700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CD0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well, I think it's a bit strange. Opinions may differ "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C"},{"client_msg_id":"ca8d8d4c-9844-4032-ab97-d45578360122","type":"message","text":"Right, but the problem is that Julia already does have both error types. E.g. `find*` uses `Nothing` , but `reduce` uses exceptions. Even more on the nose, `parse` uses exceptions, and `tryparse` is the exact same function, it just uses `Nothing` .\nI think it's hard to be consistent here: sometimes, you need to throw an error, and sometimes, you really don't","user":"U7HAYKY9X","ts":"1614953314.062900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ti0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Right, but the problem is that Julia already does have both error types. E.g. "},{"type":"text","text":"find*","style":{"code":true}},{"type":"text","text":" uses "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" , but "},{"type":"text","text":"reduce","style":{"code":true}},{"type":"text","text":" uses exceptions. Even more on the nose, "},{"type":"text","text":"parse","style":{"code":true}},{"type":"text","text":" uses exceptions, and "},{"type":"text","text":"tryparse","style":{"code":true}},{"type":"text","text":" is the exact same function, it just uses "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" .\nI think it's hard to be consistent here: sometimes, you need to throw an error, and sometimes, you really don't"}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C"},{"client_msg_id":"740f4bc4-d2ed-4ef7-8ec3-f60c44368788","type":"message","text":"Yeah, I know we already have a mix. The `find` and `match` uses of `nothing` make sense to me, for some reason. It certainly helps that it is not possible for `nothing` to be a genuine value from those functions, which is much less clear for something much more generic like `reduce`  (and I think I have shown that `nothing` is a valid return value).","user":"UAUCGGD6C","ts":"1614953772.063100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4lss","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I know we already have a mix. The "},{"type":"text","text":"find","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"match","style":{"code":true}},{"type":"text","text":" uses of "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" make sense to me, for some reason. It certainly helps that it is not possible for "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" to be a genuine value from those functions, which is much less clear for something much more generic like "},{"type":"text","text":"reduce","style":{"code":true}},{"type":"text","text":"  (and I think I have shown that "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" is a valid return value)."}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"d6746325-c9cc-4ae9-b4cf-6901714362fb","type":"message","text":"Even `findfirst` returning `nothing` is a bit strange for dictionaries:\n```julia&gt; findfirst(==(1), Dict(nothing=&gt;1, missing=&gt;2))```\n(returns `nothing`... but which `nothing`?)","user":"U66QZ3QF3","ts":"1615104283.063700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JpYU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Even "},{"type":"text","text":"findfirst","style":{"code":true}},{"type":"text","text":" returning "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" is a bit strange for dictionaries:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> findfirst(==(1), Dict(nothing=>1, missing=>2))"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"(returns "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":"... but which "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":"?)"}]}]}],"thread_ts":"1614952382.061700","parent_user_id":"UAUCGGD6C"}]