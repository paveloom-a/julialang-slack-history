[{"client_msg_id":"E2CF7B92-173A-4223-9361-2B7860AB4E09","type":"message","text":"Hereâ€™s an announcement for a new package I have that is mostly geared toward controls work. It basically replicates the functionality of scopes and signal logging from Simulink, but for DifferentialEquations models.\n\n<https://discourse.julialang.org/t/ann-simulationlogs-jl/58527|https://discourse.julialang.org/t/ann-simulationlogs-jl/58527>","user":"US4A6G6B0","ts":"1617486284.021500","team":"T68168MUP","attachments":[{"service_name":"JuliaLang","title":"[ANN] SimulationLogs.jl ðŸªµðŸªµðŸªµ","title_link":"https://discourse.julialang.org/t/ann-simulationlogs-jl/58527","text":"One of the killer features of Simulink is the ability to log or plot (with a scope) any intermediate signal in a simulation with a click. Itâ€™s one of the things that Iâ€™ve been sorely missing in my DifferentialEquations.jl simulations. ModelingToolkit gives this ability, but it would be nice to have for non-ModelingToolkit simulations as well. So let me introduce SimulationLogs.jl (currently unregistered). By simply placing the macro @log before any variable declaration in your simulation, you c...","fallback":"JuliaLang: [ANN] SimulationLogs.jl ðŸªµðŸªµðŸªµ","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/3X/4/d/4d4ceb9d653c2d393846d6ac554a2935fcb83803.png","fields":[{"title":"Reading time","value":"1 mins :clock2:","short":true},{"title":"Likes","value":"1 :heart:","short":true}],"ts":1617485720,"from_url":"https://discourse.julialang.org/t/ann-simulationlogs-jl/58527","thumb_width":600,"thumb_height":800,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/ann-simulationlogs-jl/58527"}],"blocks":[{"type":"rich_text","block_id":"jLE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hereâ€™s an announcement for a new package I have that is mostly geared toward controls work. It basically replicates the functionality of scopes and signal logging from Simulink, but for DifferentialEquations models.\n"},{"type":"text","text":"\n"},{"type":"link","url":"https://discourse.julialang.org/t/ann-simulationlogs-jl/58527","text":"https://discourse.julialang.org/t/ann-simulationlogs-jl/58527"}]}]}],"thread_ts":"1617486284.021500","reply_count":1,"reply_users_count":1,"latest_reply":"1617681630.022500","reply_users":["U0138UTB7A4"],"is_locked":false,"subscribed":false,"reactions":[{"name":"heart","users":["U0138UTB7A4","U9MD78Z9N","U01SFUPBJ9E","ULY5YL9F1"],"count":4},{"name":"log","users":["U0138UTB7A4","US4A6G6B0","U9MD78Z9N","ULY5YL9F1"],"count":4}]},{"client_msg_id":"c6b0382c-d1b5-4ac5-a45c-73ec3eac1071","type":"message","text":"This looks super useful! For immediate results and so on.\n\n\nSo based on my understanding `@log` works for expressions that is explicitly a function of the state? i.e. x = f(u), and then after the simulation and solve, your package calculates what the expression should have been based on the states timeseries after the solve? Is this a correct understanding/simplification of how it works?\n\nJust out of curiosity, how does it handle time varying expressions or maybe expressions based on the parameters? e.g.\n`@log x = u[1] * t` or\n`@log x = u[1] * p[1]` or\n`@log x = u[1] * p[1](t)` (where p[1] is a function)\n\n(I tried reading log.jl that you had but I don't know enough about metaprogramming (yet!))\n\nI could imagine this could be possible because we know the parameters and times throughout the entire simulation afterwards.\n\nJust curious because you have a really useful package here with SimulationsLogs!","user":"U0138UTB7A4","ts":"1617681630.022500","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1617682301.000000"},"blocks":[{"type":"rich_text","block_id":"Ue3B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This looks super useful! For immediate results and so on.\n\n\nSo based on my understanding "},{"type":"text","text":"@log","style":{"code":true}},{"type":"text","text":" works for expressions that is explicitly a function of the state? i.e. x = f(u), and then after the simulation and solve, your package calculates what the expression should have been based on the states timeseries after the solve? Is this a correct understanding/simplification of how it works?\n\nJust out of curiosity, how does it handle time varying expressions or maybe expressions based on the parameters? e.g.\n"},{"type":"text","text":"@log x = u[1] * t","style":{"code":true}},{"type":"text","text":" or\n"},{"type":"text","text":"@log x = u[1] * p[1]","style":{"code":true}},{"type":"text","text":" or\n"},{"type":"text","text":"@log x = u[1] * p[1](t)","style":{"code":true}},{"type":"text","text":" (where p[1] is a function)\n\n(I tried reading log.jl that you had but I don't know enough about metaprogramming (yet!))\n\nI could imagine this could be possible because we know the parameters and times throughout the entire simulation afterwards.\n\nJust curious because you have a really useful package here with SimulationsLogs!"}]}]}],"thread_ts":"1617486284.021500","parent_user_id":"US4A6G6B0"}]