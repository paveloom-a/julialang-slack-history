[{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":1,"reply_users_count":1,"latest_reply":"1614126750.042300","reply_users":["U72B7LTMX"],"subscribed":false},{"type":"message","subtype":"thread_broadcast","text":"I wonder if you can elaborate on how losing that a `nothing` corresponds to not-a-`T` causes an issue down the line? I don't doubt it's an issue, but I'd like to see an example if you have one handy.\n\nThere's some (core-to-julia) sense in which functions are supposed to be generic, and so any methods defined for specific types should be conceptually related to any other method. Is there a function with e.g. a method for  `Vector{Nothing}` and a method for `Vector{Union{T, Nothing}}` and these methods \"mean\" different things?","user":"U72B7LTMX","ts":"1614126750.042300","thread_ts":"1614125386.034800","root":{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":1,"reply_users_count":1,"latest_reply":"1614126750.042300","reply_users":["U72B7LTMX"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"ghHt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wonder if you can elaborate on how losing that a "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" corresponds to not-a-"},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" causes an issue down the line? I don't doubt it's an issue, but I'd like to see an example if you have one handy.\n\nThere's some (core-to-julia) sense in which functions are supposed to be generic, and so any methods defined for specific types should be conceptually related to any other method. Is there a function with e.g. a method for  "},{"type":"text","text":"Vector{Nothing}","style":{"code":true}},{"type":"text","text":" and a method for "},{"type":"text","text":"Vector{Union{T, Nothing}}","style":{"code":true}},{"type":"text","text":" and these methods \"mean\" different things?"}]}]}],"client_msg_id":"2565328d-caf6-4591-b68f-08d2919302b3"}]