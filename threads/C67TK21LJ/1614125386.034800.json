[{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":10,"reply_users_count":2,"latest_reply":"1614130516.049700","reply_users":["U72B7LTMX","U66QZ3QF3"],"subscribed":false},{"type":"message","subtype":"thread_broadcast","text":"I wonder if you can elaborate on how losing that a `nothing` corresponds to not-a-`T` causes an issue down the line? I don't doubt it's an issue, but I'd like to see an example if you have one handy.\n\nThere's some (core-to-julia) sense in which functions are supposed to be generic, and so any methods defined for specific types should be conceptually related to any other method. Is there a function with e.g. a method for  `Vector{Nothing}` and a method for `Vector{Union{T, Nothing}}` and these methods \"mean\" different things?","user":"U72B7LTMX","ts":"1614126750.042300","thread_ts":"1614125386.034800","root":{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":10,"reply_users_count":2,"latest_reply":"1614130516.049700","reply_users":["U72B7LTMX","U66QZ3QF3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"ghHt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wonder if you can elaborate on how losing that a "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" corresponds to not-a-"},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" causes an issue down the line? I don't doubt it's an issue, but I'd like to see an example if you have one handy.\n\nThere's some (core-to-julia) sense in which functions are supposed to be generic, and so any methods defined for specific types should be conceptually related to any other method. Is there a function with e.g. a method for  "},{"type":"text","text":"Vector{Nothing}","style":{"code":true}},{"type":"text","text":" and a method for "},{"type":"text","text":"Vector{Union{T, Nothing}}","style":{"code":true}},{"type":"text","text":" and these methods \"mean\" different things?"}]}]}],"client_msg_id":"2565328d-caf6-4591-b68f-08d2919302b3"},{"client_msg_id":"e294cdc1-cfbe-43c1-a92d-024a33eb1c6c","type":"message","text":"Yes - in the case this morning I had some \"automatic\" averaging code that took the mean for vectors of `Float64` (or `Union{Float64, Nothing}` by skipping the `nothing`s), and took the mode for vectors of `String` (or `Union{Nothing, String}`) and so on. We also have some more interesting cases for finding averages of dictionaries etc.\n\nI think for vectors of `Nothing` with could just return `nothing` as the average but the point was that I didn't realize the dispatch had problems until _after_ throwing production data at it. (I like me my compile-time guarantees!).","user":"U66QZ3QF3","ts":"1614128905.043300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"b7sa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes - in the case this morning I had some \"automatic\" averaging code that took the mean for vectors of "},{"type":"text","text":"Float64","style":{"code":true}},{"type":"text","text":" (or "},{"type":"text","text":"Union{Float64, Nothing}","style":{"code":true}},{"type":"text","text":" by skipping the "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":"s), and took the mode for vectors of "},{"type":"text","text":"String","style":{"code":true}},{"type":"text","text":" (or "},{"type":"text","text":"Union{Nothing, String}","style":{"code":true}},{"type":"text","text":") and so on. We also have some more interesting cases for finding averages of dictionaries etc.\n\nI think for vectors of "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" with could just return "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" as the average but the point was that I didn't realize the dispatch had problems until "},{"type":"text","text":"after","style":{"italic":true}},{"type":"text","text":" throwing production data at it. (I like me my compile-time guarantees!)."}]}]}],"thread_ts":"1614125386.034800","parent_user_id":"U66QZ3QF3"},{"type":"message","subtype":"thread_broadcast","text":"Yeah! I gotcha. So did you have\n\n`average(v::Vector{Union{Nothing, Float64}})`","user":"U72B7LTMX","ts":"1614129657.045100","thread_ts":"1614125386.034800","root":{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":10,"reply_users_count":2,"latest_reply":"1614130516.049700","reply_users":["U72B7LTMX","U66QZ3QF3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"+ZdK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah! I gotcha. So did you have\n\n"},{"type":"text","text":"average(v::Vector{Union{Nothing, Float64}})","style":{"code":true}}]}]}],"client_msg_id":"b8b0e7d6-09d5-43ee-aa60-f61425a9ab70"},{"client_msg_id":"3a7a9781-d839-4d4b-937f-ce079c317900","type":"message","text":"or\n\n`average(v::Vector{&lt;:Union{Nothing, Float64}})`","user":"U72B7LTMX","ts":"1614129669.045400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vx3/d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or\n\n"},{"type":"text","text":"average(v::Vector{<:Union{Nothing, Float64}})","style":{"code":true}}]}]}],"thread_ts":"1614125386.034800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"a415af9d-0e96-49a4-9a39-2d59d5839a6c","type":"message","text":"The latter as well as `average(v::Vector{&lt;:Union{Nothing, String}}` so we hit a method ambiguity error when `v` was `Vector{Nothing}`.\n\n(There are some method ambiguity detection tools we could use).","user":"U66QZ3QF3","ts":"1614129788.045900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cf1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The latter as well as "},{"type":"text","text":"average(v::Vector{<:Union{Nothing, String}}","style":{"code":true}},{"type":"text","text":" so we hit a method ambiguity error when "},{"type":"text","text":"v","style":{"code":true}},{"type":"text","text":" was "},{"type":"text","text":"Vector{Nothing}","style":{"code":true}},{"type":"text","text":".\n\n(There are some method ambiguity detection tools we could use)."}]}]}],"thread_ts":"1614125386.034800","parent_user_id":"U66QZ3QF3"},{"type":"message","subtype":"thread_broadcast","text":"In any case, this is my guess for what happened in a nutshell:\n\n```julia&gt; average(v::Vector{&lt;:Union{Nothing, Float64}}) = :mean\naverage (generic function with 1 method)\n\njulia&gt; average(v::Vector{&lt;:Union{Nothing, String}}) = :mode\naverage (generic function with 2 methods)\n\njulia&gt; average([1.0, 2.0])\n:mean\n\njulia&gt; average([1.0, 2.0, nothing])\n:mean\n\njulia&gt; average([\"\"])\n:mode\n\njulia&gt; average([\"\", nothing])\n:mode\n\njulia&gt; average([nothing])\nERROR: MethodError: average(::Vector{Nothing}) is ambiguous. Candidates:\n  average(v::Vector{var\"#s24\"} where var\"#s24\"&lt;:Union{Nothing, Float64}) in Main at REPL[21]:1\n  average(v::Vector{var\"#s24\"} where var\"#s24\"&lt;:Union{Nothing, String}) in Main at REPL[22]:1```","user":"U72B7LTMX","ts":"1614129807.046600","thread_ts":"1614125386.034800","root":{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":10,"reply_users_count":2,"latest_reply":"1614130516.049700","reply_users":["U72B7LTMX","U66QZ3QF3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"NoP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In any case, this is my guess for what happened in a nutshell:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> average(v::Vector{<:Union{Nothing, Float64}}) = :mean\naverage (generic function with 1 method)\n\njulia> average(v::Vector{<:Union{Nothing, String}}) = :mode\naverage (generic function with 2 methods)\n\njulia> average([1.0, 2.0])\n:mean\n\njulia> average([1.0, 2.0, nothing])\n:mean\n\njulia> average([\"\"])\n:mode\n\njulia> average([\"\", nothing])\n:mode\n\njulia> average([nothing])\nERROR: MethodError: average(::Vector{Nothing}) is ambiguous. Candidates:\n  average(v::Vector{var\"#s24\"} where var\"#s24\"<:Union{Nothing, Float64}) in Main at REPL[21]:1\n  average(v::Vector{var\"#s24\"} where var\"#s24\"<:Union{Nothing, String}) in Main at REPL[22]:1"}]}]}],"client_msg_id":"fc17d274-cb05-449a-9d13-9e87a10e549f","reactions":[{"name":"heavy_check_mark","users":["U66QZ3QF3"],"count":1}]},{"client_msg_id":"41bb9826-fe3c-4bca-97a2-acddea0c5073","type":"message","text":"Exactly","user":"U66QZ3QF3","ts":"1614129822.047100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RWPD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Exactly"}]}]}],"thread_ts":"1614125386.034800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"1f35ed60-f1be-45a8-a8dd-c87109c48ad1","type":"message","text":"It makes me want a \"proper\" parametric type (\"functor\" if we're speaking category-theoretically) `Maybe{Float64}` and `Maybe{String}` for this in particular, to \"circumvent\" / guard against  any \"helpful\" type narrowing and inference.","user":"U72B7LTMX","ts":"1614129984.048300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A9o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It makes me want a \"proper\" parametric type (\"functor\" if we're speaking category-theoretically) "},{"type":"text","text":"Maybe{Float64}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Maybe{String}","style":{"code":true}},{"type":"text","text":" for this in particular, to \"circumvent\" / guard against  any \"helpful\" type narrowing and inference."}]}]}],"thread_ts":"1614125386.034800","parent_user_id":"U66QZ3QF3"},{"type":"message","subtype":"thread_broadcast","text":"I bet this has been hashed out to some extent in: <https://github.com/JuliaLang/julia/issues/22682>\n\nand perhaps this example should be mentioned at <https://docs.julialang.org/en/v1/manual/types/#Type-Unions> since `Union{Nothing, T}` is really not a perfect replacement for \"Maybe{T}\".","user":"U72B7LTMX","ts":"1614130410.049400","thread_ts":"1614125386.034800","root":{"client_msg_id":"447eb761-b0b1-4b23-825e-af4175cc2ef0","type":"message","text":"I keep getting annoyed that `eltype(map(f, vector))` isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when `Union{T, Nothing}` becomes `Nothing` or `Union{T, Missing}` becomes `Missing`  then we loose all the semantic information that `T` tells us. We can fix it up with `T[f(x) for x in vector]` or similar, having determined the correct output `T` manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of `map` was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?","user":"U66QZ3QF3","ts":"1614125386.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8AaKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I keep getting annoyed that "},{"type":"text","text":"eltype(map(f, vector))","style":{"code":true}},{"type":"text","text":" isn't deterministic. We've got nullable data the output (or it's eltype) will be used in dispatch or other logic elsewhere - and when "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Union{T, Missing}","style":{"code":true}},{"type":"text","text":" becomes "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":"  then we loose all the semantic information that "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" tells us. We can fix it up with "},{"type":"text","text":"T[f(x) for x in vector]","style":{"code":true}},{"type":"text","text":" or similar, having determined the correct output "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" manually ourselves, but honestly it seems better to me in basically all cases I use it if the output type of "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" was determined solely from the type of the inputs rather than the values.\n\nDoes anyone else feel this way? Or is there something people find particularly useful about the current value-based semantics?"}]}]}],"thread_ts":"1614125386.034800","reply_count":10,"reply_users_count":2,"latest_reply":"1614130516.049700","reply_users":["U72B7LTMX","U66QZ3QF3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"Wb9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I bet this has been hashed out to some extent in: "},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/22682"},{"type":"text","text":"\n\nand perhaps this example should be mentioned at "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/types/#Type-Unions"},{"type":"text","text":" since "},{"type":"text","text":"Union{Nothing, T}","style":{"code":true}},{"type":"text","text":" is really not a perfect replacement for \"Maybe{T}\"."}]}]}],"client_msg_id":"0f6837f3-f788-41d9-b92a-eeb368f434f5"},{"client_msg_id":"92db7877-22d1-414f-8e2a-bc7ffc6be1a2","type":"message","text":"(and neither is `Union{Nothing, Some{T}}` to be clear)","user":"U72B7LTMX","ts":"1614130516.049700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/uZ0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(and neither is "},{"type":"text","text":"Union{Nothing, Some{T}}","style":{"code":true}},{"type":"text","text":" to be clear)"}]}]}],"thread_ts":"1614125386.034800","parent_user_id":"U66QZ3QF3"}]