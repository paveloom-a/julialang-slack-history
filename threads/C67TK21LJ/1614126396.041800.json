[{"client_msg_id":"1b378b5b-2441-4a84-b240-22a96143a008","type":"message","text":"In my opinion, this is a big wart:\n\n```julia\njulia&gt; f(x) = ifelse(iseven(x), \"even\", :odd)\nf (generic function with 1 method)\n\njulia&gt; map(f, 1:2)\n2-element Vector{Any}:\n :odd\n \"even\"\n\njulia&gt; map(f, 1:1)\n1-element Vector{Symbol}:\n :odd\n\njulia&gt; map(f, 1:0)\nUnion{String, Symbol}[]```","user":"U72B7LTMX","ts":"1614126396.041800","team":"T68168MUP","edited":{"user":"U72B7LTMX","ts":"1614126455.000000"},"blocks":[{"type":"rich_text","block_id":"FbM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In my opinion, this is a big wart:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia\njulia> f(x) = ifelse(iseven(x), \"even\", :odd)\nf (generic function with 1 method)\n\njulia> map(f, 1:2)\n2-element Vector{Any}:\n :odd\n \"even\"\n\njulia> map(f, 1:1)\n1-element Vector{Symbol}:\n :odd\n\njulia> map(f, 1:0)\nUnion{String, Symbol}[]"}]}]}],"thread_ts":"1614126396.041800","reply_count":3,"reply_users_count":2,"latest_reply":"1614157598.055500","reply_users":["U66QZ3QF3","U67431ELR"],"subscribed":false,"reactions":[{"name":"+1","users":["U66QZ3QF3","U017AJ68PFZ","U01HD5VFXJM","U7HAYKY9X"],"count":4}]},{"client_msg_id":"007915ee-d3b7-4899-87b0-4da2363356c6","type":"message","text":"This is pretty much the issue.\n\nAlthough the automatic narrowing helps in some cases like Alex's example, in other cases you get something less precise!\n\nWorse than that, the infered output of the `map` is at best `Union{Vector{Any}, Vector{Symbol}, Vector{String}, Vector{Union{String, Symbol}}` or else a widened version thereof (like `Vector` or `Any`). It could just be `Vector{Union{Symbol, String}}` and all the subsequent generated code would be about as efficient as I could imagine it possibly being.","user":"U66QZ3QF3","ts":"1614129340.044900","team":"T68168MUP","edited":{"user":"U66QZ3QF3","ts":"1614129678.000000"},"blocks":[{"type":"rich_text","block_id":"Jdam","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is pretty much the issue.\n\nAlthough the automatic narrowing helps in some cases like Alex's example, in other cases you get something less precise!\n\nWorse than that, the infered output of the "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" is at best "},{"type":"text","text":"Union{Vector{Any}, Vector{Symbol}, Vector{String}, Vector{Union{String, Symbol}}","style":{"code":true}},{"type":"text","text":" or else a widened version thereof (like "},{"type":"text","text":"Vector","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":"). It could just be "},{"type":"text","text":"Vector{Union{Symbol, String}}","style":{"code":true}},{"type":"text","text":" and all the subsequent generated code would be about as efficient as I could imagine it possibly being."}]}]}],"thread_ts":"1614126396.041800","parent_user_id":"U72B7LTMX"},{"client_msg_id":"1e4fa04d-93d3-4e2b-818e-861aaf0cd906","type":"message","text":"I just fixed inference of `broadcast` in similar cases at <https://github.com/JuliaLang/julia/pull/30485>, it should be possible to do the same for `map`.","user":"U67431ELR","ts":"1614157489.055300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cK+W2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just fixed inference of "},{"type":"text","text":"broadcast","style":{"code":true}},{"type":"text","text":" in similar cases at "},{"type":"link","url":"https://github.com/JuliaLang/julia/pull/30485"},{"type":"text","text":", it should be possible to do the same for "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1614126396.041800","parent_user_id":"U72B7LTMX","reactions":[{"name":"+1","users":["U66QZ3QF3"],"count":1}]},{"client_msg_id":"0d1738f4-e4c9-417f-aa30-3aa65ff2cd43","type":"message","text":"But yeah `Vector{Any}` is really not optimal, and the fact that we special-case `Missing` and `Nothing` to work around it isn't a super clean design. Maybe something we can improve in 2.0. One solution would be to preserve `Union`s up to e.g. 4 types. That would be quite arbitrary but maybe OK.","user":"U67431ELR","ts":"1614157598.055500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wzW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But yeah "},{"type":"text","text":"Vector{Any}","style":{"code":true}},{"type":"text","text":" is really not optimal, and the fact that we special-case "},{"type":"text","text":"Missing","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Nothing","style":{"code":true}},{"type":"text","text":" to work around it isn't a super clean design. Maybe something we can improve in 2.0. One solution would be to preserve "},{"type":"text","text":"Union","style":{"code":true}},{"type":"text","text":"s up to e.g. 4 types. That would be quite arbitrary but maybe OK."}]}]}],"thread_ts":"1614126396.041800","parent_user_id":"U72B7LTMX"}]