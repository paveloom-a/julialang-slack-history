[{"client_msg_id":"65ff654c-7919-43ed-a6fe-1941045ff876","type":"message","text":"No 'as fast as a loop'  `yield` statements in Julia base.","user":"U01FAHWCMFF","ts":"1617140446.230000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uQR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No 'as fast as a loop'  "},{"type":"text","text":"yield","style":{"code":true}},{"type":"text","text":" statements in Julia base."}]}]}],"thread_ts":"1617140446.230000","reply_count":21,"reply_users_count":5,"latest_reply":"1617157240.237800","reply_users":["U0179G7FG4F","U8D9768Q6","U6QGE7S86","U01FAHWCMFF","UC7AF7NSU"],"is_locked":false,"subscribed":false},{"client_msg_id":"61e3a1fa-5cfb-410f-bb44-b0d4c65b0ac3","type":"message","text":"yeah. Python's `yield` is really nice. I really wish Julia had something as good. (Unfortunately, I think `yield` might not be possible to make fast)","user":"U0179G7FG4F","ts":"1617140595.230100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WuuYT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah. Python's "},{"type":"text","text":"yield","style":{"code":true}},{"type":"text","text":" is really nice. I really wish Julia had something as good. (Unfortunately, I think "},{"type":"text","text":"yield","style":{"code":true}},{"type":"text","text":" might not be possible to make fast)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"97a0813b-f740-4a1a-b0de-4657bfd3acb1","type":"message","text":"FGenerators.jl and FLoops.jl together get you a lot","user":"U8D9768Q6","ts":"1617140619.230300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pbli","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"FGenerators.jl and FLoops.jl together get you a lot"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5e1e7afb-516b-4035-8377-5c16411d0713","type":"message","text":"Asymptotically about as fast as a for loop, not sure what the extra allocations are.\n```julia&gt; using FGenerators\n\njulia&gt; @fgenerator function squares_yield(nmax)\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n           end\n       end\nsquares_yield (generic function with 1 method)\n\njulia&gt; function squares_eager(nmax)\n           out = Int[]\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   push!(out, n)\n               end\n           end\n           out\n       end\nsquares_eager (generic function with 1 method)\n\njulia&gt; foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime collect(squares_yield($n[]))\n           @btime         squares_eager($n[])\n           println()\n       end\nn[] = 10\n  138.952 ns (4 allocations: 208 bytes)\n  118.216 ns (2 allocations: 128 bytes)\n\nn[] = 1000\n  10.619 μs (35 allocations: 1.56 KiB)\n  10.390 μs (5 allocations: 624 bytes)\n\nn[] = 1000000\n  10.202 ms (1009 allocations: 47.62 KiB)\n  9.899 ms (10 allocations: 16.39 KiB)```","user":"U8D9768Q6","ts":"1617141237.230500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mM5tZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Asymptotically about as fast as a for loop, not sure what the extra allocations are.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using FGenerators\n\njulia> @fgenerator function squares_yield(nmax)\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n           end\n       end\nsquares_yield (generic function with 1 method)\n\njulia> function squares_eager(nmax)\n           out = Int[]\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   push!(out, n)\n               end\n           end\n           out\n       end\nsquares_eager (generic function with 1 method)\n\njulia> foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime collect(squares_yield($n[]))\n           @btime         squares_eager($n[])\n           println()\n       end\nn[] = 10\n  138.952 ns (4 allocations: 208 bytes)\n  118.216 ns (2 allocations: 128 bytes)\n\nn[] = 1000\n  10.619 μs (35 allocations: 1.56 KiB)\n  10.390 μs (5 allocations: 624 bytes)\n\nn[] = 1000000\n  10.202 ms (1009 allocations: 47.62 KiB)\n  9.899 ms (10 allocations: 16.39 KiB)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"937f543e-2d7f-42ac-9afa-a772915b2bff","type":"message","text":"Here's the same, but a summed `fgenerator` versus an explicit loop.\n```julia&gt; function sum_squares_to(nmax)\n           out = 0\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   out += n\n               end\n           end\n           out\n       end\nsum_squares_to (generic function with 1 method)\n\njulia&gt; foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime sum(squares_yield($n[]))\n           @btime sum_squares_to($n[])\n           println()\n       end\nn[] = 10\n  70.790 ns (0 allocations: 0 bytes)\n  72.445 ns (0 allocations: 0 bytes)\n\nn[] = 1000\n  10.299 μs (0 allocations: 0 bytes)\n  10.240 μs (0 allocations: 0 bytes)\n\nn[] = 1000000\n  10.109 ms (0 allocations: 0 bytes)\n  10.188 ms (0 allocations: 0 bytes)```","user":"U8D9768Q6","ts":"1617144595.231000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J1L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here's the same, but a summed "},{"type":"text","text":"fgenerator","style":{"code":true}},{"type":"text","text":" versus an explicit loop.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function sum_squares_to(nmax)\n           out = 0\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   out += n\n               end\n           end\n           out\n       end\nsum_squares_to (generic function with 1 method)\n\njulia> foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime sum(squares_yield($n[]))\n           @btime sum_squares_to($n[])\n           println()\n       end\nn[] = 10\n  70.790 ns (0 allocations: 0 bytes)\n  72.445 ns (0 allocations: 0 bytes)\n\nn[] = 1000\n  10.299 μs (0 allocations: 0 bytes)\n  10.240 μs (0 allocations: 0 bytes)\n\nn[] = 1000000\n  10.109 ms (0 allocations: 0 bytes)\n  10.188 ms (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5abb9d86-32d6-469f-bdd8-e6b1bec71473","type":"message","text":"<@U0179G7FG4F> I think the part that's questionable is if *iterators* can generally be as fast as loops. On the other hand, transducers seem to offer very compelling ways to optimize things like yields.\n\nI think in theory, a yielding transducer should be possible to be just as fast as the corresponding loop while being lazy and composable.","user":"U8D9768Q6","ts":"1617144851.231200","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1617144910.000000"},"blocks":[{"type":"rich_text","block_id":"fW=Jk","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U0179G7FG4F"},{"type":"text","text":" I think the part that's questionable is if "},{"type":"text","text":"iterators","style":{"bold":true}},{"type":"text","text":" can generally be as fast as loops. On the other hand, transducers seem to offer very compelling ways to optimize things like yields.\n\nI think in theory, a yielding transducer should be possible to be just as fast as the corresponding loop while being lazy and composable."}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"476a3abc-8802-49a0-b11b-139bf362c418","type":"message","text":"Wait what's a yield and why is it nice?","user":"U6QGE7S86","ts":"1617147379.233300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S6XI0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Wait what's a yield and why is it nice?"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5d879adf-ad23-46a8-baec-45271ac66dc0","type":"message","text":"All the methods you’ve shown need the size specified within the function call.\n\nWhile that is great for many use-cases, I’m wondering if it can be done using while loops and `next` commands like python. While loops are great when querying APIs or doing IO stuff.\n\nExample: Lets say Im using a rest API to download a big table. The API returns an iterator so that the user can download as little or as much of the data as they want.\n```function download_table(query)\n    table_iterator = postRequest(query)\n    while table_iterator != nothing\n        yield table_iterator\n    end\nend\n\ntable_iteration = download_table(query)\n\n# I only want two rows of my table\nappendToFile('mytable.csv', next(table_iterator))\nappendToFile('mytable.csv', next(table_iterator))\n\n# Now i want all the rows of my table\nwhile table_iterator != nothing\n    appendToFile('mytable.csv', next(table_iterator))\nend```","user":"U01FAHWCMFF","ts":"1617147452.233500","team":"T68168MUP","edited":{"user":"U01FAHWCMFF","ts":"1617147802.000000"},"blocks":[{"type":"rich_text","block_id":"GQ67","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"All the methods you’ve shown need the size specified within the function call.\n\nWhile that is great for many use-cases, I’m wondering if it can be done using while loops and "},{"type":"text","text":"next","style":{"code":true}},{"type":"text","text":" commands like python. While loops are great when querying APIs or doing IO stuff.\n\nExample: Lets say Im using a rest API to download a big table. The API returns an iterator so that the user can download as little or as much of the data as they want.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function download_table(query)\n    table_iterator = postRequest(query)\n    while table_iterator != nothing\n        yield table_iterator\n    end\nend\n\ntable_iteration = download_table(query)\n\n# I only want two rows of my table\nappendToFile('mytable.csv', next(table_iterator))\nappendToFile('mytable.csv', next(table_iterator))\n\n# Now i want all the rows of my table\nwhile table_iterator != nothing\n    appendToFile('mytable.csv', next(table_iterator))\nend"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"e86af8cb-5a42-46bf-9a29-36492f08de12","type":"message","text":"&gt; Wait what's a yield and why is it nice?\nIt's a way of writing lazy generators / iterators / foldables. You just tell the function what it should lazily return.","user":"U8D9768Q6","ts":"1617147560.233900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r=V","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Wait what's a yield and why is it nice?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It's a way of writing lazy generators / iterators / foldables. You just tell the function what it should lazily return."}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"96d3e315-f3e2-4db5-9a2d-1a97d763ef55","type":"message","text":"<@U01FAHWCMFF> there's no reason in principal one must supply a size to the `@fgenerator`. You can just make the fgenerator infinite and then combine it with `Transducers.Take` or `Transducers.Reduced`. However, this unfortunately seems to cause a performance degredation in FGenerators and I'm not sure why.","user":"U8D9768Q6","ts":"1617148479.234500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"N67F","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01FAHWCMFF"},{"type":"text","text":" there's no reason in principal one must supply a size to the "},{"type":"text","text":"@fgenerator","style":{"code":true}},{"type":"text","text":". You can just make the fgenerator infinite and then combine it with "},{"type":"text","text":"Transducers.Take","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"Transducers.Reduced","style":{"code":true}},{"type":"text","text":". However, this unfortunately seems to cause a performance degredation in FGenerators and I'm not sure why."}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"+1","users":["U01FAHWCMFF"],"count":1}]},{"client_msg_id":"cec00c02-c10f-4496-9070-77be115b00ba","type":"message","text":"<@UC7AF7NSU> Do you know what's going wrong here? Perhaps a type instability?\n```julia&gt; using FGenerators, Transducers\n\njulia&gt; @fgenerator function squares_yield()\n           n = 1\n           while true\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n               n += 1\n           end\n       end\nsquares_yield (generic function with 1 method)\n\njulia&gt; function sum_squares_to(nmax)\n           out = 0\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   out += n\n               end\n           end\n           out\n       end\nsum_squares_to (generic function with 1 method)\n\njulia&gt; foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime sum(squares_yield() |&gt; Take($n[]))\n           @btime sum_squares_to($n[])\n           println()\n       end\nn[] = 10\n  2.531 μs (32 allocations: 816 bytes)\n  72.507 ns (0 allocations: 0 bytes)\n\nn[] = 1000\n  10.412 ms (4481 allocations: 101.25 KiB)\n  10.249 μs (0 allocations: 0 bytes)\n\nn[] = 1000000\n  14.267 s (4999481 allocations: 106.80 MiB)\n  10.013 ms (0 allocations: 0 bytes)```","user":"U8D9768Q6","ts":"1617148701.234700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aMR","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UC7AF7NSU"},{"type":"text","text":" Do you know what's going wrong here? Perhaps a type instability?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using FGenerators, Transducers\n\njulia> @fgenerator function squares_yield()\n           n = 1\n           while true\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n               n += 1\n           end\n       end\nsquares_yield (generic function with 1 method)\n\njulia> function sum_squares_to(nmax)\n           out = 0\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   out += n\n               end\n           end\n           out\n       end\nsum_squares_to (generic function with 1 method)\n\njulia> foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime sum(squares_yield() |> Take($n[]))\n           @btime sum_squares_to($n[])\n           println()\n       end\nn[] = 10\n  2.531 μs (32 allocations: 816 bytes)\n  72.507 ns (0 allocations: 0 bytes)\n\nn[] = 1000\n  10.412 ms (4481 allocations: 101.25 KiB)\n  10.249 μs (0 allocations: 0 bytes)\n\nn[] = 1000000\n  14.267 s (4999481 allocations: 106.80 MiB)\n  10.013 ms (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"a75e5397-ab8e-4121-ac9f-680bf233a66a","type":"message","text":"```julia&gt; versioninfo()\nJulia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD Ryzen 5 2600 Six-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver1)\nEnvironment:\n  JULIA_NUM_THREADS = 6```\nI can open an issue in FGenerators or Transducers if you like, not sure where would be most appropriate","user":"U8D9768Q6","ts":"1617148952.234900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sRwn","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> versioninfo()\nJulia Version 1.6.0\nCommit f9720dc2eb* (2021-03-24 12:55 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD Ryzen 5 2600 Six-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver1)\nEnvironment:\n  JULIA_NUM_THREADS = 6"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I can open an issue in FGenerators or Transducers if you like, not sure where would be most appropriate"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"8082c777-a914-4c67-85d5-a976a78f153a","type":"message","text":"`sum(squares_yield() |&gt; Take($n[]))` and `sum_squares_to($n[])` compute different things, right? `Take(n)` means to hit the yield `n` times while `sum_squares_to($n[])` do the iteration `n` times (so it hits the inner block of `if` much less times)","user":"UC7AF7NSU","ts":"1617150571.235600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3jvw0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sum(squares_yield() |> Take($n[]))","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"sum_squares_to($n[])","style":{"code":true}},{"type":"text","text":" compute different things, right? "},{"type":"text","text":"Take(n)","style":{"code":true}},{"type":"text","text":" means to hit the yield "},{"type":"text","text":"n","style":{"code":true}},{"type":"text","text":" times while "},{"type":"text","text":"sum_squares_to($n[])","style":{"code":true}},{"type":"text","text":" do the iteration "},{"type":"text","text":"n","style":{"code":true}},{"type":"text","text":" times (so it hits the inner block of "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" much less times)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"bbe322de-2e0a-4c08-9cb2-44b0c149f31f","type":"message","text":"But yeah, `Take` is still a bit harsh to the compiler. e.g., `sum(squares_yield() |&gt; Take(10000); init = 0)` is much better for inference. This also helps inference:\n\n```julia&gt; @fgenerator function squares_yield2()\n           @yield 1\n           n = 2\n           while true\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n               n += 1\n           end\n       end```","user":"UC7AF7NSU","ts":"1617150788.235900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XxzYc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But yeah, "},{"type":"text","text":"Take","style":{"code":true}},{"type":"text","text":" is still a bit harsh to the compiler. e.g., "},{"type":"text","text":"sum(squares_yield() |> Take(10000); init = 0)","style":{"code":true}},{"type":"text","text":" is much better for inference. This also helps inference:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @fgenerator function squares_yield2()\n           @yield 1\n           n = 2\n           while true\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n               n += 1\n           end\n       end"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"bf06e524-600d-4b32-9414-ee74453ba391","type":"message","text":"Oh, right of course, thanks on both counts.","user":"U8D9768Q6","ts":"1617151008.236100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f4erc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, right of course, thanks on both counts."}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"4a552fd1-ee99-4c7c-8634-cf20dafadee4","type":"message","text":"I was thinking about how we'd do Ayman's example above with a foldable. It seems we need a concept of `Transducers.Peel` in order to do it well though. Any ideas?","user":"U8D9768Q6","ts":"1617151070.236300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tvwEH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was thinking about how we'd do Ayman's example above with a foldable. It seems we need a concept of "},{"type":"text","text":"Transducers.Peel","style":{"code":true}},{"type":"text","text":" in order to do it well though. Any ideas?"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"53770c19-2fc3-4661-87e2-3603d90a62d9","type":"message","text":"That is, the Transducers.jl version of `Iterators.peel`. If we had it, the example could be something like\n```@fgenerator function download_table(query)\n    table_iterator = postRequest(query)\n    while table_iterator != nothing\n        @yield table_iterator\n    end\nend\n\nfunction next(f::Foldable)\n    x = foldxl(f) do x, _\n        reduced(x)\n    end\n    x, f |&gt; Peel \nend\n\ntable_iteration = download_table(query)\n# I only want two rows of my table\nrow, table_iterator = next(table_iterator)\nappendToFile('mytable.csv', row)\nrow, table_iterator = next(table_iterator)\nappendToFile('mytable.csv', row)\n# Now i want all the rows of my table\nwhile table_iterator != nothing\n    row, table_iterator = next(table_iterator)\n    appendToFile('mytable.csv', row)\nend```","user":"U8D9768Q6","ts":"1617151377.236500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vgZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is, the Transducers.jl version of "},{"type":"text","text":"Iterators.peel","style":{"code":true}},{"type":"text","text":". If we had it, the example could be something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@fgenerator function download_table(query)\n    table_iterator = postRequest(query)\n    while table_iterator != nothing\n        @yield table_iterator\n    end\nend\n\nfunction next(f::Foldable)\n    x = foldxl(f) do x, _\n        reduced(x)\n    end\n    x, f |> Peel \nend\n\ntable_iteration = download_table(query)\n# I only want two rows of my table\nrow, table_iterator = next(table_iterator)\nappendToFile('mytable.csv', row)\nrow, table_iterator = next(table_iterator)\nappendToFile('mytable.csv', row)\n# Now i want all the rows of my table\nwhile table_iterator != nothing\n    row, table_iterator = next(table_iterator)\n    appendToFile('mytable.csv', row)\nend"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"b2a0f226-d6c4-4a7e-be41-4a79b1d08dac","type":"message","text":"\"Stepping\" on the consumer side is pretty much what `iterate` is designed for. So, I guess we better just use `iterate`?","user":"UC7AF7NSU","ts":"1617151756.236700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/vl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"\"Stepping\" on the consumer side is pretty much what "},{"type":"text","text":"iterate","style":{"code":true}},{"type":"text","text":" is designed for. So, I guess we better just use "},{"type":"text","text":"iterate","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"f1986f11-42b1-4245-be9e-13447c1990ae","type":"message","text":"(This is exactly why I wanted something like GeneratorsX.jl, to co-generate iterator and fold)","user":"UC7AF7NSU","ts":"1617151763.236900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/=Iyn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(This is exactly why I wanted something like GeneratorsX.jl, to co-generate iterator and fold)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"8fa20263-7e51-4514-bb13-d88f21afcbca","type":"message","text":"sorry if you wanted to hear more foldl-extremist opinion from me :laughing:","user":"UC7AF7NSU","ts":"1617151803.237100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iSpq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sorry if you wanted to hear more foldl-extremist opinion from me "},{"type":"emoji","name":"laughing"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"joy","users":["U8D9768Q6"],"count":1}]},{"client_msg_id":"7cbaae75-055c-4890-ade6-0a3da4f16149","type":"message","text":"<@U01FAHWCMFF> Just in case you haven't considered this, you can use `Channel` for what you wrote:\n\n```function download_table(query)\n    return Channel() do ch\n        while true\n            x = postRequest(query)\n            x === nothing &amp;&amp; break\n            put!(ch, x)\n        end\n    end\nend\n\ntable_iterator = download_table(query)\n\nappendToFile('mytable.csv', take!(table_iterator))\nappendToFile('mytable.csv', take!(table_iterator))\n\n# Now i want all the rows of my table\nfor x in table_iterator\n    appendToFile('mytable.csv', x)\nend```\nOf course, Channel adds some overhead. But I don't think it's relevant if you are doing I/O like network request. Also, having channel as an abstraction is good for concurrent processing using multiple threads.","user":"UC7AF7NSU","ts":"1617155199.237500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XaM","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01FAHWCMFF"},{"type":"text","text":" Just in case you haven't considered this, you can use "},{"type":"text","text":"Channel","style":{"code":true}},{"type":"text","text":" for what you wrote:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function download_table(query)\n    return Channel() do ch\n        while true\n            x = postRequest(query)\n            x === nothing && break\n            put!(ch, x)\n        end\n    end\nend\n\ntable_iterator = download_table(query)\n\nappendToFile('mytable.csv', take!(table_iterator))\nappendToFile('mytable.csv', take!(table_iterator))\n\n# Now i want all the rows of my table\nfor x in table_iterator\n    appendToFile('mytable.csv', x)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nOf course, Channel adds some overhead. But I don't think it's relevant if you are doing I/O like network request. Also, having channel as an abstraction is good for concurrent processing using multiple threads."}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"+1","users":["U8D9768Q6","U01FAHWCMFF"],"count":2}]},{"client_msg_id":"9fbc0d62-d12f-4225-9d24-1f529ade279f","type":"message","text":"Thank you <@UC7AF7NSU>","user":"U01FAHWCMFF","ts":"1617157240.237800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KeG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you "},{"type":"user","user_id":"UC7AF7NSU"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"}]