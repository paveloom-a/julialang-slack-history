[{"client_msg_id":"65ff654c-7919-43ed-a6fe-1941045ff876","type":"message","text":"No 'as fast as a loop'  `yield` statements in Julia base.","user":"U01FAHWCMFF","ts":"1617140446.230000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uQR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No 'as fast as a loop'  "},{"type":"text","text":"yield","style":{"code":true}},{"type":"text","text":" statements in Julia base."}]}]}],"thread_ts":"1617140446.230000","reply_count":5,"reply_users_count":2,"latest_reply":"1617144851.231200","reply_users":["U0179G7FG4F","U8D9768Q6"],"is_locked":false,"subscribed":false},{"client_msg_id":"61e3a1fa-5cfb-410f-bb44-b0d4c65b0ac3","type":"message","text":"yeah. Python's `yield` is really nice. I really wish Julia had something as good. (Unfortunately, I think `yield` might not be possible to make fast)","user":"U0179G7FG4F","ts":"1617140595.230100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WuuYT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah. Python's "},{"type":"text","text":"yield","style":{"code":true}},{"type":"text","text":" is really nice. I really wish Julia had something as good. (Unfortunately, I think "},{"type":"text","text":"yield","style":{"code":true}},{"type":"text","text":" might not be possible to make fast)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"97a0813b-f740-4a1a-b0de-4657bfd3acb1","type":"message","text":"FGenerators.jl and FLoops.jl together get you a lot","user":"U8D9768Q6","ts":"1617140619.230300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pbli","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"FGenerators.jl and FLoops.jl together get you a lot"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5e1e7afb-516b-4035-8377-5c16411d0713","type":"message","text":"Asymptotically about as fast as a for loop, not sure what the extra allocations are.\n```julia&gt; using FGenerators\n\njulia&gt; @fgenerator function squares_yield(nmax)\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n           end\n       end\nsquares_yield (generic function with 1 method)\n\njulia&gt; function squares_eager(nmax)\n           out = Int[]\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   push!(out, n)\n               end\n           end\n           out\n       end\nsquares_eager (generic function with 1 method)\n\njulia&gt; foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime collect(squares_yield($n[]))\n           @btime         squares_eager($n[])\n           println()\n       end\nn[] = 10\n  138.952 ns (4 allocations: 208 bytes)\n  118.216 ns (2 allocations: 128 bytes)\n\nn[] = 1000\n  10.619 μs (35 allocations: 1.56 KiB)\n  10.390 μs (5 allocations: 624 bytes)\n\nn[] = 1000000\n  10.202 ms (1009 allocations: 47.62 KiB)\n  9.899 ms (10 allocations: 16.39 KiB)```","user":"U8D9768Q6","ts":"1617141237.230500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mM5tZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Asymptotically about as fast as a for loop, not sure what the extra allocations are.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using FGenerators\n\njulia> @fgenerator function squares_yield(nmax)\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   @yield n\n               end\n           end\n       end\nsquares_yield (generic function with 1 method)\n\njulia> function squares_eager(nmax)\n           out = Int[]\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   push!(out, n)\n               end\n           end\n           out\n       end\nsquares_eager (generic function with 1 method)\n\njulia> foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime collect(squares_yield($n[]))\n           @btime         squares_eager($n[])\n           println()\n       end\nn[] = 10\n  138.952 ns (4 allocations: 208 bytes)\n  118.216 ns (2 allocations: 128 bytes)\n\nn[] = 1000\n  10.619 μs (35 allocations: 1.56 KiB)\n  10.390 μs (5 allocations: 624 bytes)\n\nn[] = 1000000\n  10.202 ms (1009 allocations: 47.62 KiB)\n  9.899 ms (10 allocations: 16.39 KiB)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"937f543e-2d7f-42ac-9afa-a772915b2bff","type":"message","text":"Here's the same, but a summed `fgenerator` versus an explicit loop.\n```julia&gt; function sum_squares_to(nmax)\n           out = 0\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   out += n\n               end\n           end\n           out\n       end\nsum_squares_to (generic function with 1 method)\n\njulia&gt; foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime sum(squares_yield($n[]))\n           @btime sum_squares_to($n[])\n           println()\n       end\nn[] = 10\n  70.790 ns (0 allocations: 0 bytes)\n  72.445 ns (0 allocations: 0 bytes)\n\nn[] = 1000\n  10.299 μs (0 allocations: 0 bytes)\n  10.240 μs (0 allocations: 0 bytes)\n\nn[] = 1000000\n  10.109 ms (0 allocations: 0 bytes)\n  10.188 ms (0 allocations: 0 bytes)```","user":"U8D9768Q6","ts":"1617144595.231000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J1L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here's the same, but a summed "},{"type":"text","text":"fgenerator","style":{"code":true}},{"type":"text","text":" versus an explicit loop.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function sum_squares_to(nmax)\n           out = 0\n           for n in 1:nmax\n               sqrtn = sqrt(n)\n               if sqrtn ≈ round(sqrtn)\n                   out += n\n               end\n           end\n           out\n       end\nsum_squares_to (generic function with 1 method)\n\njulia> foreach(Ref.((10, 1_000, 1_000_000))) do n\n           @show n[]\n           @btime sum(squares_yield($n[]))\n           @btime sum_squares_to($n[])\n           println()\n       end\nn[] = 10\n  70.790 ns (0 allocations: 0 bytes)\n  72.445 ns (0 allocations: 0 bytes)\n\nn[] = 1000\n  10.299 μs (0 allocations: 0 bytes)\n  10.240 μs (0 allocations: 0 bytes)\n\nn[] = 1000000\n  10.109 ms (0 allocations: 0 bytes)\n  10.188 ms (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5abb9d86-32d6-469f-bdd8-e6b1bec71473","type":"message","text":"<@U0179G7FG4F> I think the part that's questionable is if *iterators* can generally be as fast as loops. On the other hand, transducers seem to offer very compelling ways to optimize things like yields.\n\nI think in theory, a yielding transducer should be possible to be just as fast as the corresponding loop while being lazy and composable.","user":"U8D9768Q6","ts":"1617144851.231200","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1617144910.000000"},"blocks":[{"type":"rich_text","block_id":"fW=Jk","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U0179G7FG4F"},{"type":"text","text":" I think the part that's questionable is if "},{"type":"text","text":"iterators","style":{"bold":true}},{"type":"text","text":" can generally be as fast as loops. On the other hand, transducers seem to offer very compelling ways to optimize things like yields.\n\nI think in theory, a yielding transducer should be possible to be just as fast as the corresponding loop while being lazy and composable."}]}]}],"thread_ts":"1617140446.230000","parent_user_id":"U01FAHWCMFF"}]