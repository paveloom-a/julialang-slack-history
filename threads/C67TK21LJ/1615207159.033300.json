[{"client_msg_id":"925145a7-f614-410e-afbc-42fc86b7a837","type":"message","text":"\"Julia needs better tools for understanding heap allocations and how to avoid them. Sometimes I feel like giving up and going back to C/C++ where I actually understand what is going on. It is frustrating finding workarounds that avoid unnecessary allocations without really understanding why these work.\" I share this feeling, but going back to C/C++ is not an option for me. I like the rest that Julia has to offer too much.","user":"UEA5FBCRH","ts":"1615207159.033300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fLH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"\"Julia needs better tools for understanding heap allocations and how to avoid them. Sometimes I feel like giving up and going back to C/C++ where I actually understand what is going on. It is frustrating finding workarounds that avoid unnecessary allocations without really understanding why these work.\" I share this feeling, but going back to C/C++ is not an option for me. I like the rest that Julia has to offer too much."}]}]}],"thread_ts":"1615207159.033300","reply_count":11,"reply_users_count":6,"latest_reply":"1615226414.054000","reply_users":["U67D54KS8","ULMSM9MAL","U7HAYKY9X","UAUCGGD6C","U6795JH6H","UEA5FBCRH"],"subscribed":false},{"client_msg_id":"db3a7fb0-79ce-4e30-915a-3df13dcde120","type":"message","text":"Saying C/C++ like they are at all similar with respect to heap allocation is a bit weird imo. C should be fairly easy to understand but accidental copies and allocations in C++ is all over the place. Move semantics, return value optimization, copy elision, implicit converts that allocate, perfect forwarding etc etc. See e.g <https://www.youtube.com/watch?v=PNRju6_yn3o> for some interesting examples.","user":"U67D54KS8","ts":"1615207456.035000","team":"T68168MUP","edited":{"user":"U67D54KS8","ts":"1615207479.000000"},"attachments":[{"service_name":"YouTube","service_url":"https://www.youtube.com/","title":"CppCon 2017: Nicolai Josuttis “The Nightmare of Move Semantics for Trivial Classes”","title_link":"https://www.youtube.com/watch?v=PNRju6_yn3o","author_name":"CppCon","author_link":"https://www.youtube.com/user/CppCon","thumb_url":"https://i.ytimg.com/vi/PNRju6_yn3o/hqdefault.jpg","thumb_width":480,"thumb_height":360,"fallback":"YouTube Video: CppCon 2017: Nicolai Josuttis “The Nightmare of Move Semantics for Trivial Classes”","video_html":"<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/PNRju6_yn3o?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","video_html_width":400,"video_html_height":225,"from_url":"https://www.youtube.com/watch?v=PNRju6_yn3o","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png","id":1,"original_url":"https://www.youtube.com/watch?v=PNRju6_yn3o"}],"blocks":[{"type":"rich_text","block_id":"oHcg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Saying C/C++ like they are at all similar with respect to heap allocation is a bit weird imo. C should be fairly easy to understand but accidental copies and allocations in C++ is all over the place. Move semantics, return value optimization, copy elision, implicit converts that allocate, perfect forwarding etc etc. See e.g "},{"type":"link","url":"https://www.youtube.com/watch?v=PNRju6_yn3o"},{"type":"text","text":" for some interesting examples."}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"dd4706fb-00c7-4985-9134-86babbed877f","type":"message","text":"Go has some excellent resources on when things escape to the heap. Maybe something like that exists for Julia already?","user":"ULMSM9MAL","ts":"1615208711.035400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2T6VW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Go has some excellent resources on when things escape to the heap. Maybe something like that exists for Julia already?"}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"43362798-366b-4308-af79-875134d3b640","type":"message","text":"There is a fundamental issue of Julia that much of what makes it fast is considered an implementation detail. That overall a good thing, but it does mean that there are many cases where you can't order the compiler to do X (e.g. avoid allocations, or SIMD something)","user":"U7HAYKY9X","ts":"1615208775.035600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"c9UF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is a fundamental issue of Julia that much of what makes it fast is considered an implementation detail. That overall a good thing, but it does mean that there are many cases where you can't order the compiler to do X (e.g. avoid allocations, or SIMD something)"}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"56902fc8-baa7-4a02-989a-93d44f8db31e","type":"message","text":"On toy problems I've been able to avoid most or all allocations in Julia by writing it like C code.","user":"UAUCGGD6C","ts":"1615212723.037100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w4UJi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On toy problems I've been able to avoid most or all allocations in Julia by writing it like C code."}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"A7E0E99A-1362-4CAB-8034-0AA457C9ACE1","type":"message","text":"The general rule of thumb is that any dynamically sized data structure will probably be heap allocated, ie (non-static) arrays, dicts, etc.","user":"U6795JH6H","ts":"1615221590.043100","team":"T68168MUP","edited":{"user":"U6795JH6H","ts":"1615221658.000000"},"blocks":[{"type":"rich_text","block_id":"laL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The general rule of thumb is that any dynamically sized data structure will probably be heap allocated, ie (non-static) arrays, dicts, etc."}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"09431E1C-9ABE-425F-8736-B41AB2A21D26","type":"message","text":"Statically sized small objects will generally be stack allocated: native number types, tulles static arrays, views post 1.5","user":"U6795JH6H","ts":"1615221647.044800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=Wvf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Statically sized small objects will generally be stack allocated: native number types, tulles static arrays, views post 1.5"}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"23190FF9-6F21-495A-BE6E-F3F222CEBE11","type":"message","text":"I would also point out that people are generally a little too concerned about avoiding heap allocation. On the CPU, it’s often little or no performance hit to do a bit of allocation.","user":"U6795JH6H","ts":"1615221752.047300","team":"T68168MUP","edited":{"user":"U6795JH6H","ts":"1615221781.000000"},"blocks":[{"type":"rich_text","block_id":"NSa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would also point out that people are generally a little too concerned about avoiding heap allocation. On the CPU, it’s often little or no performance hit to do a bit of allocation."}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"07FEA2FF-BB91-42E7-89BE-84ECC1767AFE","type":"message","text":"In some situations you need to avoid potentially running gc, like if you need to ensure no pauses or on the GPU","user":"U6795JH6H","ts":"1615221837.049000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Qnyj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In some situations you need to avoid potentially running gc, like if you need to ensure no pauses or on the GPU"}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"227E703F-9F9E-41A1-9065-B6FF16C43037","type":"message","text":"There it would indeed be good to have more tools for trying harder to avoid allocation","user":"U6795JH6H","ts":"1615221874.050200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R04","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There it would indeed be good to have more tools for trying harder to avoid allocation"}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"D56AB2A7-D2AC-4895-84F8-20A05142E6EC","type":"message","text":"Regarding the rule of thumb, if you think of creating an array as doing a malloc call, you’re not going to be far off; creating an instance of a mutable object is the other case that allocated a fixed size object on the heap. The annoyance there is having to know if something is mutable or not","user":"U6795JH6H","ts":"1615222021.053500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0VR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Regarding the rule of thumb, if you think of creating an array as doing a malloc call, you’re not going to be far off; creating an instance of a mutable object is the other case that allocated a fixed size object on the heap. The annoyance there is having to know if something is mutable or not"}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH"},{"client_msg_id":"8d920c84-d378-497f-a460-2e1189dc441e","type":"message","text":"Thanks a lot for the comments. Hopefully, with more hands-on experience I'll get a better model of what gets allocated where and why. Just wanted to share that this is an aspect that us coming from a C background tend to struggle with when optimizing for performance.","user":"UEA5FBCRH","ts":"1615226414.054000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0UJK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks a lot for the comments. Hopefully, with more hands-on experience I'll get a better model of what gets allocated where and why. Just wanted to share that this is an aspect that us coming from a C background tend to struggle with when optimizing for performance."}]}]}],"thread_ts":"1615207159.033300","parent_user_id":"UEA5FBCRH","reactions":[{"name":"+1","users":["U6795JH6H"],"count":1}]}]