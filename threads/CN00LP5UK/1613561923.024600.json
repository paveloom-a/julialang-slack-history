[{"client_msg_id":"e28f609f-e1a6-482b-8357-3323b4099db6","type":"message","text":":star:: JET.jl is amazing. It's static analysis for Julia! :D And it also works in practice!\n:grapes: : As soon as I apply it to anything I write, it turns out possible type errors in Base and various lower-level packages I use. That's not a problem with JET, but... it's like opening a Pandora's box of issues in Base and everywhere else.","user":"U7HAYKY9X","ts":"1613561923.024600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HMCfm","elements":[{"type":"rich_text_section","elements":[{"type":"emoji","name":"star"},{"type":"text","text":": JET.jl is amazing. It's static analysis for Julia! :D And it also works in practice!\n"},{"type":"emoji","name":"grapes"},{"type":"text","text":" : As soon as I apply it to anything I write, it turns out possible type errors in Base and various lower-level packages I use. That's not a problem with JET, but... it's like opening a Pandora's box of issues in Base and everywhere else."}]}]}],"thread_ts":"1613561923.024600","reply_count":4,"reply_users_count":2,"latest_reply":"1613566247.025300","reply_users":["U73KENNG4","U7HAYKY9X"],"subscribed":false},{"client_msg_id":"4ea6c61c-27ca-4d1e-8a53-20c8aca4cf9d","type":"message","text":"I had a bit of a hard time imagining actual use cases for this - could you give examples?","user":"U73KENNG4","ts":"1613564171.024700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D=GM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I had a bit of a hard time imagining actual use cases for this - could you give examples?"}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"1a0d7b48-6502-420a-bd8b-831d4d3ed9d3","type":"message","text":"It's good for catching bugs that may not be obvious. It would be even better for catching bugs if people would lean a little heavier on the type system to cover edge cases.\nFor example, I just ran JET on some code with a FASTA file, where I would do some manipulation of the FASTA identifier. Turns out `FASTA.identifier(::Record)` returns `Union{String, Nothing}`  - I totally forgot that `nothing` is a valid return value, so there was a latent bug in my code that I probably wouldn't have discovered.","user":"U7HAYKY9X","ts":"1613565501.024900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4hEx2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's good for catching bugs that may not be obvious. It would be even better for catching bugs if people would lean a little heavier on the type system to cover edge cases.\nFor example, I just ran JET on some code with a FASTA file, where I would do some manipulation of the FASTA identifier. Turns out "},{"type":"text","text":"FASTA.identifier(::Record)","style":{"code":true}},{"type":"text","text":" returns "},{"type":"text","text":"Union{String, Nothing}","style":{"code":true}},{"type":"text","text":"  - I totally forgot that "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" is a valid return value, so there was a latent bug in my code that I probably wouldn't have discovered."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"200d6ed7-443f-4f67-8663-c84e04e07d08","type":"message","text":"But I do hope that the advent of static checking will change what people percieve to be idiomatic Julia code. Here's an example: In Julia 0.6, if `findfirst` failed to find anything, it returned `0` . In Julia 0.7, it returns `nothing` . When `maximum` fails to find something, it throws an error. That's three distinct ways of handling what happens when a function errors in an expected manner. Which is best, and why?\nI think it's clear that the `nothing` way is much better. And it also happens to be the only one amenable to static analysis.","user":"U7HAYKY9X","ts":"1613565760.025100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zyl+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I do hope that the advent of static checking will change what people percieve to be idiomatic Julia code. Here's an example: In Julia 0.6, if "},{"type":"text","text":"findfirst","style":{"code":true}},{"type":"text","text":" failed to find anything, it returned "},{"type":"text","text":"0","style":{"code":true}},{"type":"text","text":" . In Julia 0.7, it returns "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" . When "},{"type":"text","text":"maximum","style":{"code":true}},{"type":"text","text":" fails to find something, it throws an error. That's three distinct ways of handling what happens when a function errors in an expected manner. Which is best, and why?\nI think it's clear that the "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" way is much better. And it also happens to be the only one amenable to static analysis."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"f3b4cd1b-0934-4696-9e2b-f505afd6a1e4","type":"message","text":"very cool, thanks","user":"U73KENNG4","ts":"1613566247.025300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zaY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"very cool, thanks"}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"}]