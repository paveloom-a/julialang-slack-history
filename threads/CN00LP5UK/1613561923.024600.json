[{"client_msg_id":"e28f609f-e1a6-482b-8357-3323b4099db6","type":"message","text":":star:: JET.jl is amazing. It's static analysis for Julia! :D And it also works in practice!\n:grapes: : As soon as I apply it to anything I write, it turns out possible type errors in Base and various lower-level packages I use. That's not a problem with JET, but... it's like opening a Pandora's box of issues in Base and everywhere else.","user":"U7HAYKY9X","ts":"1613561923.024600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HMCfm","elements":[{"type":"rich_text_section","elements":[{"type":"emoji","name":"star"},{"type":"text","text":": JET.jl is amazing. It's static analysis for Julia! :D And it also works in practice!\n"},{"type":"emoji","name":"grapes"},{"type":"text","text":" : As soon as I apply it to anything I write, it turns out possible type errors in Base and various lower-level packages I use. That's not a problem with JET, but... it's like opening a Pandora's box of issues in Base and everywhere else."}]}]}],"thread_ts":"1613561923.024600","reply_count":8,"reply_users_count":4,"latest_reply":"1613570441.032400","reply_users":["U73KENNG4","U7HAYKY9X","UC8821DPY","UM30MT6RF"],"subscribed":false,"reactions":[{"name":"rocket","users":["UM30MT6RF","UC8821DPY"],"count":2},{"name":"heart","users":["UM30MT6RF","UC8821DPY"],"count":2}]},{"client_msg_id":"4ea6c61c-27ca-4d1e-8a53-20c8aca4cf9d","type":"message","text":"I had a bit of a hard time imagining actual use cases for this - could you give examples?","user":"U73KENNG4","ts":"1613564171.024700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D=GM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I had a bit of a hard time imagining actual use cases for this - could you give examples?"}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"1a0d7b48-6502-420a-bd8b-831d4d3ed9d3","type":"message","text":"It's good for catching bugs that may not be obvious. It would be even better for catching bugs if people would lean a little heavier on the type system to cover edge cases.\nFor example, I just ran JET on some code with a FASTA file, where I would do some manipulation of the FASTA identifier. Turns out `FASTA.identifier(::Record)` returns `Union{String, Nothing}`  - I totally forgot that `nothing` is a valid return value, so there was a latent bug in my code that I probably wouldn't have discovered.","user":"U7HAYKY9X","ts":"1613565501.024900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4hEx2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's good for catching bugs that may not be obvious. It would be even better for catching bugs if people would lean a little heavier on the type system to cover edge cases.\nFor example, I just ran JET on some code with a FASTA file, where I would do some manipulation of the FASTA identifier. Turns out "},{"type":"text","text":"FASTA.identifier(::Record)","style":{"code":true}},{"type":"text","text":" returns "},{"type":"text","text":"Union{String, Nothing}","style":{"code":true}},{"type":"text","text":"  - I totally forgot that "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" is a valid return value, so there was a latent bug in my code that I probably wouldn't have discovered."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"200d6ed7-443f-4f67-8663-c84e04e07d08","type":"message","text":"But I do hope that the advent of static checking will change what people percieve to be idiomatic Julia code. Here's an example: In Julia 0.6, if `findfirst` failed to find anything, it returned `0` . In Julia 0.7, it returns `nothing` . When `maximum` fails to find something, it throws an error. That's three distinct ways of handling what happens when a function errors in an expected manner. Which is best, and why?\nI think it's clear that the `nothing` way is much better. And it also happens to be the only one amenable to static analysis.","user":"U7HAYKY9X","ts":"1613565760.025100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zyl+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I do hope that the advent of static checking will change what people percieve to be idiomatic Julia code. Here's an example: In Julia 0.6, if "},{"type":"text","text":"findfirst","style":{"code":true}},{"type":"text","text":" failed to find anything, it returned "},{"type":"text","text":"0","style":{"code":true}},{"type":"text","text":" . In Julia 0.7, it returns "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" . When "},{"type":"text","text":"maximum","style":{"code":true}},{"type":"text","text":" fails to find something, it throws an error. That's three distinct ways of handling what happens when a function errors in an expected manner. Which is best, and why?\nI think it's clear that the "},{"type":"text","text":"nothing","style":{"code":true}},{"type":"text","text":" way is much better. And it also happens to be the only one amenable to static analysis."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"f3b4cd1b-0934-4696-9e2b-f505afd6a1e4","type":"message","text":"very cool, thanks","user":"U73KENNG4","ts":"1613566247.025300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zaY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"very cool, thanks"}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"3ce04df7-bb17-44bf-a5ab-cf8d642744a9","type":"message","text":"It's a general \"code quality\" analysis tool which I think has been sorely needed. A lot of the things we've done recently on invalidations would have been caught long ago had we had JET.\n\nAnother benefit is that inference failures reduce precompilability which increases latency (<https://julialang.org/blog/2021/01/precompile_tutorial/>). The new SnoopCompile `@snoopi_deep` is also sensitive to this particular issue and has a `suggest` framework to provide hints for fixing problems (<https://timholy.github.io/SnoopCompile.jl/stable/snoopi_deep_analysis/>). I've not done a detailed comparison between SnoopCompile and JET (I need to play with JET more myself), but one of the things I like about the JET approach are that it can catch problems for types you've not tested. I've found it a little more fragile and a little more performance-challenged, but presumably those are fixable problems. JET's promise is really extraordinary.","user":"UC8821DPY","ts":"1613569987.031200","team":"T68168MUP","attachments":[{"title":"Tutorial on precompilation","title_link":"https://julialang.org/blog/2021/01/precompile_tutorial/","text":"Tutorial on precompilation","fallback":"Tutorial on precompilation","image_url":"https://julialang.org/assets/images/julia-open-graph.png","from_url":"https://julialang.org/blog/2021/01/precompile_tutorial/","image_width":500,"image_height":250,"image_bytes":742374,"service_name":"julialang.org","id":1,"original_url":"https://julialang.org/blog/2021/01/precompile_tutorial/"}],"blocks":[{"type":"rich_text","block_id":"7zU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's a general \"code quality\" analysis tool which I think has been sorely needed. A lot of the things we've done recently on invalidations would have been caught long ago had we had JET.\n\nAnother benefit is that inference failures reduce precompilability which increases latency ("},{"type":"link","url":"https://julialang.org/blog/2021/01/precompile_tutorial/"},{"type":"text","text":"). The new SnoopCompile "},{"type":"text","text":"@snoopi_deep","style":{"code":true}},{"type":"text","text":" is also sensitive to this particular issue and has a "},{"type":"text","text":"suggest","style":{"code":true}},{"type":"text","text":" framework to provide hints for fixing problems ("},{"type":"link","url":"https://timholy.github.io/SnoopCompile.jl/stable/snoopi_deep_analysis/"},{"type":"text","text":"). I've not done a detailed comparison between SnoopCompile and JET (I need to play with JET more myself), but one of the things I like about the JET approach are that it can catch problems for types you've not tested. I've found it a little more fragile and a little more performance-challenged, but presumably those are fixable problems. JET's promise is really extraordinary."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"dc1adb93-8e81-4bcb-b3e7-2d40cd7d3351","type":"message","text":"<@UC8821DPY> Since you've spent a long time looking at the invalidations/inference failures of Base, do you have a sense that Julia will eventually get to a point where nearly all of Base is completely inferred, perhaps except some obvious places like REPL input and deserialization? Are there any techinical limitations to this, or is it perhaps not even really desired to get there?","user":"U7HAYKY9X","ts":"1613570178.031900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"87xy","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UC8821DPY"},{"type":"text","text":" Since you've spent a long time looking at the invalidations/inference failures of Base, do you have a sense that Julia will eventually get to a point where nearly all of Base is completely inferred, perhaps except some obvious places like REPL input and deserialization? Are there any techinical limitations to this, or is it perhaps not even really desired to get there?"}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X"},{"client_msg_id":"e957def5-b637-45db-b6e9-1ed5b052402a","type":"message","text":"Not practical to get to 100% inference. You don't want to have to compile specializations of `print(a, b, c, d, e, f, g, h, i)` for all possible combinations; `length(subtypes(Any)) == 534` for me, and so in theory this could require 4725533005843289600 specializations not including parametric types, subtypes of subtypes, etc. You need to place limits on inference to guarantee reasonable behavior.","user":"UC8821DPY","ts":"1613570440.032200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jdf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not practical to get to 100% inference. You don't want to have to compile specializations of "},{"type":"text","text":"print(a, b, c, d, e, f, g, h, i)","style":{"code":true}},{"type":"text","text":" for all possible combinations; "},{"type":"text","text":"length(subtypes(Any)) == 534","style":{"code":true}},{"type":"text","text":" for me, and so in theory this could require 4725533005843289600 specializations not including parametric types, subtypes of subtypes, etc. You need to place limits on inference to guarantee reasonable behavior."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X","reactions":[{"name":"+1","users":["UM30MT6RF","U7HAYKY9X"],"count":2}]},{"client_msg_id":"c9f7a606-0834-4485-886a-9bb21dbb2cb9","type":"message","text":"&gt; do you have a sense that Julia will eventually get to a point where nearly all of Base is completely inferred\nI am not sure that this is necessarily the goal, i.e. in a lot of cases we explicitly made inference worse, since more specialization is not always worth it. Especially the REPL has some good examples of code that is fundamentally uninferrable.","user":"UM30MT6RF","ts":"1613570441.032400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6vE6","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"do you have a sense that Julia will eventually get to a point where nearly all of Base is completely inferred"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I am not sure that this is necessarily the goal, i.e. in a lot of cases we explicitly made inference worse, since more specialization is not always worth it. Especially the REPL has some good examples of code that is fundamentally uninferrable."}]}]}],"thread_ts":"1613561923.024600","parent_user_id":"U7HAYKY9X","reactions":[{"name":"+1","users":["UC8821DPY"],"count":1}]}]