[{"client_msg_id":"c122e149-6978-41cf-8096-3cb93cfa062b","type":"message","text":"then `corr` should contain the values for `⟨A(t+τ)B(t)⟩`","user":"UBWLSPU1E","ts":"1617175665.019300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bC1d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"then "},{"type":"text","text":"corr","style":{"code":true}},{"type":"text","text":" should contain the values for "},{"type":"text","text":"⟨A(t+τ)B(t)⟩","style":{"code":true}}]}]}],"thread_ts":"1617175665.019300","reply_count":9,"reply_users_count":2,"latest_reply":"1617725495.026900","reply_users":["U0158N77PFT","UBWLSPU1E"],"is_locked":false,"subscribed":false},{"type":"message","text":"Thank you for the feedback. I'm attempting to rewrite the attached in Julia. I have the exponential and Gaussian wavepackets created, but calculating the first-order coherences of the sources' has been illusive so far.\n\nI'll try computing  `ρ0`  from a standard time evolution and use the approach you suggested.\n\nThanks again.","files":[{"id":"F01T0KVUHFC","created":1617241015,"timestamp":1617241015,"name":"example-pulse-wise-two-photon-interference.pdf","title":"example-pulse-wise-two-photon-interference.pdf","mimetype":"application/pdf","filetype":"pdf","pretty_type":"PDF","user":"U0158N77PFT","editable":false,"size":541214,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01T0KVUHFC/example-pulse-wise-two-photon-interference.pdf","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01T0KVUHFC/download/example-pulse-wise-two-photon-interference.pdf","thumb_pdf":"https://files.slack.com/files-tmb/T68168MUP-F01T0KVUHFC-96d8cb0afc/example-pulse-wise-two-photon-interference_thumb_pdf.png","thumb_pdf_w":935,"thumb_pdf_h":1210,"permalink":"https://julialang.slack.com/files/U0158N77PFT/F01T0KVUHFC/example-pulse-wise-two-photon-interference.pdf","permalink_public":"https://slack-files.com/T68168MUP-F01T0KVUHFC-cd0115d03d","is_starred":false,"has_rich_preview":false}],"upload":false,"blocks":[{"type":"rich_text","block_id":"jmWZC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you for the feedback. I'm attempting to rewrite the attached in Julia. I have the exponential and Gaussian wavepackets created, but calculating the first-order coherences of the sources' has been illusive so far.\n\nI'll try computing  "},{"type":"text","text":"ρ0","style":{"code":true}},{"type":"text","text":"  from a standard time evolution and use the approach you suggested.\n\nThanks again."}]}]}],"user":"U0158N77PFT","display_as_bot":false,"ts":"1617241021.024100","thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"type":"message","text":"```using QuantumOptics\nusing Plots\n# shared parameters\nγ = [1.0, 0.0]          # decay rate\ntlist = Vector(range(0.0, stop=13.0, length=300))\ntaulist = tlist\n\n# parameters for TLS with exponential shape wavepacket(short pulse)\ntp_e = 0.060                        # Gaussian pulse parameters\nOm_e = 19.40                        # driving strength\nt_offset_e = 0.405                  #\n\n\n# parameters for TLS with Gaussian sahpe wavepacket (long pulse)\ntp_G = 2.000                        # Gaussian pulse parameter\nOm_G = 0.702                        # driving strength\nt_offset_G = 5\n\n\n# initial state\nbasis = FockBasis(1)\nψ_0 = fockstate(basis, 0)\nρ_0 = ψ_0 ⊗ dagger(ψ_0)\n\n# operators\nsm = destroy(basis)\nsm_t = create(basis)\nn = number(basis)\n\n# Hamiltonian\nH_I = sm + sm_t\n\n\nfunction H_e(t, ρ)\n    pulse_shape_e = Om_e/2 * exp(-(t - t_offset_e)^2 / (2 * tp_e^2))\n    H = sm * pulse_shape_e + sm_t * pulse_shape_e\n    J = [sm, sm_t]\n    Jdagger = dagger.(J)\n    rates = γ\n    return H, J, Jdagger, rates\nend\n\nfunction H_G(t, ρ)\n    pulse_shape_G = Om_G/2 * exp(-(t - t_offset_G)^2 / (2 * tp_G^2))\n    H = sm * pulse_shape_G + sm_t * pulse_shape_G\n    J = [sm, sm_t]\n    Jdagger = dagger.(J)\n    rates = γ\n    return H, J, Jdagger, rates\nend\n\n# calculate emission flux\ntout1, pt_master1 = timeevolution.master_dynamic(tlist, ψ_0, H_e)\ntout2, pt_master2 = timeevolution.master_dynamic(tlist, ψ_0, H_G)\n\nn_e = real(expect(n,pt_master1))\nn_G = real(expect(n,pt_master2))\n\nplot(tlist, [n_e, n_G], label = [\"exponential wavepacket\" \"Gaussian wavepacket\"])```\n","files":[{"id":"F01SKU3UUKH","created":1617242994,"timestamp":1617242994,"name":"image.png","title":"image.png","mimetype":"image/png","filetype":"png","pretty_type":"PNG","user":"U0158N77PFT","editable":false,"size":34203,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01SKU3UUKH/image.png","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01SKU3UUKH/download/image.png","thumb_64":"https://files.slack.com/files-tmb/T68168MUP-F01SKU3UUKH-62662cf20f/image_64.png","thumb_80":"https://files.slack.com/files-tmb/T68168MUP-F01SKU3UUKH-62662cf20f/image_80.png","thumb_360":"https://files.slack.com/files-tmb/T68168MUP-F01SKU3UUKH-62662cf20f/image_360.png","thumb_360_w":360,"thumb_360_h":240,"thumb_480":"https://files.slack.com/files-tmb/T68168MUP-F01SKU3UUKH-62662cf20f/image_480.png","thumb_480_w":480,"thumb_480_h":320,"thumb_160":"https://files.slack.com/files-tmb/T68168MUP-F01SKU3UUKH-62662cf20f/image_160.png","original_w":632,"original_h":421,"thumb_tiny":"AwAfADC7Ai+RHlV+6O1SeWn9xfypkH+oj/3R/KpaAG+Wn9xfyoMaf3F/KnUUAR+Xzwi/lUN2gFpIdqg7ewq1UF7/AMekv+7QA63/ANRH/uipapxXkCxIC/IUA/Kaf9ug/wCen/jpoAs0VW+3Qf8APT/x00fboP8Anp/46aALNQXv/HpL/u037dB/z0/8dNRXN3DJbSKr5YjgYNAH/9k=","permalink":"https://julialang.slack.com/files/U0158N77PFT/F01SKU3UUKH/image.png","permalink_public":"https://slack-files.com/T68168MUP-F01SKU3UUKH-28dc41c531","is_starred":false,"has_rich_preview":false}],"upload":false,"blocks":[{"type":"rich_text","block_id":"hyP","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using QuantumOptics\nusing Plots\n# shared parameters\nγ = [1.0, 0.0]          # decay rate\ntlist = Vector(range(0.0, stop=13.0, length=300))\ntaulist = tlist\n\n# parameters for TLS with exponential shape wavepacket(short pulse)\ntp_e = 0.060                        # Gaussian pulse parameters\nOm_e = 19.40                        # driving strength\nt_offset_e = 0.405                  #\n\n\n# parameters for TLS with Gaussian sahpe wavepacket (long pulse)\ntp_G = 2.000                        # Gaussian pulse parameter\nOm_G = 0.702                        # driving strength\nt_offset_G = 5\n\n\n# initial state\nbasis = FockBasis(1)\nψ_0 = fockstate(basis, 0)\nρ_0 = ψ_0 ⊗ dagger(ψ_0)\n\n# operators\nsm = destroy(basis)\nsm_t = create(basis)\nn = number(basis)\n\n# Hamiltonian\nH_I = sm + sm_t\n\n\nfunction H_e(t, ρ)\n    pulse_shape_e = Om_e/2 * exp(-(t - t_offset_e)^2 / (2 * tp_e^2))\n    H = sm * pulse_shape_e + sm_t * pulse_shape_e\n    J = [sm, sm_t]\n    Jdagger = dagger.(J)\n    rates = γ\n    return H, J, Jdagger, rates\nend\n\nfunction H_G(t, ρ)\n    pulse_shape_G = Om_G/2 * exp(-(t - t_offset_G)^2 / (2 * tp_G^2))\n    H = sm * pulse_shape_G + sm_t * pulse_shape_G\n    J = [sm, sm_t]\n    Jdagger = dagger.(J)\n    rates = γ\n    return H, J, Jdagger, rates\nend\n\n# calculate emission flux\ntout1, pt_master1 = timeevolution.master_dynamic(tlist, ψ_0, H_e)\ntout2, pt_master2 = timeevolution.master_dynamic(tlist, ψ_0, H_G)\n\nn_e = real(expect(n,pt_master1))\nn_G = real(expect(n,pt_master2))\n\nplot(tlist, [n_e, n_G], label = [\"exponential wavepacket\" \"Gaussian wavepacket\"])"}]},{"type":"rich_text_section","elements":[]}]}],"user":"U0158N77PFT","display_as_bot":false,"ts":"1617242999.024500","thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"client_msg_id":"00a7e228-0d00-474f-9730-a556105b6cf9","type":"message","text":"That looks good so far. Now you can just take `pbar = B*0` and compute `&lt;A&gt;` for all pairs of operators `A` and `B` that you need.","user":"UBWLSPU1E","ts":"1617260843.024900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Io6E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That looks good so far. Now you can just take "},{"type":"text","text":"pbar = B*0","style":{"code":true}},{"type":"text","text":" and compute "},{"type":"text","text":"<A>","style":{"code":true}},{"type":"text","text":" for all pairs of operators "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" that you need."}]}]}],"thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"client_msg_id":"f08be0d1-4d90-463b-b059-93048f15e348","type":"message","text":"I'm not sure though, does QuTiPs two-time correlation function return a 2D array for all pairs of `t` and `tau`? If so, you can get the same by computing `pbar = B*pt[i]` for all `i=1:length(tlist)` and do the same thing as before","user":"UBWLSPU1E","ts":"1617260922.025100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oCN8u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure though, does QuTiPs two-time correlation function return a 2D array for all pairs of "},{"type":"text","text":"t","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"tau","style":{"code":true}},{"type":"text","text":"? If so, you can get the same by computing "},{"type":"text","text":"pbar = B*pt[i]","style":{"code":true}},{"type":"text","text":" for all "},{"type":"text","text":"i=1:length(tlist)","style":{"code":true}},{"type":"text","text":" and do the same thing as before"}]}]}],"thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"client_msg_id":"8389921e-a33d-4001-8232-80e11dddb675","type":"message","text":"Thank you for keeping the conversation going. It helps me think through next steps.\n\nQuTiP does create a 2D array for all pairs of of `t` and `tau`   (which are initially the same -- `t=tau` ).\n\nFirst a 2D array is created using ⟨_A_(_t_+_τ_)_B_(_t_)⟩.\n```G1_t_tau_e = qt.correlation_2op_2t(H_e, psi0, tlist, taulist, c_ops,\n                                a_op, b_op)```\nThen another is created using  ⟨_A_(_t_)_B_(_t_+_τ_)⟩ (noted by the `reverse=True`).\n```G1_t_tau_e_r = qt.correlation_2op_2t(H_e, psi0, tlist, taulist, c_ops,\n                                  a_op, b_op, reverse=True)```\nLater the 2D arrays are each used to create an associated function that can map new `t` and `tau`  values where `t`  is changed by a small `t_delay` . This function uses `tau` and `t-t_delay` to calculate the time correlation between 2 \"identical\" photons that only vary temporally when incident on a 50/50 beam splitter (this is done for both the exponential and Gaussian wavepackets).\n\nSo I'll do `pbar = B*pt_masterX[i]` for all `i=1:length(tlist)` . Then:\n\n```for i=1:length(tlist)\n    tout1[i], ρout1[:,i] = timeevolution.master_dynamic(tlist, ρbar[i], H_G);\nend\ncorr_G = [expect(a_op,ρout1[:,i]) for i=1:length(tlist)];```\n","user":"U0158N77PFT","ts":"1617290663.025300","team":"T68168MUP","edited":{"user":"U0158N77PFT","ts":"1617301878.000000"},"blocks":[{"type":"rich_text","block_id":"QD5B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you for keeping the conversation going. It helps me think through next steps.\n\nQuTiP does create a 2D array for all pairs of of "},{"type":"text","text":"t","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"tau ","style":{"code":true}},{"type":"text","text":"  (which are initially the same -- "},{"type":"text","text":"t=tau","style":{"code":true}},{"type":"text","text":" ).\n\nFirst a 2D array is created using ⟨"},{"type":"text","text":"A","style":{"italic":true}},{"type":"text","text":"("},{"type":"text","text":"t","style":{"italic":true}},{"type":"text","text":"+"},{"type":"text","text":"τ","style":{"italic":true}},{"type":"text","text":")"},{"type":"text","text":"B","style":{"italic":true}},{"type":"text","text":"("},{"type":"text","text":"t","style":{"italic":true}},{"type":"text","text":")⟩.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"G1_t_tau_e = qt.correlation_2op_2t(H_e, psi0, tlist, taulist, c_ops,\n                                a_op, b_op)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Then another is created using  ⟨"},{"type":"text","text":"A","style":{"italic":true}},{"type":"text","text":"("},{"type":"text","text":"t","style":{"italic":true}},{"type":"text","text":")"},{"type":"text","text":"B","style":{"italic":true}},{"type":"text","text":"("},{"type":"text","text":"t","style":{"italic":true}},{"type":"text","text":"+"},{"type":"text","text":"τ","style":{"italic":true}},{"type":"text","text":")⟩ (noted by the "},{"type":"text","text":"reverse=True","style":{"code":true}},{"type":"text","text":").\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"G1_t_tau_e_r = qt.correlation_2op_2t(H_e, psi0, tlist, taulist, c_ops,\n                                  a_op, b_op, reverse=True)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Later the 2D arrays are each used to create an associated function that can map new "},{"type":"text","text":"t","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"tau ","style":{"code":true}},{"type":"text","text":" values where "},{"type":"text","text":"t","style":{"code":true}},{"type":"text","text":"  is changed by a small "},{"type":"text","text":"t_delay","style":{"code":true}},{"type":"text","text":" . This function uses "},{"type":"text","text":"tau","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"t-t_delay","style":{"code":true}},{"type":"text","text":" to calculate the time correlation between 2 \"identical\" photons that only vary temporally when incident on a 50/50 beam splitter (this is done for both the exponential and Gaussian wavepackets).\n\nSo I'll do "},{"type":"text","text":"pbar = B*pt_masterX[i]","style":{"code":true}},{"type":"text","text":" for all "},{"type":"text","text":"i=1:length(tlist)","style":{"code":true}},{"type":"text","text":" . Then:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"for i=1:length(tlist)\n    tout1[i], ρout1[:,i] = timeevolution.master_dynamic(tlist, ρbar[i], H_G);\nend\ncorr_G = [expect(a_op,ρout1[:,i]) for i=1:length(tlist)];"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"client_msg_id":"b72f2e70-47d0-46fd-be21-d49ae91c9d9e","type":"message","text":"Yes that should work. And for the reverse case you'd only need to swap `a_op` and `B`","user":"UBWLSPU1E","ts":"1617704887.025800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o7P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes that should work. And for the reverse case you'd only need to swap "},{"type":"text","text":"a_op","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B","style":{"code":true}}]}]}],"thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E","reactions":[{"name":"+1","users":["U0158N77PFT"],"count":1}]},{"type":"message","text":"Thanks again. Here's what I have so far.\n\nI don't understand why the visibility of the HOM dip doesn't match the theory (i.e., see attached MATLAB plot) so I'm still investigating.","files":[{"id":"F01TB8KUGFP","created":1617724661,"timestamp":1617724661,"name":"qutip_to_julia_hom.pdf","title":"qutip_to_julia_hom.pdf","mimetype":"application/pdf","filetype":"pdf","pretty_type":"PDF","user":"U0158N77PFT","editable":false,"size":216484,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01TB8KUGFP/qutip_to_julia_hom.pdf","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01TB8KUGFP/download/qutip_to_julia_hom.pdf","thumb_pdf":"https://files.slack.com/files-tmb/T68168MUP-F01TB8KUGFP-01678de9b5/qutip_to_julia_hom_thumb_pdf.png","thumb_pdf_w":898,"thumb_pdf_h":6018,"permalink":"https://julialang.slack.com/files/U0158N77PFT/F01TB8KUGFP/qutip_to_julia_hom.pdf","permalink_public":"https://slack-files.com/T68168MUP-F01TB8KUGFP-a55bb36f29","is_starred":false,"has_rich_preview":false}],"upload":false,"blocks":[{"type":"rich_text","block_id":"mPsH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks again. Here's what I have so far.\n\nI don't understand why the visibility of the HOM dip doesn't match the theory (i.e., see attached MATLAB plot) so I'm still investigating."}]}]}],"user":"U0158N77PFT","display_as_bot":false,"ts":"1617724693.026100","thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"type":"message","text":"","files":[{"id":"F01TEH91B2P","created":1617724720,"timestamp":1617724720,"name":"image.png","title":"image.png","mimetype":"image/png","filetype":"png","pretty_type":"PNG","user":"U0158N77PFT","editable":false,"size":42754,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01TEH91B2P/image.png","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01TEH91B2P/download/image.png","thumb_64":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_64.png","thumb_80":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_80.png","thumb_360":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_360.png","thumb_360_w":360,"thumb_360_h":267,"thumb_480":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_480.png","thumb_480_w":480,"thumb_480_h":357,"thumb_160":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_160.png","thumb_720":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_720.png","thumb_720_w":720,"thumb_720_h":535,"thumb_800":"https://files.slack.com/files-tmb/T68168MUP-F01TEH91B2P-482638de76/image_800.png","thumb_800_w":800,"thumb_800_h":594,"original_w":852,"original_h":633,"thumb_tiny":"AwAjADDQaMM2cD9ab5I9B+Zp/BbI/OnUARiJOQV/U0GJAvQ+nBp56g/hQeoFMCPyV/uj8zSiJe4H61JR3pAJjB4Ix6UtIxA5x+NLnFACN0+lHG7n0o6j60i5IyaYC7h6il71GUJJ5GfoKcODgnJpAOooooARuFP0psRJXk5pzfdP0pkP3aAJKKKKAP/Z","permalink":"https://julialang.slack.com/files/U0158N77PFT/F01TEH91B2P/image.png","permalink_public":"https://slack-files.com/T68168MUP-F01TEH91B2P-71162a3bb4","is_starred":false,"has_rich_preview":false}],"upload":false,"user":"U0158N77PFT","display_as_bot":false,"ts":"1617724722.026500","thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"},{"client_msg_id":"0a0f1a1d-0284-4537-a61f-4cfe66b96b1a","type":"message","text":"It's difficult to tell like this. One thing I noticed is that you provide the same functions for the Hamiltonian at all time points when calculating the correlation functions. Should the Hamiltonian not be recomputed starting from the time where `pbar[i]` has been computed instead of starting from `0`?","user":"UBWLSPU1E","ts":"1617725495.026900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VqAq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's difficult to tell like this. One thing I noticed is that you provide the same functions for the Hamiltonian at all time points when calculating the correlation functions. Should the Hamiltonian not be recomputed starting from the time where "},{"type":"text","text":"pbar[i]","style":{"code":true}},{"type":"text","text":" has been computed instead of starting from "},{"type":"text","text":"0","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1617175665.019300","parent_user_id":"UBWLSPU1E"}]