[{"client_msg_id":"44da1a66-be7c-4e4f-b5e5-6df406654a17","type":"message","text":"Hi there! Does the JuliaGraphs ecosystem include a weighted graph type with general weights? From the looks of it, `SimpleWeightedGraphs.jl` only accepts `Real` weights, and for my next project I need weights from abstract algebraic structures. Should I use `MetaGraphs.jl`, or write my own structure (without sparse matrices since they also prefer real entries)? Thanks :pray:","user":"U01GMP3HF9C","ts":"1613329380.033800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wL794","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi there! Does the JuliaGraphs ecosystem include a weighted graph type with general weights? From the looks of it, "},{"type":"text","text":"SimpleWeightedGraphs.jl","style":{"code":true}},{"type":"text","text":" only accepts "},{"type":"text","text":"Real","style":{"code":true}},{"type":"text","text":" weights, and for my next project I need weights from abstract algebraic structures. Should I use "},{"type":"text","text":"MetaGraphs.jl","style":{"code":true}},{"type":"text","text":", or write my own structure (without sparse matrices since they also prefer real entries)? Thanks "},{"type":"emoji","name":"pray"}]}]}],"thread_ts":"1613329380.033800","reply_count":29,"reply_users_count":3,"latest_reply":"1613475356.044000","reply_users":["UBEF50B7C","U01GMP3HF9C","U82RE6STE"],"subscribed":false},{"client_msg_id":"a70e11e6-9ecd-4ee7-83f1-ec10071f0d3e","type":"message","text":"Depends on the size of your graph and the performance hat you need. MetaGraphs uses dicionaries to store metadata, so if you will have large graphs or algorithms that access metadata a lot  you might run in some issues.","user":"UBEF50B7C","ts":"1613329736.033900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UO6Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Depends on the size of your graph and the performance hat you need. MetaGraphs uses dicionaries to store metadata, so if you will have large graphs or algorithms that access metadata a lot  you might run in some issues."}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"c78c7ee5-6f89-478c-8b89-6553c7d7f791","type":"message","text":"I could also use some feedback/betatesters for <https://github.com/simonschoelly/SimpleValueGraphs.jl> if you wan to give that a try","user":"UBEF50B7C","ts":"1613329820.034100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Sq+sM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I could also use some feedback/betatesters for "},{"type":"link","url":"https://github.com/simonschoelly/SimpleValueGraphs.jl"},{"type":"text","text":" if you wan to give that a try"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C","reactions":[{"name":"heart","users":["U01GMP3HF9C"],"count":1}]},{"client_msg_id":"573e2d82-99b4-48c3-9a76-f9ee698f1aca","type":"message","text":"Thanks, I will definitely give it a try and contribute if you need a (beginner's) hand!","user":"U01GMP3HF9C","ts":"1613339150.034400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Yfwrg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, I will definitely give it a try and contribute if you need a (beginner's) hand!"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"1f7d1384-7476-473e-bf7e-b4126d3947a8","type":"message","text":"<@U82RE6STE> since you have nothing to do this morning :slightly_smiling_face:","user":"U01GMP3HF9C","ts":"1613378203.034600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s1U","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U82RE6STE"},{"type":"text","text":" since you have nothing to do this morning "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"3bb135f8-d981-4f06-b6ef-8caf9a78f299","type":"message","text":"busted","user":"U82RE6STE","ts":"1613378219.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Omzo9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"busted"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"11b24341-0ecd-41b5-95ad-f43da399d0e5","type":"message","text":"the best bets would be\n• defining a new graph type (that can go fairly quickly, few functions to implement for the graph interface)\n• using MetaGraphs, you don't have a weight semantic but you can attach your weights and then manipulate them in other functions\n• SimpleValueGraphs, haven't tried it myself but I'm sure Simon baked something cool there","user":"U82RE6STE","ts":"1613378406.035000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eWExa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the best bets would be\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"defining a new graph type (that can go fairly quickly, few functions to implement for the graph interface)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"using MetaGraphs, you don't have a weight semantic but you can attach your weights and then manipulate them in other functions"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"SimpleValueGraphs, haven't tried it myself but I'm sure Simon baked something cool there"}]}],"style":"bullet","indent":0}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"92160fab-e86f-4a68-9441-5d80ff538be4","type":"message","text":"I took a look at `SimpleValueGraphs.jl` <@UBEF50B7C>, and it's really nice! However, since I only need one (non-tuple) attribute for each edge and none for the vertices, do you think I could gain performance / clarity by making my own structure?","user":"U01GMP3HF9C","ts":"1613378624.035200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4eVA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I took a look at "},{"type":"text","text":"SimpleValueGraphs.jl","style":{"code":true}},{"type":"text","text":" "},{"type":"user","user_id":"UBEF50B7C"},{"type":"text","text":", and it's really nice! However, since I only need one (non-tuple) attribute for each edge and none for the vertices, do you think I could gain performance / clarity by making my own structure?"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"452e5601-4e82-4860-8dfa-eaeadb796f69","type":"message","text":"I think this is a good starting point. For clarity you can add your own function on top, and the package accepts custom types to indicate what you attach to verices / edges.\nFor performance I don't think you'll gain much in a rewrite","user":"U82RE6STE","ts":"1613378872.035400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Fae","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this is a good starting point. For clarity you can add your own function on top, and the package accepts custom types to indicate what you attach to verices / edges.\nFor performance I don't think you'll gain much in a rewrite"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C","reactions":[{"name":"thumbsup_all","users":["U01GMP3HF9C"],"count":1}]},{"client_msg_id":"f6c67248-91ab-4ef4-bf47-f02e6bf7b2e4","type":"message","text":"<@UBEF50B7C>, I have a question about SVG. Say I use a `SimpleValueDiGraph` with one edge attribute (`:resource`) and no vertex attribute. I would like to define a type shortcut to indicate resource type (`RT`) to the compiler in function definitions, but I’m not sure how to do it. My best guess for now is:\n```ResourceDiGraph{RT} = ValDiGraph{\n    Int32,\n    Tuple{},\n    NamedTuple{(:resource,),Tuple{RT}},\n    Tuple{},\n    Tuple{},\n    NamedTuple{(:resource,),Tuple{Array{Array{RT},1}}}\n}```","user":"U01GMP3HF9C","ts":"1613456046.038800","team":"T68168MUP","edited":{"user":"U01GMP3HF9C","ts":"1613464053.000000"},"blocks":[{"type":"rich_text","block_id":"Aa02","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UBEF50B7C"},{"type":"text","text":", I have a question about SVG. Say I use a "},{"type":"text","text":"SimpleValueDiGraph","style":{"code":true}},{"type":"text","text":" with one edge attribute ("},{"type":"text","text":":resource","style":{"code":true}},{"type":"text","text":") and no vertex attribute. I would like to define a type shortcut to indicate resource type ("},{"type":"text","text":"RT","style":{"code":true}},{"type":"text","text":") to the compiler in function definitions, but I’m not sure how to do it. My best guess for now is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ResourceDiGraph{RT} = ValDiGraph{\n    Int32,\n    Tuple{},\n    NamedTuple{(:resource,),Tuple{RT}},\n    Tuple{},\n    Tuple{},\n    NamedTuple{(:resource,),Tuple{Array{Array{RT},1}}}\n}"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"7ebdb82d-9046-4858-85bf-17861ee22f9f","type":"message","text":"But it seems a bit overkill","user":"U01GMP3HF9C","ts":"1613456051.039000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RV=s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it seems a bit overkill"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"c1bbf6d1-783f-4602-9c77-fdf479dc0b1e","type":"message","text":"And I’m not even sure it would work","user":"U01GMP3HF9C","ts":"1613456154.039200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ohz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And I’m not even sure it would work"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"e6eee1e5-c8e7-4fa2-8241-d0075976e4f3","type":"message","text":"what would `RT`  stand for here?","user":"U82RE6STE","ts":"1613463388.039600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0=Fv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what would "},{"type":"text","text":"RT","style":{"code":true}},{"type":"text","text":"  stand for here?"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"4eb7d39c-6d1e-4efb-94bc-27fd2287b7b7","type":"message","text":"The resource type","user":"U01GMP3HF9C","ts":"1613464044.039800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"U2P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The resource type"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"eab19b53-86fd-4c2e-b343-1d324aeb9c50","type":"message","text":"well then it should work as is. You should define this type alias as a const at the top-level of your package and then you can use it","user":"U82RE6STE","ts":"1613464109.040100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JBilE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"well then it should work as is. You should define this type alias as a const at the top-level of your package and then you can use it"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C","reactions":[{"name":"thumbsup_all","users":["U01GMP3HF9C"],"count":1}]},{"client_msg_id":"89a62f91-5c10-41e3-aa19-3535498fd79b","type":"message","text":"So you want to use the type of the graph for specifying in  method signatures? Maybe then you can only specify the first three template parameters:\n\n```ResourceDiGraph{RT} = ValDiGraph{\n    Int32,\n    Tuple{},\n    NamedTuple{(:resource,),Tuple{RT}}}```\nYou could also use the `@NamedTuple` macro to make it a bit more readable\n```ResourceDiGraph{RT} = ValDiGraph{\n    Int32,\n    Tuple{},\n    @NamedTuple{resource::RT}}```","user":"UBEF50B7C","ts":"1613468876.040400","team":"T68168MUP","edited":{"user":"UBEF50B7C","ts":"1613468889.000000"},"blocks":[{"type":"rich_text","block_id":"lCL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So you want to use the type of the graph for specifying in  method signatures? Maybe then you can only specify the first three template parameters:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ResourceDiGraph{RT} = ValDiGraph{\n    Int32,\n    Tuple{},\n    NamedTuple{(:resource,),Tuple{RT}}}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"You could also use the "},{"type":"text","text":"@NamedTuple","style":{"code":true}},{"type":"text","text":" macro to make it a bit more readable\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ResourceDiGraph{RT} = ValDiGraph{\n    Int32,\n    Tuple{},\n    @NamedTuple{resource::RT}}"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C","reactions":[{"name":"today-i-learned","users":["U82RE6STE","U01GMP3HF9C"],"count":2}]},{"client_msg_id":"ebeb7594-e82d-484f-b2d6-e88aeb3f70c1","type":"message","text":"If I don't specify the last three template parameters, won't they be `Any` and therefore hard to optimize for the compiler?","user":"U01GMP3HF9C","ts":"1613470289.040900","team":"T68168MUP","edited":{"user":"U01GMP3HF9C","ts":"1613470316.000000"},"blocks":[{"type":"rich_text","block_id":"/JanM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I don't specify the last three template parameters, won't they be "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" and therefore hard to optimize for the compiler?"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"d2f02379-bd8f-4ad8-9c38-16dd08940a45","type":"message","text":"And yes, I need the resource type in method signatures to make those clearer, and optimized if possible","user":"U01GMP3HF9C","ts":"1613470335.041300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Qf=P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And yes, I need the resource type in method signatures to make those clearer, and optimized if possible"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"37a8b592-e94c-4eac-ad87-122c133029aa","type":"message","text":"It is a bit different, I will use a Vector to demonstrate. When you type `Vector`, then what you get is\n```julia&gt; Vector\nVector{T} where T```\nWhich means that is a vector where one of the parameters is not specified yet. This is different from a `Vector{Any` that can store anything.\n\nSo if you declare a function `f(v::Vector)` then is is actually a function `f(v::Vector)` . If you now call this method with a vector `Vector{Int}` then Julia will call a specialized method for that.\n\nThe one exception is, if you want to store the vector in a container, e.e.  `Set{Vector}` is indeed not optimal for the compiler as this set must be able to store any kind of vector. If you later write a function that takes elements from such a set, then the type of those elements cannot be determined at compile time.","user":"UBEF50B7C","ts":"1613470917.041500","team":"T68168MUP","edited":{"user":"UBEF50B7C","ts":"1613470934.000000"},"blocks":[{"type":"rich_text","block_id":"ySli7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It is a bit different, I will use a Vector to demonstrate. When you type "},{"type":"text","text":"Vector","style":{"code":true}},{"type":"text","text":", then what you get is\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Vector\nVector{T} where T"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Which means that is a vector where one of the parameters is not specified yet. This is different from a "},{"type":"text","text":"Vector{Any","style":{"code":true}},{"type":"text","text":" that can store anything.\n\nSo if you declare a function "},{"type":"text","text":"f(v::Vector)","style":{"code":true}},{"type":"text","text":" then is is actually a function "},{"type":"text","text":"f(v::Vector)","style":{"code":true}},{"type":"text","text":" . If you now call this method with a vector "},{"type":"text","text":"Vector{Int}","style":{"code":true}},{"type":"text","text":" then Julia will call a specialized method for that.\n\nThe one exception is, if you want to store the vector in a container, e.e.  `Set{Vector}` is indeed not optimal for the compiler as this set must be able to store any kind of vector. If you later write a function that takes elements from such a set, then the type of those elements cannot be determined at compile time."}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"d9ae8674-38d2-4be4-8f08-8838b904cb48","type":"message","text":"OK, so my question boils down to: with your construction of SVG, is the compiler able to fill in the last 3 types in `ValDiGraph{_,_,@NamedTuple{resource::RT},4,5,6}` knowing only the first three ones?","user":"U01GMP3HF9C","ts":"1613471162.041800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Nbhvu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OK, so my question boils down to: with your construction of SVG, is the compiler able to fill in the last 3 types in "},{"type":"text","text":"ValDiGraph{_,_,@NamedTuple{resource::RT},4,5,6}","style":{"code":true}},{"type":"text","text":" knowing only the first three ones?"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"ec65e4fa-43a4-47b5-85b6-5020b89887f6","type":"message","text":"As soon as you construct a graph (as long as you use the provided constructors at least), all the unspecified parameters are filled in.","user":"UBEF50B7C","ts":"1613471299.042000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MzLn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As soon as you construct a graph (as long as you use the provided constructors at least), all the unspecified parameters are filled in."}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"53a4e0ee-8f02-4e9d-97f6-b8f59ced46f6","type":"message","text":"```julia&gt; g = ValDiGraph{Int16}(4, edgeval_types=(resource=Int,))\n{4, 0} directed ValDiGraph with\n              eltype: Int16\n  vertex value types: ()\n    edge value types: (resource = Int64,)\n   graph value types: ()\n\njulia&gt; typeof(g)\nValDiGraph{Int16, Tuple{}, NamedTuple{(:resource,), Tuple{Int64}}, Tuple{}, Tuple{}, NamedTuple{(:resource,), Tuple{Vector{Vector{Int64}}}}}```","user":"UBEF50B7C","ts":"1613471396.042200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cwvo","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> g = ValDiGraph{Int16}(4, edgeval_types=(resource=Int,))\n{4, 0} directed ValDiGraph with\n              eltype: Int16\n  vertex value types: ()\n    edge value types: (resource = Int64,)\n   graph value types: ()\n\njulia> typeof(g)\nValDiGraph{Int16, Tuple{}, NamedTuple{(:resource,), Tuple{Int64}}, Tuple{}, Tuple{}, NamedTuple{(:resource,), Tuple{Vector{Vector{Int64}}}}}"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"d7501746-29eb-41f8-b0f4-5c6ef3cbef52","type":"message","text":"Yeah I had noticed this in the constructor, what I wondered was whether it also held for type annotations, which don't build an SVG object","user":"U01GMP3HF9C","ts":"1613471616.042400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fYu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah I had noticed this in the constructor, what I wondered was whether it also held for type annotations, which don't build an SVG object"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"8b3efc78-d93e-4c1a-8ea2-d19720cb4575","type":"message","text":"Sorry if the question isn't clear, I'm having a hard time wrapping my head around this","user":"U01GMP3HF9C","ts":"1613471629.042600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PSl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry if the question isn't clear, I'm having a hard time wrapping my head around this"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"f1f42c6f-e868-4211-b2c0-db24c54045b9","type":"message","text":"And sorry for taking so much time from you ^^","user":"U01GMP3HF9C","ts":"1613471640.042800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wwM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And sorry for taking so much time from you ^^"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"4d5d45a7-3059-41ce-ad6a-720f2bd7538b","type":"message","text":"no problem","user":"UBEF50B7C","ts":"1613472175.043000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/iikg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no problem"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"adeaad77-61a1-486a-b3e4-86b0d2fac5bf","type":"message","text":"I tried to look up the correct section in the manual but can't find it the moment","user":"UBEF50B7C","ts":"1613472197.043200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lSN7q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I tried to look up the correct section in the manual but can't find it the moment"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C","reactions":[{"name":"thumbsup_all","users":["U01GMP3HF9C"],"count":1}]},{"client_msg_id":"7376cf93-1783-408d-8dfd-7be316bc7df6","type":"message","text":"but when you declare a method\n`f(v::Vector) = .. ` and you call that method with `f(Int[])`  then the Julia compiler will check if it already has seen the combination `f, Vector{Int}` . If not, it will create a specialised implementation for that.\n\nIf you call this method next time with  `f(String[]) `  then Julia will see that it has not seen the combination `f, Vector{String}` so it will create an implementation for that","user":"UBEF50B7C","ts":"1613472372.043500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iHy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but when you declare a method\n`f(v::Vector) = .. ` and you call that method with "},{"type":"text","text":"f(Int[])","style":{"code":true}},{"type":"text","text":"  then the Julia compiler will check if it already has seen the combination "},{"type":"text","text":"f, Vector{Int}","style":{"code":true}},{"type":"text","text":" . If not, it will create a specialised implementation for that.\n\nIf you call this method next time with  `f(String[]) `  then Julia will see that it has not seen the combination "},{"type":"text","text":"f, Vector{String}","style":{"code":true}},{"type":"text","text":" so it will create an implementation for that"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"794b6afc-3129-47d9-b768-d2f245899ae3","type":"message","text":"I ll use the large definition for now, conciseness can wait. At any rate, SVGs will replace MGs in all my future projects","user":"U01GMP3HF9C","ts":"1613472379.043700","team":"T68168MUP","edited":{"user":"U01GMP3HF9C","ts":"1613472386.000000"},"blocks":[{"type":"rich_text","block_id":"pSs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I ll use the large definition for now, conciseness can wait. At any rate, SVGs will replace MGs in all my future projects"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"},{"client_msg_id":"0b96d893-ae0e-42c5-92a3-5b1613138194","type":"message","text":"OK, I think an example will be clearer: with the method you're proposing, what I'm worried about is the difference between `ResourceGraph1` and `ResourceGraph2`. Again, this is not an important problem since I don't mind the length of the second definition (which is coherent with the constructor), I was just curious to understand it better.\n\n```julia&gt; const ResourceGraph1{RT} = ValDiGraph{Int,Tuple{},@NamedTuple{resource::RT}}\nValDiGraph{Int64,Tuple{},NamedTuple{(:resource,),Tuple{RT}},G_VALS,V_VALS_C,E_VALS_C} where E_VALS_C where V_VALS_C where G_VALS&lt;:(Union{NamedTuple{S,T} where S, T} where T&lt;:Tuple) where RT\n\njulia&gt; ResourceGraph1{String}\nValDiGraph{Int64,Tuple{},NamedTuple{(:resource,),Tuple{String}},G_VALS,V_VALS_C,E_VALS_C} where E_VALS_C where V_VALS_C where G_VALS&lt;:(Union{NamedTuple{S,T} where S, T} where T&lt;:Tuple)\n\njulia&gt; const ResourceGraph2{RT} = ValDiGraph{\n           Int32,\n           Tuple{},\n           NamedTuple{(:resource,),Tuple{RT}},\n           Tuple{},\n           Tuple{},\n           NamedTuple{(:resource,),Tuple{Array{Array{RT,1},1}}},\n       }\nValDiGraph{Int32,Tuple{},NamedTuple{(:resource,),Tuple{RT}},Tuple{},Tuple{},NamedTuple{(:resource,),Tuple{Array{Array{RT,1},1}}}} where RT\n\njulia&gt; ResourceGraph2{String}\nValDiGraph{Int32,Tuple{},NamedTuple{(:resource,),Tuple{String}},Tuple{},Tuple{},NamedTuple{(:resource,),Tuple{Array{Array{String,1},1}}}}\n\njulia&gt; vg = ValDiGraph(0, edgeval_types = (resource = String,))\n{0, 0} directed ValDiGraph with\n              eltype: Int32\n  vertex value types: ()\n    edge value types: (resource = String,)\n   graph value types: ()\n\njulia&gt; typeof(vg)\nValDiGraph{Int32,Tuple{},NamedTuple{(:resource,),Tuple{String}},Tuple{},Tuple{},NamedTuple{(:resource,),Tuple{Array{Array{String,1},1}}}}```","user":"U01GMP3HF9C","ts":"1613475356.044000","team":"T68168MUP","edited":{"user":"U01GMP3HF9C","ts":"1613475620.000000"},"blocks":[{"type":"rich_text","block_id":"mISv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OK, I think an example will be clearer: with the method you're proposing, what I'm worried about is the difference between "},{"type":"text","text":"ResourceGraph1","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"ResourceGraph2","style":{"code":true}},{"type":"text","text":". Again, this is not an important problem since I don't mind the length of the second definition (which is coherent with the constructor), I was just curious to understand it better.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> const ResourceGraph1{RT} = ValDiGraph{Int,Tuple{},@NamedTuple{resource::RT}}\nValDiGraph{Int64,Tuple{},NamedTuple{(:resource,),Tuple{RT}},G_VALS,V_VALS_C,E_VALS_C} where E_VALS_C where V_VALS_C where G_VALS<:(Union{NamedTuple{S,T} where S, T} where T<:Tuple) where RT\n\njulia> ResourceGraph1{String}\nValDiGraph{Int64,Tuple{},NamedTuple{(:resource,),Tuple{String}},G_VALS,V_VALS_C,E_VALS_C} where E_VALS_C where V_VALS_C where G_VALS<:(Union{NamedTuple{S,T} where S, T} where T<:Tuple)\n\njulia> const ResourceGraph2{RT} = ValDiGraph{\n           Int32,\n           Tuple{},\n           NamedTuple{(:resource,),Tuple{RT}},\n           Tuple{},\n           Tuple{},\n           NamedTuple{(:resource,),Tuple{Array{Array{RT,1},1}}},\n       }\nValDiGraph{Int32,Tuple{},NamedTuple{(:resource,),Tuple{RT}},Tuple{},Tuple{},NamedTuple{(:resource,),Tuple{Array{Array{RT,1},1}}}} where RT\n\njulia> ResourceGraph2{String}\nValDiGraph{Int32,Tuple{},NamedTuple{(:resource,),Tuple{String}},Tuple{},Tuple{},NamedTuple{(:resource,),Tuple{Array{Array{String,1},1}}}}\n\njulia> vg = ValDiGraph(0, edgeval_types = (resource = String,))\n{0, 0} directed ValDiGraph with\n              eltype: Int32\n  vertex value types: ()\n    edge value types: (resource = String,)\n   graph value types: ()\n\njulia> typeof(vg)\nValDiGraph{Int32,Tuple{},NamedTuple{(:resource,),Tuple{String}},Tuple{},Tuple{},NamedTuple{(:resource,),Tuple{Array{Array{String,1},1}}}}"}]}]}],"thread_ts":"1613329380.033800","parent_user_id":"U01GMP3HF9C"}]