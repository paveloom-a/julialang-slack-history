[{"client_msg_id":"f45dc03e-27d0-4713-a184-eeb9b0aa0967","type":"message","text":"Hi there. I have a very basic question about macros. I am trying to define a macro that generate the second method based on the first one. (something does something based on x, not only x[i])\n```f(i::Int, x::Vector) = something(x[i],x)\nf(x::Vector) = map(i -&gt; f(i, x), 1:length(x))```\nAny idea?","user":"U01FR2HFJ7M","ts":"1608622994.068400","team":"T68168MUP","edited":{"user":"U01FR2HFJ7M","ts":"1608623257.000000"},"blocks":[{"type":"rich_text","block_id":"iPO2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi there. I have a very basic question about macros. I am trying to define a macro that generate the second method based on the first one. (something does something based on x, not only x[i])\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"f(i::Int, x::Vector) = something(x[i],x)\nf(x::Vector) = map(i -> f(i, x), 1:length(x))"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Any idea?"}]}]}],"thread_ts":"1608622994.068400","reply_count":3,"reply_users_count":2,"latest_reply":"1608701819.081600","reply_users":["U7QLM6E2E","U01FR2HFJ7M"],"subscribed":false},{"client_msg_id":"588debd6-d20a-41bf-b172-b82408f8c063","type":"message","text":"You could just rewrite that as `something.(x, Ref(x))`","user":"U7QLM6E2E","ts":"1608677342.075300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wrUl2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could just rewrite that as "},{"type":"text","text":"something.(x, Ref(x))","style":{"code":true}}]}]}],"thread_ts":"1608622994.068400","parent_user_id":"U01FR2HFJ7M"},{"client_msg_id":"3bb9cc13-405a-4013-aa46-08f836fd07fd","type":"message","text":"Sorry for the wait. Here a MWE of what I want to do.\n```julia&gt; map_transformation(f, x) = ((g, y) -&gt; map(i -&gt; g(i, y), 1:length(y)))(f, x)\nmap_transformation (generic function with 1 method)\n\njulia&gt; function _count_eq(i::Int, x::V) where {T &lt;: Number,V &lt;: AbstractVector{T}}\n           return count(y -&gt; x[i] == y, x)\n       end\n_count_eq (generic function with 1 method)\n\njulia&gt; _count_eq(x) = (y -&gt; map_transformation(_count_eq, y))(x)\n_count_eq (generic function with 2 methods)\n\njulia&gt; _count_eq([1,2,2,3])\n4-element Array{Int64,1}:\n 1\n 2\n 2\n 1```\n I can of course define each function in a similar way as `_count_eq`, however, it would be easy and concise to use something similar to the behavior of `@lazy` from Lazy.jl. By that I mean something along\n```@mylazy count_eq, f2, f3, f4, ..., fn```\nThat would generate the second method automatically like I did manually above","user":"U01FR2HFJ7M","ts":"1608690718.081300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zu/f","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry for the wait. Here a MWE of what I want to do.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> map_transformation(f, x) = ((g, y) -> map(i -> g(i, y), 1:length(y)))(f, x)\nmap_transformation (generic function with 1 method)\n\njulia> function _count_eq(i::Int, x::V) where {T <: Number,V <: AbstractVector{T}}\n           return count(y -> x[i] == y, x)\n       end\n_count_eq (generic function with 1 method)\n\njulia> _count_eq(x) = (y -> map_transformation(_count_eq, y))(x)\n_count_eq (generic function with 2 methods)\n\njulia> _count_eq([1,2,2,3])\n4-element Array{Int64,1}:\n 1\n 2\n 2\n 1"}]},{"type":"rich_text_section","elements":[{"type":"text","text":" I can of course define each function in a similar way as `_count_eq`, however, it would be easy and concise to use something similar to the behavior of "},{"type":"text","text":"@lazy","style":{"code":true}},{"type":"text","text":" from Lazy.jl. By that I mean something along\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@mylazy count_eq, f2, f3, f4, ..., fn"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"That would generate the second method automatically like I did manually above"}]}]}],"thread_ts":"1608622994.068400","parent_user_id":"U01FR2HFJ7M"},{"client_msg_id":"e4f87d67-403c-49bc-84a2-61104e33fabc","type":"message","text":"OK, I think I am getting close.\n```map_tr(f, x) = ((g, y) -&gt; map(i -&gt; g(i, y), 1:length(y)))(f, x)\n\nfunction lazy(funcs...)\n    foreach(f -&gt; eval(:($f(x) = (y -&gt; map_tr($f, y))(x))), map(Symbol, funcs))\nend```\nThis work out somewhat. I can't make it a macro directly, so I guess there is some syntax issue I have to find out.","user":"U01FR2HFJ7M","ts":"1608701819.081600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P5gUc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OK, I think I am getting close.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"map_tr(f, x) = ((g, y) -> map(i -> g(i, y), 1:length(y)))(f, x)\n\nfunction lazy(funcs...)\n    foreach(f -> eval(:($f(x) = (y -> map_tr($f, y))(x))), map(Symbol, funcs))\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"This work out somewhat. I can't make it a macro directly, so I guess there is some syntax issue I have to find out."}]}]}],"thread_ts":"1608622994.068400","parent_user_id":"U01FR2HFJ7M"}]