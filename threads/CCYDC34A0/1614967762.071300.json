[{"client_msg_id":"422a66f7-a1af-40ff-b02d-7a2722c20171","type":"message","text":"What is the best way to encode parameter interdependendence in a Turing. ? E.g. paramerter bounds are dependent on a second parameter. The parameter part of my models looks like this at the moment, basically just rejecting any sample which doesn't satisfy the conditions by add `-Inf` to `logprob` but that doesn't seem a particular efficient nor elegant way of doing it.\n\n```@model function _turing_model(data::NamedTuple, ode_prob::ODEProblem, solver, priors::NamedTuple, sim::Bool=false, logp::Bool=false; ode_args = (;))\n\t### priors\n    p_preDCbm ~ priors.p_preDCbm\n    p_cDC1bm ~ priors.p_cDC1bm\n    p_cDC2bm ~ priors.p_cDC2bm\n    δ_preDCb ~ Uniform(0.0,2.0)\n    λ_cDC1 ~ Uniform(0.0,2.0)\n    λ_cDC2 ~ Uniform(0.0,2.0)\n    Δ_cDC2bm ~ Uniform(0.0,2.0)\n    Δ_cDC2b ~ Uniform(0.0,2.0)\n    σ1 ~ TruncatedNormal(0.0, 1.0, 0.0,Inf)\n    σ2 ~ TruncatedNormal(0.0, 1.0, 0.0,Inf)\n    σ3 ~ TruncatedNormal(0.0, 1.0, 0.0,Inf)\n\n    λ_preDC = (Δ_cDC2b + δ_preDCb) / data.R.RpreDC\n\n\t### parameter constraints\n\tif p_preDCbm ≤ (λ_preDC + Δ_cDC2bm)\n\t\tTuring.@addlogprob! -Inf\n\t\treturn\n\telseif λ_cDC1 ≥ p_cDC1bm\n\t\tTuring.@addlogprob! -Inf\n\t\treturn\n\telseif λ_cDC2 ≥ p_cDC2bm + Δ_cDC2bm * data.R.RpreDC_cDC2_bm\n\t \tTuring.@addlogprob! -Inf\n\t \treturn\n\tend\n\n    ### compound parameter\n    δ_preDCbm = p_preDCbm - λ_preDC - Δ_cDC2bm\n    δ_cDC1bm = p_cDC1bm - λ_cDC1\n    δ_cDC2bm = p_cDC2bm + Δ_cDC2bm * data.R.RpreDC_cDC2_bm - λ_cDC2\n    δ_cDC1b = λ_cDC1 * data.R.RcDC1\n    δ_cDC2b = λ_cDC2 * data.R.RcDC2 + Δ_cDC2b * data.R.RpreDC_cDC2_blood\n\n    ### parameter vector\n    theta = [p_preDCbm, δ_preDCbm, p_cDC1bm, δ_cDC1bm, p_cDC2bm, δ_cDC2bm, δ_preDCb, δ_cDC1b, δ_cDC2b, λ_preDC, λ_cDC1, λ_cDC2, Δ_cDC2bm, Δ_cDC2b]\n\n...\nend```","user":"UGFMDAMC3","ts":"1614967762.071300","team":"T68168MUP","edited":{"user":"UGFMDAMC3","ts":"1614968023.000000"},"blocks":[{"type":"rich_text","block_id":"A+BE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What is the best way to encode parameter interdependendence in a Turing. ? E.g. paramerter bounds are dependent on a second parameter. The parameter part of my models looks like this at the moment, basically just rejecting any sample which doesn't satisfy the conditions by add "},{"type":"text","text":"-Inf","style":{"code":true}},{"type":"text","text":" to "},{"type":"text","text":"logprob","style":{"code":true}},{"type":"text","text":" but that doesn't seem a particular efficient nor elegant way of doing it.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function _turing_model(data::NamedTuple, ode_prob::ODEProblem, solver, priors::NamedTuple, sim::Bool=false, logp::Bool=false; ode_args = (;))\n\t### priors\n    p_preDCbm ~ priors.p_preDCbm\n    p_cDC1bm ~ priors.p_cDC1bm\n    p_cDC2bm ~ priors.p_cDC2bm\n    δ_preDCb ~ Uniform(0.0,2.0)\n    λ_cDC1 ~ Uniform(0.0,2.0)\n    λ_cDC2 ~ Uniform(0.0,2.0)\n    Δ_cDC2bm ~ Uniform(0.0,2.0)\n    Δ_cDC2b ~ Uniform(0.0,2.0)\n    σ1 ~ TruncatedNormal(0.0, 1.0, 0.0,Inf)\n    σ2 ~ TruncatedNormal(0.0, 1.0, 0.0,Inf)\n    σ3 ~ TruncatedNormal(0.0, 1.0, 0.0,Inf)\n\n    λ_preDC = (Δ_cDC2b + δ_preDCb) / data.R.RpreDC\n\n\t### parameter constraints\n\tif p_preDCbm ≤ (λ_preDC + Δ_cDC2bm)\n\t\tTuring.@addlogprob! -Inf\n\t\treturn\n\telseif λ_cDC1 ≥ p_cDC1bm\n\t\tTuring.@addlogprob! -Inf\n\t\treturn\n\telseif λ_cDC2 ≥ p_cDC2bm + Δ_cDC2bm * data.R.RpreDC_cDC2_bm\n\t \tTuring.@addlogprob! -Inf\n\t \treturn\n\tend\n\n    ### compound parameter\n    δ_preDCbm = p_preDCbm - λ_preDC - Δ_cDC2bm\n    δ_cDC1bm = p_cDC1bm - λ_cDC1\n    δ_cDC2bm = p_cDC2bm + Δ_cDC2bm * data.R.RpreDC_cDC2_bm - λ_cDC2\n    δ_cDC1b = λ_cDC1 * data.R.RcDC1\n    δ_cDC2b = λ_cDC2 * data.R.RcDC2 + Δ_cDC2b * data.R.RpreDC_cDC2_blood\n\n    ### parameter vector\n    theta = [p_preDCbm, δ_preDCbm, p_cDC1bm, δ_cDC1bm, p_cDC2bm, δ_cDC2bm, δ_preDCb, δ_cDC1b, δ_cDC2b, λ_preDC, λ_cDC1, λ_cDC2, Δ_cDC2bm, Δ_cDC2b]\n\n...\nend"}]}]}],"thread_ts":"1614967762.071300","reply_count":3,"reply_users_count":2,"latest_reply":"1615022611.073200","reply_users":["U9JNHB83X","U85JBUGGP"],"subscribed":false},{"client_msg_id":"84bc87ca-c880-48be-945b-09fc3e0e7d88","type":"message","text":"We don't support stochastic bounds yet I think, so I suspect this'll have to be sufficient for now","user":"U9JNHB83X","ts":"1614988737.072700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yZJU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"We don't support stochastic bounds yet I think, so I suspect this'll have to be sufficient for now"}]}]}],"thread_ts":"1614967762.071300","parent_user_id":"UGFMDAMC3"},{"client_msg_id":"3b7611ef-200f-4159-ac9e-d742eb99eb7b","type":"message","text":"you can write your own distribution to do that though","user":"U85JBUGGP","ts":"1615022531.072900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s9u7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you can write your own distribution to do that though"}]}]}],"thread_ts":"1614967762.071300","parent_user_id":"UGFMDAMC3"},{"client_msg_id":"7940feb8-8d4f-40ee-a0f9-ebd34375ad3f","type":"message","text":"<https://github.com/TuringLang/Turing.jl/issues/1270>","user":"U85JBUGGP","ts":"1615022611.073200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eC2G","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/TuringLang/Turing.jl/issues/1270"}]}]}],"thread_ts":"1614967762.071300","parent_user_id":"UGFMDAMC3"}]