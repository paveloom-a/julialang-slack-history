[{"client_msg_id":"0913ebd4-edeb-492a-81f3-31eb69f72101","type":"message","text":"Some help with this type stability / AD issue would be greatly appreciated (details in thread)","user":"U017YGFQTE3","ts":"1615732094.126800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uFVsZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Some help with this type stability / AD issue would be greatly appreciated (details in thread)"}]}]}],"thread_ts":"1615732094.126800","reply_count":11,"reply_users_count":3,"latest_reply":"1615966222.006900","reply_users":["U017YGFQTE3","UHDNY2YMA","UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"a31753ca-2076-4c28-90ad-d37bd2f40f9c","type":"message","text":"Turing model:\n```@model function m(b,Ω,t)\n   n = maximum(t)\n   κ = Vector{Real}(undef, n)\n   κ ~ MvNormal(Fill(0.30, n),0.05)\n   for i in 1:length(b)\n      b[i] ~ Normal(merton(LArray(Ω[i];κ=κ[t[i]])),0.005)\n   end\nend\n\nchain = sample(m(b,Ω,t), NUTS(0.65), 1_000)```\nmerton\n``` function merton(Ω::AbstractVector{T}) where T\n\n    A₀ = (exp(Ω.ve)+exp(Ω.vd))\n    d₁₀= (log(1+exp(Ω.ve-Ω.vd)) + Ω.r + (Ω.σ^2)/2)/Ω.σ;\n    x₀ = @LArray Array{T,1}([\n            log(1.05*A₀);\n            log(0.05*A₀);\n            d₁₀;\n            log(exp(Ω.vd)*(1+Ω.r+0.05))\n            ]) (:a,:vκ,:d₁,:b)\n\n    Φ = x -&gt; Distributions.cdf(Normal(),x)\n\n    function residuals!(F,x)\n\n        F[1] = exp(x.a) - exp(Ω.ve) - exp(Ω.vd) - exp(x.vκ)\n        F[2] = x.d₁ - (x.a - x.b + Ω.r + (Ω.σ^2)/2)/Ω.σ\n        F[3] = exp(Ω.ve) - exp(x.a)*Φ(x.d₁) + exp(x.b)*exp(-Ω.r)*Φ(x.d₁-Ω.σ)\n        F[4] = exp(x.vκ) - Ω.κ*exp(x.a)*Φ(-x.d₁)\n\n    end\n\n     x̂ = nlsolve(residuals!, x₀,autodiff=:forward,show_trace=false).zero\n\n     return x̂.b\nend```\nKey part of error message (with a few line breaks added)\n```ERROR: LoadError: MethodError: no method matching NLsolve.NewtonTrustRegionCache(\n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Real,1,Array{Real,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)})\nClosest candidates are:\n  NLsolve.NewtonTrustRegionCache(::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx) where Tx at /home/alfred/.julia/packages/NLsolve/gJL1I/src/solvers/trust_region.jl:5```","user":"U017YGFQTE3","ts":"1615732245.126900","team":"T68168MUP","edited":{"user":"U017YGFQTE3","ts":"1615732317.000000"},"blocks":[{"type":"rich_text","block_id":"Kur/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Turing model:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function m(b,Ω,t)\n   n = maximum(t)\n   κ = Vector{Real}(undef, n)\n   κ ~ MvNormal(Fill(0.30, n),0.05)\n   for i in 1:length(b)\n      b[i] ~ Normal(merton(LArray(Ω[i];κ=κ[t[i]])),0.005)\n   end\nend\n\nchain = sample(m(b,Ω,t), NUTS(0.65), 1_000)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nmerton\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":" function merton(Ω::AbstractVector{T}) where T\n\n    A₀ = (exp(Ω.ve)+exp(Ω.vd))\n    d₁₀= (log(1+exp(Ω.ve-Ω.vd)) + Ω.r + (Ω.σ^2)/2)/Ω.σ;\n    x₀ = @LArray Array{T,1}([\n            log(1.05*A₀);\n            log(0.05*A₀);\n            d₁₀;\n            log(exp(Ω.vd)*(1+Ω.r+0.05))\n            ]) (:a,:vκ,:d₁,:b)\n\n    Φ = x -> Distributions.cdf(Normal(),x)\n\n    function residuals!(F,x)\n\n        F[1] = exp(x.a) - exp(Ω.ve) - exp(Ω.vd) - exp(x.vκ)\n        F[2] = x.d₁ - (x.a - x.b + Ω.r + (Ω.σ^2)/2)/Ω.σ\n        F[3] = exp(Ω.ve) - exp(x.a)*Φ(x.d₁) + exp(x.b)*exp(-Ω.r)*Φ(x.d₁-Ω.σ)\n        F[4] = exp(x.vκ) - Ω.κ*exp(x.a)*Φ(-x.d₁)\n\n    end\n\n     x̂ = nlsolve(residuals!, x₀,autodiff=:forward,show_trace=false).zero\n\n     return x̂.b\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nKey part of error message (with a few line breaks added)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ERROR: LoadError: MethodError: no method matching NLsolve.NewtonTrustRegionCache(\n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Real,1,Array{Real,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)})\nClosest candidates are:\n  NLsolve.NewtonTrustRegionCache(::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx) where Tx at /home/alfred/.julia/packages/NLsolve/gJL1I/src/solvers/trust_region.jl:5"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"86053aaf-8913-4540-8444-ceb6b4d4098b","type":"message","text":"I've checked to see that I can differentiate `merton` directly using `ForwardDiff` (which works, and generates the same result as `FiniteDiff` ). I have another project with a similar combination of NLsolve and Turing that works fine.","user":"U017YGFQTE3","ts":"1615732504.127300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YmP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've checked to see that I can differentiate "},{"type":"text","text":"merton","style":{"code":true}},{"type":"text","text":" directly using "},{"type":"text","text":"ForwardDiff","style":{"code":true}},{"type":"text","text":" (which works, and generates the same result as "},{"type":"text","text":"FiniteDiff","style":{"code":true}},{"type":"text","text":" ). I have another project with a similar combination of NLsolve and Turing that works fine."}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"ec74db46-efce-4a05-a6da-2c94cacb3941","type":"message","text":"Separately, this is an example where it would be great to be able to use an frule derivative. It is straightforward to write an frule for `merton`, and forward mode differentiation suits the problem (the parameter space is small).","user":"U017YGFQTE3","ts":"1615735935.127500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zZfrA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Separately, this is an example where it would be great to be able to use an frule derivative. It is straightforward to write an frule for "},{"type":"text","text":"merton","style":{"code":true}},{"type":"text","text":", and forward mode differentiation suits the problem (the parameter space is small)."}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"e8130135-8dc3-4be1-8086-53c18aca4a96","type":"message","text":"For type-stability:\n```@model function m(b,Ω,t, TV = Vector{Float64}) where {TV}\n   n = maximum(t)\n   κ = TV(undef, n)\n   κ ~ MvNormal(Fill(0.30, n),0.05)\n   for i in 1:length(b)\n      b[i] ~ Normal(merton(LArray(Ω[i];κ=κ[t[i]])),0.005)\n   end\nend```","user":"UHDNY2YMA","ts":"1615755622.129800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pMNX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For type-stability:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function m(b,Ω,t, TV = Vector{Float64}) where {TV}\n   n = maximum(t)\n   κ = TV(undef, n)\n   κ ~ MvNormal(Fill(0.30, n),0.05)\n   for i in 1:length(b)\n      b[i] ~ Normal(merton(LArray(Ω[i];κ=κ[t[i]])),0.005)\n   end\nend"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"2f43d60a-16ef-4b39-ad8d-b325f6d0b31d","type":"message","text":"And regarding `frule`, AFAIK there is no AD-backend (apparently ForwardDiff2.jl does but it's on hiatus) which actually makes use of `frule` atm as ChainRules.jl came about after ForwardDiff.jl was quite mature :confused:","user":"UHDNY2YMA","ts":"1615757922.130600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rUsu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And regarding "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":", AFAIK there is no AD-backend (apparently ForwardDiff2.jl does but it's on hiatus) which actually makes use of "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" atm as ChainRules.jl came about after ForwardDiff.jl was quite mature "},{"type":"emoji","name":"confused"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"691f8cbd-057e-4185-a0f2-3683914172a0","type":"message","text":"I was made aware of this example by Yingbo, though he said it could potentially be quite inefficient: <https://gist.github.com/YingboMa/c22dcf8239a62e01b27ac679dfe5d4c5>","user":"UHDNY2YMA","ts":"1615759845.132700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cdK4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was made aware of this example by Yingbo, though he said it could potentially be quite inefficient: "},{"type":"link","url":"https://gist.github.com/YingboMa/c22dcf8239a62e01b27ac679dfe5d4c5"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"2c892e07-4502-4174-a908-11b3a6ffda61","type":"message","text":"Curious to hear if you give it a try!:)","user":"UHDNY2YMA","ts":"1615759863.132900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hWAI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Curious to hear if you give it a try!:)"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"5310ddf4-83b7-41ab-be42-a833f994d4b8","type":"message","text":"If you can write down the `frule`, then it's not too hard to derive the `rrule`. See <https://juliadiff.org/ChainRulesCore.jl/dev/arrays.html#Reverse-mode-rules> for worked examples.","user":"UHDQQ4GN6","ts":"1615789793.133900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zX5hs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you can write down the "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":", then it's not too hard to derive the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":". See "},{"type":"link","url":"https://juliadiff.org/ChainRulesCore.jl/dev/arrays.html#Reverse-mode-rules"},{"type":"text","text":" for worked examples."}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"0677e3f7-e20a-44ff-a047-2412536e36c1","type":"message","text":"But I think he wants to use ForwardDiff.jl for the rest of the code, and so it's not a question about deriving the `rrule` but rather figuring out how he can make use of his custom pushforward in a forward-diff AD system. Also, I might be the one misunderstanding :upside_down_face:","user":"UHDNY2YMA","ts":"1615798160.134100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yFWjK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I think he wants to use ForwardDiff.jl for the rest of the code, and so it's not a question about deriving the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" but rather figuring out how he can make use of his custom pushforward in a forward-diff AD system. Also, I might be the one misunderstanding "},{"type":"emoji","name":"upside_down_face"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"8c78f556-cf49-48b8-8c99-5250db6c63c6","type":"message","text":"Thanks both! It turned out that the particular type problem that I was having (compared with another project where similar code worked) was down to an update of NLSolversBase. I had checked the manifests for package numbers of NLsolve, Turing and ForwardDiff, but I had not dived deep enough.\n\nThe example by Yingbo is really neat. I'll follow that and let you know how it goes.\n\n<@UHDQQ4GN6> I'll admit that I need to start learning and writing rrules; I thought that your post on the LU decomposition was excellent.","user":"U017YGFQTE3","ts":"1615830121.148500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vwp4E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks both! It turned out that the particular type problem that I was having (compared with another project where similar code worked) was down to an update of NLSolversBase. I had checked the manifests for package numbers of NLsolve, Turing and ForwardDiff, but I had not dived deep enough.\n\nThe example by Yingbo is really neat. I'll follow that and let you know how it goes.\n\n"},{"type":"user","user_id":"UHDQQ4GN6"},{"type":"text","text":" I'll admit that I need to start learning and writing rrules; I thought that your post on the LU decomposition was excellent."}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"3582f329-4a07-4906-ae15-9785984e6276","type":"message","text":"Glad to hear it was useful!","user":"UHDQQ4GN6","ts":"1615966222.006900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1RQmH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Glad to hear it was useful!"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"}]