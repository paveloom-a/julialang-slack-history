[{"client_msg_id":"0913ebd4-edeb-492a-81f3-31eb69f72101","type":"message","text":"Some help with this type stability / AD issue would be greatly appreciated (details in thread)","user":"U017YGFQTE3","ts":"1615732094.126800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uFVsZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Some help with this type stability / AD issue would be greatly appreciated (details in thread)"}]}]}],"thread_ts":"1615732094.126800","reply_count":2,"reply_users_count":1,"latest_reply":"1615732504.127300","reply_users":["U017YGFQTE3"],"subscribed":false},{"client_msg_id":"a31753ca-2076-4c28-90ad-d37bd2f40f9c","type":"message","text":"Turing model:\n```@model function m(b,Ω,t)\n   n = maximum(t)\n   κ = Vector{Real}(undef, n)\n   κ ~ MvNormal(Fill(0.30, n),0.05)\n   for i in 1:length(b)\n      b[i] ~ Normal(merton(LArray(Ω[i];κ=κ[t[i]])),0.005)\n   end\nend\n\nchain = sample(m(b,Ω,t), NUTS(0.65), 1_000)```\nmerton\n``` function merton(Ω::AbstractVector{T}) where T\n\n    A₀ = (exp(Ω.ve)+exp(Ω.vd))\n    d₁₀= (log(1+exp(Ω.ve-Ω.vd)) + Ω.r + (Ω.σ^2)/2)/Ω.σ;\n    x₀ = @LArray Array{T,1}([\n            log(1.05*A₀);\n            log(0.05*A₀);\n            d₁₀;\n            log(exp(Ω.vd)*(1+Ω.r+0.05))\n            ]) (:a,:vκ,:d₁,:b)\n\n    Φ = x -&gt; Distributions.cdf(Normal(),x)\n\n    function residuals!(F,x)\n\n        F[1] = exp(x.a) - exp(Ω.ve) - exp(Ω.vd) - exp(x.vκ)\n        F[2] = x.d₁ - (x.a - x.b + Ω.r + (Ω.σ^2)/2)/Ω.σ\n        F[3] = exp(Ω.ve) - exp(x.a)*Φ(x.d₁) + exp(x.b)*exp(-Ω.r)*Φ(x.d₁-Ω.σ)\n        F[4] = exp(x.vκ) - Ω.κ*exp(x.a)*Φ(-x.d₁)\n\n    end\n\n     x̂ = nlsolve(residuals!, x₀,autodiff=:forward,show_trace=false).zero\n\n     return x̂.b\nend```\nKey part of error message (with a few line breaks added)\n```ERROR: LoadError: MethodError: no method matching NLsolve.NewtonTrustRegionCache(\n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Real,1,Array{Real,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)})\nClosest candidates are:\n  NLsolve.NewtonTrustRegionCache(::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx) where Tx at /home/alfred/.julia/packages/NLsolve/gJL1I/src/solvers/trust_region.jl:5```","user":"U017YGFQTE3","ts":"1615732245.126900","team":"T68168MUP","edited":{"user":"U017YGFQTE3","ts":"1615732317.000000"},"blocks":[{"type":"rich_text","block_id":"Kur/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Turing model:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function m(b,Ω,t)\n   n = maximum(t)\n   κ = Vector{Real}(undef, n)\n   κ ~ MvNormal(Fill(0.30, n),0.05)\n   for i in 1:length(b)\n      b[i] ~ Normal(merton(LArray(Ω[i];κ=κ[t[i]])),0.005)\n   end\nend\n\nchain = sample(m(b,Ω,t), NUTS(0.65), 1_000)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nmerton\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":" function merton(Ω::AbstractVector{T}) where T\n\n    A₀ = (exp(Ω.ve)+exp(Ω.vd))\n    d₁₀= (log(1+exp(Ω.ve-Ω.vd)) + Ω.r + (Ω.σ^2)/2)/Ω.σ;\n    x₀ = @LArray Array{T,1}([\n            log(1.05*A₀);\n            log(0.05*A₀);\n            d₁₀;\n            log(exp(Ω.vd)*(1+Ω.r+0.05))\n            ]) (:a,:vκ,:d₁,:b)\n\n    Φ = x -> Distributions.cdf(Normal(),x)\n\n    function residuals!(F,x)\n\n        F[1] = exp(x.a) - exp(Ω.ve) - exp(Ω.vd) - exp(x.vκ)\n        F[2] = x.d₁ - (x.a - x.b + Ω.r + (Ω.σ^2)/2)/Ω.σ\n        F[3] = exp(Ω.ve) - exp(x.a)*Φ(x.d₁) + exp(x.b)*exp(-Ω.r)*Φ(x.d₁-Ω.σ)\n        F[4] = exp(x.vκ) - Ω.κ*exp(x.a)*Φ(-x.d₁)\n\n    end\n\n     x̂ = nlsolve(residuals!, x₀,autodiff=:forward,show_trace=false).zero\n\n     return x̂.b\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nKey part of error message (with a few line breaks added)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ERROR: LoadError: MethodError: no method matching NLsolve.NewtonTrustRegionCache(\n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Real,1,Array{Real,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)}, \n  ::LArray{Float64,1,Array{Float64,1},(:a, :vκ, :d₁, :b)})\nClosest candidates are:\n  NLsolve.NewtonTrustRegionCache(::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx, ::Tx) where Tx at /home/alfred/.julia/packages/NLsolve/gJL1I/src/solvers/trust_region.jl:5"}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"},{"client_msg_id":"86053aaf-8913-4540-8444-ceb6b4d4098b","type":"message","text":"I've checked to see that I can differentiate `merton` directly using `ForwardDiff` (which works, and generates the same result as `FiniteDiff` ). I have another project with a similar combination of NLsolve and Turing that works fine.","user":"U017YGFQTE3","ts":"1615732504.127300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YmP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've checked to see that I can differentiate "},{"type":"text","text":"merton","style":{"code":true}},{"type":"text","text":" directly using "},{"type":"text","text":"ForwardDiff","style":{"code":true}},{"type":"text","text":" (which works, and generates the same result as "},{"type":"text","text":"FiniteDiff","style":{"code":true}},{"type":"text","text":" ). I have another project with a similar combination of NLsolve and Turing that works fine."}]}]}],"thread_ts":"1615732094.126800","parent_user_id":"U017YGFQTE3"}]