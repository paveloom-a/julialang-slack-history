[{"client_msg_id":"865232ee-c16a-498b-8906-3c53af6a9d74","type":"message","text":"The bugged code (if I try to force covariance matrix to be symmetry and positive definite externally) and its error message attaches:\n```using Random\nusing DifferentialEquations\nusing GenericLinearAlgebra\nusing Statistics\nusing Distributions\nusing Turing\n# data\nu_account = [1.0; 2.0];\n@model bayes_lna(y) = begin\n    log_delta ~ Normal(0.0,1.0) \n    delta = [exp(log_delta)]\n    phi = [delta  0; 10^-7 delta] # covariance matrix \n    D,V = GenericLinearAlgebra.eigen(GenericLinearAlgebra.Symmetric(phi))  # get eigen-values and eigen-vectos\n    D .= max.(D,1e-12) # force eigen values to be positive\n    phi_new = V*GenericLinearAlgebra.Diagonal(D)*V' # create new symmetry and positive definite matrix\n    y[:] ~ MvNormal([0.0,0.0],GenericLinearAlgebra.Symmetric(phi_new))\nend\nRandom.seed!(87654)\niterations = 20\nchain = sample(bayes_lna(u_account), NUTS(0.65),iterations)```","user":"U01Q398M3QB","ts":"1616578091.056700","team":"T68168MUP","edited":{"user":"U01Q398M3QB","ts":"1616578570.000000"},"blocks":[{"type":"rich_text","block_id":"Ynsh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The bugged code (if I try to force covariance matrix to be symmetry and positive definite externally) and its error message attaches:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Random\nusing DifferentialEquations\nusing GenericLinearAlgebra\nusing Statistics\nusing Distributions\nusing Turing\n# data\nu_account = [1.0; 2.0];\n@model bayes_lna(y) = begin\n    log_delta ~ Normal(0.0,1.0) \n    delta = [exp(log_delta)]\n    phi = [delta  0; 10^-7 delta] # covariance matrix \n    D,V = GenericLinearAlgebra.eigen(GenericLinearAlgebra.Symmetric(phi))  # get eigen-values and eigen-vectos\n    D .= max.(D,1e-12) # force eigen values to be positive\n    phi_new = V*GenericLinearAlgebra.Diagonal(D)*V' # create new symmetry and positive definite matrix\n    y[:] ~ MvNormal([0.0,0.0],GenericLinearAlgebra.Symmetric(phi_new))\nend\nRandom.seed!(87654)\niterations = 20\nchain = sample(bayes_lna(u_account), NUTS(0.65),iterations)"}]}]}],"thread_ts":"1616578091.056700","reply_count":2,"reply_users_count":2,"latest_reply":"1616581529.062700","reply_users":["U8T9JUA5R","U01Q398M3QB"],"is_locked":false,"subscribed":false},{"type":"message","subtype":"thread_broadcast","text":"I don't have any experience with ProximalOperators.jl, so I can't comment on this part. In general, if you have full control over the model and work with custom distributions, probably it would be much more efficient if you do not work with the covariance matrix `C` directly but instead with the lower-triangular matrix `L` in its decomposition `C = LL'`. In the example you show `phi` is actually already a lower-triangular matrix. Generally, you then just have to enforce that the diagonal entries of `L` are non-negative (e.g., by using `exp` or `log1pexp` ), the off-diagonal elements of `L` can be arbitrary. BTW I am a bit surprised you have to use `GenericLinearAlgebra` here - at least `Symmetric`  and `Diagonal` from `LinearAlgebra` should work fine with dual numbers (so maybe it is just due to `eigen`?). In fact, AFAIK PDMats (which is used by the constructors of `MvNormal`) only defines special dispatches for `LinearAlgebra.Symmetric` but not GenericLinearAlgebra.","user":"U8T9JUA5R","ts":"1616580167.061100","thread_ts":"1616578091.056700","root":{"client_msg_id":"865232ee-c16a-498b-8906-3c53af6a9d74","type":"message","text":"The bugged code (if I try to force covariance matrix to be symmetry and positive definite externally) and its error message attaches:\n```using Random\nusing DifferentialEquations\nusing GenericLinearAlgebra\nusing Statistics\nusing Distributions\nusing Turing\n# data\nu_account = [1.0; 2.0];\n@model bayes_lna(y) = begin\n    log_delta ~ Normal(0.0,1.0) \n    delta = [exp(log_delta)]\n    phi = [delta  0; 10^-7 delta] # covariance matrix \n    D,V = GenericLinearAlgebra.eigen(GenericLinearAlgebra.Symmetric(phi))  # get eigen-values and eigen-vectos\n    D .= max.(D,1e-12) # force eigen values to be positive\n    phi_new = V*GenericLinearAlgebra.Diagonal(D)*V' # create new symmetry and positive definite matrix\n    y[:] ~ MvNormal([0.0,0.0],GenericLinearAlgebra.Symmetric(phi_new))\nend\nRandom.seed!(87654)\niterations = 20\nchain = sample(bayes_lna(u_account), NUTS(0.65),iterations)```","user":"U01Q398M3QB","ts":"1616578091.056700","team":"T68168MUP","edited":{"user":"U01Q398M3QB","ts":"1616578570.000000"},"blocks":[{"type":"rich_text","block_id":"Ynsh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The bugged code (if I try to force covariance matrix to be symmetry and positive definite externally) and its error message attaches:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Random\nusing DifferentialEquations\nusing GenericLinearAlgebra\nusing Statistics\nusing Distributions\nusing Turing\n# data\nu_account = [1.0; 2.0];\n@model bayes_lna(y) = begin\n    log_delta ~ Normal(0.0,1.0) \n    delta = [exp(log_delta)]\n    phi = [delta  0; 10^-7 delta] # covariance matrix \n    D,V = GenericLinearAlgebra.eigen(GenericLinearAlgebra.Symmetric(phi))  # get eigen-values and eigen-vectos\n    D .= max.(D,1e-12) # force eigen values to be positive\n    phi_new = V*GenericLinearAlgebra.Diagonal(D)*V' # create new symmetry and positive definite matrix\n    y[:] ~ MvNormal([0.0,0.0],GenericLinearAlgebra.Symmetric(phi_new))\nend\nRandom.seed!(87654)\niterations = 20\nchain = sample(bayes_lna(u_account), NUTS(0.65),iterations)"}]}]}],"thread_ts":"1616578091.056700","reply_count":2,"reply_users_count":2,"latest_reply":"1616581529.062700","reply_users":["U8T9JUA5R","U01Q398M3QB"],"is_locked":false,"subscribed":false},"blocks":[{"type":"rich_text","block_id":"05o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't have any experience with ProximalOperators.jl, so I can't comment on this part. In general, if you have full control over the model and work with custom distributions, probably it would be much more efficient if you do not work with the covariance matrix "},{"type":"text","text":"C","style":{"code":true}},{"type":"text","text":" directly but instead with the lower-triangular matrix "},{"type":"text","text":"L","style":{"code":true}},{"type":"text","text":" in its decomposition "},{"type":"text","text":"C = LL'","style":{"code":true}},{"type":"text","text":". In the example you show "},{"type":"text","text":"phi","style":{"code":true}},{"type":"text","text":" is actually already a lower-triangular matrix. Generally, you then just have to enforce that the diagonal entries of "},{"type":"text","text":"L","style":{"code":true}},{"type":"text","text":" are non-negative (e.g., by using "},{"type":"text","text":"exp","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"log1pexp","style":{"code":true}},{"type":"text","text":" ), the off-diagonal elements of "},{"type":"text","text":"L","style":{"code":true}},{"type":"text","text":" can be arbitrary. BTW I am a bit surprised you have to use "},{"type":"text","text":"GenericLinearAlgebra","style":{"code":true}},{"type":"text","text":" here - at least "},{"type":"text","text":"Symmetric","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"Diagonal","style":{"code":true}},{"type":"text","text":" from "},{"type":"text","text":"LinearAlgebra","style":{"code":true}},{"type":"text","text":" should work fine with dual numbers (so maybe it is just due to "},{"type":"text","text":"eigen","style":{"code":true}},{"type":"text","text":"?). In fact, AFAIK PDMats (which is used by the constructors of "},{"type":"text","text":"MvNormal","style":{"code":true}},{"type":"text","text":") only defines special dispatches for "},{"type":"text","text":"LinearAlgebra.Symmetric","style":{"code":true}},{"type":"text","text":" but not GenericLinearAlgebra."}]}]}],"client_msg_id":"9b05f06e-d571-4bcc-8abc-95ddaceacc68"},{"type":"message","text":"<@U8T9JUA5R> Hi! David, thanks for replying so quickly. In my original code. The covariance matrix *C* is calculated by an ODE function which might become not symmetry nor positive definite due to the numerical errors. I do not have a good way to get its lower triangular decomposition *L*. I will change GenericLinearAlgebra back into LinearAlgebra.\n\nI just checked the matrix factorizations in LinearAlgebra.jl   I feel that if I could use the SVD decomposition to replace the cholesky decomposition in MvNomral(). Then, I do not need to make the matrix to be symmetry and positive definite. Is this achievable?","files":[{"id":"F01S9C3RSQ3","created":1616581526,"timestamp":1616581526,"name":"image.png","title":"image.png","mimetype":"image/png","filetype":"png","pretty_type":"PNG","user":"U01Q398M3QB","editable":false,"size":83242,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01S9C3RSQ3/image.png","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01S9C3RSQ3/download/image.png","thumb_64":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_64.png","thumb_80":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_80.png","thumb_360":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_360.png","thumb_360_w":360,"thumb_360_h":340,"thumb_480":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_480.png","thumb_480_w":480,"thumb_480_h":453,"thumb_160":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_160.png","thumb_720":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_720.png","thumb_720_w":720,"thumb_720_h":680,"thumb_800":"https://files.slack.com/files-tmb/T68168MUP-F01S9C3RSQ3-c3ec7b227d/image_800.png","thumb_800_w":800,"thumb_800_h":755,"original_w":826,"original_h":780,"thumb_tiny":"AwAtADC5KszMRGwUY6n1p0KuqYkIJzxing806gBv8XTNKc560YyTzQaADPtS0gHvS0ANHNLTQPQ06gA5z/8AWoPWkzyecUpoAOaUU3jvinZFADBmnUxTk4p9ACYOTj9aGXJ6n8DTDIMn5f1pVcEgbf1oAUIOuW/M0/AznHNGBRQB/9k=","permalink":"https://julialang.slack.com/files/U01Q398M3QB/F01S9C3RSQ3/image.png","permalink_public":"https://slack-files.com/T68168MUP-F01S9C3RSQ3-d5f96acf1e","is_starred":false,"has_rich_preview":false}],"upload":false,"blocks":[{"type":"rich_text","block_id":"PnmQ","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8T9JUA5R"},{"type":"text","text":" Hi! David, thanks for replying so quickly. In my original code. The covariance matrix "},{"type":"text","text":"C","style":{"bold":true}},{"type":"text","text":" is calculated by an ODE function which might become not symmetry nor positive definite due to the numerical errors. I do not have a good way to get its lower triangular decomposition "},{"type":"text","text":"L","style":{"bold":true}},{"type":"text","text":". I will change GenericLinearAlgebra back into LinearAlgebra.\n\nI just checked the matrix factorizations in LinearAlgebra.jl   I feel that if I could use the SVD decomposition to replace the cholesky decomposition in MvNomral(). Then, I do not need to make the matrix to be symmetry and positive definite. Is this achievable?"}]}]}],"user":"U01Q398M3QB","display_as_bot":false,"ts":"1616581529.062700","edited":{"user":"U01Q398M3QB","ts":"1616581563.000000"},"thread_ts":"1616578091.056700","parent_user_id":"U01Q398M3QB"}]