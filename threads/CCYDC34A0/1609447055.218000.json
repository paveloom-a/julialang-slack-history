[{"client_msg_id":"37973ed3-3138-4331-9b1e-b343ea154287","type":"message","text":"Hey folks. I was hoping someone could point me in the right direction with this error message. I am setting up a very simple vanilla discrete dynamical simulation (to proof of concept). So I define a simple growth model, generate some data, and then wrote a Turing model to see if I can recover the parameters used to generate the simulated data. The code is below. But I am getting an error when I run the `chain` function to execute the sample. The error is `TypeError: in typeassert, expected Float64, got a value of type ForwardDiff.Dual{Nothing,Float64,2}`. I am not really sure how to debug these types of issues in Turing, so if anyone could tell me where to look, I would appreciate it. Here is the simple code that I wrote. I use the Turing Diffeq tutorial as a model, but removed the Diffeq solver with my own solver. I can add more to the stacktrace if it is helpful.\n```\n# Create a simple discrete simulation\nfunction simple_growth!(du, u0, p)\n    r = p[1]\n    du[1] = r*u0[1]\n    du\nend\n\n# solve the dynamical system\nfunction solve_system(f,u0,p,n)\n    u = Vector{typeof(u0)}(undef,n)\n    du = similar(u0)\n    u[1] = u0\n    for i in 1:n-1\n        f(du,u[i],p)\n        u[i+1] = copy(du)\n    end\n    u\nend\n\n# simulate some data\ndata = solve_system(simple_growth!, [0.9], [2.0], 10)\ndata = [data[i][1] for i in 1:length(data)]\n\n# define the Turing model\nTuring.setadbackend(:forwarddiff)\n\n@model function fitlv(data, f, u0, n)\n    σ ~ InverseGamma(2, 3) # ~ is the tilde character\n    α ~ truncated(Normal(0.7,0.5),0.5,2.5)\n\n    p = [α]\n    #prob = remake(prob1, p=p)\n    predicted = solve_system(f, u0, p, n)\n\tpredicted = [predicted[i][1] for i in 1:length(predicted)]\n    for i = 1:length(predicted)\n        data[i] ~ Normal(predicted[i], σ)\n    end\nend\n\n# setup the Turing sampler\nu0 = [0.9]\nn = 10\nmodel = fitlv(data, simple_growth!, u0, n)\nchain = mapreduce(c -&gt; sample(model, NUTS(.65),1000), chainscat, 1:3)```\nHere is just the first part of the stacktrace for the error.\n\n```chain\n\nTypeError: in typeassert, expected Float64, got a value of type ForwardDiff.Dual{Nothing,Float64,2}\n\n    setindex!(::Array{Float64,1}, ::ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2}, ::Int64)@array.jl:847\n    simple_growth!(::Array{Float64,1}, ::Array{Float64,1}, ::Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1})@Other: 3\n    solve_system(::typeof(Main.workspace115.simple_growth!), ::Array{Float64,1}, ::Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1}, ::Int64)@Other: 6\n    #1@Other: 10[inlined]\n    (::Main.workspace150.var\"#1#3\")(::Random._GLOBAL_RNG, ::DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}}, ::DynamicPPL.ThreadSafeVarInfo{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1},Array{Set{DynamicPPL.Selector},1}}}},ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2}},Array{Base.RefValue{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2}},1}}, ::DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}}, ::DynamicPPL.DefaultContext, ::Array{Float64,1}, ::Function, ::Array{Float64,1}, ::Int64)@none:0```","user":"UDDSTBX19","ts":"1609447055.218000","team":"T68168MUP","edited":{"user":"UDDSTBX19","ts":"1609447459.000000"},"blocks":[{"type":"rich_text","block_id":"ZZ9K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey folks. I was hoping someone could point me in the right direction with this error message. I am setting up a very simple vanilla discrete dynamical simulation (to proof of concept). So I define a simple growth model, generate some data, and then wrote a Turing model to see if I can recover the parameters used to generate the simulated data. The code is below. But I am getting an error when I run the `chain` function to execute the sample. The error is "},{"type":"text","text":"TypeError: in typeassert, expected Float64, got a value of type ForwardDiff.Dual{Nothing,Float64,2}","style":{"code":true}},{"type":"text","text":". I am not really sure how to debug these types of issues in Turing, so if anyone could tell me where to look, I would appreciate it. Here is the simple code that I wrote. I use the Turing Diffeq tutorial as a model, but removed the Diffeq solver with my own solver. I can add more to the stacktrace if it is helpful.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\n# Create a simple discrete simulation\nfunction simple_growth!(du, u0, p)\n    r = p[1]\n    du[1] = r*u0[1]\n    du\nend\n\n# solve the dynamical system\nfunction solve_system(f,u0,p,n)\n    u = Vector{typeof(u0)}(undef,n)\n    du = similar(u0)\n    u[1] = u0\n    for i in 1:n-1\n        f(du,u[i],p)\n        u[i+1] = copy(du)\n    end\n    u\nend\n\n# simulate some data\ndata = solve_system(simple_growth!, [0.9], [2.0], 10)\ndata = [data[i][1] for i in 1:length(data)]\n\n# define the Turing model\nTuring.setadbackend(:forwarddiff)\n\n@model function fitlv(data, f, u0, n)\n    σ ~ InverseGamma(2, 3) # ~ is the tilde character\n    α ~ truncated(Normal(0.7,0.5),0.5,2.5)\n\n    p = [α]\n    #prob = remake(prob1, p=p)\n    predicted = solve_system(f, u0, p, n)\n\tpredicted = [predicted[i][1] for i in 1:length(predicted)]\n    for i = 1:length(predicted)\n        data[i] ~ Normal(predicted[i], σ)\n    end\nend\n\n# setup the Turing sampler\nu0 = [0.9]\nn = 10\nmodel = fitlv(data, simple_growth!, u0, n)\nchain = mapreduce(c -> sample(model, NUTS(.65),1000), chainscat, 1:3)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Here is just the first part of the stacktrace for the error.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"chain\n\nTypeError: in typeassert, expected Float64, got a value of type ForwardDiff.Dual{Nothing,Float64,2}\n\n    setindex!(::Array{Float64,1}, ::ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2}, ::Int64)@array.jl:847\n    simple_growth!(::Array{Float64,1}, ::Array{Float64,1}, ::Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1})@Other: 3\n    solve_system(::typeof(Main.workspace115.simple_growth!), ::Array{Float64,1}, ::Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1}, ::Int64)@Other: 6\n    #1@Other: 10[inlined]\n    (::Main.workspace150.var\"#1#3\")(::Random._GLOBAL_RNG, ::DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}}, ::DynamicPPL.ThreadSafeVarInfo{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2},1},Array{Set{DynamicPPL.Selector},1}}}},ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2}},Array{Base.RefValue{ForwardDiff.Dual{ForwardDiff.Tag{Turing.Core.var\"#f#1\"{DynamicPPL.VarInfo{NamedTuple{(:σ, :α),Tuple{DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:σ,Tuple{}},Int64},Array{Distributions.InverseGamma{Float64},1},Array{DynamicPPL.VarName{:σ,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}},DynamicPPL.Metadata{Dict{DynamicPPL.VarName{:α,Tuple{}},Int64},Array{Distributions.Truncated{Distributions.Normal{Float64},Distributions.Continuous,Float64},1},Array{DynamicPPL.VarName{:α,Tuple{}},1},Array{Float64,1},Array{Set{DynamicPPL.Selector},1}}}},Float64},DynamicPPL.Model{Main.workspace150.var\"#1#3\",(:data, :f, :u0, :n),(),(),Tuple{Array{Float64,1},typeof(Main.workspace115.simple_growth!),Array{Float64,1},Int64},Tuple{}},DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}},DynamicPPL.DefaultContext},Float64},Float64,2}},1}}, ::DynamicPPL.Sampler{Turing.Inference.NUTS{Turing.Core.ForwardDiffAD{40},(),AdvancedHMC.DiagEuclideanMetric}}, ::DynamicPPL.DefaultContext, ::Array{Float64,1}, ::Function, ::Array{Float64,1}, ::Int64)@none:0"}]}]}],"thread_ts":"1609447055.218000","reply_count":10,"reply_users_count":2,"latest_reply":"1609448470.220100","reply_users":["U69BL50BF","UDDSTBX19"],"subscribed":false},{"client_msg_id":"9096ab97-a957-45a7-9f25-653dc56f34a8","type":"message","text":"There is DiscreteProblem BTW and it should just work fine","user":"U69BL50BF","ts":"1609447853.218300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9WK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is DiscreteProblem BTW and it should just work fine"}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"138a2df8-5442-4c30-9b87-908725052db7","type":"message","text":"Your issue is that you need to promote the u type","user":"U69BL50BF","ts":"1609447897.218500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gqlj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Your issue is that you need to promote the u type"}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"4ef161d8-3c1a-4fdb-89e0-3a7041f8b2a3","type":"message","text":"<@U69BL50BF> Oh that is good to know. I can check that out and use it as a workaround for now. I just wanted to write my own solver, so that I have more flexibility for callbacks, etc. Promote the u type, oh interesting.","user":"UDDSTBX19","ts":"1609447942.218700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eXUV","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U69BL50BF"},{"type":"text","text":" Oh that is good to know. I can check that out and use it as a workaround for now. I just wanted to write my own solver, so that I have more flexibility for callbacks, etc. Promote the u type, oh interesting."}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"e8546c90-725f-4161-beb7-449c33b34f27","type":"message","text":"I would be interested in hearing what flexibility it doesn't have","user":"U69BL50BF","ts":"1609448007.218900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ElJb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would be interested in hearing what flexibility it doesn't have"}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"13a94596-8382-4511-affe-1c98f2deb315","type":"message","text":"Hmm, so when you say promote the u time, you mean the type for `u0` or am I just totally off, haha.","user":"UDDSTBX19","ts":"1609448014.219100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"g3S","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm, so when you say promote the u time, you mean the type for "},{"type":"text","text":"u0","style":{"code":true}},{"type":"text","text":" or am I just totally off, haha."}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"62145b98-6384-4bfe-8d47-4a348450a10d","type":"message","text":"Yes you need to convert.((eltype(p),), u0)","user":"U69BL50BF","ts":"1609448080.219300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lZZMa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes you need to convert.((eltype(p),), u0)"}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"d2a1179d-362b-426d-bdf8-c14075832a19","type":"message","text":"Oh sure. I can totally look at DiscreteProblem and it might just work perfectly. Let me check that out. I need to mix some solving of a dynamical system on a graph, and then that updates some parameters in the simulation, etc. But I can see if DiscreteProblem solves that issue for me.","user":"UDDSTBX19","ts":"1609448157.219500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B/8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh sure. I can totally look at DiscreteProblem and it might just work perfectly. Let me check that out. I need to mix some solving of a dynamical system on a graph, and then that updates some parameters in the simulation, etc. But I can see if DiscreteProblem solves that issue for me."}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"87b3140b-ecde-4222-bf53-4c972db7b2fb","type":"message","text":"Oh thanks so much. Yeah, I can do that promotion. Sounds easy enough. Thanks so much <@U69BL50BF>. Happy New Years. And thanks again for the help.","user":"UDDSTBX19","ts":"1609448326.219700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tkLF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh thanks so much. Yeah, I can do that promotion. Sounds easy enough. Thanks so much "},{"type":"user","user_id":"U69BL50BF"},{"type":"text","text":". Happy New Years. And thanks again for the help."}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"009fb752-86aa-4fae-aaf9-d927a7f72128","type":"message","text":"If you use `init` for the integrator interface you can control the steps and change parameters on the fly. At least with DiscreteProblem you should get almost the same flexibility as by hand because it's a relatively light interface, mostly handling issues like this kind of type stuff.","user":"U69BL50BF","ts":"1609448463.219900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zWO8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you use "},{"type":"text","text":"init","style":{"code":true}},{"type":"text","text":" for the integrator interface you can control the steps and change parameters on the fly. At least with DiscreteProblem you should get almost the same flexibility as by hand because it's a relatively light interface, mostly handling issues like this kind of type stuff."}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"},{"client_msg_id":"bd68da20-8b63-485e-9006-65eb309875ef","type":"message","text":"Happy New Years","user":"U69BL50BF","ts":"1609448470.220100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sfE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Happy New Years"}]}]}],"thread_ts":"1609447055.218000","parent_user_id":"UDDSTBX19"}]