[{"client_msg_id":"05D56180-4900-48CA-AAB5-8754E2781AF1","type":"message","text":"I‘m fitting a multilevel model on multiple nominal classes (say string a, b, c). Is there a way to propagate these classes to MCMCChains? Would that be via CategoricalArrays maybe?","user":"U01BTNDCUBX","ts":"1613746603.158900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xgR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I‘m fitting a multilevel model on multiple nominal classes (say string a, b, c). Is there a way to propagate these classes to MCMCChains? Would that be via CategoricalArrays maybe?"}]}]}],"thread_ts":"1613746603.158900","reply_count":8,"reply_users_count":2,"latest_reply":"1613839285.008800","reply_users":["U01C2AJ9F63","U01BTNDCUBX"],"subscribed":false},{"client_msg_id":"52bbde95-806d-4668-a7c8-6569f8bd189b","type":"message","text":"As in, conditioning based on multiple nominal classes? In that case maybe a Dictionary works. I recently tried this at least, and it seemed to work, this indeed allowed string outputs for the various different classes for a parameter.","user":"U01C2AJ9F63","ts":"1613747726.159000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WXApW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As in, conditioning based on multiple nominal classes? In that case maybe a Dictionary works. I recently tried this at least, and it seemed to work, this indeed allowed string outputs for the various different classes for a parameter."}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"},{"client_msg_id":"30c76518-4a15-456c-8478-09d384e865ab","type":"message","text":"I'm not sure whether conditioning means the same here. My question was unclear too. Say that I got <https://statisticalrethinkingjulia.github.io/TuringModels.jl/models/multinomial-poisson/|this> model, but I want `chns` to show parameters a, A, B, C, D, E, F, bm and sigma_dept, where the capital letters are the departements. So, `a_dept[1]` should show as `A`. You did that via a dict? Sounds good (except for the fact that a dict is unordered). How did you pass the dict? Do you still have the code somewhere? Thanks!","user":"U01BTNDCUBX","ts":"1613766929.159200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FNvY=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure whether conditioning means the same here. My question was unclear too. Say that I got "},{"type":"link","url":"https://statisticalrethinkingjulia.github.io/TuringModels.jl/models/multinomial-poisson/","text":"this"},{"type":"text","text":" model, but I want "},{"type":"text","text":"chns","style":{"code":true}},{"type":"text","text":" to show parameters a, A, B, C, D, E, F, bm and sigma_dept, where the capital letters are the departements. So, "},{"type":"text","text":"a_dept[1]","style":{"code":true}},{"type":"text","text":" should show as "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":". You did that via a dict? Sounds good (except for the fact that a dict is unordered). How did you pass the dict? Do you still have the code somewhere? Thanks!"}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"},{"client_msg_id":"C1940752-BCE2-401C-8230-7C13F8744EB7","type":"message","text":"I think I get it now. Will try out soon and let you know when I need more info ","user":"U01BTNDCUBX","ts":"1613773289.160100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qCqYc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think I get it now. Will try out soon and let you know when I need more info "}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"},{"client_msg_id":"339a2f25-24be-4100-a2b9-87dfe6a21c1a","type":"message","text":"Did you put the dict in the model? In <https://statisticalrethinkingjulia.github.io/TuringModels.jl/models/spatial-autocorrelation-oceanic/|this> model, for example, I'm not sure whether I can replace the MvNormal with a Dict containing multiple normal distributions, because I'm not sure whether Turing assumes the distributions to be independent univariate normal random variables. I'm not a fan of using the dict outside of the Turing model, because it's more code and easier to mess up the mapping when going in the reverse direction.","user":"U01BTNDCUBX","ts":"1613818139.007400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"axQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Did you put the dict in the model? In "},{"type":"link","url":"https://statisticalrethinkingjulia.github.io/TuringModels.jl/models/spatial-autocorrelation-oceanic/","text":"this"},{"type":"text","text":" model, for example, I'm not sure whether I can replace the MvNormal with a Dict containing multiple normal distributions, because I'm not sure whether Turing assumes the distributions to be independent univariate normal random variables. I'm not a fan of using the dict outside of the Turing model, because it's more code and easier to mess up the mapping when going in the reverse direction."}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"},{"client_msg_id":"f6a24947-1cfa-4b12-832e-a67b3b851cc6","type":"message","text":"Hmm in that case with MvNormal I don't see either how you would use a Dict directly, because indeed the MvNormal does not really know I guess what it is producing, it just 10 values, with no meaning on its own. In that case it seems almost like you would need to somehow postprocess it to give meaning to the representations. I haven't figured out that part either, because indeed it is very annoying having to constantly look up what each number means in essence.","user":"U01C2AJ9F63","ts":"1613819296.007600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MU8a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm in that case with MvNormal I don't see either how you would use a Dict directly, because indeed the MvNormal does not really know I guess what it is producing, it just 10 values, with no meaning on its own. In that case it seems almost like you would need to somehow postprocess it to give meaning to the representations. I haven't figured out that part either, because indeed it is very annoying having to constantly look up what each number means in essence."}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"},{"client_msg_id":"861e9c09-63bb-44e0-bcea-8630578774e3","type":"message","text":"Thanks, Michiel for thinking along. I was still doubting, but indeed it's probably not possible with MvNormal. I've asked about it <https://discourse.julialang.org/t/datastructure-for-two-way-map/52735/6|here>, and they told me to use Bijectors or CategoricalArrays. I've had succes with CategoricalArrays in other circumstances, but not yet with Turing. I gonna experiment a bit more with it","user":"U01BTNDCUBX","ts":"1613820159.008000","team":"T68168MUP","attachments":[{"service_name":"JuliaLang","title":"Datastructure for two-way map","title_link":"https://discourse.julialang.org/t/datastructure-for-two-way-map/52735/6","text":"If you’re looking for a bijection, look no further: Example: julia&gt; using Bijections julia&gt; d = Dict(\"A\" =&gt; \"F\", \"D\" =&gt; \"G\", \"B\" =&gt; \"B\") Dict{String,String} with 3 entries: \"B\" =&gt; \"B\" \"A\" =&gt; \"F\" \"D\" =&gt; \"G\" julia&gt; b = Bijection(d) Bijection{String,String} (with 3 pairs) julia&gt; b[\"A\"] \"F\" julia&gt; b(\"G\") \"D\"","fallback":"JuliaLang: Datastructure for two-way map","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","ts":1609698474,"from_url":"https://discourse.julialang.org/t/datastructure-for-two-way-map/52735/6","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/datastructure-for-two-way-map/52735/6"}],"blocks":[{"type":"rich_text","block_id":"JP8h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, Michiel for thinking along. I was still doubting, but indeed it's probably not possible with MvNormal. I've asked about it "},{"type":"link","url":"https://discourse.julialang.org/t/datastructure-for-two-way-map/52735/6","text":"here"},{"type":"text","text":", and they told me to use Bijectors or CategoricalArrays. I've had succes with CategoricalArrays in other circumstances, but not yet with Turing. I gonna experiment a bit more with it"}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX","reactions":[{"name":"thumbsup_all","users":["U01C2AJ9F63"],"count":1}]},{"client_msg_id":"26d59f08-bee5-4fb1-9016-32a38ddf2e5d","type":"message","text":"If you manually define <https://github.com/JuliaData/CategoricalArrays.jl/pull/329|these> specializations, then you can pass CategoricalArrays to Turing, say `x = CategoricalArray([\"a\", \"b\"])`. I hope they merge it into CategoricalArrays. After that, MCMCChains still shows `a[1]` , which can be fixed via\n```function fix_categorical_names(chns, v::CategoricalArray, prefix)\n    kwargs = [\"$prefix[$(levelcode(e))]\" =&gt; string(e) for e in v]\n    MCMCChains.replacenames(chns, kwargs...)\nend```","user":"U01BTNDCUBX","ts":"1613839065.008600","team":"T68168MUP","edited":{"user":"U01BTNDCUBX","ts":"1613995633.000000"},"blocks":[{"type":"rich_text","block_id":"THY5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you manually define "},{"type":"link","url":"https://github.com/JuliaData/CategoricalArrays.jl/pull/329","text":"these"},{"type":"text","text":" specializations, then you can pass CategoricalArrays to Turing, say "},{"type":"text","text":"x = CategoricalArray([\"a\", \"b\"])","style":{"code":true}},{"type":"text","text":". I hope they merge it into CategoricalArrays. After that, MCMCChains still shows "},{"type":"text","text":"a[1]","style":{"code":true}},{"type":"text","text":" , which can be fixed via\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function fix_categorical_names(chns, v::CategoricalArray, prefix)\n    kwargs = [\"$prefix[$(levelcode(e))]\" => string(e) for e in v]\n    MCMCChains.replacenames(chns, kwargs...)\nend"}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"},{"client_msg_id":"64a15a98-b6c9-408b-8cfa-257d0a4f1eab","type":"message","text":"For clarity: by manually defining, I mean import those methods from base explicitly and add the specializations before you call Turing. Then, Turing will use the CategoricalArrays like they were normal integer arrays.","user":"U01BTNDCUBX","ts":"1613839285.008800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hu7QR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For clarity: by manually defining, I mean import those methods from base explicitly and add the specializations before you call Turing. Then, Turing will use the CategoricalArrays like they were normal integer arrays."}]}]}],"thread_ts":"1613746603.158900","parent_user_id":"U01BTNDCUBX"}]