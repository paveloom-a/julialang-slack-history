[{"client_msg_id":"15c166f2-e967-46bb-990f-fc766cfe9570","type":"message","text":"Hi,\n\n I’m trying to get von Mises distributions to work with Turing and would like some advise on how best to proceed. I’ve got a simple FowardDiff implementation of SpecialFunctions besselix to enable HMC/NUTS to work with the distribution, but I’ve now got a more fundamental problem with the definition in Distributions.jl.\n\n If I test a distribution with a low κ (i.e. large variance) almost all the test proposals fail the isinfinite check. Looking through the code, the problem appears to be the definition of the range of the von Mises function:\n\nWith low κ the observation values (y) cover the whole range from -π to π, so when a test point has a non zero mean (μ) there’s always some observations where |y-μ|&gt;π. This violates the definition given in Distributions.jl\n\n`@distr_support VonMises d.μ - π d.μ + π`\n\nIf I remove the value check in the Distributions.jl logpdf definition, sampling works well. And, at least for my use case, this is perfectly valid definition. von Mises is then a continuous, repeating, distribution, and any limitations on the range of μ are defined in the prior.\n\nI’ve been trying to understand why Distributions.jl has this range definition, but haven’t been able to find much. It was introduced in #273 with this <https://github.com/JuliaStats/Distributions.jl/issues/273#issuecomment-61982908|comment> but without further discussion, or explanation in the quoted source (wikipedia).\n\nSo, does anyone know why von Mises has this range? And what would be the best way to get it working with Turing? A fix for Distributions.jl or an import of the logpdf function within Turing?\n\nThanks.","user":"U01JL6RGKU7","ts":"1612784378.068100","team":"T68168MUP","edited":{"user":"U01JL6RGKU7","ts":"1612784870.000000"},"blocks":[{"type":"rich_text","block_id":"ZG5Py","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi,\n\n I’m trying to get von Mises distributions to work with Turing and would like some advise on how best to proceed. I’ve got a simple FowardDiff implementation of SpecialFunctions besselix to enable HMC/NUTS to work with the distribution, but I’ve now got a more fundamental problem with the definition in Distributions.jl.\n\n If I test a distribution with a low κ (i.e. large variance) almost all the test proposals fail the isinfinite check. Looking through the code, the problem appears to be the definition of the range of the von Mises function:\n\nWith low κ the observation values (y) cover the whole range from -π to π, so when a test point has a non zero mean (μ) there’s always some observations where |y-μ|>π. This violates the definition given in Distributions.jl\n\n"},{"type":"text","text":"@distr_support VonMises d.μ - π d.μ + π","style":{"code":true}},{"type":"text","text":"\n\nIf I remove the value check in the Distributions.jl logpdf definition, sampling works well. And, at least for my use case, this is perfectly valid definition. von Mises is then a continuous, repeating, distribution, and any limitations on the range of μ are defined in the prior.\n\nI’ve been trying to understand why Distributions.jl has this range definition, but haven’t been able to find much. It was introduced in #273 with this "},{"type":"link","url":"https://github.com/JuliaStats/Distributions.jl/issues/273#issuecomment-61982908","text":"comment"},{"type":"text","text":" but without further discussion, or explanation in the quoted source (wikipedia).\n\nSo, does anyone know why von Mises has this range? And what would be the best way to get it working with Turing? A fix for Distributions.jl or an import of the logpdf function within Turing?\n\nThanks."}]}]}],"thread_ts":"1612784378.068100","reply_count":11,"reply_users_count":5,"latest_reply":"1612889379.077000","reply_users":["UC0SY9JFP","U01H36BUDJB","U01JL6RGKU7","UHDQQ4GN6","UCRDHV7PB"],"subscribed":false},{"client_msg_id":"8ae31e84-ed37-43a2-b1d9-1d14c8ad2d60","type":"message","text":"Yeah, that’s indeed strange. Should the von Mises not have support everywhere as it’s 2π periodic. Looks to me as if they “fixed” the bug by adding a bug. :thinking_face: Strange.","user":"UC0SY9JFP","ts":"1612786123.068300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vc5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, that’s indeed strange. Should the von Mises not have support everywhere as it’s 2π periodic. Looks to me as if they “fixed” the bug by adding a bug. "},{"type":"emoji","name":"thinking_face"},{"type":"text","text":" Strange."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"f3f568e0-35c6-4436-b390-96422c92e438","type":"message","text":"Yeah this is just wrong. You should open an issue. I can't read the one you linked to, unfortunately, because it appears GitHub is having server issues.","user":"U01H36BUDJB","ts":"1612789525.068500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"op9EO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah this is just wrong. You should open an issue. I can't read the one you linked to, unfortunately, because it appears GitHub is having server issues."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"dfcf44d4-4992-4be5-b652-aca22e80b2a2","type":"message","text":"Thanks for the info. I now see that the range checks on pdf and logpdf were added in <https://github.com/JuliaStats/Distributions.jl/pull/965|#965> as part of a generic fix for several distributions, and so weren’t really considering the circular nature of von Mises. I’ll open an issue and make a pull request to revert the change.","user":"U01JL6RGKU7","ts":"1612790330.068700","team":"T68168MUP","edited":{"user":"U01JL6RGKU7","ts":"1612798335.000000"},"blocks":[{"type":"rich_text","block_id":"iD0o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the info. I now see that the range checks on pdf and logpdf were added in "},{"type":"link","url":"https://github.com/JuliaStats/Distributions.jl/pull/965","text":"#965"},{"type":"text","text":" as part of a generic fix for several distributions, and so weren’t really considering the circular nature of von Mises. I’ll open an issue and make a pull request to revert the change."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"type":"message","subtype":"thread_broadcast","text":"Another issue with circular distributions parameterized by an angle with NUTS is that you either are supported on the entire real line, in which case the distribution has infinite modes (and if you can transition between nodes in NUTS, then this will cause poor adaptation), or you are supported only on the the range [0, pi], in which case you could bifurcate a single mode and only explore one of them. The same is true whether we're talking about the random variable or the mean parameter of von Mises. The way Stan handles this is to internally represent circular variables in terms of two normally distributed cartesian coordinates x and y such that theta = atan(y, x). theta is then uniformly distributed on the circle. To apply a von Mises distribution, to theta, you'd want to increment the logpdf manually. Does Turing give us access to this? In brief something like\n```# equivalent to `μ ~ UniformOnCircle(); θ ~ VonMises(μ)` if we had such a thing\n@model function vMmodel(θ)\n    μx ~ Normal()\n    μy ~ Normal()\n    μ = atan(μy, μx)\n    lp += logpdf(VonMises(μ), θ) # is there a syntax for this?\nend```\n","user":"UHDQQ4GN6","ts":"1612825842.070100","thread_ts":"1612784378.068100","root":{"client_msg_id":"15c166f2-e967-46bb-990f-fc766cfe9570","type":"message","text":"Hi,\n\n I’m trying to get von Mises distributions to work with Turing and would like some advise on how best to proceed. I’ve got a simple FowardDiff implementation of SpecialFunctions besselix to enable HMC/NUTS to work with the distribution, but I’ve now got a more fundamental problem with the definition in Distributions.jl.\n\n If I test a distribution with a low κ (i.e. large variance) almost all the test proposals fail the isinfinite check. Looking through the code, the problem appears to be the definition of the range of the von Mises function:\n\nWith low κ the observation values (y) cover the whole range from -π to π, so when a test point has a non zero mean (μ) there’s always some observations where |y-μ|&gt;π. This violates the definition given in Distributions.jl\n\n`@distr_support VonMises d.μ - π d.μ + π`\n\nIf I remove the value check in the Distributions.jl logpdf definition, sampling works well. And, at least for my use case, this is perfectly valid definition. von Mises is then a continuous, repeating, distribution, and any limitations on the range of μ are defined in the prior.\n\nI’ve been trying to understand why Distributions.jl has this range definition, but haven’t been able to find much. It was introduced in #273 with this <https://github.com/JuliaStats/Distributions.jl/issues/273#issuecomment-61982908|comment> but without further discussion, or explanation in the quoted source (wikipedia).\n\nSo, does anyone know why von Mises has this range? And what would be the best way to get it working with Turing? A fix for Distributions.jl or an import of the logpdf function within Turing?\n\nThanks.","user":"U01JL6RGKU7","ts":"1612784378.068100","team":"T68168MUP","edited":{"user":"U01JL6RGKU7","ts":"1612784870.000000"},"blocks":[{"type":"rich_text","block_id":"ZG5Py","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi,\n\n I’m trying to get von Mises distributions to work with Turing and would like some advise on how best to proceed. I’ve got a simple FowardDiff implementation of SpecialFunctions besselix to enable HMC/NUTS to work with the distribution, but I’ve now got a more fundamental problem with the definition in Distributions.jl.\n\n If I test a distribution with a low κ (i.e. large variance) almost all the test proposals fail the isinfinite check. Looking through the code, the problem appears to be the definition of the range of the von Mises function:\n\nWith low κ the observation values (y) cover the whole range from -π to π, so when a test point has a non zero mean (μ) there’s always some observations where |y-μ|>π. This violates the definition given in Distributions.jl\n\n"},{"type":"text","text":"@distr_support VonMises d.μ - π d.μ + π","style":{"code":true}},{"type":"text","text":"\n\nIf I remove the value check in the Distributions.jl logpdf definition, sampling works well. And, at least for my use case, this is perfectly valid definition. von Mises is then a continuous, repeating, distribution, and any limitations on the range of μ are defined in the prior.\n\nI’ve been trying to understand why Distributions.jl has this range definition, but haven’t been able to find much. It was introduced in #273 with this "},{"type":"link","url":"https://github.com/JuliaStats/Distributions.jl/issues/273#issuecomment-61982908","text":"comment"},{"type":"text","text":" but without further discussion, or explanation in the quoted source (wikipedia).\n\nSo, does anyone know why von Mises has this range? And what would be the best way to get it working with Turing? A fix for Distributions.jl or an import of the logpdf function within Turing?\n\nThanks."}]}]}],"thread_ts":"1612784378.068100","reply_count":11,"reply_users_count":5,"latest_reply":"1612889379.077000","reply_users":["UC0SY9JFP","U01H36BUDJB","U01JL6RGKU7","UHDQQ4GN6","UCRDHV7PB"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"sjC9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Another issue with circular distributions parameterized by an angle with NUTS is that you either are supported on the entire real line, in which case the distribution has infinite modes (and if you can transition between nodes in NUTS, then this will cause poor adaptation), or you are supported only on the the range [0, pi], in which case you could bifurcate a single mode and only explore one of them. The same is true whether we're talking about the random variable or the mean parameter of von Mises. The way Stan handles this is to internally represent circular variables in terms of two normally distributed cartesian coordinates x and y such that theta = atan(y, x). theta is then uniformly distributed on the circle. To apply a von Mises distribution, to theta, you'd want to increment the logpdf manually. Does Turing give us access to this? In brief something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"# equivalent to `μ ~ UniformOnCircle(); θ ~ VonMises(μ)` if we had such a thing\n@model function vMmodel(θ)\n    μx ~ Normal()\n    μy ~ Normal()\n    μ = atan(μy, μx)\n    lp += logpdf(VonMises(μ), θ) # is there a syntax for this?\nend"}]},{"type":"rich_text_section","elements":[]}]}],"client_msg_id":"eaebf69d-e77b-4b42-9a18-927892bb3470"},{"client_msg_id":"1A9E84E0-101C-4AF6-B2F0-0CF651E8ED30","type":"message","text":"That’s a clever idea. <@UCRDHV7PB>, that looks like a useful transformation.\n\nYou can increase the log joint using: `Turing.@addlogprob! logpdf(VonMises(m), theta)`","user":"UC0SY9JFP","ts":"1612852618.074300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aNTcu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s a clever idea. "},{"type":"user","user_id":"UCRDHV7PB"},{"type":"text","text":", that looks like a useful transformation.\n\nYou can increase the log joint using: "},{"type":"text","text":"Turing.@addlogprob! logpdf(VonMises(m), theta)","style":{"code":true}}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7","reactions":[{"name":"+1","users":["UHDQQ4GN6"],"count":1}]},{"client_msg_id":"249b555a-ae28-4dd5-8248-daad0b0c7141","type":"message","text":"Looks like a cool feature to have! <@UHDQQ4GN6> Would you like to create an issue / PR for it?","user":"UCRDHV7PB","ts":"1612887845.075900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tzNC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Looks like a cool feature to have! "},{"type":"user","user_id":"UHDQQ4GN6"},{"type":"text","text":" Would you like to create an issue / PR for it?"}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"de8529e8-f02d-45aa-9366-2f4b2c1033ca","type":"message","text":"I opened an issue on Bijectors a while back, but it doesn't seem like the right place for it (the transform isn't bijective): <https://github.com/TuringLang/Bijectors.jl/issues/58>. Is there a better place to open an issue?","user":"UHDQQ4GN6","ts":"1612887984.076100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lN5JM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I opened an issue on Bijectors a while back, but it doesn't seem like the right place for it (the transform isn't bijective): "},{"type":"link","url":"https://github.com/TuringLang/Bijectors.jl/issues/58"},{"type":"text","text":". Is there a better place to open an issue?"}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"da0a105a-0a6e-4b15-9731-811a5956290f","type":"message","text":"Perhaps `Turing.jl/src/contrib/` for now? It could also live in `Distributions.jl` if possible.","user":"UCRDHV7PB","ts":"1612888121.076300","team":"T68168MUP","edited":{"user":"UCRDHV7PB","ts":"1612888138.000000"},"blocks":[{"type":"rich_text","block_id":"utZ8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Perhaps "},{"type":"text","text":"Turing.jl/src/contrib/","style":{"code":true}},{"type":"text","text":" for now? It could also live in "},{"type":"text","text":"Distributions.jl","style":{"code":true}},{"type":"text","text":" if possible."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"2cc33ce4-c728-4d95-823c-39242ddac7d9","type":"message","text":"&gt;  the transform isn't bijective\nFYI, there are other non-bijective transforms in `Bijectors` , e.g. the one for Dirichlet distribution.","user":"UCRDHV7PB","ts":"1612888211.076600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e3A","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" the transform isn't bijective"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"FYI, there are other non-bijective transforms in "},{"type":"text","text":"Bijectors","style":{"code":true}},{"type":"text","text":" , e.g. the one for Dirichlet distribution."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"ba52c4e8-7bfe-4101-95e6-6c866ed6803a","type":"message","text":"IIRC, the simplex bijector has n-1 degrees of freedom and produces a size n vector where the nth term can be uniquely determined by the first n-1. That map is still bijective map (we can write its inverse), it's just that the output is embedded in a space of one dimension higher. What I'm proposing is a map from a 2-dimensional space to a one-dimensional space, which is not invertible. Note that `x` and `y` are not constrained to be on the circle. We could \"pretend\" the map is invertible by mapping `x -&gt; reverse(sincos(x))`. We'd want to be fairly thorough though in testing that e.g. NUTS with metric adaptation works well with this invertibility being broken.","user":"UHDQQ4GN6","ts":"1612889010.076800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j4h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"IIRC, the simplex bijector has n-1 degrees of freedom and produces a size n vector where the nth term can be uniquely determined by the first n-1. That map is still bijective map (we can write its inverse), it's just that the output is embedded in a space of one dimension higher. What I'm proposing is a map from a 2-dimensional space to a one-dimensional space, which is not invertible. Note that "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" are not constrained to be on the circle. We could \"pretend\" the map is invertible by mapping "},{"type":"text","text":"x -> reverse(sincos(x))","style":{"code":true}},{"type":"text","text":". We'd want to be fairly thorough though in testing that e.g. NUTS with metric adaptation works well with this invertibility being broken."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7"},{"client_msg_id":"58212539-1d76-49be-82bf-e7e1a8e08239","type":"message","text":"Mmm, no, I'm mis-remembering. Anyways, I'll open a PR with a \"bijector\" for `VonMises` in Bijectors, and we can discuss it further there.","user":"UHDQQ4GN6","ts":"1612889379.077000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rrxh2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Mmm, no, I'm mis-remembering. Anyways, I'll open a PR with a \"bijector\" for "},{"type":"text","text":"VonMises","style":{"code":true}},{"type":"text","text":" in Bijectors, and we can discuss it further there."}]}]}],"thread_ts":"1612784378.068100","parent_user_id":"U01JL6RGKU7","reactions":[{"name":"+1","users":["UCRDHV7PB"],"count":1}]}]