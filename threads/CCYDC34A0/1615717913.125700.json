[{"client_msg_id":"49b42c15-4ee7-46aa-a23b-0aefe04cbe0d","type":"message","text":"Hello Turing community, how do I compute predictions for `Turing.addlogprob!` ? MWE\n\n```@model function gdemo(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        y[i] ~ Normal(mu,1)\n    end\nend\n\n@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemo(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\n\ntestModel = gdemo(yTest)\npredictions = predict(testModel, chn)\n\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia&gt; ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing).....................```","user":"U011PPW7K53","ts":"1615717913.125700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Ec+Q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hello Turing community, how do I compute predictions for "},{"type":"text","text":"Turing.addlogprob!","style":{"code":true}},{"type":"text","text":" ? MWE\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function gdemo(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        y[i] ~ Normal(mu,1)\n    end\nend\n\n@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemo(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\n\ntestModel = gdemo(yTest)\npredictions = predict(testModel, chn)\n\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia> ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing)....................."}]}]}],"thread_ts":"1615717913.125700","reply_count":6,"reply_users_count":2,"latest_reply":"1616057997.023000","reply_users":["UHDNY2YMA","U011PPW7K53"],"subscribed":false},{"client_msg_id":"1113794a-372b-4d19-aa53-f3b946b2e6a8","type":"message","text":"The purpose of `@addlogprob!` is to allow the user to override Turing's detection of what is and what is not a observation; it will just assume that the user knows what they're doing and execute everything on the RHS and expecting it to return a number.\n\nSo you need to manually check if it's missing or not, e.g. `ismissing(y[i]) &amp;&amp; Turing.@addlogprob! ...`","user":"UHDNY2YMA","ts":"1615721289.125800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zcr/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The purpose of "},{"type":"text","text":"@addlogprob!","style":{"code":true}},{"type":"text","text":" is to allow the user to override Turing's detection of what is and what is not a observation; it will just assume that the user knows what they're doing and execute everything on the RHS and expecting it to return a number.\n\nSo you need to manually check if it's missing or not, e.g. "},{"type":"text","text":"ismissing(y[i]) && Turing.@addlogprob! ...","style":{"code":true}}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"49f056b4-ffe4-42c2-8355-6aea2f2da26c","type":"message","text":"Thank you <@UHDNY2YMA> for your help. Unfortunately it still does not work for me to compute predictions with `ismissing(y[i]) &amp;&amp; Turing.@addlogprob! ...`\n\n```@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        ismissing(y[i]) &amp;&amp; Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemoFail(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia&gt; ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing).....................```","user":"U011PPW7K53","ts":"1615812085.142900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DJrLo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you "},{"type":"user","user_id":"UHDNY2YMA"},{"type":"text","text":" for your help. Unfortunately it still does not work for me to compute predictions with "},{"type":"text","text":"ismissing(y[i]) && Turing.@addlogprob! ...","style":{"code":true}},{"type":"text","text":"\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        ismissing(y[i]) && Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemoFail(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia> ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing)....................."}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"b9220763-cf02-4575-af76-5b884415024b","type":"message","text":"Oh sorry, haha, it should be `||`. Julia first checks the LHS of the or-statement, if it's `true` then Julia immediately knows that the entire or-statement is true and thus don't have to execute the code on the RHS of the or-statement. If it's `false`, it needs to check RHS to see if entire statement is false or true.\n\nBut I realize you also need to sample `y`, which you're not doing now, right? There's no way for Turing to know what you want to sample `y` from. In the case where you want to do both observe and predict on a variable, then you *need* the ability to both compute `logpdf` and randomly sample from the distribution whose `logpdf` you're computing, i.e. you might as well just implement a `Distribution` from Distributions.jl","user":"UHDNY2YMA","ts":"1615812356.143100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Qo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh sorry, haha, it should be "},{"type":"text","text":"||","style":{"code":true}},{"type":"text","text":". Julia first checks the LHS of the or-statement, if it's "},{"type":"text","text":"true","style":{"code":true}},{"type":"text","text":" then Julia immediately knows that the entire or-statement is true and thus don't have to execute the code on the RHS of the or-statement. If it's "},{"type":"text","text":"false","style":{"code":true}},{"type":"text","text":", it needs to check RHS to see if entire statement is false or true.\n\nBut I realize you also need to sample "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":", which you're not doing now, right? There's no way for Turing to know what you want to sample "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" from. In the case where you want to do both observe and predict on a variable, then you "},{"type":"text","text":"need","style":{"bold":true}},{"type":"text","text":" the ability to both compute "},{"type":"text","text":"logpdf","style":{"code":true}},{"type":"text","text":" and randomly sample from the distribution whose "},{"type":"text","text":"logpdf","style":{"code":true}},{"type":"text","text":" you're computing, i.e. you might as well just implement a "},{"type":"text","text":"Distribution","style":{"code":true}},{"type":"text","text":" from Distributions.jl"}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"6af0ce88-6980-4243-9348-8ecd7e98f854","type":"message","text":"You COULD, but I don't recommend, do\n```if ismissing(y[i])\n    y[i] = rand(Normal(mu, 1))\nelse\n    Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\nend```\nBut I can't think of a scenario where you'd want to do this instead of just do `y[i] ~ Normal(mu, 1)` (or implement a custom distribution if necessary)","user":"UHDNY2YMA","ts":"1615812443.143300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qyWa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You COULD, but I don't recommend, do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"if ismissing(y[i])\n    y[i] = rand(Normal(mu, 1))\nelse\n    Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"But I can't think of a scenario where you'd want to do this instead of just do "},{"type":"text","text":"y[i] ~ Normal(mu, 1)","style":{"code":true}},{"type":"text","text":" (or implement a custom distribution if necessary)"}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"92806ed7-42ba-4f5d-8c4b-beefa26baa7b","type":"message","text":"Thank you <@UHDNY2YMA> for your explanations. My question wasn't clear sorry for the confusion. Yeah my full question is that I want to do *both observe and predict on a variable*. It seems that implementing a *custom distributions is the best solution*. I will read through the document later <https://turing.ml/dev/docs/using-turing/advanced#how-to-define-a-customized-distribution>\n\nI thought `Turing.@addlogprob!` is the solution for this. I am confused now. Then what are the use cases for `Turing.addlogprob!`?","user":"U011PPW7K53","ts":"1615983674.011200","team":"T68168MUP","edited":{"user":"U011PPW7K53","ts":"1615983704.000000"},"blocks":[{"type":"rich_text","block_id":"tkp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you "},{"type":"user","user_id":"UHDNY2YMA"},{"type":"text","text":" for your explanations. My question wasn't clear sorry for the confusion. Yeah my full question is that I want to do "},{"type":"text","text":"both observe and predict on a variable","style":{"bold":true}},{"type":"text","text":". It seems that implementing a "},{"type":"text","text":"custom distributions is the best solution","style":{"bold":true}},{"type":"text","text":". I will read through the document later "},{"type":"link","url":"https://turing.ml/dev/docs/using-turing/advanced#how-to-define-a-customized-distribution"},{"type":"text","text":"\n\nI thought "},{"type":"text","text":"Turing.@addlogprob!","style":{"code":true}},{"type":"text","text":" is the solution for this. I am confused now. Then what are the use cases for "},{"type":"text","text":"Turing.addlogprob!","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"32f69853-19ca-451b-ac7f-591add085e98","type":"message","text":"`Turing.@addlogprob!` doesn't do anything a custom distribution couldn't do, but it makes it convenient to add any arbitrary terms to the logjoint. One particular usage is enforcing certain constraints, e.g.\n```if notvalid(theta)\n    Turing.@addlogprob! -Inf\n    return\nend```\nThis will make the sampler reject the sample due to having `-Inf` logjoint and return immediately. This of course makes sampling harder, and ideally such constraints ought to be enforced in the distributions themselves, but there are cases where this is not possible or just infeasible.","user":"UHDNY2YMA","ts":"1616057997.023000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nT43B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Turing.@addlogprob!","style":{"code":true}},{"type":"text","text":" doesn't do anything a custom distribution couldn't do, but it makes it convenient to add any arbitrary terms to the logjoint. One particular usage is enforcing certain constraints, e.g.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"if notvalid(theta)\n    Turing.@addlogprob! -Inf\n    return\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"This will make the sampler reject the sample due to having "},{"type":"text","text":"-Inf","style":{"code":true}},{"type":"text","text":" logjoint and return immediately. This of course makes sampling harder, and ideally such constraints ought to be enforced in the distributions themselves, but there are cases where this is not possible or just infeasible."}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"}]