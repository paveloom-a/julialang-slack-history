[{"client_msg_id":"49b42c15-4ee7-46aa-a23b-0aefe04cbe0d","type":"message","text":"Hello Turing community, how do I compute predictions for `Turing.addlogprob!` ? MWE\n\n```@model function gdemo(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        y[i] ~ Normal(mu,1)\n    end\nend\n\n@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemo(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\n\ntestModel = gdemo(yTest)\npredictions = predict(testModel, chn)\n\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia&gt; ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing).....................```","user":"U011PPW7K53","ts":"1615717913.125700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Ec+Q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hello Turing community, how do I compute predictions for "},{"type":"text","text":"Turing.addlogprob!","style":{"code":true}},{"type":"text","text":" ? MWE\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function gdemo(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        y[i] ~ Normal(mu,1)\n    end\nend\n\n@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemo(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\n\ntestModel = gdemo(yTest)\npredictions = predict(testModel, chn)\n\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia> ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing)....................."}]}]}],"thread_ts":"1615717913.125700","reply_count":4,"reply_users_count":2,"latest_reply":"1615812443.143300","reply_users":["UHDNY2YMA","U011PPW7K53"],"subscribed":false},{"client_msg_id":"1113794a-372b-4d19-aa53-f3b946b2e6a8","type":"message","text":"The purpose of `@addlogprob!` is to allow the user to override Turing's detection of what is and what is not a observation; it will just assume that the user knows what they're doing and execute everything on the RHS and expecting it to return a number.\n\nSo you need to manually check if it's missing or not, e.g. `ismissing(y[i]) &amp;&amp; Turing.@addlogprob! ...`","user":"UHDNY2YMA","ts":"1615721289.125800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zcr/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The purpose of "},{"type":"text","text":"@addlogprob!","style":{"code":true}},{"type":"text","text":" is to allow the user to override Turing's detection of what is and what is not a observation; it will just assume that the user knows what they're doing and execute everything on the RHS and expecting it to return a number.\n\nSo you need to manually check if it's missing or not, e.g. "},{"type":"text","text":"ismissing(y[i]) && Turing.@addlogprob! ...","style":{"code":true}}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"49f056b4-ffe4-42c2-8355-6aea2f2da26c","type":"message","text":"Thank you <@UHDNY2YMA> for your help. Unfortunately it still does not work for me to compute predictions with `ismissing(y[i]) &amp;&amp; Turing.@addlogprob! ...`\n\n```@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        ismissing(y[i]) &amp;&amp; Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemoFail(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia&gt; ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing).....................```","user":"U011PPW7K53","ts":"1615812085.142900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DJrLo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you "},{"type":"user","user_id":"UHDNY2YMA"},{"type":"text","text":" for your help. Unfortunately it still does not work for me to compute predictions with "},{"type":"text","text":"ismissing(y[i]) && Turing.@addlogprob! ...","style":{"code":true}},{"type":"text","text":"\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@model function gdemoFail(y)\n    mu ~ Normal(0,2)\n    for i in eachindex(y)\n        ismissing(y[i]) && Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\n    end\nend\n\ny = randn(50)\nchn = sample(gdemoFail(y), NUTS(), 100)\nyTest = Vector{Union{Missing,Float64}}(undef, length(y))\ntestModelFail = gdemoFail(yTest)\npredictionsFail = predict(testModelFail, chn)\njulia> ERROR: MethodError: no method matching logpdf(::Normal{Float64}, ::Missing)....................."}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"b9220763-cf02-4575-af76-5b884415024b","type":"message","text":"Oh sorry, haha, it should be `||`. Julia first checks the LHS of the or-statement, if it's `true` then Julia immediately knows that the entire or-statement is true and thus don't have to execute the code on the RHS of the or-statement. If it's `false`, it needs to check RHS to see if entire statement is false or true.\n\nBut I realize you also need to sample `y`, which you're not doing now, right? There's no way for Turing to know what you want to sample `y` from. In the case where you want to do both observe and predict on a variable, then you *need* the ability to both compute `logpdf` and randomly sample from the distribution whose `logpdf` you're computing, i.e. you might as well just implement a `Distribution` from Distributions.jl","user":"UHDNY2YMA","ts":"1615812356.143100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Qo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh sorry, haha, it should be "},{"type":"text","text":"||","style":{"code":true}},{"type":"text","text":". Julia first checks the LHS of the or-statement, if it's "},{"type":"text","text":"true","style":{"code":true}},{"type":"text","text":" then Julia immediately knows that the entire or-statement is true and thus don't have to execute the code on the RHS of the or-statement. If it's "},{"type":"text","text":"false","style":{"code":true}},{"type":"text","text":", it needs to check RHS to see if entire statement is false or true.\n\nBut I realize you also need to sample "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":", which you're not doing now, right? There's no way for Turing to know what you want to sample "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" from. In the case where you want to do both observe and predict on a variable, then you "},{"type":"text","text":"need","style":{"bold":true}},{"type":"text","text":" the ability to both compute "},{"type":"text","text":"logpdf","style":{"code":true}},{"type":"text","text":" and randomly sample from the distribution whose "},{"type":"text","text":"logpdf","style":{"code":true}},{"type":"text","text":" you're computing, i.e. you might as well just implement a "},{"type":"text","text":"Distribution","style":{"code":true}},{"type":"text","text":" from Distributions.jl"}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"},{"client_msg_id":"6af0ce88-6980-4243-9348-8ecd7e98f854","type":"message","text":"You COULD, but I don't recommend, do\n```if ismissing(y[i])\n    y[i] = rand(Normal(mu, 1))\nelse\n    Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\nend```\nBut I can't think of a scenario where you'd want to do this instead of just do `y[i] ~ Normal(mu, 1)` (or implement a custom distribution if necessary)","user":"UHDNY2YMA","ts":"1615812443.143300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qyWa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You COULD, but I don't recommend, do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"if ismissing(y[i])\n    y[i] = rand(Normal(mu, 1))\nelse\n    Turing.@addlogprob! logpdf(Normal(mu, 1), y[i])\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"But I can't think of a scenario where you'd want to do this instead of just do "},{"type":"text","text":"y[i] ~ Normal(mu, 1)","style":{"code":true}},{"type":"text","text":" (or implement a custom distribution if necessary)"}]}]}],"thread_ts":"1615717913.125700","parent_user_id":"U011PPW7K53"}]