[{"client_msg_id":"60daded1-4121-4a93-9298-44e570fcc69c","type":"message","text":"Whats if __name == '___main' equivalent for julia, can i stop slack from consuming those underscores_","user":"U01FTP75MBR","ts":"1614372624.010400","team":"T68168MUP","edited":{"user":"U01FTP75MBR","ts":"1614372654.000000"},"blocks":[{"type":"rich_text","block_id":"qza","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Whats if __name == '_"},{"type":"text","text":"_main' equivalent for julia, can i stop slack from consuming those underscores","style":{"italic":true}}]}]}],"thread_ts":"1614372624.010400","reply_count":9,"reply_users_count":4,"latest_reply":"1614587633.012700","reply_users":["U7HAYKY9X","U01FTP75MBR","UN97XTLCV","UPSSPPBFV"],"subscribed":false},{"client_msg_id":"8ba28cb5-3cad-454d-a7b3-2948fa050a83","type":"message","text":"There are two: \"if isinteractive ()\" and \"if abspath (PROGRAM_FILE) == @___FILE___","user":"U7HAYKY9X","ts":"1614374042.010900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zh19","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are two: \"if isinteractive ()\" and \"if abspath (PROGRAM_FILE) == @"},{"type":"text","text":"__FILE__","style":{"italic":true}}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"bb809ae0-df05-4ff8-9122-5f21da9ed388","type":"message","text":"Where in manual is it mentioned","user":"U01FTP75MBR","ts":"1614376386.011100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f4=9G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Where in manual is it mentioned"}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"b6f52e50-e8c4-46c5-8574-033de1a3afa0","type":"message","text":"since the julia files are declarative, I’ve seen people write stuff like this:\n```function main()\n    # main method\nend\n\n# at the bottom of your file\nmain()```\nsimple and clear","user":"UN97XTLCV","ts":"1614376425.011300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5XD8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"since the julia files are declarative, I’ve seen people write stuff like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function main()\n    # main method\nend\n\n# at the bottom of your file\nmain()"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"simple and clear"}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"e2fe2311-34f9-4ef5-bed6-3426016a2424","type":"message","text":"Assuming main() is just another function not special same thing can be done in python as well, makes me wonder do we even need name=='main' thing","user":"U01FTP75MBR","ts":"1614379247.011500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2ZB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Assuming main() is just another function not special same thing can be done in python as well, makes me wonder do we even need name=='main' thing"}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"d1dafe36-c54f-4a62-8605-6d29f395aa16","type":"message","text":"What do u mean declarative, isnt python that as well <@UN97XTLCV>","user":"U01FTP75MBR","ts":"1614379292.011700","team":"T68168MUP","edited":{"user":"U01FTP75MBR","ts":"1614379369.000000"},"blocks":[{"type":"rich_text","block_id":"+EaMq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do u mean declarative, isnt python that as well "},{"type":"user","user_id":"UN97XTLCV"}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"a3f9c871-786e-4e46-a28b-1b09ef9b865c","type":"message","text":"the file `file.jl` will have the exact same effect if you do\n```$ julia file.jl```\nor\n```julia&gt; include(\"file.jl\")```\n. The file will be parsed line by line, so if you just throw the function execution at the bottom of the file, it’ll be executed, no matter how you “read” the file. Basically Python has special rules for script execution vs. importing a file, but Julia doesn’t. Both are declarative.","user":"UN97XTLCV","ts":"1614379421.012000","team":"T68168MUP","edited":{"user":"UN97XTLCV","ts":"1614379438.000000"},"blocks":[{"type":"rich_text","block_id":"VOmub","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the file "},{"type":"text","text":"file.jl","style":{"code":true}},{"type":"text","text":" will have the exact same effect if you do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"$ julia file.jl"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"or\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> include(\"file.jl\")"}]},{"type":"rich_text_section","elements":[{"type":"text","text":". The file will be parsed line by line, so if you just throw the function execution at the bottom of the file, it’ll be executed, no matter how you “read” the file. Basically Python has special rules for script execution vs. importing a file, but Julia doesn’t. Both are declarative."}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"316de705-0089-4888-9035-11ba6eaefc1b","type":"message","text":"Usually, that Python idiom is used when you don't want to execute a block of code when importing","user":"U7HAYKY9X","ts":"1614413783.012300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+sOq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Usually, that Python idiom is used when you don't want to execute a block of code when importing"}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"d7bc6b8c-4b47-4c29-a9f7-832ac619e2c4","type":"message","text":"The Python idiom exists because Python's `import` keyword is actually rather dumb, and running `import module` simply _executes_ the file `module.py`. In fact, the only differences between running `import module` and `python module.py` (which can be written `python -m module`, emphasising the similarity) are:\n• Whatever function, global variable and class that gets defined when running the file using `import module` gets namespaced, and;\n• The special variable `__name__` has the value `\"module\"` when `module.py` is executed via `import module`, but `\"__main__\"` when executed via `python module.py`, which is what allows for the Python idiom.\nNow, because Julia has a notion of modules that is independent and orthogonal of files, `import` and `using` _do not_ behave like Python's `import`, i.e. they don't execute a file. Rather, they make the symbols created in an already defined module available in the current namespace (whether with or without prefix). That module is defined either by adding it as a package to your project using `Pkg.add()` (or `Pkg.dev()`), or as a local module using `module... end` in your code. Because of this, you usually won't need something like the Python idiom in Julia.","user":"UPSSPPBFV","ts":"1614585137.012500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PcLL+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The Python idiom exists because Python's "},{"type":"text","text":"import","style":{"code":true}},{"type":"text","text":" keyword is actually rather dumb, and running "},{"type":"text","text":"import module","style":{"code":true}},{"type":"text","text":" simply "},{"type":"text","text":"executes","style":{"italic":true}},{"type":"text","text":" the file "},{"type":"text","text":"module.py","style":{"code":true}},{"type":"text","text":". In fact, the only differences between running "},{"type":"text","text":"import module","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"python module.py","style":{"code":true}},{"type":"text","text":" (which can be written "},{"type":"text","text":"python -m module","style":{"code":true}},{"type":"text","text":", emphasising the similarity) are:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Whatever function, global variable and class that gets defined when running the file using "},{"type":"text","text":"import module","style":{"code":true}},{"type":"text","text":" gets namespaced, and;"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The special variable "},{"type":"text","text":"__name__","style":{"code":true}},{"type":"text","text":" has the value "},{"type":"text","text":"\"module\"","style":{"code":true}},{"type":"text","text":" when "},{"type":"text","text":"module.py","style":{"code":true}},{"type":"text","text":" is executed via "},{"type":"text","text":"import module","style":{"code":true}},{"type":"text","text":", but "},{"type":"text","text":"\"__main__\"","style":{"code":true}},{"type":"text","text":" when executed via "},{"type":"text","text":"python module.py","style":{"code":true}},{"type":"text","text":", which is what allows for the Python idiom."}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Now, because Julia has a notion of modules that is independent and orthogonal of files, "},{"type":"text","text":"import","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"using","style":{"code":true}},{"type":"text","text":" "},{"type":"text","text":"do not","style":{"italic":true}},{"type":"text","text":" behave like Python's "},{"type":"text","text":"import","style":{"code":true}},{"type":"text","text":", i.e. they don't execute a file. Rather, they make the symbols created in an already defined module available in the current namespace (whether with or without prefix). That module is defined either by adding it as a package to your project using "},{"type":"text","text":"Pkg.add()","style":{"code":true}},{"type":"text","text":" (or "},{"type":"text","text":"Pkg.dev()","style":{"code":true}},{"type":"text","text":"), or as a local module using "},{"type":"text","text":"module... end","style":{"code":true}},{"type":"text","text":" in your code. Because of this, you usually won't need something like the Python idiom in Julia."}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"},{"client_msg_id":"9c76e516-34d5-40a3-9522-7bf1a0433f06","type":"message","text":"Now, the only case where you would want something like the Python idiom in Julia is if you want `file.jl` to execute differently if you do `julia file.jl` than if you do `include(\"file.jl\")`. There are a few issues with this:\nFirst, the Python situation and the Julia situation do not map well. In Python, you only have two choices: executing a file as a script, or executing it as an `import`ed module. In Julia, because of the very common interactive workflow using the REPL, you want to distinguish three cases:\n• executing a file via the command line: `julia file.jl`;\n• executing a file in the Julia REPL: `julia&gt; include(\"file.jl\")`;\n• executing a file from within another file: `include(\"file.jl\")`.\nIf you really want to do things right, you have to consider all three cases, in which case a simply idiom like the Python idiom won't work.\nSecond, the situation typically only comes up if you built up your Julia project as if it was a Python project, i.e. with one module per file (i.e. put `module Module... end` in a file called `module.jl`, forcing you to load it in another file using `include(\"module.jl\"); import .Module`. The problem is that Julia isn't Python, and I'd argue that organising your Julia code like Python code is not necessarily the right way to do things.\nSo before you ask _what_ the Julia equivalent is for the `if __name__ == \"__main__\":` Python idiom, ask yourself whether you actually _need_ that idiom at all.","user":"UPSSPPBFV","ts":"1614587633.012700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"94sA3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Now, the only case where you would want something like the Python idiom in Julia is if you want "},{"type":"text","text":"file.jl","style":{"code":true}},{"type":"text","text":" to execute differently if you do "},{"type":"text","text":"julia file.jl","style":{"code":true}},{"type":"text","text":" than if you do "},{"type":"text","text":"include(\"file.jl\")","style":{"code":true}},{"type":"text","text":". There are a few issues with this:\nFirst, the Python situation and the Julia situation do not map well. In Python, you only have two choices: executing a file as a script, or executing it as an "},{"type":"text","text":"import","style":{"code":true}},{"type":"text","text":"ed module. In Julia, because of the very common interactive workflow using the REPL, you want to distinguish three cases:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"executing a file via the command line: "},{"type":"text","text":"julia file.jl","style":{"code":true}},{"type":"text","text":";"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"executing a file in the Julia REPL: "},{"type":"text","text":"julia> include(\"file.jl\")","style":{"code":true}},{"type":"text","text":";"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"executing a file from within another file: "},{"type":"text","text":"include(\"file.jl\")","style":{"code":true}},{"type":"text","text":"."}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"If you really want to do things right, you have to consider all three cases, in which case a simply idiom like the Python idiom won't work.\nSecond, the situation typically only comes up if you built up your Julia project as if it was a Python project, i.e. with one module per file (i.e. put "},{"type":"text","text":"module Module... end","style":{"code":true}},{"type":"text","text":" in a file called "},{"type":"text","text":"module.jl","style":{"code":true}},{"type":"text","text":", forcing you to load it in another file using "},{"type":"text","text":"include(\"module.jl\"); import .Module","style":{"code":true}},{"type":"text","text":". The problem is that Julia isn't Python, and I'd argue that organising your Julia code like Python code is not necessarily the right way to do things.\nSo before you ask "},{"type":"text","text":"what","style":{"italic":true}},{"type":"text","text":" the Julia equivalent is for the "},{"type":"text","text":"if __name__ == \"__main__\":","style":{"code":true}},{"type":"text","text":" Python idiom, ask yourself whether you actually "},{"type":"text","text":"need","style":{"italic":true}},{"type":"text","text":" that idiom at all."}]}]}],"thread_ts":"1614372624.010400","parent_user_id":"U01FTP75MBR"}]