[{"client_msg_id":"19cef7ec-aaf5-4d13-9515-ee8d89b8d38a","type":"message","text":"This is more of a curiosity, but I was wondering, how can Tullio.jl handle raise conditions when the LHS uses a nontrivial function of the indices? For example, I've noticed that one can do things like\n```@tullio C[i ÷ 2, k] += A[i, j] * B[j, k]```\nDoes Tullio have some smart way to multithread this, or does it just fall back to a sequential approach?","user":"U6BJ9E351","ts":"1613657824.027300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YOK1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is more of a curiosity, but I was wondering, how can Tullio.jl handle raise conditions when the LHS uses a nontrivial function of the indices? For example, I've noticed that one can do things like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@tullio C[i ÷ 2, k] += A[i, j] * B[j, k]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Does Tullio have some smart way to multithread this, or does it just fall back to a sequential approach?"}]}]}],"thread_ts":"1613657824.027300","reply_count":3,"reply_users_count":2,"latest_reply":"1613660141.027800","reply_users":["U6BJ9E351","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"ac16844e-7ce7-47be-b20f-3e8819d1a728","type":"message","text":"I guess \"where\" the nontrivial expression is doesn't really matter, because even if the nontrivial expression is only on the RHS, then computing the `rrule` for differentiation will generate a call with the nontrivial expression on the LHS","user":"U6BJ9E351","ts":"1613658104.027400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Bnv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess \"where\" the nontrivial expression is doesn't really matter, because even if the nontrivial expression is only on the RHS, then computing the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" for differentiation will generate a call with the nontrivial expression on the LHS"}]}]}],"thread_ts":"1613657824.027300","parent_user_id":"U6BJ9E351"},{"client_msg_id":"9bd26f70-4564-4bd6-87e0-d39ae29088a6","type":"message","text":"Oh I never thought to try this. It looks like it may not be safe, in fact. My check, perhaps not readable…\n```julia&gt; @macroexpand @tullio C[i ÷ 2, k] += A[i, j] * B[j, k] verbose=2 grad=false;\n│    quote\n│        local @inline(function 𝒜𝒸𝓉!(::Type, ℛ::AbstractArray{𝒯}, A, B, 𝒶𝓍k, 𝒶𝓍i, 𝒶𝓍j, :recycle: = nothing, :skull: = true) where 𝒯\n│                    @inbounds @fastmath(begin\n│                                for i = 𝒶𝓍i\n│                                    for k = 𝒶𝓍k\n│                                        𝒜𝒸𝒸 = ℛ[i ÷ 2, k]\n│                                        for j = 𝒶𝓍j\n│                                            𝒜𝒸𝒸 = 𝒜𝒸𝒸 + A[i, j] * B[j, k]\n│                                        end\n│                                        ℛ[i ÷ 2, k] = 𝒜𝒸𝒸\n│                                    end\n│                                end\n│                            end)\n│                end)\n└    end\n│    quote\n│        local 𝒶𝓍k = axes(C, 2)\n│        local 𝒶𝓍j = axes(A, 2)\n│        local 𝒶𝓍i = intersect(axes(C, 1) .* 2, axes(A, 1))\n│        begin\n│            (Tullio.threader)(𝒜𝒸𝓉!, (Tullio.storage_type)(C, A, B), C, tuple(A, B), tuple(𝒶𝓍k, 𝒶𝓍i), tuple(𝒶𝓍j), +, 262144, true)\n│            C\n│        end\n└    end```\nThe NB part of this is that `threader(𝒜𝒸𝓉!, ..., C, (A,B), (𝒶𝓍k, 𝒶𝓍i), (𝒶𝓍j,), +, ...)` groups `k` &amp; `i` as indices safe to thread over, and `j` not.","user":"UD0NS8PDF","ts":"1613660134.027600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0On2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh I never thought to try this. It looks like it may not be safe, in fact. My check, perhaps not readable…\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @macroexpand @tullio C[i ÷ 2, k] += A[i, j] * B[j, k] verbose=2 grad=false;\n│    quote\n│        local @inline(function 𝒜𝒸𝓉!(::Type, ℛ::AbstractArray{𝒯}, A, B, 𝒶𝓍k, 𝒶𝓍i, 𝒶𝓍j, :recycle: = nothing, :skull: = true) where 𝒯\n│                    @inbounds @fastmath(begin\n│                                for i = 𝒶𝓍i\n│                                    for k = 𝒶𝓍k\n│                                        𝒜𝒸𝒸 = ℛ[i ÷ 2, k]\n│                                        for j = 𝒶𝓍j\n│                                            𝒜𝒸𝒸 = 𝒜𝒸𝒸 + A[i, j] * B[j, k]\n│                                        end\n│                                        ℛ[i ÷ 2, k] = 𝒜𝒸𝒸\n│                                    end\n│                                end\n│                            end)\n│                end)\n└    end\n│    quote\n│        local 𝒶𝓍k = axes(C, 2)\n│        local 𝒶𝓍j = axes(A, 2)\n│        local 𝒶𝓍i = intersect(axes(C, 1) .* 2, axes(A, 1))\n│        begin\n│            (Tullio.threader)(𝒜𝒸𝓉!, (Tullio.storage_type)(C, A, B), C, tuple(A, B), tuple(𝒶𝓍k, 𝒶𝓍i), tuple(𝒶𝓍j), +, 262144, true)\n│            C\n│        end\n└    end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The NB part of this is that "},{"type":"text","text":"threader(𝒜𝒸𝓉!, ..., C, (A,B), (𝒶𝓍k, 𝒶𝓍i), (𝒶𝓍j,), +, ...)","style":{"code":true}},{"type":"text","text":" groups "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" & "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":" as indices safe to thread over, and "},{"type":"text","text":"j","style":{"code":true}},{"type":"text","text":" not."}]}]}],"thread_ts":"1613657824.027300","parent_user_id":"U6BJ9E351"},{"client_msg_id":"d0570901-3cbb-4bc2-86c4-572dcbc1dc35","type":"message","text":"The goal is to be safe by default, though. For example `@tullio C[I[i], k] += A[i, j] * B[j, k];` sets flag `unsafeleft = [:i]` and as a result should only thread over `k`.","user":"UD0NS8PDF","ts":"1613660141.027800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X7Fbz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The goal is to be safe by default, though. For example "},{"type":"text","text":"@tullio C[I[i], k] += A[i, j] * B[j, k];","style":{"code":true}},{"type":"text","text":" sets flag "},{"type":"text","text":"unsafeleft = [:i]","style":{"code":true}},{"type":"text","text":" and as a result should only thread over "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1613657824.027300","parent_user_id":"U6BJ9E351"}]