[{"client_msg_id":"a87b6708-1e31-4bbb-ae5e-969dface2fe3","type":"message","text":"Is there a Julia package that allows exploiting the function space structure of the problem (using the right inner products, instead of Euclidian l^2)?","user":"UFMH09DAR","ts":"1614809224.055300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r4ts","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a Julia package that allows exploiting the function space structure of the problem (using the right inner products, instead of Euclidian l^2)?"}]}]}],"thread_ts":"1614809224.055300","reply_count":14,"reply_users_count":5,"latest_reply":"1614871956.064900","reply_users":["UCT7E536E","UFMH09DAR","U9AHT3YM7","UPJ6Q2SQY","UMDEUKM29"],"subscribed":false},{"client_msg_id":"69236648-2351-4cd1-a264-c4f95eb7ab45","type":"message","text":"What do you mean by that?","user":"UCT7E536E","ts":"1614809944.055400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xj=Vc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do you mean by that?"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"79dd01dd-9b15-478f-bab7-435a033b0fb6","type":"message","text":"If we want to minimize the functional J : ℝⁿ -&gt; ℝ, we can use steepest descent x_new = x_old - stepsize * ∇J(x_old). ∇J(x_old) ∈ ℝⁿ is the gradient of J.\nNow if we have minimization of J: V -&gt; ℝ, where V is a Hilbert Space, the analogue of steepest descent is Fréchet derivative J' that lives in the dual of V and we need a Riesz map R: V* -&gt; V, then the minimization algorithm is x_new = x_old - stepsize*R ( J' (x_old) ). Without the Riesz map number of iterations required for convergence blows up. That's usually considered in PDE-constrained optimization or preconditioning of PDEs for Krylov methods.","user":"UFMH09DAR","ts":"1614811887.055600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1MTWy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If we want to minimize the functional J : ℝⁿ -> ℝ, we can use steepest descent x_new = x_old - stepsize * ∇J(x_old). ∇J(x_old) ∈ ℝⁿ is the gradient of J.\nNow if we have minimization of J: V -> ℝ, where V is a Hilbert Space, the analogue of steepest descent is Fréchet derivative J' that lives in the dual of V and we need a Riesz map R: V* -> V, then the minimization algorithm is x_new = x_old - stepsize*R ( J' (x_old) ). Without the Riesz map number of iterations required for convergence blows up. That's usually considered in PDE-constrained optimization or preconditioning of PDEs for Krylov methods."}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR","reactions":[{"name":"today-i-learned","users":["U0138UTB7A4"],"count":1},{"name":"astonished","users":["U0138UTB7A4"],"count":1}]},{"client_msg_id":"963d8b69-29b0-40eb-9af1-8e098fed921f","type":"message","text":"I don't know what to answer to that :slightly_smiling_face:","user":"UCT7E536E","ts":"1614816301.059400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k5AO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't know what to answer to that "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"e6032410-d8a4-40fc-bfe4-2f33a22e7a75","type":"message","text":"Manopt.jl + FunManifolds.jl should be relatively close to what you want to do here","user":"U9AHT3YM7","ts":"1614853735.061200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kNYj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Manopt.jl + FunManifolds.jl should be relatively close to what you want to do here"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"475a284d-c29a-462d-977d-dca60bf70d06","type":"message","text":"They are still somewhat a work-in-progress but geometric-functional optimization is one of the goals there","user":"U9AHT3YM7","ts":"1614853897.061400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z7Y5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"They are still somewhat a work-in-progress but geometric-functional optimization is one of the goals there"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"c1ea9a91-1bd1-4ba0-9ffc-8b8825e21424","type":"message","text":"<@UPJ6Q2SQY> may be able to help here :slightly_smiling_face:","user":"U9AHT3YM7","ts":"1614854004.061600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KxB","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UPJ6Q2SQY"},{"type":"text","text":" may be able to help here "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"9da4f9cc-6c95-4211-bde4-b5a0c9ab8388","type":"message","text":"Ah, one thing you can do is take the `Euclidean` manifold from `Manifolds.jl` , implement your own new metric in a `MetricManifold` (I can help you with that if you want to go that way) and then use `Manopt.jl` (for example its gradient descent or even its CG).","user":"UPJ6Q2SQY","ts":"1614854543.061800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1G4a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, one thing you can do is take the "},{"type":"text","text":"Euclidean","style":{"code":true}},{"type":"text","text":" manifold from "},{"type":"text","text":"Manifolds.jl","style":{"code":true}},{"type":"text","text":" , implement your own new metric in a "},{"type":"text","text":"MetricManifold","style":{"code":true}},{"type":"text","text":" (I can help you with that if you want to go that way) and then use "},{"type":"text","text":"Manopt.jl","style":{"code":true}},{"type":"text","text":" (for example its gradient descent or even its CG)."}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"81c685ac-6dda-4390-9ace-2b799ecc2476","type":"message","text":"Sure the manifold approach is broader than what you actually need, but is a first way you can look into","user":"UPJ6Q2SQY","ts":"1614854603.062000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+Gk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sure the manifold approach is broader than what you actually need, but is a first way you can look into"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"28a0321d-5055-4ca6-b5ea-ed18af938a0a","type":"message","text":"Yiy don't need manifolds, what you're describing is preconditioning","user":"UMDEUKM29","ts":"1614859488.062200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t7V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yiy don't need manifolds, what you're describing is preconditioning"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"5ead96c5-6097-4ee7-a59c-6a43c7d72ed5","type":"message","text":"The riesz map is the preconditionner","user":"UMDEUKM29","ts":"1614859529.062400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TYZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The riesz map is the preconditionner"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"f1275c31-c4c9-4f5b-a256-3db1004a894d","type":"message","text":"So any package that allows preconditioning will do what you want","user":"UMDEUKM29","ts":"1614859567.062600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iQms2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So any package that allows preconditioning will do what you want"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"4488212e-2652-4052-8788-88c4fac35503","type":"message","text":"Sure, a preconditioner would do, too, the metric manifold would do the same (and the only reason I propsed that is, I could directly implement that I think). But yes, your favourite package would do, too.","user":"UPJ6Q2SQY","ts":"1614859988.062800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v5YP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sure, a preconditioner would do, too, the metric manifold would do the same (and the only reason I propsed that is, I could directly implement that I think). But yes, your favourite package would do, too."}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"42bc52cf-0ce4-4e90-87e1-ee685d284a92","type":"message","text":"Thank you for the suggestions! I just found out that Optim.jl supports preconditioners for GradientDescent and LBFGS, that's what I needed. I'll take a look at Manopt.jl as well!","user":"UFMH09DAR","ts":"1614871923.064700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VvHcQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you for the suggestions! I just found out that Optim.jl supports preconditioners for GradientDescent and LBFGS, that's what I needed. I'll take a look at Manopt.jl as well!"}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"},{"client_msg_id":"2fd83c06-fa80-42f7-8eb2-faa7e5502b8a","type":"message","text":"Then Optim.jl is for sure the better choice.","user":"UPJ6Q2SQY","ts":"1614871956.064900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/HLYe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Then Optim.jl is for sure the better choice."}]}]}],"thread_ts":"1614809224.055300","parent_user_id":"UFMH09DAR"}]