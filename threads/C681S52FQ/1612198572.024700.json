[{"client_msg_id":"0cacdfb3-f079-4244-93ae-55162efcec46","type":"message","text":"What do we think the quickest way to find roots of bessel functions of first kind zero order that would satisfy `J₀(A*sₙ) = 0` where A is some varying positive constant? I see there is FunctionZeros.jl that will find the roots of bessels functions but unfortunately I am using this as an inverse model and calculating sₙ for each iteration is very slow (as the constant A depends on the fitting parameters in the fitting model)....","user":"U01FSUY7YES","ts":"1612198572.024700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M23I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do we think the quickest way to find roots of bessel functions of first kind zero order that would satisfy `J₀(A*sₙ) = 0` where A is some varying positive constant? I see there is FunctionZeros.jl that will find the roots of bessels functions but unfortunately I am using this as an inverse model and calculating sₙ for each iteration is very slow (as the constant A depends on the fitting parameters in the fitting model)...."}]}]}],"thread_ts":"1612198572.024700","reply_count":9,"reply_users_count":3,"latest_reply":"1612324646.033300","reply_users":["U01FSUY7YES","U67G3QRJM","UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"59b15160-cc50-42c7-9d47-91baf5236853","type":"message","text":"Ideally I would be able to precompute the roots and store them prior to the inverse fit and modify it based on the factor A but the number of roots over a fixed region changes rapidly as A increases...","user":"U01FSUY7YES","ts":"1612198954.024800","team":"T68168MUP","edited":{"user":"U01FSUY7YES","ts":"1612199321.000000"},"blocks":[{"type":"rich_text","block_id":"hLVfs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ideally I would be able to precompute the roots and store them prior to the inverse fit and modify it based on the factor A but the number of roots over a fixed region changes rapidly as A increases..."}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES"},{"client_msg_id":"541ae5de-3198-4b57-9fbf-168cde69fcff","type":"message","text":"I made some modifications to the FunctionZeros.jl code that appear to give the desired results for sn but unfortunately still have to recompute sn each iteration in the inverse solver.....\n```using SpecialFunctions, Roots\nbesselj_zero_asymptotic(n, A) = π*(4*n + 3) / (4*A) # with factor A and 0 order\nbesselj_zero(n, A; order=2) = Roots.fzero((x) -&gt; SpecialFunctions.besselj0(A*x), besselj_zero_asymptotic(n, A); order=order)\nsn = map(s -&gt; besselj_zero(s, 1; order = 2), 1:1000)```","user":"U01FSUY7YES","ts":"1612206624.025100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rAw7r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I made some modifications to the FunctionZeros.jl code that appear to give the desired results for sn but unfortunately still have to recompute sn each iteration in the inverse solver.....\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using SpecialFunctions, Roots\nbesselj_zero_asymptotic(n, A) = π*(4*n + 3) / (4*A) # with factor A and 0 order\nbesselj_zero(n, A; order=2) = Roots.fzero((x) -> SpecialFunctions.besselj0(A*x), besselj_zero_asymptotic(n, A); order=order)\nsn = map(s -> besselj_zero(s, 1; order = 2), 1:1000)"}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES"},{"client_msg_id":"0f726dd4-1d56-49d4-ae83-31246fcb29de","type":"message","text":"If `z_n` are the roots of J_0 then `s_n = z_n / A` as far as I understand. So precompute a big table of all the zeros of J_0 and then just use that relation?","user":"U67G3QRJM","ts":"1612220561.025400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3Qzs9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If "},{"type":"text","text":"z_n","style":{"code":true}},{"type":"text","text":" are the roots of J_0 then "},{"type":"text","text":"s_n = z_n / A","style":{"code":true}},{"type":"text","text":" as far as I understand. So precompute a big table of all the zeros of J_0 and then just use that relation?"}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES","reactions":[{"name":"white_check_mark","users":["U01FSUY7YES"],"count":1}]},{"client_msg_id":"87db34b2-dd62-4f94-9e1b-5a4d97a1c0dc","type":"message","text":"You can do it adaptively where you check if you are outside the range you already computed; if so then add some more to the table","user":"U67G3QRJM","ts":"1612220607.025600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6QI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can do it adaptively where you check if you are outside the range you already computed; if so then add some more to the table"}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES","reactions":[{"name":"+1","users":["U01FSUY7YES"],"count":1}]},{"client_msg_id":"CD531815-923A-4542-9BF6-B6EF2B51D902","type":"message","text":"Haha yes wow they are directly related just like that! Super helpful thank you! But yes I’ll try to integrate something adaptive as it’s an infinite summation that I have to truncate somewhere. ","user":"U01FSUY7YES","ts":"1612222002.029700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"klRal","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Haha yes wow they are directly related just like that! Super helpful thank you! But yes I’ll try to integrate something adaptive as it’s an infinite summation that I have to truncate somewhere. "}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"c70841ea-8f60-465d-aa1a-46ab24788377","type":"message","text":"There's also `GSL.sf_bessel_zero_J0`, which is I believe faster than the approach with Roots, if you're comfortable limiting to Float32 and Float64 and adding GSL.jl as a dependency. We use it in Hankel.jl to initialize the Roots approach, which is inaccurate for large order with the initialization FunctionZeros uses: <https://github.com/chrisbrahms/Hankel.jl/blob/v0.5.4/src/utils.jl#L166-L186>","user":"UHDQQ4GN6","ts":"1612302793.032400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nyiNu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There's also "},{"type":"text","text":"GSL.sf_bessel_zero_J0","style":{"code":true}},{"type":"text","text":", which is I believe faster than the approach with Roots, if you're comfortable limiting to Float32 and Float64 and adding GSL.jl as a dependency. We use it in Hankel.jl to initialize the Roots approach, which is inaccurate for large order with the initialization FunctionZeros uses: "},{"type":"link","url":"https://github.com/chrisbrahms/Hankel.jl/blob/v0.5.4/src/utils.jl#L166-L186"}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES","reactions":[{"name":"bulb","users":["U01FSUY7YES"],"count":1}]},{"client_msg_id":"a2827346-b046-4964-8e3d-d217db4841e6","type":"message","text":"Also, I found `Roots.find_zero` to be substantially faster than `Roots.fzero` for this task.","user":"UHDQQ4GN6","ts":"1612302855.032600","team":"T68168MUP","edited":{"user":"UHDQQ4GN6","ts":"1612302865.000000"},"blocks":[{"type":"rich_text","block_id":"q7Xww","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, I found "},{"type":"text","text":"Roots.find_zero","style":{"code":true}},{"type":"text","text":" to be substantially faster than "},{"type":"text","text":"Roots.fzero","style":{"code":true}},{"type":"text","text":" for this task."}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES","reactions":[{"name":"+1","users":["U01FSUY7YES"],"count":1}]},{"client_msg_id":"a52b840e-4e80-4c8a-9f28-6b8a3d227809","type":"message","text":"Thank you <@UHDQQ4GN6> I will definitely check that out! So far it looks like precomputing the zeros once and storing them on the repo is going to work ok. Thanks for introducing me to those packages!!\n\n I was dealing with a model that had a hankel transform a couple of weeks ago so looking at your package would've been helpful! This model actually takes the form f(sn, ω)*J₀(sₙ*r)/J₁(A*sₙ)^2 that can usually be truncated for 600-800 zeros.. the crux is now the transform from the frequency domain to time domain. The current implementation is a DFT that has to compute about 1200 frequencies to get a good time domain signal but is incredibly slow.\n\nIs the recommended package for laplace transforms InverseLaplace.jl? This looks like a much more efficient way to compute the TD signal from the spatial or frequency domain but have never implemented it... Thanks for the suggestions!","user":"U01FSUY7YES","ts":"1612313960.032900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BLUj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you "},{"type":"user","user_id":"UHDQQ4GN6"},{"type":"text","text":" I will definitely check that out! So far it looks like precomputing the zeros once and storing them on the repo is going to work ok. Thanks for introducing me to those packages!!\n\n I was dealing with a model that had a hankel transform a couple of weeks ago so looking at your package would've been helpful! This model actually takes the form f(sn, ω)*J₀(sₙ*r)/J₁(A*sₙ)^2 that can usually be truncated for 600-800 zeros.. the crux is now the transform from the frequency domain to time domain. The current implementation is a DFT that has to compute about 1200 frequencies to get a good time domain signal but is incredibly slow.\n\nIs the recommended package for laplace transforms InverseLaplace.jl? This looks like a much more efficient way to compute the TD signal from the spatial or frequency domain but have never implemented it... Thanks for the suggestions!"}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES"},{"client_msg_id":"2c4dd507-df36-4777-bc29-248313d4d757","type":"message","text":"&gt; This model actually takes the form f(sn, ω)*J₀(sₙ*r)/J₁(A*sₙ)^2 that can usually be truncated for 600-800 zeros\nYeah, that looks pretty similar to the quasi-discrete Hankel transform we use. Currently our implementation would require recomputing zeros whenever  `A` (maps to our `R` or `K` I believe) changes, but that could be refactored.","user":"UHDQQ4GN6","ts":"1612324646.033300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W79YF","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"This model actually takes the form f(sn, ω)*J₀(sₙ*r)/J₁(A*sₙ)^2 that can usually be truncated for 600-800 zeros"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, that looks pretty similar to the quasi-discrete Hankel transform we use. Currently our implementation would require recomputing zeros whenever  "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" (maps to our "},{"type":"text","text":"R","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"K","style":{"code":true}},{"type":"text","text":" I believe) changes, but that could be refactored."}]}]}],"thread_ts":"1612198572.024700","parent_user_id":"U01FSUY7YES"}]