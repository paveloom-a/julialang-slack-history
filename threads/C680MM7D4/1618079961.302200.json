[{"client_msg_id":"e9bc28c8-15c0-4968-8478-2e43711df048","type":"message","text":"Someone remember the link to a swift feature that resulted not being able to always be solvable by the compiler because something related to group theory?","user":"U0110B59U0Y","ts":"1618079961.302200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kPr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Someone remember the link to a swift feature that resulted not being able to always be solvable by the compiler because something related to group theory?"}]}]}],"thread_ts":"1618079961.302200","reply_count":6,"reply_users_count":2,"latest_reply":"1618199092.316200","reply_users":["U0110B59U0Y","U6795JH6H"],"is_locked":false,"subscribed":false},{"client_msg_id":"82dbd7ea-cc8d-4430-8827-660f87cdc044","type":"message","text":"Found it! It was the type checking.\n<https://forums.swift.org/t/swift-type-checking-is-undecidable/39024>","user":"U0110B59U0Y","ts":"1618080150.302300","team":"T68168MUP","attachments":[{"service_name":"Swift Forums","title":"Swift type checking is undecidable","title_link":"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024","text":"More precisely, the introduction of SE-0142 and SE-0157 has made canonical type computation into an undecidable problem. I'll begin with the necessary background information before presenting my argument, and then outlining the next steps. Canonical types Consider these two protocols, stripped down from the real implementations in the standard library: protocol IteratorProtocol { associatedtype Element } protocol Sequence { associatedtype Iterator : IteratorProtocol associatedtype Eleme...","fallback":"Swift Forums: Swift type checking is undecidable","thumb_url":"https://aws1.discourse-cdn.com/swift/original/1X/0a90dde98a223f5841eeca49d89dc9f57592e8d6.png","fields":[{"title":"Reading time","value":"13 mins :clock2:","short":true},{"title":"Likes","value":"260 :heart:","short":true}],"ts":1596488258,"from_url":"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024","thumb_width":590,"thumb_height":585,"service_icon":"https://aws1.discourse-cdn.com/swift/optimized/1X/0a90dde98a223f5841eeca49d89dc9f57592e8d6_2_180x180.png","id":1,"original_url":"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024"}],"blocks":[{"type":"rich_text","block_id":"bRTz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Found it! It was the type checking.\n"},{"type":"link","url":"https://forums.swift.org/t/swift-type-checking-is-undecidable/39024"}]}]}],"thread_ts":"1618079961.302200","parent_user_id":"U0110B59U0Y"},{"client_msg_id":"0AE6F8E0-7E7F-4D7F-8D4A-5192D0F63C18","type":"message","text":"Very interesting","user":"U6795JH6H","ts":"1618171228.311500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zJs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Very interesting"}]}]}],"thread_ts":"1618079961.302200","parent_user_id":"U0110B59U0Y"},{"client_msg_id":"CB9E9386-8BEC-420F-88DD-326518C06CCE","type":"message","text":"Seems like a somewhat obviously too powerful feature IMO, but some limitation would no doubt allow it to continue to work and be decidable","user":"U6795JH6H","ts":"1618171294.313200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/qO54","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Seems like a somewhat obviously too powerful feature IMO, but some limitation would no doubt allow it to continue to work and be decidable"}]}]}],"thread_ts":"1618079961.302200","parent_user_id":"U0110B59U0Y"},{"client_msg_id":"0623cfe7-3aa9-4104-9164-8c1002a6253e","type":"message","text":"I must admit that I don't really understand the feature, as I don't know the type checker of Swift, neither the how the protocols work.","user":"U0110B59U0Y","ts":"1618198823.315800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T2i","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I must admit that I don't really understand the feature, as I don't know the type checker of Swift, neither the how the protocols work."}]}]}],"thread_ts":"1618079961.302200","parent_user_id":"U0110B59U0Y"},{"client_msg_id":"813dc9c0-6e8d-4ad5-9678-4cc3c631f44b","type":"message","text":"But it looked as a fun example to show to a friend (who is studying group theory) of some problems that sometimes appear in programming.","user":"U0110B59U0Y","ts":"1618198833.316000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8mSx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it looked as a fun example to show to a friend (who is studying group theory) of some problems that sometimes appear in programming."}]}]}],"thread_ts":"1618079961.302200","parent_user_id":"U0110B59U0Y"},{"client_msg_id":"7676c328-cede-4fc0-8ec1-8b39dfdc5dba","type":"message","text":"Respect to the limitations to make it work, the <https://en.wikipedia.org/wiki/Word_problem_for_groups|Wikipedia Page> list some classes of groups the are solvable. Also there is mentions of the Knuth-Bendix algorithm and variants to solve the word problem in some cases. :)","user":"U0110B59U0Y","ts":"1618199092.316200","team":"T68168MUP","edited":{"user":"U0110B59U0Y","ts":"1618199109.000000"},"attachments":[{"title":"Word problem for groups","title_link":"https://en.wikipedia.org/wiki/Word_problem_for_groups","from_url":"https://en.wikipedia.org/wiki/Word_problem_for_groups","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"In mathematics, especially in the area of abstract algebra known as combinatorial group theory, the word problem for a finitely generated group G is the algorithmic problem of deciding whether two words in the generators represent the same element. More precisely, if A is a finite set of generators for G then the word problem is the membership problem for the formal language of all words in A and a formal set of inverses that map to the identity under the natural map from the free monoid with involution on A to the group G.  If B is another finite generating set for G, then the word problem over the generating set B is equivalent to the word problem over the generating set A. Thus one can speak unambiguously of the decidability of the word problem for the finitely generated group G.\nThe related but different uniform word problem for a class K of recursively presented groups is the algorithmic problem of deciding, given as input a presentation P for a group G in the class K and two words in the generators of G, whether the words represent the same element of G. Some authors require the class K to be definable by a recursively enumerable set of presentations.","fallback":"wikipedia: Word problem for groups","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/Word_problem_for_groups"}],"blocks":[{"type":"rich_text","block_id":"2ZCpe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Respect to the limitations to make it work, the "},{"type":"link","url":"https://en.wikipedia.org/wiki/Word_problem_for_groups","text":"Wikipedia Page"},{"type":"text","text":" list some classes of groups the are solvable. Also there is mentions of the Knuth-Bendix algorithm and variants to solve the word problem in some cases. :)"}]}]}],"thread_ts":"1618079961.302200","parent_user_id":"U0110B59U0Y"}]