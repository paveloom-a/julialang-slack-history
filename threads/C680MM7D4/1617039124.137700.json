[{"client_msg_id":"736017d4-184a-4116-8c05-5914b912f36d","type":"message","text":"Random question about chips. Can the M1 chip do avx instructions? Is avx going to become less useful as more cloud computing switches to ARM architectures?","user":"UBF9YRB6H","ts":"1617039124.137700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"48db","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Random question about chips. Can the M1 chip do avx instructions? Is avx going to become less useful as more cloud computing switches to ARM architectures?"}]}]}],"thread_ts":"1617039124.137700","reply_count":35,"reply_users_count":7,"latest_reply":"1617059345.180100","reply_users":["U0179G7FG4F","U01C3624SGJ","UBF9YRB6H","UDB26738Q","U8D9768Q6","UAUPJLBQX","U9MD78Z9N"],"is_locked":false,"subscribed":false},{"client_msg_id":"9aa0eae6-eedc-416f-9269-ff76e15cc3c4","type":"message","text":"m1 doesn't have avx (that's x86 specific), but it does have it's own set of vectorization instructions","user":"U0179G7FG4F","ts":"1617039277.138400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=gIr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"m1 doesn't have avx (that's x86 specific), but it does have it's own set of vectorization instructions"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"8e770646-5e45-4147-bf5b-27b0ead610fe","type":"message","text":"ARM has neon which is 128 bit SIMD","user":"U01C3624SGJ","ts":"1617039359.138700","team":"T68168MUP","edited":{"user":"U01C3624SGJ","ts":"1617039597.000000"},"blocks":[{"type":"rich_text","block_id":"aURI8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ARM has neon which is 128 bit SIMD"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"585beb9a-30fe-4674-84c2-6cf788143c09","type":"message","text":"for mac, it's the amx unit that does vectorization","user":"U0179G7FG4F","ts":"1617039375.138900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kRy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for mac, it's the amx unit that does vectorization"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"a3b69c95-b674-44be-bb93-c848611c1410","type":"message","text":"does loopvectorization have separate branches to emulate the other instruction types?","user":"UBF9YRB6H","ts":"1617039430.139100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6dZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"does loopvectorization have separate branches to emulate the other instruction types?"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"6c6401d0-173e-4afa-86b3-aeb9365a2940","type":"message","text":"what chips have SVE?","user":"UDB26738Q","ts":"1617039436.139300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2dI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what chips have SVE?"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"15f7b570-6333-4f95-a2b9-2639d3ac5a7a","type":"message","text":"<@UBF9YRB6H> currently it probably doesn't. The vectorization instructions aren't generated by Rosetta, so it won't work until Julia runs native on m1","user":"U0179G7FG4F","ts":"1617039567.139600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZZ9l=","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UBF9YRB6H"},{"type":"text","text":" currently it probably doesn't. The vectorization instructions aren't generated by Rosetta, so it won't work until Julia runs native on m1"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"730bfc4e-77f6-410c-a715-7f136fd1172c","type":"message","text":"I wrote it wrong. I meant neon, I think only the fujitsu ones have sve","user":"U01C3624SGJ","ts":"1617039587.139800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3sH1u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wrote it wrong. I meant neon, I think only the fujitsu ones have sve"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H","reactions":[{"name":"+1","users":["UDB26738Q"],"count":1}]},{"client_msg_id":"e00537ed-2442-4602-a156-f29894eeb372","type":"message","text":"Ah interesting. is Rosetta going to be upstreamed into LLVM?","user":"UBF9YRB6H","ts":"1617039641.140200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JfPZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah interesting. is Rosetta going to be upstreamed into LLVM?"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"271c102e-75a4-44fb-9344-4bd9a405f251","type":"message","text":"??","user":"U0179G7FG4F","ts":"1617039657.140400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ajnr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"??"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"a4c811d3-1100-4d1a-bb1c-75e95b6d02d3","type":"message","text":"I think also the new neoverse ones will have SVE but I'm not sure about when","user":"U01C3624SGJ","ts":"1617039704.140600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k1R/f","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think also the new neoverse ones will have SVE but I'm not sure about when"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"c2027a5b-6950-4954-a4c2-4f9d4c721fdf","type":"message","text":"I mean, Rosetta is a low-level translator from x86 intructions to instructions the M1 can process, right? Isn't that kind of the job of the compiler? In the future, wouldn't their just be tooling to compile to different chip targets? Or is my mental model for that process not right","user":"UBF9YRB6H","ts":"1617039756.140900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Hm+RX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, Rosetta is a low-level translator from x86 intructions to instructions the M1 can process, right? Isn't that kind of the job of the compiler? In the future, wouldn't their just be tooling to compile to different chip targets? Or is my mental model for that process not right"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"06d6073c-58f5-45f6-8b06-d26a1d8133f9","type":"message","text":"I'm not sure why that would go to llvm. LLVM compiles some code to native assembly not x86 to arm or other architectures","user":"U01C3624SGJ","ts":"1617039881.142200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fmZj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure why that would go to llvm. LLVM compiles some code to native assembly not x86 to arm or other architectures"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"447fb881-2a01-485b-b1e1-74406b17f21d","type":"message","text":"I see what you're saying. LLVM has been able to compile for arm for a while. The thing that's missing is some C libraries for stuff like printing and thread management (or stuff like that)","user":"U0179G7FG4F","ts":"1617039886.142500","team":"T68168MUP","edited":{"user":"U0179G7FG4F","ts":"1617039898.000000"},"blocks":[{"type":"rich_text","block_id":"W3Hi5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see what you're saying. LLVM has been able to compile for arm for a while. The thing that's missing is some C libraries for stuff like printing and thread management (or stuff like that)"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"bf8242da-b02c-4439-902c-a517e243c2dd","type":"message","text":"Wait so when we say \"julia works natively on M1\", it will still compile, roughly, to x86 instructions, then Rosetta will take over and re-write it for the M1 chip? I think I'm not understanding the distinction between assembly and x86 instructions. If anyone can point me to more to read I would appreciate it","user":"UBF9YRB6H","ts":"1617040192.144100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GVfz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Wait so when we say \"julia works natively on M1\", it will still compile, roughly, to x86 instructions, then Rosetta will take over and re-write it for the M1 chip? I think I'm not understanding the distinction between assembly and x86 instructions. If anyone can point me to more to read I would appreciate it"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"44d8dee0-4e46-40c9-bfd3-e7ed569f48bf","type":"message","text":"no, master works on M1 natively, without rosetta involved","user":"UDB26738Q","ts":"1617040231.144300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pnw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no, master works on M1 natively, without rosetta involved"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"906013a5-b59e-482d-aa6c-6a256b110449","type":"message","text":"so is there a translation of SIMD to the M1 equivelents? by Julia? What level does this happen at?","user":"UBF9YRB6H","ts":"1617040345.144500","team":"T68168MUP","edited":{"user":"UBF9YRB6H","ts":"1617040362.000000"},"blocks":[{"type":"rich_text","block_id":"lTTT4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so is there a translation of SIMD to the M1 equivelents? by Julia? What level does this happen at?"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"44114788-8e43-4da5-a628-07713ae8ff17","type":"message","text":"arm and x86 both have their own assembly instructions","user":"U0179G7FG4F","ts":"1617040408.145000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1P+jH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"arm and x86 both have their own assembly instructions"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"cb204e0c-4417-4742-902e-d509ab12d25f","type":"message","text":"what happens on 1.6, is you go julia -&gt; julia bytecode -&gt; llvm bytecode -&gt; x86 -&gt; arm","user":"U0179G7FG4F","ts":"1617040444.145200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sONZL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what happens on 1.6, is you go julia -> julia bytecode -> llvm bytecode -> x86 -> arm"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"fd724a6d-6e8f-4215-943d-86baea686d42","type":"message","text":"On Master, it's just julia -&gt; julia bytecode -&gt; llvm bytecode -&gt; arm","user":"U0179G7FG4F","ts":"1617040463.145400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7Ge/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On Master, it's just julia -> julia bytecode -> llvm bytecode -> arm"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"ebeef0dd-152b-49de-9c43-2095a104ee31","type":"message","text":"so are \"julia bytecode\" or \"llvm bytecode\" agnostic about the way that code gets vectorized?, i.e. SIMD, avx, or others.","user":"UBF9YRB6H","ts":"1617040505.145600","team":"T68168MUP","edited":{"user":"UBF9YRB6H","ts":"1617040524.000000"},"blocks":[{"type":"rich_text","block_id":"C5Rw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so are \"julia bytecode\" or \"llvm bytecode\" agnostic about the way that code gets vectorized?, i.e. SIMD, avx, or others."}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"b36c7fc7-7339-4599-b3c9-58429b2c0464","type":"message","text":"yes. To look at Julia's bytecode look at `@code_typed` on some random code.","user":"U0179G7FG4F","ts":"1617040612.146000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IqYvs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes. To look at Julia's bytecode look at "},{"type":"text","text":"@code_typed","style":{"code":true}},{"type":"text","text":" on some random code."}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"5476b7d0-1a0c-408e-8062-aa74070cfa88","type":"message","text":"By the way, Rosetta is not believed to just be a software solution. You couldn't just stick it on an arbitrary ARM chip and expect it to work. M1 has specicialized hardware that works in tandem with their software solution. That's part of why nobody has x86 emulation even close to Rosetta","user":"U8D9768Q6","ts":"1617040671.146200","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1617040695.000000"},"blocks":[{"type":"rich_text","block_id":"Vtw19","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"By the way, Rosetta is not believed to just be a software solution. You couldn't just stick it on an arbitrary ARM chip and expect it to work. M1 has specicialized hardware that works in tandem with their software solution. That's part of why nobody has x86 emulation even close to Rosetta"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"b4d63021-ab75-4d59-8fd9-7c4b60ca1b1f","type":"message","text":"Okay wonderful. so ARM chips use NEON or something when they see a `SIMD` instruction command.\n\nThat's interesting about Rosetta and the M1. I'm sure lots of chip companies are racing to get their own Rosetta equivalent up to feature parity.","user":"UBF9YRB6H","ts":"1617040823.146600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e+b7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Okay wonderful. so ARM chips use NEON or something when they see a "},{"type":"text","text":"SIMD","style":{"code":true}},{"type":"text","text":" instruction command.\n\nThat's interesting about Rosetta and the M1. I'm sure lots of chip companies are racing to get their own Rosetta equivalent up to feature parity."}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"5aa3844f-3e6a-46ec-b7c7-17291e71b9d6","type":"message","text":"Note though that a rosetta equivalent for say Windows is a *much* harder task than for MacOS. The problem is that Microsoft makes gigantic commitments to backwards compatability of APIs going way back like 20-30 years. This means that the surface area for possible ways a program can interact with the chip are gigantic and incredibly difficult to optimize.\n\nOn the other hand, Apple has rules about APIs where if they introduce a new API, in order to use that, you are not allowed to use any old APIs that are consuidered out of date. Eventually, Apple ends up deprecating old APIs and forcing developers onto new ones. This makes the software side of Rosettas job much much easier on MacOS","user":"U8D9768Q6","ts":"1617041611.148800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"olKI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Note though that a rosetta equivalent for say Windows is a "},{"type":"text","text":"much ","style":{"bold":true}},{"type":"text","text":"harder task than for MacOS. The problem is that Microsoft makes gigantic commitments to backwards compatability of APIs going way back like 20-30 years. This means that the surface area for possible ways a program can interact with the chip are gigantic and incredibly difficult to optimize.\n\nOn the other hand, Apple has rules about APIs where if they introduce a new API, in order to use that, you are not allowed to use any old APIs that are consuidered out of date. Eventually, Apple ends up deprecating old APIs and forcing developers onto new ones. This makes the software side of Rosettas job much much easier on MacOS"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"2a33a8dd-479e-4d58-9865-506032f83d78","type":"message","text":"how does linux handle it? My understanding is that AWS and Azure are going to be buying a lot more bespoke ARM based chips to cut down on cooling costs, and that's where the biggest switch will happen, as opposed to personal computers","user":"UBF9YRB6H","ts":"1617041750.149100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J/M","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"how does linux handle it? My understanding is that AWS and Azure are going to be buying a lot more bespoke ARM based chips to cut down on cooling costs, and that's where the biggest switch will happen, as opposed to personal computers"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"bb196e27-677e-40d1-9e14-5c59bd1a86ed","type":"message","text":"The downside of course, is that if you constantly force developers to update and rewrite the guts of mature applications, those applications will often get either abandonded, or sloppily half-updated. Apple themselves aren't immune to this. Last time there was a major API change, Apple 'updated' their Office equivalent apps but ended up deleting like half of the advanced functionality, severely gimping the apps which were already behind their microsoft competitors.","user":"U8D9768Q6","ts":"1617041762.149300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f1/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The downside of course, is that if you constantly force developers to update and rewrite the guts of mature applications, those applications will often get either abandonded, or sloppily half-updated. Apple themselves aren't immune to this. Last time there was a major API change, Apple 'updated' their Office equivalent apps but ended up deleting like half of the advanced functionality, severely gimping the apps which were already behind their microsoft competitors."}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"d3332e12-bfab-4355-b305-32e1999e4cd3","type":"message","text":"My understanding is that where Windows is designed around binary compatability, i.e. a compiled binary bundle from 20 years ago is supposed to run on modern windows, Linux instead mostly goes for source code compatability. So your old binary may no longer work on newer linux versions, but if you just recompile the old source code, it is supposed to work. This gives more options for moving APIs forward than demanding binary compatability,  because you can do the compatability translations at compile time.\n\nI don't know a lot about this and am probably getting something wrong though.","user":"U8D9768Q6","ts":"1617042039.149800","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1617042059.000000"},"blocks":[{"type":"rich_text","block_id":"=xR3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My understanding is that where Windows is designed around binary compatability, i.e. a compiled binary bundle from 20 years ago is supposed to run on modern windows, Linux instead mostly goes for source code compatability. So your old binary may no longer work on newer linux versions, but if you just recompile the old source code, it is supposed to work. This gives more options for moving APIs forward than demanding binary compatability,  because you can do the compatability translations at compile time.\n\nI don't know a lot about this and am probably getting something wrong though."}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"d7869781-9e4b-4cfb-8ec0-486761e80ef0","type":"message","text":"Thanks for all the info everyone! Appreciate the responses.","user":"UBF9YRB6H","ts":"1617042103.151200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HE=p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for all the info everyone! Appreciate the responses."}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"2e48f2c6-8ae1-4b4a-91f8-b03fd6fec252","type":"message","text":"glibc is backward-compatible (reason why we build with a fairly old glibc in BinaryBuilder)","user":"UDB26738Q","ts":"1617042155.152000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8kD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"glibc is backward-compatible (reason why we build with a fairly old glibc in BinaryBuilder)"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H","reactions":[{"name":"+1","users":["U8D9768Q6"],"count":1}]},{"client_msg_id":"61e7d983-2675-4f0e-b613-3edad3429005","type":"message","text":"I thought Linux constantly breaks ABI compatibility","user":"UAUPJLBQX","ts":"1617042587.158400","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1617042615.000000"},"blocks":[{"type":"rich_text","block_id":"u4c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I thought Linux constantly breaks ABI compatibility"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"019d00d0-46b3-4bb3-991d-d58b2973e491","type":"message","text":"maybe the kernel?  glibc is reasonably stable, libstdcxx and libgfortran are more problematic","user":"UDB26738Q","ts":"1617042651.159500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fME","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"maybe the kernel?  glibc is reasonably stable, libstdcxx and libgfortran are more problematic"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"68473bdb-fad4-47aa-8231-7126c7d1d8ee","type":"message","text":"<https://en.wikipedia.org/wiki/File:Linux_kernel_interfaces.svg>","user":"UAUPJLBQX","ts":"1617042752.159900","team":"T68168MUP","attachments":[{"image_url":"https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Linux_kernel_interfaces.svg/1200px-Linux_kernel_interfaces.svg.png","image_width":1200,"image_height":900,"image_bytes":224181,"title":"File:Linux kernel interfaces.svg","title_link":"https://en.wikipedia.org/wiki/File:Linux_kernel_interfaces.svg","from_url":"https://en.wikipedia.org/wiki/File:Linux_kernel_interfaces.svg","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","fallback":"wikipedia: File:Linux kernel interfaces.svg","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/File:Linux_kernel_interfaces.svg"}],"blocks":[{"type":"rich_text","block_id":"Cbd","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://en.wikipedia.org/wiki/File:Linux_kernel_interfaces.svg"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"c7f8055a-47a2-4ec5-b989-06b3c359b013","type":"message","text":"incompatibilities seem specific to internals of the kernel?","user":"UDB26738Q","ts":"1617042836.161200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TqWe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"incompatibilities seem specific to internals of the kernel?"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"fb83c197-1e3a-484a-9a02-379325b3fbad","type":"message","text":"AFAIK the A64FX is the only chip with SVE so far.\nNeoverse v1 and n2 will get it (256bits x2 and 128bits x2, respectively):\n<https://www.anandtech.com/show/16073/arm-announces-neoverse-v1-n2>\nNot sure if any chips are already using these designs yet, but presumably cloud servers with them will become available in the next couple years. Graviton 3?","user":"UAUPJLBQX","ts":"1617043067.163300","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1617043092.000000"},"blocks":[{"type":"rich_text","block_id":"iXru","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"AFAIK the A64FX is the only chip with SVE so far.\nNeoverse v1 and n2 will get it (256bits x2 and 128bits x2, respectively):\n"},{"type":"link","url":"https://www.anandtech.com/show/16073/arm-announces-neoverse-v1-n2"},{"type":"text","text":"\nNot sure if any chips are already using these designs yet, but presumably cloud servers with them will become available in the next couple years. Graviton 3?"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"},{"client_msg_id":"8e524c90-a10d-4fe5-b4f5-6b4ed32923e8","type":"message","text":"<@UDB26738Q> Only A64FX by Fujitsu has the architecture ATM. However the ARM neoverse V1 and N2 chips which are going to have SVE are already getting compiler support for GCC/LLVM <https://www.phoronix.com/scan.php?page=news_item&amp;px=Arm-Neoverse-V1-Tuning-GCC11|https://www.phoronix.com/scan.php?page=news_item&amp;px=Arm-Neoverse-V1-Tuning-GCC11>","user":"U9MD78Z9N","ts":"1617059345.180100","team":"T68168MUP","attachments":[{"title":"Arm Neoverse V1 Tuning Lands In GCC 11 Compiler - Phoronix","title_link":"https://www.phoronix.com/scan.php?page=news_item&px=Arm-Neoverse-V1-Tuning-GCC11","text":"Phoronix is the leading technology website for Linux hardware reviews, open-source news, Linux benchmarks, open-source benchmarks, and computer hardware tests.","fallback":"Arm Neoverse V1 Tuning Lands In GCC 11 Compiler - Phoronix","from_url":"https://www.phoronix.com/scan.php?page=news_item&px=Arm-Neoverse-V1-Tuning-GCC11","service_icon":"https://www.phoronix.com/apple-touch-icon-57x57.png","service_name":"phoronix.com","id":1,"original_url":"https://www.phoronix.com/scan.php?page=news_item&amp;px=Arm-Neoverse-V1-Tuning-GCC11"}],"blocks":[{"type":"rich_text","block_id":"ZBgni","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDB26738Q"},{"type":"text","text":" Only A64FX by Fujitsu has the architecture ATM. However the ARM neoverse V1 and N2 chips which are going to have SVE are already getting compiler support for GCC/LLVM "},{"type":"link","url":"https://www.phoronix.com/scan.php?page=news_item&px=Arm-Neoverse-V1-Tuning-GCC11","text":"https://www.phoronix.com/scan.php?page=news_item&px=Arm-Neoverse-V1-Tuning-GCC11"}]}]}],"thread_ts":"1617039124.137700","parent_user_id":"UBF9YRB6H"}]