[{"client_msg_id":"bc6dc7e5-ad43-4633-882f-1caec035f98f","type":"message","text":"For old projects, I think FFI wrappers, APIs, macros and/or transpilers can get you most if not all the way. It's a question of which language to pick for a new project. I think if your only reason for choosing language X for a new project is \"because everyone around me is using language X\" or because \"I can only call such and such libraries in language X\" when you can call the same libraries with FFI or such from language Y, then it's not a technical reason anymore that's stopping you from switching, it's social and psychological, legitimate as it may be. I think some common social and psychological reasons are:\n1. \"I am already good enough in language X and I don't have too much time to learn a new language.\".\n2. \"Even if I had or could find the time, I am not confident language Y is here to remain so I don't want to waste my time learning a dying technology. I would rather spend time learning something else, doing more work, spending more time with family, etc.\"\n3. \"I am not comfortable going against the tide using a different language than everyone around me.\"\nI think if academia and the major tech giants start moving way from C, C++, Python, Matlab and Java towards Julia, Rust, Swift, Go and Kotlin, the rest of the world will follow for the same reasons they are reluctant to make the switch now. But it takes time. I don't think Julia will ever dominate and it's not supposed to in order to be successful. Julia makes a certain set of design decisions and compromises and every language makes a slightly different set of such compromises. It's good to have the choice between different tradeoffs. So now it's Julia vs Python. 10 years from now, it will be probably Julia vs Swift, Julia vs Go or Julia vs some new language.","user":"U85JBUGGP","ts":"1611042258.273000","team":"T68168MUP","edited":{"user":"U85JBUGGP","ts":"1611042275.000000"},"blocks":[{"type":"rich_text","block_id":"az=o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For old projects, I think FFI wrappers, APIs, macros and/or transpilers can get you most if not all the way. It's a question of which language to pick for a new project. I think if your only reason for choosing language X for a new project is \"because everyone around me is using language X\" or because \"I can only call such and such libraries in language X\" when you can call the same libraries with FFI or such from language Y, then it's not a technical reason anymore that's stopping you from switching, it's social and psychological, legitimate as it may be. I think some common social and psychological reasons are:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"\"I am already good enough in language X and I don't have too much time to learn a new language.\"."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\"Even if I had or could find the time, I am not confident language Y is here to remain so I don't want to waste my time learning a dying technology. I would rather spend time learning something else, doing more work, spending more time with family, etc.\""}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\"I am not comfortable going against the tide using a different language than everyone around me.\""}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI think if academia and the major tech giants start moving way from C, C++, Python, Matlab and Java towards Julia, Rust, Swift, Go and Kotlin, the rest of the world will follow for the same reasons they are reluctant to make the switch now. But it takes time. I don't think Julia will ever dominate and it's not supposed to in order to be successful. Julia makes a certain set of design decisions and compromises and every language makes a slightly different set of such compromises. It's good to have the choice between different tradeoffs. So now it's Julia vs Python. 10 years from now, it will be probably Julia vs Swift, Julia vs Go or Julia vs some new language."}]}]}],"thread_ts":"1611042258.273000","reply_count":5,"reply_users_count":2,"latest_reply":"1611099596.307000","reply_users":["ULSFQ48UQ","U85JBUGGP"],"subscribed":false},{"client_msg_id":"66fcf6b4-91b4-4a98-ab42-24dc6795ca9d","type":"message","text":"All of those reasons apply. In addition, many scientists have these large FORTRAN and C++ applications that are horrendous to decipher, let alone improve and maintain. They believe that converting the application to another language will take just as long and provide no performance benefit. Because they have little to no experience working with modern programming languages, they can not comprehend the benefits a modern language can provide for the development and maintenance of their app. That is a big hurdle to overcome. I know. I've tried for many years and am still trying. It is a big impediment to scientific research because many of these apps are de facto standards, so you are somewhat forced to use them, even though you'd prefer not to.","user":"ULSFQ48UQ","ts":"1611063196.278500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PKt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"All of those reasons apply. In addition, many scientists have these large FORTRAN and C++ applications that are horrendous to decipher, let alone improve and maintain. They believe that converting the application to another language will take just as long and provide no performance benefit. Because they have little to no experience working with modern programming languages, they can not comprehend the benefits a modern language can provide for the development and maintenance of their app. That is a big hurdle to overcome. I know. I've tried for many years and am still trying. It is a big impediment to scientific research because many of these apps are de facto standards, so you are somewhat forced to use them, even though you'd prefer not to."}]}]}],"thread_ts":"1611042258.273000","parent_user_id":"U85JBUGGP"},{"client_msg_id":"16554925-7650-4b7e-92f9-c1d1d5a22e71","type":"message","text":"I think there is no reason to re-write a well-tested code in another language unless you want to extend it in ways currently impossible. Just call it via FFI or an API.","user":"U85JBUGGP","ts":"1611095319.306300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"995ds","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think there is no reason to re-write a well-tested code in another language unless you want to extend it in ways currently impossible. Just call it via FFI or an API."}]}]}],"thread_ts":"1611042258.273000","parent_user_id":"U85JBUGGP"},{"client_msg_id":"7f8458a4-8932-4a36-bc4f-02c4a3480c5e","type":"message","text":"Also I think the difficulty of code re-write is often over-rated. Often you can break down a large code base into small modules and build one at a time over weeks, months or even a couple of years in one's free time. The expressiveness of high level languages can help shrink a multi-million lines of code (loc) project to 10s of thousands of loc with the appropriate abstractions and dependencies. And not all old projects are many millions of loc.","user":"U85JBUGGP","ts":"1611095553.306500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fbS4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also I think the difficulty of code re-write is often over-rated. Often you can break down a large code base into small modules and build one at a time over weeks, months or even a couple of years in one's free time. The expressiveness of high level languages can help shrink a multi-million lines of code (loc) project to 10s of thousands of loc with the appropriate abstractions and dependencies. And not all old projects are many millions of loc."}]}]}],"thread_ts":"1611042258.273000","parent_user_id":"U85JBUGGP"},{"client_msg_id":"2848ba23-e6ad-41fb-b03e-fbdeb575e805","type":"message","text":"A 10k loc project in Julia can be finished in a year comfortably by one person during his/her free time.","user":"U85JBUGGP","ts":"1611095614.306700","team":"T68168MUP","edited":{"user":"U85JBUGGP","ts":"1611095622.000000"},"blocks":[{"type":"rich_text","block_id":"rPOo0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A 10k loc project in Julia can be finished in a year comfortably by one person during his/her free time."}]}]}],"thread_ts":"1611042258.273000","parent_user_id":"U85JBUGGP"},{"client_msg_id":"efe3678f-befc-4ba2-a231-b38d1eda5c45","type":"message","text":"But that is the point. They will spend months, if not years, trying to make significant improvements to the software. Whereas incrementally re-writing the code in higher level language will enable them to make those improvements much more quickly. About 20 years ago David Beasley, the creator of Python's SWIG, said that the Python interface to LANL's C++ magnetohydrodynamic code allowed the scientists to do more research in three months than in the previous three years.","user":"ULSFQ48UQ","ts":"1611099596.307000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JT6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But that is the point. They will spend months, if not years, trying to make significant improvements to the software. Whereas incrementally re-writing the code in higher level language will enable them to make those improvements much more quickly. About 20 years ago David Beasley, the creator of Python's SWIG, said that the Python interface to LANL's C++ magnetohydrodynamic code allowed the scientists to do more research in three months than in the previous three years."}]}]}],"thread_ts":"1611042258.273000","parent_user_id":"U85JBUGGP"}]