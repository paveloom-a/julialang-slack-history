[{"client_msg_id":"9ceb3fcc-1496-447f-869f-6eddf5113d43","type":"message","text":"I would really appreciate advice on how to make use of threads when solving a large system of ODEs.\nThe function being solved can be thought of as:\n 1) Assess all states and populate some matrices\n 2) Act on columns of those matrices individually to calculate derivatives\n\nThe way I'm attempting to do this (which may well be terrible, please tell me if so) is to create one `ODEProblem` per thread in which the first step runs, then wait for all threads to finish step 1, then continues with the second step on a range of the columns of the matrices. This means that the second step can be threaded which gives a good speed improvement.\n\nOne of the difficulties is that I need to sync the ODEProblems themselves to make sure they're always solving the same timestep, and the syncing in general is a bit nasty/inefficient.\n\nThis feels like a hacky way of doing this, and I'd be grateful for any advice on either how to do this better or if this is an OK way how to sync simultaneous solving of ODE problems.\n\nThanks in advance.\n\nExample code here:\n```function f!(du, u, p t)\n    # This function sets values used by all threads\n    f_global!(du, u, p)\n\n    # Need to sync all threads after f_global!\n    sync_thread(Threads.threadid())\n\n    # This function can be done on separate thread as per range and finish whenever\n    f_separate!(du, u, p)\nend\n\nranges = [1:10000, 10001:20000] # Assume two threads for this example\n# u0, t_range, p exist\n\nThreads.@threads for i in 1:Threads.nthreads()\n    range = ranges[Threads.threadid()]\n    prob = ODEProblem(f!, u0[range], t_range, p)\n    sol = solve(prob, Tsit5())\n    do_something_with_output(sol)\nend```\n","user":"U017FUJDBT7","ts":"1615436515.047400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QgeL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would really appreciate advice on how to make use of threads when solving a large system of ODEs.\nThe function being solved can be thought of as:\n 1) Assess all states and populate some matrices\n 2) Act on columns of those matrices individually to calculate derivatives\n\nThe way I'm attempting to do this (which may well be terrible, please tell me if so) is to create one "},{"type":"text","text":"ODEProblem","style":{"code":true}},{"type":"text","text":" per thread in which the first step runs, then wait for all threads to finish step 1, then continues with the second step on a range of the columns of the matrices. This means that the second step can be threaded which gives a good speed improvement.\n\nOne of the difficulties is that I need to sync the ODEProblems themselves to make sure they're always solving the same timestep, and the syncing in general is a bit nasty/inefficient.\n\nThis feels like a hacky way of doing this, and I'd be grateful for any advice on either how to do this better or if this is an OK way how to sync simultaneous solving of ODE problems.\n\nThanks in advance.\n\nExample code here:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f!(du, u, p t)\n    # This function sets values used by all threads\n    f_global!(du, u, p)\n\n    # Need to sync all threads after f_global!\n    sync_thread(Threads.threadid())\n\n    # This function can be done on separate thread as per range and finish whenever\n    f_separate!(du, u, p)\nend\n\nranges = [1:10000, 10001:20000] # Assume two threads for this example\n# u0, t_range, p exist\n\nThreads.@threads for i in 1:Threads.nthreads()\n    range = ranges[Threads.threadid()]\n    prob = ODEProblem(f!, u0[range], t_range, p)\n    sol = solve(prob, Tsit5())\n    do_something_with_output(sol)\nend"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1615436515.047400","reply_count":11,"reply_users_count":2,"latest_reply":"1615442899.049600","reply_users":["U69BL50BF","U017FUJDBT7"],"subscribed":false},{"client_msg_id":"22f79527-7eb4-4f9c-88d9-50b1f1c02d6f","type":"message","text":"Is it supposed to be one big ODE? I don't get how come they are supposed to sync","user":"U69BL50BF","ts":"1615437165.047500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/ZoE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it supposed to be one big ODE? I don't get how come they are supposed to sync"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"da9dffcf-222f-4ea7-9a66-33f96a05f1bc","type":"message","text":"Yeah its one big ODE. The first step in the function needs all of the states to populate some intermediate matrices and the second step just using the columns of that matrix. If I was doing it in one ODEProblem it would look like this:\n\n```function f!(du, u, p t)\n    f_global!(p, u, du) # modifies p\n\n    for (i, col) in enumerate(eachcol(p.intermediate_matrices))\n        du[i] = use_col(col, u[i])\n    end\nend```\nAnd I'd like the for loop to be threaded. It seems that just using `Threads.@threads` isn't fast, I think due to context switching. It needed to be synced if split up into multiple ODEProblems that are solved independently, as for `use_col` to work for any index `f_global!` has to have finished\n\nHope that makes more sense","user":"U017FUJDBT7","ts":"1615437598.047700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Biybc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah its one big ODE. The first step in the function needs all of the states to populate some intermediate matrices and the second step just using the columns of that matrix. If I was doing it in one ODEProblem it would look like this:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f!(du, u, p t)\n    f_global!(p, u, du) # modifies p\n\n    for (i, col) in enumerate(eachcol(p.intermediate_matrices))\n        du[i] = use_col(col, u[i])\n    end\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"And I'd like the for loop to be threaded. It seems that just using "},{"type":"text","text":"Threads.@threads","style":{"code":true}},{"type":"text","text":" isn't fast, I think due to context switching. It needed to be synced if split up into multiple ODEProblems that are solved independently, as for "},{"type":"text","text":"use_col","style":{"code":true}},{"type":"text","text":" to work for any index "},{"type":"text","text":"f_global!","style":{"code":true}},{"type":"text","text":" has to have finished\n\nHope that makes more sense"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"2e320907-3f45-4afc-a125-7e3b7d987ce6","type":"message","text":"<https://github.com/chriselrod/CheapThreads.jl> is worth a shot here then, with one ODE","user":"U69BL50BF","ts":"1615438422.047900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7cp","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/chriselrod/CheapThreads.jl"},{"type":"text","text":" is worth a shot here then, with one ODE"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7","reactions":[{"name":"+1","users":["U017FUJDBT7"],"count":1}]},{"client_msg_id":"e278ed82-8da1-4682-8d10-a2b4d409aa66","type":"message","text":"is that function completely non-allocating?","user":"U69BL50BF","ts":"1615438431.048100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FrUgK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is that function completely non-allocating?"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"54ee4aa9-0926-4196-b635-22b9434f6740","type":"message","text":"you'll want to make sure that's the case.","user":"U69BL50BF","ts":"1615438436.048300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LYa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you'll want to make sure that's the case."}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"084f4bad-15ad-4450-a7a9-dc8ff8ffcf29","type":"message","text":"Oh cool, I'll give that a go thanks. Yep all non-allocating.","user":"U017FUJDBT7","ts":"1615439353.048600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RmUnz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh cool, I'll give that a go thanks. Yep all non-allocating."}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"414ee1f0-b2b6-46f8-958e-1e97428a0b33","type":"message","text":"Just to double check I was correct - does it make a difference that it's a large system of ODEs (agent based model with a few thousand agents, each with a few states)? Also if there any example you can point me to of CheapThreads that would be appreciated. Cheers!","user":"U017FUJDBT7","ts":"1615440776.048800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kbeo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just to double check I was correct - does it make a difference that it's a large system of ODEs (agent based model with a few thousand agents, each with a few states)? Also if there any example you can point me to of CheapThreads that would be appreciated. Cheers!"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"5b246f87-0efc-4d7c-b5e7-69809192eb21","type":"message","text":"Octavian.jl uses CheapThreads.jl IIRC","user":"U69BL50BF","ts":"1615442610.049000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"29Xk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Octavian.jl uses CheapThreads.jl IIRC"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"37c52200-9266-4c7e-9bbf-848906a31778","type":"message","text":"having it as a single system should have a lot less overhead than trying to sync multiple ODEs","user":"U69BL50BF","ts":"1615442629.049200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WMP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"having it as a single system should have a lot less overhead than trying to sync multiple ODEs"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"2eded0c8-4ee9-4128-8338-fc50dfabe757","type":"message","text":"I looked at Octavian.jl but can only see ThreadingUtilities on there. Looks like there is a ForwardDiff example within CheapThreading though, so will try to use that","user":"U017FUJDBT7","ts":"1615442878.049400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=ort","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I looked at Octavian.jl but can only see ThreadingUtilities on there. Looks like there is a ForwardDiff example within CheapThreading though, so will try to use that"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"bba443ae-c1a2-41cd-8945-38c430c3b8e2","type":"message","text":"and that makes sense, cheers","user":"U017FUJDBT7","ts":"1615442899.049600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LBO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and that makes sense, cheers"}]}]}],"thread_ts":"1615436515.047400","parent_user_id":"U017FUJDBT7"}]