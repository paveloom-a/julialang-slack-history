[{"client_msg_id":"8a932b1e-211c-4c20-8e07-9082e0f9ee15","type":"message","text":"The first strategy (pretend it's `matmul`) sounds a bit naive, but given that the \"copying the tiles\" part has lower computational complexity, I was wondering whether it was enough to get things packed together to speed up the multiplication part (with `@simd` and `@inbounds`). (I hope this is not too fuzzy/unclear!)","user":"U6BJ9E351","ts":"1614074781.032800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9fSC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The first strategy (pretend it's "},{"type":"text","text":"matmul","style":{"code":true}},{"type":"text","text":") sounds a bit naive, but given that the \"copying the tiles\" part has lower computational complexity, I was wondering whether it was enough to get things packed together to speed up the multiplication part (with "},{"type":"text","text":"@simd","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":"). (I hope this is not too fuzzy/unclear!)"}]}]}],"thread_ts":"1614074781.032800","reply_count":4,"reply_users_count":2,"latest_reply":"1614180065.052900","reply_users":["U6BJ9E351","U67BJLYCS"],"subscribed":false},{"client_msg_id":"5e620f34-5970-43ff-a89a-565910357aae","type":"message","text":"Reason for asking is that I was trying to get some basic but not horribly slow implementation of `conv` and was wondering whether it needs an entirely new tiling strategy than matmul (that also considers say filter size and tiles the image with since redundance), or whether the same tiling strategy of matmul would work","user":"U6BJ9E351","ts":"1614075180.032900","team":"T68168MUP","edited":{"user":"U6BJ9E351","ts":"1614075194.000000"},"blocks":[{"type":"rich_text","block_id":"xOKg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Reason for asking is that I was trying to get some basic but not horribly slow implementation of "},{"type":"text","text":"conv ","style":{"code":true}},{"type":"text","text":"and was wondering whether it needs an entirely new tiling strategy than matmul (that also considers say filter size and tiles the image with since redundance), or whether the same tiling strategy of matmul would work"}]}]}],"thread_ts":"1614074781.032800","parent_user_id":"U6BJ9E351"},{"client_msg_id":"81a8999b-6666-4254-a101-2427f78ed2d0","type":"message","text":"I think the implementation strategy for conv depends on the filter size","user":"U67BJLYCS","ts":"1614171997.051300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mTOkk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the implementation strategy for conv depends on the filter size"}]}]}],"thread_ts":"1614074781.032800","parent_user_id":"U6BJ9E351"},{"client_msg_id":"df3adf47-0ad0-44df-9af2-f2026d4c1c0a","type":"message","text":"But I suspect an easy answer is you want a tile for the filter and another for the image","user":"U67BJLYCS","ts":"1614172035.051500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B8=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I suspect an easy answer is you want a tile for the filter and another for the image"}]}]}],"thread_ts":"1614074781.032800","parent_user_id":"U6BJ9E351"},{"client_msg_id":"12c8e014-c8b3-4b5e-bd18-0faf5c08a656","type":"message","text":"I'm in a bit of an odd scenario where it's not quite a conv, but something like `output[w, h] += filter[i, j] * input[f(i, w), g(h, j)]`, summing over `i, j`, where `f` and `g` can be less trivial than `+`. On the plus side, there are other simplifying assumptions that allow to copy the data in a packed format similar to <https://github.com/JuliaGPU/KernelAbstractions.jl/blob/master/examples/performant_matmul.jl>.\n\nFrom what I understand, when the function to get the index is a bit complex, this copying into shared memory is worth it, but I guess I should start benchmarking to get a more solid intuition (the performance examples in the docs are already super useful though!).","user":"U6BJ9E351","ts":"1614180065.052900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ck+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm in a bit of an odd scenario where it's not quite a conv, but something like "},{"type":"text","text":"output[w, h] += filter[i, j] * input[f(i, w), g(h, j)]","style":{"code":true}},{"type":"text","text":", summing over "},{"type":"text","text":"i, j","style":{"code":true}},{"type":"text","text":", where "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"g","style":{"code":true}},{"type":"text","text":" can be less trivial than "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":". On the plus side, there are other simplifying assumptions that allow to copy the data in a packed format similar to "},{"type":"link","url":"https://github.com/JuliaGPU/KernelAbstractions.jl/blob/master/examples/performant_matmul.jl"},{"type":"text","text":".\n\nFrom what I understand, when the function to get the index is a bit complex, this copying into shared memory is worth it, but I guess I should start benchmarking to get a more solid intuition (the performance examples in the docs are already super useful though!)."}]}]}],"thread_ts":"1614074781.032800","parent_user_id":"U6BJ9E351"}]