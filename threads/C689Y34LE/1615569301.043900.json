[{"client_msg_id":"0d640423-7ab9-4f43-8f8d-25e188cf0f79","type":"message","text":"Do any of you know what/where I need to start to make a kernel implementation using Julia as fast as nvcc implementation? I have two different kernel implementations, one is written in C using nvcc and the other in Julia. They are almost the same, except inevitable changes such as a pointer to array in C being implemented using CuDeviceArray in Julia. They were launched using the same kernel configuration. Currently, nvcc implementation is 6 times faster than Julia, and I would like to reduce this performance gap.\n\nIt seems that generated code is very different. In the case of nvcc, the maximum number of registers was 190 but it was 250 for Julia. When I used nvcc, I set `maxrregcount`  to 96 for better occupancy and saw about 30% improvement. I tried similar things for Julia implementation by trying different values of `maxregs` but with no luck. Any help will be greatly appreciated.","user":"U01FXSDEXN3","ts":"1615569301.043900","team":"T68168MUP","edited":{"user":"U01FXSDEXN3","ts":"1615569513.000000"},"blocks":[{"type":"rich_text","block_id":"vZb51","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Do any of you know what/where I need to start to make a kernel implementation using Julia as fast as nvcc implementation? I have two different kernel implementations, one is written in C using nvcc and the other in Julia. They are almost the same, except inevitable changes such as a pointer to array in C being implemented using CuDeviceArray in Julia. They were launched using the same kernel configuration. Currently, nvcc implementation is 6 times faster than Julia, and I would like to reduce this performance gap.\n\nIt seems that generated code is very different. In the case of nvcc, the maximum number of registers was 190 but it was 250 for Julia. When I used nvcc, I set "},{"type":"text","text":"maxrregcount","style":{"code":true}},{"type":"text","text":"  to 96 for better occupancy and saw about 30% improvement. I tried similar things for Julia implementation by trying different values of "},{"type":"text","text":"maxregs","style":{"code":true}},{"type":"text","text":" but with no luck. Any help will be greatly appreciated."}]}]}],"thread_ts":"1615569301.043900","reply_count":3,"reply_users_count":2,"latest_reply":"1615570183.044800","reply_users":["U68A3ASP9","U01FXSDEXN3"],"subscribed":false},{"client_msg_id":"4fd90423-6283-4f2b-80cd-8e7e94a4993a","type":"message","text":"are you using `@inbounds` etc? also try to avoid unnecessary type conversions","user":"U68A3ASP9","ts":"1615569954.044400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1EJw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"are you using "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" etc? also try to avoid unnecessary type conversions"}]}]}],"thread_ts":"1615569301.043900","parent_user_id":"U01FXSDEXN3"},{"client_msg_id":"1dc4635f-cdf3-44d8-bb61-bbb7bf3abe17","type":"message","text":"generally Julia GPU code can be as fast or faster than C code compiler with nvcc","user":"U68A3ASP9","ts":"1615569967.044600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nluQC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"generally Julia GPU code can be as fast or faster than C code compiler with nvcc"}]}]}],"thread_ts":"1615569301.043900","parent_user_id":"U01FXSDEXN3"},{"client_msg_id":"d8fb4056-1ec0-46e9-8f5d-1c55a3122db0","type":"message","text":"Yes, I'm using `@inbounds` to every for loop. I think I do one type conversion for shared memory at the beginning of my kernel; a chunk of dynamic shared memory (amount to 2KB) is allocated and is assigned to two different data types, Int and Float64. Except that there's no type conversion I think...","user":"U01FXSDEXN3","ts":"1615570183.044800","team":"T68168MUP","edited":{"user":"U01FXSDEXN3","ts":"1615570269.000000"},"blocks":[{"type":"rich_text","block_id":"BY5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, I'm using "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" to every for loop. I think I do one type conversion for shared memory at the beginning of my kernel; a chunk of dynamic shared memory (amount to 2KB) is allocated and is assigned to two different data types, Int and Float64. Except that there's no type conversion I think..."}]}]}],"thread_ts":"1615569301.043900","parent_user_id":"U01FXSDEXN3"}]