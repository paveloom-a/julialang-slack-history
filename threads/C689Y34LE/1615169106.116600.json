[{"client_msg_id":"4fc743e4-9ac1-4a17-86a2-586d0676a013","type":"message","text":"I just had an interesting bug. I wonder if it's a well-known pitfall. I had a CUDA kernel like this\n\n```function kernel(...)\n    acc = basecase(...)  # acc can be of different type for different thread\n    combine(acc, ...)    # uses sync_threads() in a loop\nend```\nand now I'm trying to make it work for the case where `acc` is a small `Union`.\n\nSince a method dispatch is a branch after everything is inlined, the above code tries to synchronize threads that are in different branches and hence deadlocks (or at least that's my theory for why it didn't work). It's obvious in hindsight but I had no idea when I was first writing the code. (<https://github.com/JuliaFolds/FoldsCUDA.jl/pull/49/commits/6fee3d172c68dc58b813f6b7e61a58470ace5b01#diff-d8ec7579b0bb38bbb8581baf2a6398e4b19d7859e670f009a6058a62a29b8ba4R198-R202>)\n\nAlso, this makes me wonder if union splitting can potentially introduce a deadlock, if the compiler is written for sequential programs in mind. (cc <@U67BJLYCS>)","user":"UC7AF7NSU","ts":"1615169106.116600","team":"T68168MUP","edited":{"user":"UC7AF7NSU","ts":"1615169488.000000"},"blocks":[{"type":"rich_text","block_id":"0eMeb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just had an interesting bug. I wonder if it's a well-known pitfall. I had a CUDA kernel like this\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function kernel(...)\n    acc = basecase(...)  # acc can be of different type for different thread\n    combine(acc, ...)    # uses sync_threads() in a loop\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nand now I'm trying to make it work for the case where "},{"type":"text","text":"acc","style":{"code":true}},{"type":"text","text":" is a small "},{"type":"text","text":"Union","style":{"code":true}},{"type":"text","text":".\n\nSince a method dispatch is a branch after everything is inlined, the above code tries to synchronize threads that are in different branches and hence deadlocks (or at least that's my theory for why it didn't work). It's obvious in hindsight but I had no idea when I was first writing the code. ("},{"type":"link","url":"https://github.com/JuliaFolds/FoldsCUDA.jl/pull/49/commits/6fee3d172c68dc58b813f6b7e61a58470ace5b01#diff-d8ec7579b0bb38bbb8581baf2a6398e4b19d7859e670f009a6058a62a29b8ba4R198-R202"},{"type":"text","text":")\n\nAlso, this makes me wonder if union splitting can potentially introduce a deadlock, if the compiler is written for sequential programs in mind. (cc "},{"type":"user","user_id":"U67BJLYCS"},{"type":"text","text":")"}]}]}],"thread_ts":"1615169106.116600","reply_count":6,"reply_users_count":2,"latest_reply":"1615187440.118400","reply_users":["UC7AF7NSU","U68A3ASP9"],"subscribed":false},{"client_msg_id":"b938578c-32e5-48c3-ada1-ac2c4957a44b","type":"message","text":"(x-post <https://julialang.zulipchat.com/#narrow/stream/225940-gpu/topic/CUDA.2Esync_threads.20and.20Union.20splitting/near/229237215>)","user":"UC7AF7NSU","ts":"1615169623.116800","team":"T68168MUP","attachments":[{"service_name":"Zulip","title":"JuliaLang","title_link":"https://julialang.zulipchat.com/#narrow/stream/225940-gpu/topic/CUDA.2Esync_threads.20and.20Union.20splitting/near/229237215","text":"This is the Zulip server for the Julia programming language community. We ask anyone joining to adhere to the Julia Code of Conduct. | To learn more about Julia, check out <https://julialang.org/>, or just come ask us here! | You can reach out to the admins of this Zulip by sending a direct message to @zulip-admins.","fallback":"Zulip: JuliaLang","thumb_url":"https://zulip-avatars.s3.amazonaws.com/7178/realm/icon.png?version=6","from_url":"https://julialang.zulipchat.com/#narrow/stream/225940-gpu/topic/CUDA.2Esync_threads.20and.20Union.20splitting/near/229237215","thumb_width":100,"thumb_height":100,"id":1,"original_url":"https://julialang.zulipchat.com/#narrow/stream/225940-gpu/topic/CUDA.2Esync_threads.20and.20Union.20splitting/near/229237215"}],"blocks":[{"type":"rich_text","block_id":"/=Xzq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(x-post "},{"type":"link","url":"https://julialang.zulipchat.com/#narrow/stream/225940-gpu/topic/CUDA.2Esync_threads.20and.20Union.20splitting/near/229237215"},{"type":"text","text":")"}]}]}],"thread_ts":"1615169106.116600","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"ae89b163-9af9-4901-8179-161b37de1305","type":"message","text":"ha, that's cute/surprising! in the end it's just data-dependent control flow, although the union + dispatch obfuscates that a little. I wouldn't say the compiler is really to blame here, as the code was unstable (data dependent) to begin with.","user":"U68A3ASP9","ts":"1615186132.117600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LdLo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ha, that's cute/surprising! in the end it's just data-dependent control flow, although the union + dispatch obfuscates that a little. I wouldn't say the compiler is really to blame here, as the code was unstable (data dependent) to begin with."}]}]}],"thread_ts":"1615169106.116600","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"029f940d-dd03-4ac6-8c52-1474a6c3fb8e","type":"message","text":"there isn't a good way to compile this even if the compiler was written for parallel programs in mind, since you really want to be calling two different functions on different threads here.","user":"U68A3ASP9","ts":"1615186178.117800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T/pZm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there isn't a good way to compile this even if the compiler was written for parallel programs in mind, since you really want to be calling two different functions on different threads here."}]}]}],"thread_ts":"1615169106.116600","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"4425f5d9-29ee-4860-adc2-19008397eb6d","type":"message","text":"Yeah, I think I'm OK with a bit of thread divergence and my example itself is not much to do with the compiler.\n\nIn the last comment I was rather interested in \"correctness\" (= deadlock out of thin air) of a possible optimization. I was thinking something like\n\n```acc::Union{A,B}\nfor x in xs\n    acc = f(acc, x)\n    sync_threads()\nend```\nIf the Julia compiler infers that `f` is actually type stable, i.e., `f(::A, x) :: A` and `f(::B, x) :: B`, then it can (for serial program), in principle, optimize this to\n\n```acc::Union{A,B}\nif acc isa A\n    for x in xs\n        acc = f(acc::A, x)::A\n        sync_threads()\n    end\nelse\n    for x in xs\n        acc = f(acc::B, x)::B\n        sync_threads()\n    end\nend```\nBut I'm guessing that above program will cause a deadlock?","user":"UC7AF7NSU","ts":"1615187065.118000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GVv=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I think I'm OK with a bit of thread divergence and my example itself is not much to do with the compiler.\n\nIn the last comment I was rather interested in \"correctness\" (= deadlock out of thin air) of a possible optimization. I was thinking something like\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"acc::Union{A,B}\nfor x in xs\n    acc = f(acc, x)\n    sync_threads()\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nIf the Julia compiler infers that "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" is actually type stable, i.e., "},{"type":"text","text":"f(::A, x) :: A","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"f(::B, x) :: B","style":{"code":true}},{"type":"text","text":", then it can (for serial program), in principle, optimize this to\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"acc::Union{A,B}\nif acc isa A\n    for x in xs\n        acc = f(acc::A, x)::A\n        sync_threads()\n    end\nelse\n    for x in xs\n        acc = f(acc::B, x)::B\n        sync_threads()\n    end\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nBut I'm guessing that above program will cause a deadlock?"}]}]}],"thread_ts":"1615169106.116600","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"5ed4503e-6f49-496b-883e-605110fe528f","type":"message","text":"I'm not sure if optimization like this already exists, though. Even if not, I actually want this optimization for serial programs and maybe even try to implement this myself. But then I realized that it could break SIMT programs, IIUC.","user":"UC7AF7NSU","ts":"1615187238.118200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"q3/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure if optimization like this already exists, though. Even if not, I actually want this optimization for serial programs and maybe even try to implement this myself. But then I realized that it could break SIMT programs, IIUC."}]}]}],"thread_ts":"1615169106.116600","parent_user_id":"UC7AF7NSU"},{"client_msg_id":"ef04d0ed-4707-4883-9075-b9b20b9215bb","type":"message","text":"that will probably deadlock, unless the sync and for loop can be hoisted from the branch","user":"U68A3ASP9","ts":"1615187440.118400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bR/N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that will probably deadlock, unless the sync and for loop can be hoisted from the branch"}]}]}],"thread_ts":"1615169106.116600","parent_user_id":"UC7AF7NSU"}]