[{"client_msg_id":"b77a4196-3d6a-4f08-b224-2c61dd149329","type":"message","text":"Is anyone here familiar with Nix/Guix? I'm trying to better understand the difference in approaches taking by Nix/Guix and BinaryBuilder, especially in the context of (1) patching binaries and (2) the handling of machine-specific libs like libGL.","user":"ULR33SMHB","ts":"1616779363.073400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9ywfV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is anyone here familiar with Nix/Guix? I'm trying to better understand the difference in approaches taking by Nix/Guix and BinaryBuilder, especially in the context of (1) patching binaries and (2) the handling of machine-specific libs like libGL."}]}]}],"thread_ts":"1616779363.073400","reply_count":12,"reply_users_count":4,"latest_reply":"1616817776.084400","reply_users":["U6A936746","ULR33SMHB","UDB26738Q","U677R5Q5A"],"is_locked":false,"subscribed":false},{"client_msg_id":"ce8d55e8-2500-4793-8374-87dfc0f9dacf","type":"message","text":"<@U677R5Q5A>","user":"U6A936746","ts":"1616779819.073700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wZdRA","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U677R5Q5A"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"93a925fe-a172-40a0-a44d-6da381ae0172","type":"message","text":"So far I've gathered (possibly incorrectly) that:\n\n1) Nix loads all libraries from /nix/store, while binaries built with BinaryBuilder load most, but not all, libraries from ~/julia/artifacts. Looking at dllist() for GLFW, for example, it loads \"libdl.so.2, libpthread.so.0, libc.so.6, ld-linux-x86-64.so.2, librt.so.1, libm.so.6, libXxf86vm.so.1\" from /lib.\n2) Nix patches RUNPATH and hardcoded dlopen calls to point to libraries under /nix/store. BinaryBuilder patches\nRUNPATH to $ORIGIN (unsure what it does for hardcoded dlopen calls).\n3) Nix uses a custom ld that excludes /etc/ld.so.cache and the default search paths. BinaryBuilder doesn't (and so can fallback to system libraries that aren't shipped as artifacts).\n4) BinaryBuilder ships libGL through Libglvnd_jll rather than relying on the system's libGL/drivers.\n\nWhatever black magic y'all have put into BinaryBuilder seems to just work. Especially when it comes to graphical packages that depend on libGL. I'm hoping to learn what that black magic is and how it differs from what Nix/Nixpkgs does so that I can try and emulate it over there.","user":"ULR33SMHB","ts":"1616786689.076600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"stby","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So far I've gathered (possibly incorrectly) that:\n\n1) Nix loads all libraries from /nix/store, while binaries built with BinaryBuilder load most, but not all, libraries from ~/julia/artifacts. Looking at dllist() for GLFW, for example, it loads \"libdl.so.2, libpthread.so.0, libc.so.6, ld-linux-x86-64.so.2, librt.so.1, libm.so.6, libXxf86vm.so.1\" from /lib.\n2) Nix patches RUNPATH and hardcoded dlopen calls to point to libraries under /nix/store. BinaryBuilder patches\nRUNPATH to $ORIGIN (unsure what it does for hardcoded dlopen calls).\n3) Nix uses a custom ld that excludes /etc/ld.so.cache and the default search paths. BinaryBuilder doesn't (and so can fallback to system libraries that aren't shipped as artifacts).\n4) BinaryBuilder ships libGL through Libglvnd_jll rather than relying on the system's libGL/drivers.\n\nWhatever black magic y'all have put into BinaryBuilder seems to just work. Especially when it comes to graphical packages that depend on libGL. I'm hoping to learn what that black magic is and how it differs from what Nix/Nixpkgs does so that I can try and emulate it over there."}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"b0278f05-7d96-414a-ae6e-6bd4aacb4777","type":"message","text":"I know Pontus is actively working on that for NixOS, so can probably share his tricks","user":"UDB26738Q","ts":"1616786847.076800","team":"T68168MUP","edited":{"user":"UDB26738Q","ts":"1616786871.000000"},"blocks":[{"type":"rich_text","block_id":"fYu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I know Pontus is actively working on that for NixOS, so can probably share his tricks"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"3bfde80d-1277-4e12-9ba6-276e89698b45","type":"message","text":"my understanding is that running executables is the main issue, but libraries mostly work out-of-the-box","user":"UDB26738Q","ts":"1616786923.077100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uW1RV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"my understanding is that running executables is the main issue, but libraries mostly work out-of-the-box"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"62d89dc9-f45e-4d2f-a59f-14f194b87895","type":"message","text":"The story for NixOS is a bit better: they patch their glvnd to look under '/run/opengl-driver/lib' and then install machine-specific libGL + deps into their. On non-NixOS/FHS systems that directory doesn't exist, so anything that depends on libGL fails on e.g. Ubuntu. There's ad-hoc attempt to address this (<https://github.com/guibou/nixGL>) by wrapping executables in a script that tries to detect the system's driver versions and install them in a place Nix's patched loader looks, but it's a bit fragile and doesn't work everywhere.","user":"ULR33SMHB","ts":"1616787411.077300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"STF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The story for NixOS is a bit better: they patch their glvnd to look under '/run/opengl-driver/lib' and then install machine-specific libGL + deps into their. On non-NixOS/FHS systems that directory doesn't exist, so anything that depends on libGL fails on e.g. Ubuntu. There's ad-hoc attempt to address this ("},{"type":"link","url":"https://github.com/guibou/nixGL"},{"type":"text","text":") by wrapping executables in a script that tries to detect the system's driver versions and install them in a place Nix's patched loader looks, but it's a bit fragile and doesn't work everywhere."}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"f72a7e57-127d-4cc1-8546-a9f1abfb82a0","type":"message","text":"<@UDB26738Q> are you familiar with how BinaryBuilder/Libglvnd handles (4) above for systems that may require some very specific versions of libGL/CUDA (like the Nvidia Jetson platform)? Does it use system libraries at all?","user":"ULR33SMHB","ts":"1616787497.077500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2aSH","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UDB26738Q"},{"type":"text","text":" are you familiar with how BinaryBuilder/Libglvnd handles (4) above for systems that may require some very specific versions of libGL/CUDA (like the Nvidia Jetson platform)? Does it use system libraries at all?"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"fe35965a-2466-4546-aca8-e3c8e6ca5c5c","type":"message","text":"I built libglvnd, so I guess I should say I'm familiar: <https://github.com/JuliaPackaging/Yggdrasil/blob/master/L/Libglvnd/build_tarballs.jl> :sweat_smile:","user":"UDB26738Q","ts":"1616787565.077700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zoFOx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I built libglvnd, so I guess I should say I'm familiar: "},{"type":"link","url":"https://github.com/JuliaPackaging/Yggdrasil/blob/master/L/Libglvnd/build_tarballs.jl"},{"type":"text","text":" "},{"type":"emoji","name":"sweat_smile"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"ffe1e696-73cb-4ca5-9b6b-950823b4322d","type":"message","text":"but we don't use any system library, as far as I know","user":"UDB26738Q","ts":"1616787589.077900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vBl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but we don't use any system library, as far as I know"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"eaff569f-88bc-4832-a8d0-432db3c2e4f0","type":"message","text":"Ahh that's right. I remember you building that awhile ago when you were trying to help me package that weird mujoco binary.","user":"ULR33SMHB","ts":"1616787617.078100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cw+g","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ahh that's right. I remember you building that awhile ago when you were trying to help me package that weird mujoco binary."}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB","reactions":[{"name":"+1","users":["UDB26738Q"],"count":1}]},{"client_msg_id":"3f2b0f2b-28b5-408d-b96d-d6d73992e03e","type":"message","text":"I think I have a Jetson somewhere. I'm curious to see if Libglvnd works on that platform.","user":"ULR33SMHB","ts":"1616787647.078400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gC7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think I have a Jetson somewhere. I'm curious to see if Libglvnd works on that platform."}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"51265d4c-8479-48c1-a794-f739afacece8","type":"message","text":"I think you are correct in all that you state <@ULR33SMHB> – although you seem to be more familiar with the loading mechanism than myself. From my own experience, libraries from BinaryBuilder “just works” on NixOS, but executable binaries do not and needs a light touch up from patchelf to work. My plan since autumn has been to construct a patch for Pkg that does this automatically, but being a tenured academic and recent father makes time scarce. I have notes somewhere from discussions with a few core Julia devs that I could share if you want to take a stab at this. My goal is to have a Julia-Nix fork that has a set of minimal patches to make Julia Nix compatible but that are not suitable to upstream: <https://sr.ht/~ninjin/julia-nix/>","user":"U677R5Q5A","ts":"1616816629.084200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"U6ZJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think you are correct in all that you state "},{"type":"user","user_id":"ULR33SMHB"},{"type":"text","text":" – although you seem to be more familiar with the loading mechanism than myself. From my own experience, libraries from BinaryBuilder “just works” on NixOS, but executable binaries do not and needs a light touch up from patchelf to work. My plan since autumn has been to construct a patch for Pkg that does this automatically, but being a tenured academic and recent father makes time scarce. I have notes somewhere from discussions with a few core Julia devs that I could share if you want to take a stab at this. My goal is to have a Julia-Nix fork that has a set of minimal patches to make Julia Nix compatible but that are not suitable to upstream: "},{"type":"link","url":"https://sr.ht/~ninjin/julia-nix/"}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"},{"client_msg_id":"028921b7-2a66-45cf-9771-ecad2044edd7","type":"message","text":"Created <#C01SM0JR1J7|nix> since we are now a handful of people chatting along about these things in various places.","user":"U677R5Q5A","ts":"1616817776.084400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Pm/0X","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Created "},{"type":"channel","channel_id":"C01SM0JR1J7"},{"type":"text","text":" since we are now a handful of people chatting along about these things in various places."}]}]}],"thread_ts":"1616779363.073400","parent_user_id":"ULR33SMHB"}]