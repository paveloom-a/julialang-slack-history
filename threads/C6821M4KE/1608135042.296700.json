[{"client_msg_id":"25fa8c5d-c7f4-4068-8f4f-028d146b55c8","type":"message","text":"Thanks for inviting me here, <@U67431ELR>. I'm not (yet) familiar with the stats ecosystem, so I don't think I can really help on where things should live. But in the discussion that I followed so far (the FreqTable PR), I was thinking whether one should indeed define methods in some `*Base` package, and then let other packages (including Distances.jl) import and extend them. Another example is the `return_type` function, that seems to be fairly generic (and, as you know, people were showing interest in extending it), but is owned by the rather narrow Distances.jl package. Moving that to some kind of base-package for the most generic case seems reasonable to me.","user":"U011TRN4QBU","ts":"1608135042.296700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hE1v","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for inviting me here, "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":". I'm not (yet) familiar with the stats ecosystem, so I don't think I can really help on where things should live. But in the discussion that I followed so far (the FreqTable PR), I was thinking whether one should indeed define methods in some "},{"type":"text","text":"*Base","style":{"code":true}},{"type":"text","text":" package, and then let other packages (including Distances.jl) import and extend them. Another example is the "},{"type":"text","text":"return_type","style":{"code":true}},{"type":"text","text":" function, that seems to be fairly generic (and, as you know, people were showing interest in extending it), but is owned by the rather narrow Distances.jl package. Moving that to some kind of base-package for the most generic case seems reasonable to me."}]}]}],"thread_ts":"1608135042.296700","reply_count":9,"reply_users_count":2,"latest_reply":"1608138713.298500","reply_users":["U67431ELR","U011TRN4QBU"],"subscribed":false,"reactions":[{"name":"+1","users":["U7QLM6E2E"],"count":1}]},{"client_msg_id":"d2662cc3-b7d8-4e2b-82bd-d8b73206ea4d","type":"message","text":"OK. StatsBase would be a relatively natural home for this, but currently Distances doesn't depend on it. We could add it to Statistics, but then we would have to be sure the API is good since it will be set in stone for some time.","user":"U67431ELR","ts":"1608135495.296800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PAByT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"OK. StatsBase would be a relatively natural home for this, but currently Distances doesn't depend on it. We could add it to Statistics, but then we would have to be sure the API is good since it will be set in stone for some time."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"57210d97-a7cb-4acb-b897-4089f0644454","type":"message","text":"I guess the simplest approach is to define an empty function in DataAPI and have StatsBase and Distances each define methods for it. Then if we're happy with the API we can move the general method to Statistics later (like many things in StatsBase).","user":"U67431ELR","ts":"1608136339.297100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cV7Um","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess the simplest approach is to define an empty function in DataAPI and have StatsBase and Distances each define methods for it. Then if we're happy with the API we can move the general method to Statistics later (like many things in StatsBase)."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"898f7546-9dca-40d8-aabd-1f0a19c6d513","type":"message","text":"That sounds good. The only question is whether whatever package we pick for the empty function adds little to the start-up time of Distances.jl. I think that is Kristoffer's main concern.","user":"U011TRN4QBU","ts":"1608137095.297300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pHvW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That sounds good. The only question is whether whatever package we pick for the empty function adds little to the start-up time of Distances.jl. I think that is Kristoffer's main concern."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"2ca77fbc-406b-49e5-8ee2-c971aa69daaf","type":"message","text":"Yeah. The advantage of DataAPI is that it only contains a few empty definitions so it's very lightweight (that's kind of the point).","user":"U67431ELR","ts":"1608137128.297500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R3G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah. The advantage of DataAPI is that it only contains a few empty definitions so it's very lightweight (that's kind of the point)."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"d55755d0-8c8d-4536-bc73-5071d91d6f4b","type":"message","text":"Haha, that's a whole new world of packages for me. I've never heard of DataAPI.jl.","user":"U011TRN4QBU","ts":"1608137172.297700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lM8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Haha, that's a whole new world of packages for me. I've never heard of DataAPI.jl."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"c0570485-556d-419d-8cd2-e4ff4d71e8df","type":"message","text":"Sounds like we should move the generic `result_type` , and empty  `pairwise` and `colwise`  there?","user":"U011TRN4QBU","ts":"1608137525.297900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8cCWh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sounds like we should move the generic "},{"type":"text","text":"result_type","style":{"code":true}},{"type":"text","text":" , and empty  "},{"type":"text","text":"pairwise","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"colwise","style":{"code":true}},{"type":"text","text":"  there?"}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"490a8d39-b3f5-4f66-91b0-1144d521facb","type":"message","text":"I'm not sure. I'm not a great fan of `colwise` since it can be replaced with `map(d, eachcol(x), eachcol(y))` , which wasn't possible when `colwise` was introduced. As for `result_type`, it's tricky because it seems very general, yet works only for some operations which return a single value when passed vectors. So it's a good fit for Distances but hard to generalize.","user":"U67431ELR","ts":"1608137845.298100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BZcoX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure. I'm not a great fan of "},{"type":"text","text":"colwise","style":{"code":true}},{"type":"text","text":" since it can be replaced with "},{"type":"text","text":"map(d, eachcol(x), eachcol(y))","style":{"code":true}},{"type":"text","text":" , which wasn't possible when "},{"type":"text","text":"colwise","style":{"code":true}},{"type":"text","text":" was introduced. As for "},{"type":"text","text":"result_type","style":{"code":true}},{"type":"text","text":", it's tricky because it seems very general, yet works only for some operations which return a single value when passed vectors. So it's a good fit for Distances but hard to generalize."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"ca2065e2-1e59-4a2c-9bca-f5377b585231","type":"message","text":"I agree. Given that `pairwise` is also nothing but `map(d, Iterators.product(eachcol(a), eachcol(b)))`, I wonder what the future purpose of both `colwise` and `pairwise` should be. If, in the future, we ask to provide iterators only, then what remains is to build their `zip` or their `product`. So their only function seems to be to provide some convenience, no? From the point of view of Distances.jl, if we wouldn't provide that convenience at all, but ask people to write out the composed iterators themselves, then what remains is the bare definitions of the distances, well, and specialized, more performant implementations of a few `pairwise` methods.","user":"U011TRN4QBU","ts":"1608138532.298300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P=n29","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree. Given that "},{"type":"text","text":"pairwise","style":{"code":true}},{"type":"text","text":" is also nothing but "},{"type":"text","text":"map(d, Iterators.product(eachcol(a), eachcol(b)))","style":{"code":true}},{"type":"text","text":", I wonder what the future purpose of both "},{"type":"text","text":"colwise","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"pairwise","style":{"code":true}},{"type":"text","text":" should be. If, in the future, we ask to provide iterators only, then what remains is to build their "},{"type":"text","text":"zip","style":{"code":true}},{"type":"text","text":" or their "},{"type":"text","text":"product","style":{"code":true}},{"type":"text","text":". So their only function seems to be to provide some convenience, no? From the point of view of Distances.jl, if we wouldn't provide that convenience at all, but ask people to write out the composed iterators themselves, then what remains is the bare definitions of the distances, well, and specialized, more performant implementations of a few "},{"type":"text","text":"pairwise","style":{"code":true}},{"type":"text","text":" methods."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"},{"client_msg_id":"03bd2394-31d4-4702-ae4d-ab6805beb6ed","type":"message","text":"I'd say `pairwise` is a bit different because the replacement syntax is a bit more complex, and as you say optimized implementations can be provided. More fundamentally, we really need it to be able to skip missing values (see my PR), which is currently not supported by e.g. `cor`.","user":"U67431ELR","ts":"1608138713.298500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nAa2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd say "},{"type":"text","text":"pairwise","style":{"code":true}},{"type":"text","text":" is a bit different because the replacement syntax is a bit more complex, and as you say optimized implementations can be provided. More fundamentally, we really need it to be able to skip missing values (see my PR), which is currently not supported by e.g. "},{"type":"text","text":"cor","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1608135042.296700","parent_user_id":"U011TRN4QBU"}]