[{"client_msg_id":"8c65d16f-99cb-49e9-b414-a26cd417af1f","type":"message","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc","user":"U017D4RFTFC","ts":"1616086340.012400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bwy7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc"}]}]}],"thread_ts":"1616086340.012400","reply_count":12,"reply_users_count":5,"latest_reply":"1616393038.035900","reply_users":["UHDQQ4GN6","U011ZPCEL2E","U6BJ9E351","U6A936746","ULD19UCPK"],"subscribed":false},{"client_msg_id":"42202c3f-d2ec-4629-a08c-782cf7d53e39","type":"message","text":"As I understand, no, mutation is still a ways off.","user":"UHDQQ4GN6","ts":"1616087304.012500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cV3+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As I understand, no, mutation is still a ways off."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC","reactions":[{"name":"point_up","users":["U6A936746","U6YRZ18GZ"],"count":2},{"name":"cry","users":["UKJSNT1QR","UP95S4864","UGU761DU2"],"count":3}]},{"client_msg_id":"027AF3CD-06B5-46C1-B4A4-A7B382D4496D","type":"message","text":"AD newbie question: what makes mutation difficult for reverse-mode AD? As a side note, it seems as if pytorch supports a limited form of mutation according to their 2019 paper, but it’s not really elaborated on in detail there and I’m not sure what the current state of mutation in pytorch is now.","user":"U011ZPCEL2E","ts":"1616241210.023100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oze2W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"AD newbie question: what makes mutation difficult for reverse-mode AD? As a side note, it seems as if pytorch supports a limited form of mutation according to their 2019 paper, but it’s not really elaborated on in detail there and I’m not sure what the current state of mutation in pytorch is now."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"c64a2fba-d80f-4ba6-9ac1-a0c3b98796bf","type":"message","text":"I don't really understand it. Something to do with aliasing. And it's not a reverse-mode AD issue. e.g. I believe ReverseDiff has no problems with mutation. It's I think a source-to-source difficulty.","user":"UHDQQ4GN6","ts":"1616269741.023400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Nj6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't really understand it. Something to do with aliasing. And it's not a reverse-mode AD issue. e.g. I believe ReverseDiff has no problems with mutation. It's I think a source-to-source difficulty."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC","reactions":[{"name":"point_up","users":["U6A936746"],"count":1},{"name":"thankyou","users":["U011ZPCEL2E"],"count":1}]},{"client_msg_id":"396f2e71-17fe-4306-8ed7-5dbcafec10ad","type":"message","text":"The key issue is that the \"pullback\" of reverse-mode rules often uses arrays that are pre-computed in the forward pass. (They are \"closed over\" in the closures that the reverse-mode rule returns.) For example, the reverse rule for the activation function in a neural net will use the tensor containing the input values passed to the activation function.\n\nIf, further down the line, those \"closed-over arrays\" are mutated, the pullback rule becomes wrong. As the pullback is computed after the whole forward pass, you will actually get wrong results in practice.\n\nTo solve it generally, the AD should make copies before mutating (which loses the performance benefits) or somehow prove that the mutation does not affect any pullback closure. The latter occurs reasonably frequently in practice, but I guess it's hard to prove it for the reverse-mode library.","user":"U6BJ9E351","ts":"1616322290.025300","team":"T68168MUP","edited":{"user":"U6BJ9E351","ts":"1616322393.000000"},"blocks":[{"type":"rich_text","block_id":"52uJ/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The key issue is that the \"pullback\" of reverse-mode rules often uses arrays that are pre-computed in the forward pass. (They are \"closed over\" in the closures that the reverse-mode rule returns.) For example, the reverse rule for the activation function in a neural net will use the tensor containing the input values passed to the activation function.\n\nIf, further down the line, those \"closed-over arrays\" are mutated, the pullback rule becomes wrong. As the pullback is computed after the whole forward pass, you will actually get wrong results in practice.\n\nTo solve it generally, the AD should make copies before mutating (which loses the performance benefits) or somehow prove that the mutation does not affect any pullback closure. The latter occurs reasonably frequently in practice, but I guess it's hard to prove it for the reverse-mode library."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"fb62ff8d-eff4-4dff-b374-3f3a059488db","type":"message","text":"Ideally, it should be possible to \"freeze\" arrays (ie, mark as \"read-only\") when they are passed to a closure. so that mutation only errors if the array is being used in one of the pullbacks (I imagine `Zygote.Buffer`  does something along these lines).","user":"U6BJ9E351","ts":"1616322470.025600","team":"T68168MUP","edited":{"user":"U6BJ9E351","ts":"1616322708.000000"},"blocks":[{"type":"rich_text","block_id":"PcTQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ideally, it should be possible to \"freeze\" arrays (ie, mark as \"read-only\") when they are passed to a closure. so that mutation only errors if the array is being used in one of the pullbacks (I imagine "},{"type":"text","text":"Zygote.Buffer","style":{"code":true}},{"type":"text","text":"  does something along these lines)."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"79556184-9313-4a75-83f8-4c19ab45ed71","type":"message","text":"That's part of it, but IIRC there's a reason we don't just write rules for reversible mutating functions that has something to do with aliasing. Maybe <@U6A936746> can explain.","user":"UHDQQ4GN6","ts":"1616347093.027800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wAPE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's part of it, but IIRC there's a reason we don't just write rules for reversible mutating functions that has something to do with aliasing. Maybe "},{"type":"user","user_id":"U6A936746"},{"type":"text","text":" can explain."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"b3d8ef32-601d-4d68-a626-8eed40e875f7","type":"message","text":"I can not explain. I wish I understood it properly myself.","user":"U6A936746","ts":"1616350804.028200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mtwN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I can not explain. I wish I understood it properly myself."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"84e9f062-078e-4777-aec6-bbe480e3a4e7","type":"message","text":"I am pretty sure copying is only in the worst case.\nYou just need to restore it to it's old state.\nSo you definitely rules for all you primative mutating operations.\nSo `push!` Doesn't need to remember anything, it just needs to `pop!`, And `setindex!` just needs to remember the thing/s over written.","user":"U6A936746","ts":"1616351001.028400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P/V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am pretty sure copying is only in the worst case.\nYou just need to restore it to it's old state.\nSo you definitely rules for all you primative mutating operations.\nSo "},{"type":"text","text":"push!","style":{"code":true}},{"type":"text","text":" Doesn't need to remember anything, it just needs to "},{"type":"text","text":"pop!","style":{"code":true}},{"type":"text","text":", And "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" just needs to remember the thing/s over written."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"d8721752-3e11-44fd-b699-7aefa73f9e97","type":"message","text":"But I have been told that that isn't enough","user":"U6A936746","ts":"1616351009.028600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O+h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I have been told that that isn't enough"}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"E0FD0EC4-CEF3-44A0-B213-87EF2E8567EB","type":"message","text":"I never thought about aliasing, but it makes sense. Maybe you could write code that dealt with mutation, but if an array is aliased (like you’re reusing/mutating parts of an array) then there is no way for the compiler to detect it. Is there any way to prevent aliasing in Julia? Even if not, allowing mutation while pinky swearing to not alias would be nice.","user":"ULD19UCPK","ts":"1616386786.033600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gB3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I never thought about aliasing, but it makes sense. Maybe you could write code that dealt with mutation, but if an array is aliased (like you’re reusing/mutating parts of an array) then there is no way for the compiler to detect it. Is there any way to prevent aliasing in Julia? Even if not, allowing mutation while pinky swearing to not alias would be nice."}]}]}],"thread_ts":"1616086340.012400","parent_user_id":"U017D4RFTFC"},{"type":"message","subtype":"thread_broadcast","text":"This question has come up enough that it would be good if someone who understands why this is hard could do a short write-up somewhere that we could reference when it comes up again","user":"UHDQQ4GN6","ts":"1616387568.033800","thread_ts":"1616086340.012400","root":{"client_msg_id":"8c65d16f-99cb-49e9-b414-a26cd417af1f","type":"message","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc","user":"U017D4RFTFC","ts":"1616086340.012400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bwy7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc"}]}]}],"thread_ts":"1616086340.012400","reply_count":12,"reply_users_count":5,"latest_reply":"1616393038.035900","reply_users":["UHDQQ4GN6","U011ZPCEL2E","U6BJ9E351","U6A936746","ULD19UCPK"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"iTy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This question has come up enough that it would be good if someone who understands why this is hard could do a short write-up somewhere that we could reference when it comes up again"}]}]}],"client_msg_id":"9faeea4a-9ea9-4dc6-8399-f208a47afb65"},{"type":"message","subtype":"thread_broadcast","text":"Here's a crack, although this isn't my area of expertise and could be too elementary / wrong / etc.\n\n```arr = collect(1:3)\nout1 = @view arr[1:2]\nout2 = @view arr[2:3]\n\n@. out1 = arr[1:2] + arr[2:3]\nout1_copy = copy(out1)\n\n@. out2 = out1 * arr[2:3]\n\nprintln(out1 == out1_copy) # false```\nIn reverse mode AD, I believe usually frameworks cache things like `out1`  for the reverse pass, but the overlapping memory regions (aliasing) foil that. Put another way, even if AD worked for individual `set_index!`  calls, you can't guarantee chains of multiple `set_index!` will work. In general you may not know what regions overlap until runtime (and in Julia, indexing like that is always effectively runtime, so that information isn't available to the compiler?).","user":"ULD19UCPK","ts":"1616393038.035900","thread_ts":"1616086340.012400","root":{"client_msg_id":"8c65d16f-99cb-49e9-b414-a26cd417af1f","type":"message","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc","user":"U017D4RFTFC","ts":"1616086340.012400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bwy7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Will Diffractor support setindex? I read somewhere mutation was a goal iirc"}]}]}],"thread_ts":"1616086340.012400","reply_count":12,"reply_users_count":5,"latest_reply":"1616393038.035900","reply_users":["UHDQQ4GN6","U011ZPCEL2E","U6BJ9E351","U6A936746","ULD19UCPK"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"Fsmy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here's a crack, although this isn't my area of expertise and could be too elementary / wrong / etc.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"arr = collect(1:3)\nout1 = @view arr[1:2]\nout2 = @view arr[2:3]\n\n@. out1 = arr[1:2] + arr[2:3]\nout1_copy = copy(out1)\n\n@. out2 = out1 * arr[2:3]\n\nprintln(out1 == out1_copy) # false"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nIn reverse mode AD, I believe usually frameworks cache things like "},{"type":"text","text":"out1","style":{"code":true}},{"type":"text","text":"  for the reverse pass, but the overlapping memory regions (aliasing) foil that. Put another way, even if AD worked for individual "},{"type":"text","text":"set_index!","style":{"code":true}},{"type":"text","text":"  calls, you can't guarantee chains of multiple "},{"type":"text","text":"set_index!","style":{"code":true}},{"type":"text","text":" will work. In general you may not know what regions overlap until runtime (and in Julia, indexing like that is always effectively runtime, so that information isn't available to the compiler?)."}]}]}],"client_msg_id":"f4c4ddee-c536-4803-9205-82b88ca8b7ae"}]