[{"client_msg_id":"4a0acc05-9ea8-413b-a5da-8e26004b0dcf","type":"message","text":"I need some advice for how to use ChainRulesCore to set up these rules:\n\ncontext: I’m writing code with the goal of doing statistical inference, so we want gradients w.r.t. the following parameters: `u_n, b, r`.\n\nThe “math” of the computation is broken up between the two methods, though:\n```# inside `law = PolynomialLimbDark(u_n)`\ng_n = convert_basis(u_n)\n# inside `f = compute(law, b, r)`\nx = # various functions dependent on b and r\nf = dot(g_n, x)```\nThe actual code that accompanies this is as follows\n```law = PolynomialLimbDark(u_n)\nf = compute(law, b, r)```\nI have analytical functions for the gradient `dfdg, dfdb, dfdr` and the jacobian `dgdu` . In terms of chain rules, how do I write, say, an `frule` for `compute`? here’s what I have so far-\n\n```function frule((_, Δld, Δb, Δr), ::typeof(compute), ld::PolynomialLimbDark, b, r)\n    f, dfdg, dfdb, dfdr = compute_grad(ld, b, r)\n    return f, ??? dfdb * Δb + dfdr * Δr\nend\n\nfunction frule((_, du_n), ::typeof(PolynomialLimbDark), u_n::AbstractVector)\n    ld = PolynomialLimbDark(u_n)\n    jac_gn = compute_gn_jac(u_n)\n    return ld, jac_gn # ??? is this right??? g_n is an internal field\nend```","user":"UN97XTLCV","ts":"1613925332.004600","team":"T68168MUP","edited":{"user":"UN97XTLCV","ts":"1613926239.000000"},"blocks":[{"type":"rich_text","block_id":"L+G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I need some advice for how to use ChainRulesCore to set up these rules:\n\ncontext: I’m writing code with the goal of doing statistical inference, so we want gradients w.r.t. the following parameters: "},{"type":"text","text":"u_n, b, r","style":{"code":true}},{"type":"text","text":".\n\nThe “math” of the computation is broken up between the two methods, though:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"# inside `law = PolynomialLimbDark(u_n)`\ng_n = convert_basis(u_n)\n# inside `f = compute(law, b, r)`\nx = # various functions dependent on b and r\nf = dot(g_n, x)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The actual code that accompanies this is as follows\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"law = PolynomialLimbDark(u_n)\nf = compute(law, b, r)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI have analytical functions for the gradient "},{"type":"text","text":"dfdg, dfdb, dfdr","style":{"code":true}},{"type":"text","text":" and the jacobian "},{"type":"text","text":"dgdu","style":{"code":true}},{"type":"text","text":" . In terms of chain rules, how do I write, say, an "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" for "},{"type":"text","text":"compute","style":{"code":true}},{"type":"text","text":"? here’s what I have so far-\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function frule((_, Δld, Δb, Δr), ::typeof(compute), ld::PolynomialLimbDark, b, r)\n    f, dfdg, dfdb, dfdr = compute_grad(ld, b, r)\n    return f, ??? dfdb * Δb + dfdr * Δr\nend\n\nfunction frule((_, du_n), ::typeof(PolynomialLimbDark), u_n::AbstractVector)\n    ld = PolynomialLimbDark(u_n)\n    jac_gn = compute_gn_jac(u_n)\n    return ld, jac_gn # ??? is this right??? g_n is an internal field\nend"}]}]}],"thread_ts":"1613925332.004600","reply_count":2,"reply_users_count":1,"latest_reply":"1613996974.010100","reply_users":["U6A936746"],"subscribed":false},{"client_msg_id":"24614798-0937-426c-8a42-5c910b179c40","type":"message","text":"the outputs of `frule` are a tuple\nwhere the first element is the primal result,\nand the second element is the differential for that primal result","user":"U6A936746","ts":"1613996552.006500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lc0IA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the outputs of "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" are a tuple\nwhere the first element is the primal result,\nand the second element is the differential for that primal result"}]}]}],"thread_ts":"1613925332.004600","parent_user_id":"UN97XTLCV"},{"client_msg_id":"6da8add8-1556-4a15-9275-f211d4aced6b","type":"message","text":"`Δld` should be a `Composite` , it should have a field for `u_n`","user":"U6A936746","ts":"1613996974.010100","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1613996980.000000"},"blocks":[{"type":"rich_text","block_id":"bx/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Δld","style":{"code":true}},{"type":"text","text":" should be a "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" , it should have a field for "},{"type":"text","text":"u_n","style":{"code":true}}]}]}],"thread_ts":"1613925332.004600","parent_user_id":"UN97XTLCV"}]