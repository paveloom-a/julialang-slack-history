[{"client_msg_id":"d74b7dac-3651-48cc-b78d-0297647cdab1","type":"message","text":"Anyone know how to do adjoints for making a sparse diagonal matrix? Specifically I have  `(C + diag(p))x = b` (solve for x) that I want to autodiff (where p are some numbers generated by a NN). When I try I get `ERROR: Need an adjoint for constructor SparseMatrixCSC{Complex{Float64},Int64}`","user":"U0138UTB7A4","ts":"1616085234.011300","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1616085400.000000"},"blocks":[{"type":"rich_text","block_id":"xPO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyone know how to do adjoints for making a sparse diagonal matrix? Specifically I have  "},{"type":"text","text":"(C + diag(p))x = b","style":{"code":true}},{"type":"text","text":" (solve for x) that I want to autodiff (where p are some numbers generated by a NN). When I try I get "},{"type":"text","text":"ERROR: Need an adjoint for constructor SparseMatrixCSC{Complex{Float64},Int64}","style":{"code":true}}]}]}],"thread_ts":"1616085234.011300","reply_count":18,"reply_users_count":3,"latest_reply":"1616095945.017300","reply_users":["UHDQQ4GN6","U0138UTB7A4","UCD4Z3NJZ"],"is_locked":false,"subscribed":false},{"client_msg_id":"b87a6684-e0ac-426e-b403-7b13b948642a","type":"message","text":"You might try <https://github.com/JuliaDiff/ChainRules.jl/pull/246|https://github.com/JuliaDiff/ChainRules.jl/pull/246>.","user":"UHDQQ4GN6","ts":"1616087546.012700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1Fe8c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might try "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRules.jl/pull/246","text":"https://github.com/JuliaDiff/ChainRules.jl/pull/246"},{"type":"text","text":"."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"a3ea14e8-de28-44be-bfd9-982d7df79118","type":"message","text":"I'm not too familar with how this all works with ChainRules, rrule, and Reverse AD. Right now I'm using Zygote, I thought I could define a `@adjoint` function instead?","user":"U0138UTB7A4","ts":"1616091231.013000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Md7+a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not too familar with how this all works with ChainRules, rrule, and Reverse AD. Right now I'm using Zygote, I thought I could define a "},{"type":"text","text":"@adjoint","style":{"code":true}},{"type":"text","text":" function instead?"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"4d59cd9f-7a78-4a5b-a566-281126de5cbf","type":"message","text":"You can do both. When no adjoint is available, Zygote checks ChainRules, which is more general and indeed the recommended wya to define rules that are not using some Zygote-specific feature.","user":"UHDQQ4GN6","ts":"1616091357.013300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kl4Wc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can do both. When no adjoint is available, Zygote checks ChainRules, which is more general and indeed the recommended wya to define rules that are not using some Zygote-specific feature."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"217f9598-7495-43e6-82de-c492c4a48853","type":"message","text":"But for a Zygote-specific one, check out <https://github.com/FluxML/Zygote.jl/pull/762>","user":"UHDQQ4GN6","ts":"1616091367.013500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pYo4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But for a Zygote-specific one, check out "},{"type":"link","url":"https://github.com/FluxML/Zygote.jl/pull/762"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"57a66805-7107-477a-9c41-101bc23f4e6e","type":"message","text":"If you want to generate backward rules for sparse matrice operations, NiLang might be helpful: <https://nextjournal.com/giggle/how-to-write-a-program-differentiably>","user":"UCD4Z3NJZ","ts":"1616091470.013700","team":"T68168MUP","attachments":[{"title":"How to write a program differentiably","title_link":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably","text":"In this blog, I will show how to write a linear algebra function, the sparse matrix-vector multiplication function, differentiably, by converting an existing irreversible program in SparseArrays to a reversible one, step by step.","fallback":"How to write a program differentiably","thumb_url":"https://cdn.nextjournal.com/data/QmT5fDkSq8GZVpJovSHAxvUHBpDYvcGSe16GKJfAWDawZJ?filename=julia.png&content-type=image/png","from_url":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably","thumb_width":400,"thumb_height":303,"service_name":"nextjournal.com","id":1,"original_url":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably"}],"blocks":[{"type":"rich_text","block_id":"LPU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you want to generate backward rules for sparse matrice operations, NiLang might be helpful: "},{"type":"link","url":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"d479cab2-19ad-43e4-a4d6-c68e5ba7b392","type":"message","text":"<@UCD4Z3NJZ> so NiLang can differentiate code that mutates arrays just fine? Do you have any examples of using NiLang to define ChainRules `rrules` for non-mutating wrappers of mutating functions?","user":"UHDQQ4GN6","ts":"1616092147.014000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"p5X8r","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UCD4Z3NJZ"},{"type":"text","text":" so NiLang can differentiate code that mutates arrays just fine? Do you have any examples of using NiLang to define ChainRules "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for non-mutating wrappers of mutating functions?"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"2d12d22a-00b5-4d39-9172-27d9526cc919","type":"message","text":"&gt; can differentiate code that mutates arrays just fine?\nYes, because NiLang does not use stack to record arrays.\n\n&gt; Do you have any examples of using NiLang to define ChainRules `rrules` for non-mutating wrappers of mutating functions?\nNot yet, but I have an example of porting NiLang to Zygote: <https://giggleliu.github.io/NiLang.jl/stable/examples/port_zygote/> . I can add one for Chainrules too later.","user":"UCD4Z3NJZ","ts":"1616092307.014300","team":"T68168MUP","edited":{"user":"UCD4Z3NJZ","ts":"1616092330.000000"},"blocks":[{"type":"rich_text","block_id":"Gnfch","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"can differentiate code that mutates arrays just fine?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, because NiLang does not use stack to record arrays.\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"Do you have any examples of using NiLang to define ChainRules "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for non-mutating wrappers of mutating functions?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Not yet, but I have an example of porting NiLang to Zygote: "},{"type":"link","url":"https://giggleliu.github.io/NiLang.jl/stable/examples/port_zygote/"},{"type":"text","text":" . I can add one for Chainrules too later."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4","reactions":[{"name":"open_mouth","users":["U0138UTB7A4"],"count":1}]},{"client_msg_id":"fed281c2-a214-4871-be0f-7d38a55e692f","type":"message","text":"So I could define making my own sparse diagonal arrays using mutation with NiLang. And then maybe somehow use that combine that with Zygote for Autodiff?","user":"U0138UTB7A4","ts":"1616092433.014700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FhyQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I could define making my own sparse diagonal arrays using mutation with NiLang. And then maybe somehow use that combine that with Zygote for Autodiff?"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"fe4fb274-d73d-4c84-b60d-480782bf73fb","type":"message","text":"It is better to define the backward rules with ChainRules's API. Because people are switching to ChainRules, including Zygote.","user":"UCD4Z3NJZ","ts":"1616092554.014900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DW0z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It is better to define the backward rules with ChainRules's API. Because people are switching to ChainRules, including Zygote."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"f2528084-c179-43c5-b162-ed7768a1ba12","type":"message","text":"I'm really new to autodiff concepts so from my brief understanding of ChainRules, I can define a `frule` and `rrule` , which is sorta equivalent to using `@adjoint` in Zygote, then use that to propagate through. Using NiLang to help construct the frule and rrule?","user":"U0138UTB7A4","ts":"1616093003.015100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nAJH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm really new to autodiff concepts so from my brief understanding of ChainRules, I can define a "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" , which is sorta equivalent to using "},{"type":"text","text":"@adjoint","style":{"code":true}},{"type":"text","text":" in Zygote, then use that to propagate through. Using NiLang to help construct the frule and rrule?"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"f0fc6c40-e3b6-41f2-bae7-608d552558c4","type":"message","text":"I'm also trying to just throw together a proof of concept prototype so I'm not sure how far I want to go","user":"U0138UTB7A4","ts":"1616093021.015300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NJz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm also trying to just throw together a proof of concept prototype so I'm not sure how far I want to go"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"c720a35b-9778-412d-b386-aafc575d32d4","type":"message","text":"&gt; Using NiLang to help construct the frule and rrule?\nA short answer would be yes. There are two types of reverse mode AD, one is optimized for scalars (NiLang, Tapenade et. al.) and another is optimized for tensors (most rule based AD).","user":"UCD4Z3NJZ","ts":"1616093246.015500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fcu5","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Using NiLang to help construct the frule and rrule?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"A short answer would be yes. There are two types of reverse mode AD, one is optimized for scalars (NiLang, Tapenade et. al.) and another is optimized for tensors (most rule based AD)."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"deb40438-590f-419d-90e7-d423cb738d29","type":"message","text":"Those AD optimized for tensors can not handle scalar functions, mutable arrays well. This is why we sometimes need another AD for scalars for better \"microscopic level\" performance.","user":"UCD4Z3NJZ","ts":"1616093349.015700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ePDS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Those AD optimized for tensors can not handle scalar functions, mutable arrays well. This is why we sometimes need another AD for scalars for better \"microscopic level\" performance."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"8b1840e9-a946-4bfb-86b2-17ff2c1473a4","type":"message","text":"Warning: NiLang is not trivial to learn and use. Take it as a new language. If you need the backward rule in a hurry, I can help you construct the backward rule with NiLang.","user":"UCD4Z3NJZ","ts":"1616093431.015900","team":"T68168MUP","edited":{"user":"UCD4Z3NJZ","ts":"1616093479.000000"},"blocks":[{"type":"rich_text","block_id":"zRYe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Warning: NiLang is not trivial to learn and use. Take it as a new language. If you need the backward rule in a hurry, I can help you construct the backward rule with NiLang."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"0ef33ca8-b391-45c0-baae-d2c575fa2c4a","type":"message","text":"Thank you for the offer to help! I'll see what I can try to come up with first, and see how much I can learn. I'll also check out <@UHDQQ4GN6>'s links some more. I've also been wondering if there's more analytical formula but Im really new to adjoint methods\n\nThank you!","user":"U0138UTB7A4","ts":"1616094433.016300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"58wGP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you for the offer to help! I'll see what I can try to come up with first, and see how much I can learn. I'll also check out "},{"type":"user","user_id":"UHDQQ4GN6"},{"type":"text","text":"'s links some more. I've also been wondering if there's more analytical formula but Im really new to adjoint methods\n\nThank you!"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"08de4795-3339-4ad0-b9c5-fff1117c458d","type":"message","text":"For worked examples of working out reverse-mode rules, I recommend reading <https://juliadiff.org/ChainRulesCore.jl/dev/arrays.html#Reverse-mode-rules> and <https://sethaxen.com/blog/2021/02/differentiating-the-lu-decomposition/>.","user":"UHDQQ4GN6","ts":"1616094851.016500","team":"T68168MUP","attachments":[{"title":"Differentiating the LU decomposition","title_link":"https://sethaxen.com/blog/2021/02/differentiating-the-lu-decomposition/","text":"Deriving differentiation rules for the LU decomposition of square and non-square matrices.","fallback":"Differentiating the LU decomposition","thumb_url":"https://sethaxen.com/assets/seth.jpg","from_url":"https://sethaxen.com/blog/2021/02/differentiating-the-lu-decomposition/","thumb_width":666,"thumb_height":666,"service_name":"sethaxen.com","id":1,"original_url":"https://sethaxen.com/blog/2021/02/differentiating-the-lu-decomposition/"}],"blocks":[{"type":"rich_text","block_id":"Y4LO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For worked examples of working out reverse-mode rules, I recommend reading "},{"type":"link","url":"https://juliadiff.org/ChainRulesCore.jl/dev/arrays.html#Reverse-mode-rules"},{"type":"text","text":" and "},{"type":"link","url":"https://sethaxen.com/blog/2021/02/differentiating-the-lu-decomposition/"},{"type":"text","text":"."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4","reactions":[{"name":"+1","users":["UCD4Z3NJZ","U018F5W2H24"],"count":2},{"name":"+1::skin-tone-4","users":["U0138UTB7A4"],"count":1}]},{"client_msg_id":"4b7acf0b-51ad-40a0-b2fb-240f9fa5e6ee","type":"message","text":"(the first one is more general, but the second one uses a more concise and cleaner notation)","user":"UHDQQ4GN6","ts":"1616094877.016800","team":"T68168MUP","edited":{"user":"UHDQQ4GN6","ts":"1616094951.000000"},"blocks":[{"type":"rich_text","block_id":"Qhn4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(the first one is more general, but the second one uses a more concise and cleaner notation)"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"186d1e16-418c-4840-81f6-29f979a61440","type":"message","text":"Thank you!! Its nice to see more worked out examples to help me think through things","user":"U0138UTB7A4","ts":"1616095945.017300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dHF1O","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you!! Its nice to see more worked out examples to help me think through things"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"}]