[{"client_msg_id":"d74b7dac-3651-48cc-b78d-0297647cdab1","type":"message","text":"Anyone know how to do adjoints for making a sparse diagonal matrix? Specifically I have  `(C + diag(p))x = b` (solve for x) that I want to autodiff (where p are some numbers generated by a NN). When I try I get `ERROR: Need an adjoint for constructor SparseMatrixCSC{Complex{Float64},Int64}`","user":"U0138UTB7A4","ts":"1616085234.011300","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1616085400.000000"},"blocks":[{"type":"rich_text","block_id":"xPO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyone know how to do adjoints for making a sparse diagonal matrix? Specifically I have  "},{"type":"text","text":"(C + diag(p))x = b","style":{"code":true}},{"type":"text","text":" (solve for x) that I want to autodiff (where p are some numbers generated by a NN). When I try I get "},{"type":"text","text":"ERROR: Need an adjoint for constructor SparseMatrixCSC{Complex{Float64},Int64}","style":{"code":true}}]}]}],"thread_ts":"1616085234.011300","reply_count":5,"reply_users_count":3,"latest_reply":"1616091470.013700","reply_users":["UHDQQ4GN6","U0138UTB7A4","UCD4Z3NJZ"],"subscribed":false},{"client_msg_id":"b87a6684-e0ac-426e-b403-7b13b948642a","type":"message","text":"You might try <https://github.com/JuliaDiff/ChainRules.jl/pull/246|https://github.com/JuliaDiff/ChainRules.jl/pull/246>.","user":"UHDQQ4GN6","ts":"1616087546.012700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1Fe8c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might try "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRules.jl/pull/246","text":"https://github.com/JuliaDiff/ChainRules.jl/pull/246"},{"type":"text","text":"."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"a3ea14e8-de28-44be-bfd9-982d7df79118","type":"message","text":"I'm not too familar with how this all works with ChainRules, rrule, and Reverse AD. Right now I'm using Zygote, I thought I could define a `@adjoint` function instead?","user":"U0138UTB7A4","ts":"1616091231.013000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Md7+a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not too familar with how this all works with ChainRules, rrule, and Reverse AD. Right now I'm using Zygote, I thought I could define a "},{"type":"text","text":"@adjoint","style":{"code":true}},{"type":"text","text":" function instead?"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"4d59cd9f-7a78-4a5b-a566-281126de5cbf","type":"message","text":"You can do both. When no adjoint is available, Zygote checks ChainRules, which is more general and indeed the recommended wya to define rules that are not using some Zygote-specific feature.","user":"UHDQQ4GN6","ts":"1616091357.013300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kl4Wc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can do both. When no adjoint is available, Zygote checks ChainRules, which is more general and indeed the recommended wya to define rules that are not using some Zygote-specific feature."}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"217f9598-7495-43e6-82de-c492c4a48853","type":"message","text":"But for a Zygote-specific one, check out <https://github.com/FluxML/Zygote.jl/pull/762>","user":"UHDQQ4GN6","ts":"1616091367.013500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pYo4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But for a Zygote-specific one, check out "},{"type":"link","url":"https://github.com/FluxML/Zygote.jl/pull/762"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"},{"client_msg_id":"57a66805-7107-477a-9c41-101bc23f4e6e","type":"message","text":"If you want to generate backward rules for sparse matrice operations, NiLang might be helpful: <https://nextjournal.com/giggle/how-to-write-a-program-differentiably>","user":"UCD4Z3NJZ","ts":"1616091470.013700","team":"T68168MUP","attachments":[{"title":"How to write a program differentiably","title_link":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably","text":"In this blog, I will show how to write a linear algebra function, the sparse matrix-vector multiplication function, differentiably, by converting an existing irreversible program in SparseArrays to a reversible one, step by step.","fallback":"How to write a program differentiably","thumb_url":"https://cdn.nextjournal.com/data/QmT5fDkSq8GZVpJovSHAxvUHBpDYvcGSe16GKJfAWDawZJ?filename=julia.png&content-type=image/png","from_url":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably","thumb_width":400,"thumb_height":303,"service_name":"nextjournal.com","id":1,"original_url":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably"}],"blocks":[{"type":"rich_text","block_id":"LPU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you want to generate backward rules for sparse matrice operations, NiLang might be helpful: "},{"type":"link","url":"https://nextjournal.com/giggle/how-to-write-a-program-differentiably"}]}]}],"thread_ts":"1616085234.011300","parent_user_id":"U0138UTB7A4"}]