[{"client_msg_id":"46e09e7d-03bb-452f-b3ef-80990feb3959","type":"message","text":"A quick quesh: I want to do `ifft(fft(a) .+ fft(b))` for two real vectors `a` and `b`. This composition is a real function but results in complex adjoints due to the pullback of `ifft` and `fft` . I want the adjoints to be _real_ given that this function is indeed real for real inputs.\n\nRight now made this composition into a method and then I define the `rrule` for this method, which is either:\n• Using Zygote to compute the adjoint of the function and then just add in a `real`  call at the end.\n• Manually write out the `rrule` and then adding a `real` at the end.\nCurrently I'm doing (2) because I was thinking this was also a good opportunity to move the adjoint definitions for `ifft` and `fft`, and it's relevatives, from Zygote to ChainRules.jl, but is there a better way?","user":"UHDNY2YMA","ts":"1615758974.343400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OkX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A quick quesh: I want to do "},{"type":"text","text":"ifft(fft(a) .+ fft(b))","style":{"code":true}},{"type":"text","text":" for two real vectors "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"b","style":{"code":true}},{"type":"text","text":". This composition is a real function but results in complex adjoints due to the pullback of "},{"type":"text","text":"ifft","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"fft","style":{"code":true}},{"type":"text","text":" . I want the adjoints to be "},{"type":"text","text":"real","style":{"italic":true}},{"type":"text","text":" given that this function is indeed real for real inputs.\n\nRight now made this composition into a method and then I define the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" for this method, which is either:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Using Zygote to compute the adjoint of the function and then just add in a "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":"  call at the end."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Manually write out the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" and then adding a "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" at the end."}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Currently I'm doing (2) because I was thinking this was also a good opportunity to move the adjoint definitions for "},{"type":"text","text":"ifft","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"fft","style":{"code":true}},{"type":"text","text":", and it's relevatives, from Zygote to ChainRules.jl, but is there a better way?"}]}]}],"thread_ts":"1615758974.343400","reply_count":1,"reply_users_count":1,"latest_reply":"1615762162.343700","reply_users":["UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"8d58c2f6-6839-4692-8dca-90ec0fa21421","type":"message","text":"By default Zygote treats all real numbers as embedded in the complex numbers. Likewise, in general it treats all `AbstractArray`s as embedded in the `Array`s. In reverse mode this results in composed pullbacks eventually wandering away from the cotangent space of your primal and being promoted to the cotangent space of the embedding. The Zygote way around this is via some projection. e.g. in this case `real(ifft(fft(real(a)) .+ fft(real(b))))` will be sufficient. The outer call to `real` is idempotent for real output, but its pullback ends up being a projection to the reals. The same goes for the inner `reals`. This is just a band-aid though; the right thing would be for the `rrule` to enforce these constraints, which may result in a more efficient rule in the end. ChainRules is moving towards this approach, and it would be nice to have these rules over there.","user":"UHDQQ4GN6","ts":"1615762162.343700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PyD8X","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"By default Zygote treats all real numbers as embedded in the complex numbers. Likewise, in general it treats all "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":"s as embedded in the "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":"s. In reverse mode this results in composed pullbacks eventually wandering away from the cotangent space of your primal and being promoted to the cotangent space of the embedding. The Zygote way around this is via some projection. e.g. in this case "},{"type":"text","text":"real(ifft(fft(real(a)) .+ fft(real(b))))","style":{"code":true}},{"type":"text","text":" will be sufficient. The outer call to "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" is idempotent for real output, but its pullback ends up being a projection to the reals. The same goes for the inner "},{"type":"text","text":"reals","style":{"code":true}},{"type":"text","text":". This is just a band-aid though; the right thing would be for the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" to enforce these constraints, which may result in a more efficient rule in the end. ChainRules is moving towards this approach, and it would be nice to have these rules over there."}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"}]