[{"client_msg_id":"46e09e7d-03bb-452f-b3ef-80990feb3959","type":"message","text":"A quick quesh: I want to do `ifft(fft(a) .+ fft(b))` for two real vectors `a` and `b`. This composition is a real function but results in complex adjoints due to the pullback of `ifft` and `fft` . I want the adjoints to be _real_ given that this function is indeed real for real inputs.\n\nRight now made this composition into a method and then I define the `rrule` for this method, which is either:\n• Using Zygote to compute the adjoint of the function and then just add in a `real`  call at the end.\n• Manually write out the `rrule` and then adding a `real` at the end.\nCurrently I'm doing (2) because I was thinking this was also a good opportunity to move the adjoint definitions for `ifft` and `fft`, and it's relevatives, from Zygote to ChainRules.jl, but is there a better way?","user":"UHDNY2YMA","ts":"1615758974.343400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OkX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A quick quesh: I want to do "},{"type":"text","text":"ifft(fft(a) .+ fft(b))","style":{"code":true}},{"type":"text","text":" for two real vectors "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"b","style":{"code":true}},{"type":"text","text":". This composition is a real function but results in complex adjoints due to the pullback of "},{"type":"text","text":"ifft","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"fft","style":{"code":true}},{"type":"text","text":" . I want the adjoints to be "},{"type":"text","text":"real","style":{"italic":true}},{"type":"text","text":" given that this function is indeed real for real inputs.\n\nRight now made this composition into a method and then I define the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" for this method, which is either:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Using Zygote to compute the adjoint of the function and then just add in a "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":"  call at the end."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Manually write out the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" and then adding a "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" at the end."}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"Currently I'm doing (2) because I was thinking this was also a good opportunity to move the adjoint definitions for "},{"type":"text","text":"ifft","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"fft","style":{"code":true}},{"type":"text","text":", and it's relevatives, from Zygote to ChainRules.jl, but is there a better way?"}]}]}],"thread_ts":"1615758974.343400","reply_count":6,"reply_users_count":2,"latest_reply":"1616059555.008000","reply_users":["UHDQQ4GN6","UHDNY2YMA"],"subscribed":false},{"client_msg_id":"8d58c2f6-6839-4692-8dca-90ec0fa21421","type":"message","text":"By default Zygote treats all real numbers as embedded in the complex numbers. Likewise, in general it treats all `AbstractArray`s as embedded in the `Array`s. In reverse mode this results in composed pullbacks eventually wandering away from the cotangent space of your primal and being promoted to the cotangent space of the embedding. The Zygote way around this is via some projection. e.g. in this case `real(ifft(fft(real(a)) .+ fft(real(b))))` will be sufficient. The outer call to `real` is idempotent for real output, but its pullback ends up being a projection to the reals. The same goes for the inner `reals`. This is just a band-aid though; the right thing would be for the `rrule` to enforce these constraints, which may result in a more efficient rule in the end. ChainRules is moving towards this approach, and it would be nice to have these rules over there.","user":"UHDQQ4GN6","ts":"1615762162.343700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PyD8X","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"By default Zygote treats all real numbers as embedded in the complex numbers. Likewise, in general it treats all "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":"s as embedded in the "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":"s. In reverse mode this results in composed pullbacks eventually wandering away from the cotangent space of your primal and being promoted to the cotangent space of the embedding. The Zygote way around this is via some projection. e.g. in this case "},{"type":"text","text":"real(ifft(fft(real(a)) .+ fft(real(b))))","style":{"code":true}},{"type":"text","text":" will be sufficient. The outer call to "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" is idempotent for real output, but its pullback ends up being a projection to the reals. The same goes for the inner "},{"type":"text","text":"reals","style":{"code":true}},{"type":"text","text":". This is just a band-aid though; the right thing would be for the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" to enforce these constraints, which may result in a more efficient rule in the end. ChainRules is moving towards this approach, and it would be nice to have these rules over there."}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"d0ea0693-9faf-4a66-83d6-7438ebff91fc","type":"message","text":"Ah, I see! Though one thing is confusing to me:\n&gt; outer call to real is idempotent for real output, but its pullback ends up being a projection to the reals\nDon't you mean inner call to`real`? I.e. `real(a)` and `real(b)`. Or maybe I'm just misunderstanding the terms \"inner call\" and \"outer call\"..","user":"UHDNY2YMA","ts":"1615798960.360300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"neRE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, I see! Though one thing is confusing to me:\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"outer call to real is idempotent for real output, but its pullback ends up being a projection to the reals"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Don't you mean inner call to`real`? I.e. "},{"type":"text","text":"real(a)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"real(b)","style":{"code":true}},{"type":"text","text":". Or maybe I'm just misunderstanding the terms \"inner call\" and \"outer call\".."}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"968767e4-c5b4-4f8f-ae50-93a125dddb23","type":"message","text":"&gt; he right thing would be for the rrule to enforce these constraints, which may result in a more efficient rule in the end. ChainRules is moving towards this approach,\nBy just projecting to reals if input is real and output is complex?","user":"UHDNY2YMA","ts":"1615799012.360500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ygs4","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"he right thing would be for the rrule to enforce these constraints, which may result in a more efficient rule in the end. ChainRules is moving towards this approach,"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nBy just projecting to reals if input is real and output is complex?"}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"a445da9e-42f5-4b07-b7b7-7db163912b54","type":"message","text":"Whoops, sorry, should be `ifft(fft(real(a)) .+ fft(real(b)))`, no outer `real`. (EDIT: although since the output will have an imaginary part of 0, you probably will probably want to call `real` on it anyways).\nWe've been discussing how to handle this type-widening that happens in the pullbacks for abstractly typed rules. <https://github.com/JuliaDiff/ChainRules.jl/issues/232> is the super-issue with others linking to it. How we are handling this now is mostly to 1) try to only implement rules for concrete types or type unions and 2) _sometimes_ explicitly project complex adjoints to real when necessary. We've discussed possibly adding explicit projections based on types that exist separate from the rules, but nothing is certain yet. I think though everyone agrees that if a primal is `Real` and a cotangent is `Complex`, then a projection using `real` should take place to avoid complexifying the entire pullback.","user":"UHDQQ4GN6","ts":"1615800859.360800","team":"T68168MUP","edited":{"user":"UHDQQ4GN6","ts":"1615801139.000000"},"blocks":[{"type":"rich_text","block_id":"fNkT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Whoops, sorry, should be "},{"type":"text","text":"ifft(fft(real(a)) .+ fft(real(b)))","style":{"code":true}},{"type":"text","text":", no outer "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":". (EDIT: although since the output will have an imaginary part of 0, you probably will probably want to call "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" on it anyways).\nWe've been discussing how to handle this type-widening that happens in the pullbacks for abstractly typed rules. "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRules.jl/issues/232"},{"type":"text","text":" is the super-issue with others linking to it. How we are handling this now is mostly to 1) try to only implement rules for concrete types or type unions and 2) "},{"type":"text","text":"sometimes","style":{"italic":true}},{"type":"text","text":" explicitly project complex adjoints to real when necessary. We've discussed possibly adding explicit projections based on types that exist separate from the rules, but nothing is certain yet. I think though everyone agrees that if a primal is "},{"type":"text","text":"Real","style":{"code":true}},{"type":"text","text":" and a cotangent is "},{"type":"text","text":"Complex","style":{"code":true}},{"type":"text","text":", then a projection using "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" should take place to avoid complexifying the entire pullback."}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"943f036d-72c6-4f47-867a-08f53594eeff","type":"message","text":"For reference, another trick is to use `complex(a, b)` instead of `a + im*b`. The former produces real cotangents while the latter produces complex cotangents because we haven't added the right set of rules to make `+` and `*` project. This is one of those areas where the rough edges of AD are really felt, and it's not ideal that a user would have to program around these issues.","user":"UHDQQ4GN6","ts":"1615801041.361000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j7VUt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For reference, another trick is to use "},{"type":"text","text":"complex(a, b)","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":"a + im*b","style":{"code":true}},{"type":"text","text":". The former produces real cotangents while the latter produces complex cotangents because we haven't added the right set of rules to make "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" project. This is one of those areas where the rough edges of AD are really felt, and it's not ideal that a user would have to program around these issues."}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"},{"client_msg_id":"39e81465-6411-444c-b7a8-27b787317e71","type":"message","text":"&gt; Whoops, sorry, should be ifft(fft(real(a)) .+ fft(real(b))), no outer real.\nHaha, so what I meant was that the _inner_ `real`, i.e. the `real(a)` and `real(b)`, is what makes the cotagent get projected back to the reals while the _outer_ real doesn't help with this (though it does help with computations that follow, and I'm indeed using that). Also, it turned out that using the inner `real` was more efficient than my \"custom\" adjoint where I manually called `ChainRulesCore.pullback` on the different constituents, so I've gone with your suggestion for now:) Thanks!\n\nAnd finally had a proper look at the issue you mentioned: yeaaah seems a bit non-trivial. I think your project-idea is good as it will at the very least ensure that compositions of functions will make use of the \"correct\" type even though you don't necessarily get the performance benefit within the adjoint itself. The issue also brought to my attention that this might be the cause of some numerical issues in Turing. I believe there have been cases where using different AD-systems have resulted in different numerical behavior, and this might actually have been due to things like using `cholesky` on something that should have been `PDMat` but now isn't anymore. Something to keep in mind for the future.","user":"UHDNY2YMA","ts":"1616059555.008000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xNJk","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Whoops, sorry, should be ifft(fft(real(a)) .+ fft(real(b))), no outer real."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nHaha, so what I meant was that the "},{"type":"text","text":"inner","style":{"italic":true}},{"type":"text","text":" "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":", i.e. the "},{"type":"text","text":"real(a)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"real(b)","style":{"code":true}},{"type":"text","text":", is what makes the cotagent get projected back to the reals while the "},{"type":"text","text":"outer","style":{"italic":true}},{"type":"text","text":" real doesn't help with this (though it does help with computations that follow, and I'm indeed using that). Also, it turned out that using the inner "},{"type":"text","text":"real","style":{"code":true}},{"type":"text","text":" was more efficient than my \"custom\" adjoint where I manually called "},{"type":"text","text":"ChainRulesCore.pullback","style":{"code":true}},{"type":"text","text":" on the different constituents, so I've gone with your suggestion for now:) Thanks!\n\nAnd finally had a proper look at the issue you mentioned: yeaaah seems a bit non-trivial. I think your project-idea is good as it will at the very least ensure that compositions of functions will make use of the \"correct\" type even though you don't necessarily get the performance benefit within the adjoint itself. The issue also brought to my attention that this might be the cause of some numerical issues in Turing. I believe there have been cases where using different AD-systems have resulted in different numerical behavior, and this might actually have been due to things like using "},{"type":"text","text":"cholesky","style":{"code":true}},{"type":"text","text":" on something that should have been "},{"type":"text","text":"PDMat","style":{"code":true}},{"type":"text","text":" but now isn't anymore. Something to keep in mind for the future."}]}]}],"thread_ts":"1615758974.343400","parent_user_id":"UHDNY2YMA"}]