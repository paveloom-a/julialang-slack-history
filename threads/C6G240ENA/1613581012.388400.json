[{"client_msg_id":"c843a6a8-1b59-46b3-8653-289ca9b9873b","type":"message","text":"I'm having a moment of confusion about callable structs and ChainRules. Trying to define a `rrule` on a callable struct (basically a Flux layer) I get an error in testing (on `test_rrule`) that explicitly disallows using callable structs. If that's the case, why do we need to use `NO_FIELDS` as first argument for `rrule`, given that only functions without internal fields are allowed?","user":"U6BJ9E351","ts":"1613581012.388400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vMSC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having a moment of confusion about callable structs and ChainRules. Trying to define a "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" on a callable struct (basically a Flux layer) I get an error in testing (on "},{"type":"text","text":"test_rrule","style":{"code":true}},{"type":"text","text":") that explicitly disallows using callable structs. If that's the case, why do we need to use "},{"type":"text","text":"NO_FIELDS","style":{"code":true}},{"type":"text","text":" as first argument for "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":", given that only functions without internal fields are allowed?"}]}]}],"thread_ts":"1613581012.388400","reply_count":4,"reply_users_count":2,"latest_reply":"1613586118.389900","reply_users":["U6A936746","U6BJ9E351"],"subscribed":false},{"client_msg_id":"19c7d76a-3957-44f4-914f-2ef38293064a","type":"message","text":"They are fine in rules.\nIt is a limitation in `test_rrule` right now that it doesn’t handle them.\nIt actually should handle them.\n\nthere is an issue open about it <https://github.com/JuliaDiff/ChainRulesTestUtils.jl/issues/117>\nI don’t even think it is an incredibly hard PR.\nthough might run into trouble working out how to pass things to FiniteDifferences.jl.","user":"U6A936746","ts":"1613581978.389000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BQP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"They are fine in rules.\nIt is a limitation in "},{"type":"text","text":"test_rrule","style":{"code":true}},{"type":"text","text":" right now that it doesn’t handle them.\nIt actually should handle them.\n\nthere is an issue open about it "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRulesTestUtils.jl/issues/117"},{"type":"text","text":"\nI don’t even think it is an incredibly hard PR.\nthough might run into trouble working out how to pass things to FiniteDifferences.jl."}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351"},{"client_msg_id":"b0cda305-e2ce-4af2-8cfa-3f71d7078469","type":"message","text":"actually, regarding that scenario (callable struct), I just need to return a `Composite{F}(; kwargs...)` with all the relevant fields of the callable struct `f::F`?\n\nFor now I hacked with an intermediate `(f::F)(x) = compute(f, x)`, which seems to work, even though I confess `Composite` still confuses me a little. Should I also use the `Composite` type to initialize the accumulation (eg `f ⊢ Composite{F}(; kwargs..)`  using only the \"numeric\" fields)?","user":"U6BJ9E351","ts":"1613584537.389200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vv32p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"actually, regarding that scenario (callable struct), I just need to return a "},{"type":"text","text":"Composite{F}(; kwargs...)","style":{"code":true}},{"type":"text","text":" with all the relevant fields of the callable struct "},{"type":"text","text":"f::F","style":{"code":true}},{"type":"text","text":"?\n\nFor now I hacked with an intermediate "},{"type":"text","text":"(f::F)(x) = compute(f, x)","style":{"code":true}},{"type":"text","text":", which seems to work, even though I confess "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" still confuses me a little. Should I also use the "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" type to initialize the accumulation (eg "},{"type":"text","text":"f ⊢ Composite{F}(; kwargs..)","style":{"code":true}},{"type":"text","text":"  using only the \"numeric\" fields)?"}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351","reactions":[{"name":"+1","users":["U6A936746"],"count":1}]},{"client_msg_id":"eadb10a3-e705-41cd-99fc-56423a54eb2f","type":"message","text":"&gt;  For now I hacked with an intermediate `(f::F)(x) = compute(f, x)`, which seems to work\nThat sounds good.\nCan you add that work around to the issue?","user":"U6A936746","ts":"1613585724.389700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pTf","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" For now I hacked with an intermediate "},{"type":"text","text":"(f::F)(x) = compute(f, x)","style":{"code":true}},{"type":"text","text":", which seems to work"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThat sounds good.\nCan you add that work around to the issue?"}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351"},{"client_msg_id":"f2da77c5-c776-4869-a1a5-2e6e1298bf7e","type":"message","text":"&gt;  though I confess `Composite` still confuses me a little.\n`Composite` is the tangent space “dual” of a struct type. So it overloads all the vector space-y operators like `zero` and `+`. (which your type maybe doesn’t. If it does then you don’t need `Composite` )\n\nSo normally it has a field for each differentiable field of your struct.\nthough actually it only really has the ones you list — everything you don’t provide with the kwargs it just have `getproperty` overloaded to return `Zero()`\n\nFor nondifferntiable fields, which yes, are generally nonnumeric. (though not always) you  should just not put them in to the kwargs.\n\n\n&gt;  Should I also use the `Composite` type to initialize the accumulation (eg `f ⊢ Composite{F}(; kwargs..)`  using only the “numeric” fields)?\nYes, though you may not need to.\n`ChainRulesTestUtils.rand_tangent` is decent at working out the right tangent types to use for structs.\nif it has fields that are not differentiable then you might like to overload `rand_tangent` to tell it the correct `Composite` (or other differential type) to generate.","user":"U6A936746","ts":"1613586118.389900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1613586170.000000"},"blocks":[{"type":"rich_text","block_id":"rjKI","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" though I confess "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" still confuses me a little."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n"},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" is the tangent space “dual” of a struct type. So it overloads all the vector space-y operators like `zero` and `+`. (which your type maybe doesn’t. If it does then you don’t need "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" )\n\nSo normally it has a field for each differentiable field of your struct.\nthough actually it only really has the ones you list — everything you don’t provide with the kwargs it just have "},{"type":"text","text":"getproperty","style":{"code":true}},{"type":"text","text":" overloaded to return "},{"type":"text","text":"Zero()","style":{"code":true}},{"type":"text","text":"\n\nFor nondifferntiable fields, which yes, are generally nonnumeric. (though not always) you  should just not put them in to the kwargs.\n\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":" Should I also use the "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" type to initialize the accumulation (eg "},{"type":"text","text":"f ⊢ Composite{F}(; kwargs..)","style":{"code":true}},{"type":"text","text":"  using only the “numeric” fields)?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nYes, though you may not need to.\n"},{"type":"text","text":"ChainRulesTestUtils.rand_tangent","style":{"code":true}},{"type":"text","text":" is decent at working out the right tangent types to use for structs.\nif it has fields that are not differentiable then you might like to overload "},{"type":"text","text":"rand_tangent","style":{"code":true}},{"type":"text","text":" to tell it the correct "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" (or other differential type) to generate."}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351"}]