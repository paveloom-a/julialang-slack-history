[{"client_msg_id":"c843a6a8-1b59-46b3-8653-289ca9b9873b","type":"message","text":"I'm having a moment of confusion about callable structs and ChainRules. Trying to define a `rrule` on a callable struct (basically a Flux layer) I get an error in testing (on `test_rrule`) that explicitly disallows using callable structs. If that's the case, why do we need to use `NO_FIELDS` as first argument for `rrule`, given that only functions without internal fields are allowed?","user":"U6BJ9E351","ts":"1613581012.388400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vMSC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having a moment of confusion about callable structs and ChainRules. Trying to define a "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" on a callable struct (basically a Flux layer) I get an error in testing (on "},{"type":"text","text":"test_rrule","style":{"code":true}},{"type":"text","text":") that explicitly disallows using callable structs. If that's the case, why do we need to use "},{"type":"text","text":"NO_FIELDS","style":{"code":true}},{"type":"text","text":" as first argument for "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":", given that only functions without internal fields are allowed?"}]}]}],"thread_ts":"1613581012.388400","reply_count":3,"reply_users_count":2,"latest_reply":"1613585724.389700","reply_users":["U6A936746","U6BJ9E351"],"subscribed":false},{"client_msg_id":"19c7d76a-3957-44f4-914f-2ef38293064a","type":"message","text":"They are fine in rules.\nIt is a limitation in `test_rrule` right now that it doesn’t handle them.\nIt actually should handle them.\n\nthere is an issue open about it <https://github.com/JuliaDiff/ChainRulesTestUtils.jl/issues/117>\nI don’t even think it is an incredibly hard PR.\nthough might run into trouble working out how to pass things to FiniteDifferences.jl.","user":"U6A936746","ts":"1613581978.389000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BQP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"They are fine in rules.\nIt is a limitation in "},{"type":"text","text":"test_rrule","style":{"code":true}},{"type":"text","text":" right now that it doesn’t handle them.\nIt actually should handle them.\n\nthere is an issue open about it "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRulesTestUtils.jl/issues/117"},{"type":"text","text":"\nI don’t even think it is an incredibly hard PR.\nthough might run into trouble working out how to pass things to FiniteDifferences.jl."}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351"},{"client_msg_id":"b0cda305-e2ce-4af2-8cfa-3f71d7078469","type":"message","text":"actually, regarding that scenario (callable struct), I just need to return a `Composite{F}(; kwargs...)` with all the relevant fields of the callable struct `f::F`?\n\nFor now I hacked with an intermediate `(f::F)(x) = compute(f, x)`, which seems to work, even though I confess `Composite` still confuses me a little. Should I also use the `Composite` type to initialize the accumulation (eg `f ⊢ Composite{F}(; kwargs..)`  using only the \"numeric\" fields)?","user":"U6BJ9E351","ts":"1613584537.389200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vv32p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"actually, regarding that scenario (callable struct), I just need to return a "},{"type":"text","text":"Composite{F}(; kwargs...)","style":{"code":true}},{"type":"text","text":" with all the relevant fields of the callable struct "},{"type":"text","text":"f::F","style":{"code":true}},{"type":"text","text":"?\n\nFor now I hacked with an intermediate "},{"type":"text","text":"(f::F)(x) = compute(f, x)","style":{"code":true}},{"type":"text","text":", which seems to work, even though I confess "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" still confuses me a little. Should I also use the "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" type to initialize the accumulation (eg "},{"type":"text","text":"f ⊢ Composite{F}(; kwargs..)","style":{"code":true}},{"type":"text","text":"  using only the \"numeric\" fields)?"}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351","reactions":[{"name":"+1","users":["U6A936746"],"count":1}]},{"client_msg_id":"eadb10a3-e705-41cd-99fc-56423a54eb2f","type":"message","text":"&gt;  For now I hacked with an intermediate `(f::F)(x) = compute(f, x)`, which seems to work\nThat sounds good.\nCan you add that work around to the issue?","user":"U6A936746","ts":"1613585724.389700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pTf","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" For now I hacked with an intermediate "},{"type":"text","text":"(f::F)(x) = compute(f, x)","style":{"code":true}},{"type":"text","text":", which seems to work"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThat sounds good.\nCan you add that work around to the issue?"}]}]}],"thread_ts":"1613581012.388400","parent_user_id":"U6BJ9E351"}]