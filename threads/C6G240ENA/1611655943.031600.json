[{"client_msg_id":"352b6d27-e6ee-4573-8c4a-0091024b430e","type":"message","text":"Hi, I’m trying to implement an `AbstractMatrix` -like structure with a slightly modified definition for matrix multiplication. Having it declared like a subtype of `AbstractMatrix` is convenient, because it can be for example used in `Flux.Dense` .  During implementation, I ran into several problems, which I could solve, but now I found an obstacle which I can’t get around. So I was wondering is `Flux` + `Zygote` + `ChainRules` suitable for `AbstractArray` subtypes or is there some fundamental problem why this is not recommended?","user":"U7XHKP15W","ts":"1611655943.031600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JvtW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi, I’m trying to implement an "},{"type":"text","text":"AbstractMatrix","style":{"code":true}},{"type":"text","text":" -like structure with a slightly modified definition for matrix multiplication. Having it declared like a subtype of "},{"type":"text","text":"AbstractMatrix","style":{"code":true}},{"type":"text","text":" is convenient, because it can be for example used in "},{"type":"text","text":"Flux.Dense","style":{"code":true}},{"type":"text","text":" .  During implementation, I ran into several problems, which I could solve, but now I found an obstacle which I can’t get around. So I was wondering is "},{"type":"text","text":"Flux","style":{"code":true}},{"type":"text","text":" + "},{"type":"text","text":"Zygote","style":{"code":true}},{"type":"text","text":" + "},{"type":"text","text":"ChainRules","style":{"code":true}},{"type":"text","text":" suitable for "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" subtypes or is there some fundamental problem why this is not recommended?"}]}]}],"thread_ts":"1611655943.031600","reply_count":11,"reply_users_count":3,"latest_reply":"1611672418.042400","reply_users":["U7XHKP15W","UD0NS8PDF","U6A936746"],"subscribed":false},{"client_msg_id":"82489b85-5da5-4fe7-a8b4-3d0ec241928b","type":"message","text":"for reference, I don’t know how to define `Flux.params` for such structure. By default, it falls back to this definition\n```params!(p::Params, x::AbstractArray{&lt;:Number}, seen = IdSet()) = push!(p, x)```\ni.e. the whole structure is used as a key in IdDict. This leads to `ERROR: ArgumentError: broadcasting over dictionaries and NamedTuples is reserved` error, because gradient of my structure is a named tuple","user":"U7XHKP15W","ts":"1611656088.031800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kdym","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for reference, I don’t know how to define "},{"type":"text","text":"Flux.params","style":{"code":true}},{"type":"text","text":" for such structure. By default, it falls back to this definition\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"params!(p::Params, x::AbstractArray{<:Number}, seen = IdSet()) = push!(p, x)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"i.e. the whole structure is used as a key in IdDict. This leads to "},{"type":"text","text":"ERROR: ArgumentError: broadcasting over dictionaries and NamedTuples is reserved","style":{"code":true}},{"type":"text","text":" error, because gradient of my structure is a named tuple"}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"17032ae3-390c-4474-a82c-2f2463805cf8","type":"message","text":"On the other hand, if I define `Flux.params!` for my type and push all differentiable fields into the `Params` struct, `Flux.gradient` returns an incorrect result because the structure of `IdDict` is somehow broken","user":"U7XHKP15W","ts":"1611656187.032000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YA+k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On the other hand, if I define "},{"type":"text","text":"Flux.params!","style":{"code":true}},{"type":"text","text":" for my type and push all differentiable fields into the "},{"type":"text","text":"Params","style":{"code":true}},{"type":"text","text":" struct, "},{"type":"text","text":"Flux.gradient","style":{"code":true}},{"type":"text","text":" returns an incorrect result because the structure of "},{"type":"text","text":"IdDict","style":{"code":true}},{"type":"text","text":" is somehow broken"}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"f7eaf5d5-343d-4965-888d-3e572365d334","type":"message","text":"Perhaps this can be solved by storing the whole structure as a key in `IdDict` and then redefining `Flux.update!` so that the whole `NamedTuple` is updated. I’m not sure this is the best solution though.","user":"U7XHKP15W","ts":"1611656840.032400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cFycX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Perhaps this can be solved by storing the whole structure as a key in "},{"type":"text","text":"IdDict","style":{"code":true}},{"type":"text","text":" and then redefining "},{"type":"text","text":"Flux.update!","style":{"code":true}},{"type":"text","text":" so that the whole "},{"type":"text","text":"NamedTuple","style":{"code":true}},{"type":"text","text":" is updated. I’m not sure this is the best solution though."}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"dea7adb5-8e85-4f7f-a875-bca7c4ae1ab4","type":"message","text":"One option here is `@functor MyMatrix`. This tells params to recurse into your struct, and treat arrays inside it as the real parameters.","user":"UD0NS8PDF","ts":"1611657093.032600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"g3Pv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One option here is "},{"type":"text","text":"@functor MyMatrix","style":{"code":true}},{"type":"text","text":". This tells params to recurse into your struct, and treat arrays inside it as the real parameters."}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"76c17176-9b61-4c75-9dfe-9e30b5127a7a","type":"message","text":"But I’m not sure whether that’s what you want? If you want it to be viewed as one object, defining `update!` to understand how to adjust it based on the gradient seems reasonable.","user":"UD0NS8PDF","ts":"1611657180.032800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uht","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I’m not sure whether that’s what you want? If you want it to be viewed as one object, defining "},{"type":"text","text":"update!","style":{"code":true}},{"type":"text","text":" to understand how to adjust it based on the gradient seems reasonable."}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"a4ceb95d-ce7f-4846-97fa-0c129c047f6b","type":"message","text":"AFAIK `@functor` won’t work because a different definition of `params!` (the one above) is called for `AbstractArrays` instead of the one using the `@functor`","user":"U7XHKP15W","ts":"1611660141.035100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/87Be","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"AFAIK "},{"type":"text","text":"@functor","style":{"code":true}},{"type":"text","text":" won’t work because a different definition of "},{"type":"text","text":"params!","style":{"code":true}},{"type":"text","text":" (the one above) is called for "},{"type":"text","text":"AbstractArrays","style":{"code":true}},{"type":"text","text":" instead of the one using the "},{"type":"text","text":"@functor","style":{"code":true}}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"1a40d928-4b95-42b7-8c80-7b7c40cd14d8","type":"message","text":"Redefining `update!` like this\n```function update!(opt, x::MyMatrix, x̄::MyMatrix)\n  x.A .-= apply!(opt, x.A, x̄.A)\n  x.B .-= apply!(opt, x.B, x̄.B)\nend```\nwill probably solve it, but the optimizer will have gradients stored differently than what I get from `gradient(…)` call. I’m not sure if this can cause any other problems now or in the future","user":"U7XHKP15W","ts":"1611660310.035300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7UBS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Redefining "},{"type":"text","text":"update!","style":{"code":true}},{"type":"text","text":" like this\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function update!(opt, x::MyMatrix, x̄::MyMatrix)\n  x.A .-= apply!(opt, x.A, x̄.A)\n  x.B .-= apply!(opt, x.B, x̄.B)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"will probably solve it, but the optimizer will have gradients stored differently than what I get from "},{"type":"text","text":"gradient(…)","style":{"code":true}},{"type":"text","text":" call. I’m not sure if this can cause any other problems now or in the future"}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"0ab18c94-bdd2-430d-9746-7d24971ccd03","type":"message","text":"&gt;  So I was wondering is `Flux` + `Zygote` + `ChainRules` suitable for `AbstractArray` subtypes or is there some fundamental problem why this is not recommended?\nThis *is* recommended,\nIn theory this should all work.","user":"U6A936746","ts":"1611661958.035900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"exbC","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" So I was wondering is "},{"type":"text","text":"Flux","style":{"code":true}},{"type":"text","text":" + "},{"type":"text","text":"Zygote","style":{"code":true}},{"type":"text","text":" + "},{"type":"text","text":"ChainRules","style":{"code":true}},{"type":"text","text":" suitable for "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" subtypes or is there some fundamental problem why this is not recommended?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThis "},{"type":"text","text":"is","style":{"bold":true}},{"type":"text","text":" recommended,\nIn theory this should all work."}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"b6271f01-3e0f-4a21-9af6-c83f5f5b1f33","type":"message","text":"&gt;  but the optimizer will have gradients stored differently than what I get from `gradient(…)` call.\nIt is possible that you may need to convert from a structual representation of the gradient (like`NamedTuple` with a field per field) to a natural representation of the gradient (like `MyMatrix`)\nIn general it is being worked on / considered.\nSlowly.\n\n&gt;   I’m not sure if this can cause any other problems now or in the future\nNo, if anything in the future this will cause less problems.","user":"U6A936746","ts":"1611662081.036100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/8qv","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" but the optimizer will have gradients stored differently than what I get from "},{"type":"text","text":"gradient(…)","style":{"code":true}},{"type":"text","text":" call."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nIt is possible that you may need to convert from a structual representation of the gradient (like`NamedTuple` with a field per field) to a natural representation of the gradient (like "},{"type":"text","text":"MyMatrix","style":{"code":true}},{"type":"text","text":")\nIn general it is being worked on / considered.\nSlowly.\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"  I’m not sure if this can cause any other problems now or in the future"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nNo, if anything in the future this will cause less problems."}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"d3912018-0bf1-4a82-873e-b6746a01d396","type":"message","text":"It is possible that other functor-ish stuff might get confused, by assuming that any AbstractArray is a real parameter, and other things are containers. Like `destructure`, maybe. (And `update!` apparently, sorry!)","user":"UD0NS8PDF","ts":"1611662187.036300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"neO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It is possible that other functor-ish stuff might get confused, by assuming that any AbstractArray is a real parameter, and other things are containers. Like "},{"type":"text","text":"destructure","style":{"code":true}},{"type":"text","text":", maybe. (And "},{"type":"text","text":"update!","style":{"code":true}},{"type":"text","text":" apparently, sorry!)"}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"},{"client_msg_id":"955aa309-c930-4903-beef-315ba079d4de","type":"message","text":"thank you!","user":"U7XHKP15W","ts":"1611672418.042400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wxvv6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thank you!"}]}]}],"thread_ts":"1611655943.031600","parent_user_id":"U7XHKP15W"}]