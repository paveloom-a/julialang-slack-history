[{"client_msg_id":"c04e5099-4520-4bf8-b59b-0039d576a34f","type":"message","text":"Hi. I’m trying reverse-mode AD on my physics simulation and am getting an error which I don’t know how to fix:\n```\nERROR: ArgumentError: unable to check bounds for indices of type Interpolations.WeightedAdjIndex{2,Float64}\nStacktrace:\n [1] checkindex(::Type{Bool}, ::Base.OneTo{Int64}, ::Interpolations.WeightedAdjIndex{2,Float64}) at ./abstractarray.jl:561\n [2] checkbounds at ./abstractarray.jl:491 [inlined]\n [3] checkbounds at ./abstractarray.jl:506 [inlined]\n [4] view at ./subarray.jl:158 [inlined]\n [5] (::Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/array.jl:41\n [6] (::Zygote.var\"#2225#back#360\"{Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [7] (::Zygote.var\"#151#152\"{Zygote.var\"#2225#back#360\"{Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}}},Tuple{Tuple{Nothing},Tuple{Nothing}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/lib.jl:191\n [8] (::Zygote.var\"#1694#back#153\"{Zygote.var\"#151#152\"{Zygote.var\"#2225#back#360\"{Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}}},Tuple{Tuple{Nothing},Tuple{Nothing}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [9] BSplineInterpolation at /Users/ralph/.julia/packages/Interpolations/qHlUr/src/b-splines/indexing.jl:8 [inlined]\n [10] (::Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/lib.jl:191\n [11] (::Zygote.var\"#1694#back#153\"{Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [12] ScaledInterpolation at /Users/ralph/.julia/packages/Interpolations/qHlUr/src/scaling/scaling.jl:73 [inlined]\n [13] (::Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/lib.jl:191\n [14] (::Zygote.var\"#1694#back#153\"{Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [15] Extrapolation at /Users/ralph/.julia/packages/Interpolations/qHlUr/src/extrapolation/extrapolation.jl:49 [inlined]\n [16] (::typeof(∂(λ)))(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [17] push_here! at /Users/ralph/source/repos/picfun/test_push_autodiff.jl:93 [inlined]\n [18] (::typeof(∂(push_here!)))(::Nothing) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [19] diff_me at /Users/ralph/source/repos/picfun/test_push_autodiff.jl:220 [inlined]\n [20] (::typeof(∂(diff_me)))(::Array{Float64,1}) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [21] diff_capture at /Users/ralph/source/repos/picfun/test_push_autodiff.jl:233 [inlined]\n [22] (::typeof(∂(diff_capture)))(::Array{Float64,1}) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [23] (::Zygote.var\"#41#42\"{typeof(∂(diff_capture))})(::Array{Float64,1}) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface.jl:40\n [24] top-level scope at ./REPL[9]:5```\nFrom [17] on the Stacktrace is within the function `push_here!` which uses interpolations in combination with an iterative solver for a set of equations.\nThe signature of the function is like this:\n```function push_here(aux_0, aux_12, aux_new, interpolated_field, parameters, convergence_tolerances)```\nand updates `aux_12` and `aux_new` .\n\nI’ve came across this issue here <https://github.com/FluxML/Zygote.jl/issues/643>\nbut I’m unsure how to define a custom adjoint when the function mutates its arguments `aux_12` and `aux_new`. Does anyone have a suggestion on how to get such a function working with Zygote or reverse-mode AD?","user":"U018F5W2H24","ts":"1614682603.154400","team":"T68168MUP","edited":{"user":"U018F5W2H24","ts":"1614683005.000000"},"blocks":[{"type":"rich_text","block_id":"E7U","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi. I’m trying reverse-mode AD on my physics simulation and am getting an error which I don’t know how to fix:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\nERROR: ArgumentError: unable to check bounds for indices of type Interpolations.WeightedAdjIndex{2,Float64}\nStacktrace:\n [1] checkindex(::Type{Bool}, ::Base.OneTo{Int64}, ::Interpolations.WeightedAdjIndex{2,Float64}) at ./abstractarray.jl:561\n [2] checkbounds at ./abstractarray.jl:491 [inlined]\n [3] checkbounds at ./abstractarray.jl:506 [inlined]\n [4] view at ./subarray.jl:158 [inlined]\n [5] (::Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/array.jl:41\n [6] (::Zygote.var\"#2225#back#360\"{Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [7] (::Zygote.var\"#151#152\"{Zygote.var\"#2225#back#360\"{Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}}},Tuple{Tuple{Nothing},Tuple{Nothing}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/lib.jl:191\n [8] (::Zygote.var\"#1694#back#153\"{Zygote.var\"#151#152\"{Zygote.var\"#2225#back#360\"{Zygote.var\"#364#366\"{Array{Float64,1},Tuple{Interpolations.WeightedAdjIndex{2,Float64}}}},Tuple{Tuple{Nothing},Tuple{Nothing}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [9] BSplineInterpolation at /Users/ralph/.julia/packages/Interpolations/qHlUr/src/b-splines/indexing.jl:8 [inlined]\n [10] (::Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/lib.jl:191\n [11] (::Zygote.var\"#1694#back#153\"{Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [12] ScaledInterpolation at /Users/ralph/.julia/packages/Interpolations/qHlUr/src/scaling/scaling.jl:73 [inlined]\n [13] (::Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}})(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/lib/lib.jl:191\n [14] (::Zygote.var\"#1694#back#153\"{Zygote.var\"#151#152\"{typeof(∂(λ)),Tuple{Tuple{Nothing}}}})(::Float64) at /Users/ralph/.julia/packages/ZygoteRules/OjfTt/src/adjoint.jl:59\n [15] Extrapolation at /Users/ralph/.julia/packages/Interpolations/qHlUr/src/extrapolation/extrapolation.jl:49 [inlined]\n [16] (::typeof(∂(λ)))(::Float64) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [17] push_here! at /Users/ralph/source/repos/picfun/test_push_autodiff.jl:93 [inlined]\n [18] (::typeof(∂(push_here!)))(::Nothing) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [19] diff_me at /Users/ralph/source/repos/picfun/test_push_autodiff.jl:220 [inlined]\n [20] (::typeof(∂(diff_me)))(::Array{Float64,1}) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [21] diff_capture at /Users/ralph/source/repos/picfun/test_push_autodiff.jl:233 [inlined]\n [22] (::typeof(∂(diff_capture)))(::Array{Float64,1}) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface2.jl:0\n [23] (::Zygote.var\"#41#42\"{typeof(∂(diff_capture))})(::Array{Float64,1}) at /Users/ralph/.julia/packages/Zygote/KpME9/src/compiler/interface.jl:40\n [24] top-level scope at ./REPL[9]:5"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"From [17] on the Stacktrace is within the function "},{"type":"text","text":"push_here!","style":{"code":true}},{"type":"text","text":" which uses interpolations in combination with an iterative solver for a set of equations.\nThe signature of the function is like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function push_here(aux_0, aux_12, aux_new, interpolated_field, parameters, convergence_tolerances)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and updates "},{"type":"text","text":"aux_12","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"aux_new","style":{"code":true}},{"type":"text","text":" .\n\nI’ve came across this issue here "},{"type":"link","url":"https://github.com/FluxML/Zygote.jl/issues/643"},{"type":"text","text":"\nbut I’m unsure how to define a custom adjoint when the function mutates its arguments "},{"type":"text","text":"aux_12","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"aux_new","style":{"code":true}},{"type":"text","text":". Does anyone have a suggestion on how to get such a function working with Zygote or reverse-mode AD?"}]}]}],"thread_ts":"1614682603.154400","reply_count":6,"reply_users_count":2,"latest_reply":"1614893542.226800","reply_users":["UD0NS8PDF","U018F5W2H24"],"subscribed":false},{"client_msg_id":"E818F315-21CF-4696-99C7-1E8583F3C050","type":"message","text":"Might it be possible to wrap this function call with Zygote.forwarddiff? ","user":"UD0NS8PDF","ts":"1614691200.156000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ka7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Might it be possible to wrap this function call with Zygote.forwarddiff? "}]}]}],"thread_ts":"1614682603.154400","parent_user_id":"U018F5W2H24"},{"client_msg_id":"73e12e20-25e8-4382-8a60-999d226ee48d","type":"message","text":"It works fine with ForwardDiff.jl . But eventually I’d like to patch in a deep neural network in the program and would like to get reverse mode working.","user":"U018F5W2H24","ts":"1614692157.156300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rkFIs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It works fine with ForwardDiff.jl . But eventually I’d like to patch in a deep neural network in the program and would like to get reverse mode working."}]}]}],"thread_ts":"1614682603.154400","parent_user_id":"U018F5W2H24"},{"client_msg_id":"4dae5007-4ff8-4da4-99ad-69984bf65da2","type":"message","text":"Is it possible though to couple them?","user":"U018F5W2H24","ts":"1614692164.156500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QMBX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it possible though to couple them?"}]}]}],"thread_ts":"1614682603.154400","parent_user_id":"U018F5W2H24"},{"client_msg_id":"B1B6D518-F62D-4151-BC46-C846E84C6891","type":"message","text":"Yes, the function I suggested is such a patch, to use fwd for just one thing","user":"UD0NS8PDF","ts":"1614692424.157800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pjXs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, the function I suggested is such a patch, to use fwd for just one thing"}]}]}],"thread_ts":"1614682603.154400","parent_user_id":"U018F5W2H24"},{"client_msg_id":"b4a2a92a-e390-4a5e-b1af-edff0101610d","type":"message","text":"Cool. Do you maybe have a code example how to wrap Zygote.forwarddiff inside a reverse-mode gradient call?","user":"U018F5W2H24","ts":"1614693451.158000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2lCH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Cool. Do you maybe have a code example how to wrap Zygote.forwarddiff inside a reverse-mode gradient call?"}]}]}],"thread_ts":"1614682603.154400","parent_user_id":"U018F5W2H24"},{"client_msg_id":"3447b003-3cd5-427b-9825-c72092183ae9","type":"message","text":"<@UD0NS8PDF> Okay, I’m stuck. I need to construct the interpolator inside the function of which I’m calling pullback and can’t get it to work. Here’s a minimum working example:\n<https://github.com/FluxML/Zygote.jl/issues/914>","user":"U018F5W2H24","ts":"1614893542.226800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7z5","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" Okay, I’m stuck. I need to construct the interpolator inside the function of which I’m calling pullback and can’t get it to work. Here’s a minimum working example:\n"},{"type":"link","url":"https://github.com/FluxML/Zygote.jl/issues/914"}]}]}],"thread_ts":"1614682603.154400","parent_user_id":"U018F5W2H24"}]