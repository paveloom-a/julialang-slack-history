[{"client_msg_id":"e15fa6df-711e-42a1-9b63-4c50ce2f9b1a","type":"message","text":"I’ve been trying to use Zygote to differentiate a function that is Real -&gt; Real, but uses complex numbers internally. Sometimes Zygote returns a complex gradient, while other times, it doesn’t, and I can’t figure out why. Any ideas? Ideally, it never should, IMO.\n\nMWE:\n```julia&gt; using Zygote\njulia&gt; f(θ) = abs(cis(θ) + cis(2θ));\njulia&gt; f(0.1)     # real -&gt; real\n1.9975005207899326\njulia&gt; f'(0.1)    # returns real gradient, as it should\n-0.049979169270678386\njulia&gt; f1(x) = 2 * abs(x + 1im * 2x);\njulia&gt; f1(2.0)   # real -&gt; real\n8.94427190999916\njulia&gt; f1'(2.0)  # returns complex gradient\n4.47213595499958 + 0.0im```","user":"U017AJ68PFZ","ts":"1611583598.021700","team":"T68168MUP","edited":{"user":"U017AJ68PFZ","ts":"1611583615.000000"},"blocks":[{"type":"rich_text","block_id":"pNN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’ve been trying to use Zygote to differentiate a function that is Real -> Real, but uses complex numbers internally. Sometimes Zygote returns a complex gradient, while other times, it doesn’t, and I can’t figure out why. Any ideas? Ideally, it never should, IMO.\n\nMWE:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using Zygote\njulia> f(θ) = abs(cis(θ) + cis(2θ));\njulia> f(0.1)     # real -> real\n1.9975005207899326\njulia> f'(0.1)    # returns real gradient, as it should\n-0.049979169270678386\njulia> f1(x) = 2 * abs(x + 1im * 2x);\njulia> f1(2.0)   # real -> real\n8.94427190999916\njulia> f1'(2.0)  # returns complex gradient\n4.47213595499958 + 0.0im"}]}]}],"thread_ts":"1611583598.021700","reply_count":8,"reply_users_count":4,"latest_reply":"1611636244.026800","reply_users":["U6A936746","U017AJ68PFZ","UHDQQ4GN6","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"bf035d22-d5e4-47e5-a698-f4556f3527d2","type":"message","text":"I suspect this is because Zygote doesn’t “Take Complex  Seriously”:tm:.\n\nThis is the issue I think\n<https://github.com/FluxML/Zygote.jl/issues/342>\ncc <@UHDQQ4GN6>\n\nChainRules does, but not all rules have been moved to ChainRules (including explicitly several with Complex numbers due to the fact that taking it seriously would change the behaviour).","user":"U6A936746","ts":"1611584476.022000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uWa7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I suspect this is because Zygote doesn’t “Take Complex  Seriously”"},{"type":"emoji","name":"tm"},{"type":"text","text":".\n\nThis is the issue I think\n"},{"type":"link","url":"https://github.com/FluxML/Zygote.jl/issues/342"},{"type":"text","text":"\ncc "},{"type":"user","user_id":"UHDQQ4GN6"},{"type":"text","text":"\n\nChainRules does, but not all rules have been moved to ChainRules (including explicitly several with Complex numbers due to the fact that taking it seriously would change the behaviour)."}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ","reactions":[{"name":"+1","users":["U017AJ68PFZ"],"count":1}]},{"client_msg_id":"564a26f8-27c1-4888-9433-38759146615d","type":"message","text":"Ah, yes, exactly this issue. Thx.","user":"U017AJ68PFZ","ts":"1611584535.022300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qaW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, yes, exactly this issue. Thx."}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ"},{"client_msg_id":"c9a43c3b-2a15-423a-9126-bb74942d2a69","type":"message","text":"The issue isn't that Zygote doesn't take complex numbers seriously. Zygote takes the position that all real numbers are complex numbers, so if anything ever promotes it to actually be `Complex`, then the pullback will (almost) always be complex.\n\nThe way around this is to explicitly real-ify before introducing a complex component. e.g. `2 * abs(real(x)) + im * real(2x))`. If `x` is real, this is a no-op, and the pullback is realified. Alternatively, don't use `a + im * b` syntax, and instead use `complex(a, b)`. The latter requires that `a` and `b` be real, and the pullback is real-ified.\n\nThis issue is also relevant: <https://github.com/JuliaDiff/ChainRulesCore.jl/issues/176>","user":"UHDQQ4GN6","ts":"1611608078.025000","team":"T68168MUP","edited":{"user":"UHDQQ4GN6","ts":"1611618576.000000"},"blocks":[{"type":"rich_text","block_id":"NRd4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The issue isn't that Zygote doesn't take complex numbers seriously. Zygote takes the position that all real numbers are complex numbers, so if anything ever promotes it to actually be "},{"type":"text","text":"Complex","style":{"code":true}},{"type":"text","text":", then the pullback will (almost) always be complex.\n\nThe way around this is to explicitly real-ify before introducing a complex component. e.g. "},{"type":"text","text":"2 * abs(real(x)) + im * real(2x))","style":{"code":true}},{"type":"text","text":". If "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is real, this is a no-op, and the pullback is realified. Alternatively, don't use "},{"type":"text","text":"a + im * b","style":{"code":true}},{"type":"text","text":" syntax, and instead use "},{"type":"text","text":"complex(a, b)","style":{"code":true}},{"type":"text","text":". The latter requires that "},{"type":"text","text":"a","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"b","style":{"code":true}},{"type":"text","text":" be real, and the pullback is real-ified.\n\nThis issue is also relevant: "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRulesCore.jl/issues/176"}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ","reactions":[{"name":"ty","users":["U6A936746","U017AJ68PFZ"],"count":2}]},{"client_msg_id":"368d8862-2a4f-4400-a8ca-adc0dce0bd15","type":"message","text":"I guess you can easily define a `keeptype(x) = x` function whose adjoint projects to real if `x` is real, as a quick way to fix real work.\n\nBut I agree that really we should make it do this globally, this never seems like desirable behaviour. I had a few-lines tweak to ZygoteRules somewhere to make this happen, somewhere…","user":"UD0NS8PDF","ts":"1611608303.025200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iWj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess you can easily define a "},{"type":"text","text":"keeptype(x) = x","style":{"code":true}},{"type":"text","text":" function whose adjoint projects to real if "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is real, as a quick way to fix real work.\n\nBut I agree that really we should make it do this globally, this never seems like desirable behaviour. I had a few-lines tweak to ZygoteRules somewhere to make this happen, somewhere…"}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ"},{"client_msg_id":"ced7d9f6-10df-45d7-a6ad-445b473089ec","type":"message","text":"Yeah, one should be able to use the `a + im * b` syntax with real numbers and have the pullbacks by real-ified.  It's just a matter of adding a few specific scalar overloads, but I agree it is probably better if we can work out a way to do this globally.\n\nMore generally, if eltype promotion happens in the primal, something like eltype demotion should happen in the pullback. That would be tricky to implement in rules themselves and is why I've elsewhere proposed having a cotangent projection step between pullbacks.","user":"UHDQQ4GN6","ts":"1611608767.025400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+S3h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, one should be able to use the "},{"type":"text","text":"a + im * b","style":{"code":true}},{"type":"text","text":" syntax with real numbers and have the pullbacks by real-ified.  It's just a matter of adding a few specific scalar overloads, but I agree it is probably better if we can work out a way to do this globally.\n\nMore generally, if eltype promotion happens in the primal, something like eltype demotion should happen in the pullback. That would be tricky to implement in rules themselves and is why I've elsewhere proposed having a cotangent projection step between pullbacks."}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ","reactions":[{"name":"+1","users":["U6A936746","U017AJ68PFZ"],"count":2}]},{"client_msg_id":"18bfd9d1-ac67-4459-aa2e-48831e66d6d6","type":"message","text":"Yes agree, the perfect rules would never generate the complex part, but that’s going to be a huge headache to make happen in every single rule, I think?  But projection step on every pullback would get things back on track, and should be free when not needed.","user":"UD0NS8PDF","ts":"1611608914.025600","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1611608965.000000"},"blocks":[{"type":"rich_text","block_id":"UAg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes agree, the perfect rules would never generate the complex part, but that’s going to be a huge headache to make happen in every single rule, I think?  But projection step on every pullback would get things back on track, and should be free when not needed."}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ"},{"client_msg_id":"81b9af16-e95b-41cb-9cf3-98b484f843aa","type":"message","text":"Yes, after reading the issues, I understand how Zygote “thinks”. The solution I had was a to use `hook()` to make the gradient real. But the <@UHDQQ4GN6> and <@UD0NS8PDF> ’s suggestions on forcing the type of be real are even better.\n\nBut this is something that has been raised a few times (and I personally know a few people who’ve tripped over it), so seems to be a common non-intuitive behavior of Zygote. Would be nice to address globally, or at the very minimum, have a section in the Zygote documentation on complex differentiation to explicitly explain this.","user":"U017AJ68PFZ","ts":"1611634128.026400","team":"T68168MUP","edited":{"user":"U017AJ68PFZ","ts":"1611634151.000000"},"blocks":[{"type":"rich_text","block_id":"MjT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, after reading the issues, I understand how Zygote “thinks”. The solution I had was a to use "},{"type":"text","text":"hook()","style":{"code":true}},{"type":"text","text":" to make the gradient real. But the "},{"type":"user","user_id":"UHDQQ4GN6"},{"type":"text","text":" and "},{"type":"user","user_id":"UD0NS8PDF"},{"type":"text","text":" ’s suggestions on forcing the type of be real are even better.\n\nBut this is something that has been raised a few times (and I personally know a few people who’ve tripped over it), so seems to be a common non-intuitive behavior of Zygote. Would be nice to address globally, or at the very minimum, have a section in the Zygote documentation on complex differentiation to explicitly explain this."}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ"},{"client_msg_id":"49030283-95eb-420b-8ab1-e016677590c6","type":"message","text":"I agree. We should formally document the difference in behavior somewhere. But more importantly, because ChainRules going forward will continue to take this stance that Zygote disagrees with, rules used by Zygote will be inconsistent in this behavior. And I think we need to decide what to do about that. My vote is for Zygote to adopt ChainRules's convention.","user":"UHDQQ4GN6","ts":"1611636244.026800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IiQb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree. We should formally document the difference in behavior somewhere. But more importantly, because ChainRules going forward will continue to take this stance that Zygote disagrees with, rules used by Zygote will be inconsistent in this behavior. And I think we need to decide what to do about that. My vote is for Zygote to adopt ChainRules's convention."}]}]}],"thread_ts":"1611583598.021700","parent_user_id":"U017AJ68PFZ","reactions":[{"name":"+1","users":["U017AJ68PFZ","U6A936746","UD0NS8PDF"],"count":3}]}]