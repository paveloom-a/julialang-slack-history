[{"client_msg_id":"87049932-dd76-4fbb-9baf-31d576e426af","type":"message","text":"An rrule derivation question (tldr; are there useful trace identities/tricks for arbitrary einstein summations? Other recommended ways to derive the pullback from the pushforward?):\nI have derived and implemented a working `frule` for an equation, as follows:\n• `Ω(P, Q) = sqrt(P * Q)`\n• using `Ω^2 = P*Q`, derive `Ω̇ Ω + Ω Ω̇ = Ṗ Q + P Q̇`\n• From a previous calculation, I have the eigenvectors `ϕ` and eigenvalues `q` (denoted by a diagonal matrix `Λ`)\n• So, `Ω̇ = ϕ Y ϕ^-1`  for some `Y`, we can derive `Y` by nothing the eigenvectors/values and putting in the above equations `ΛY + YΛ = ϕ^-1 (Ṗ Q + P Q̇) ϕ` . Because these are diagonal matrices, this Sylvester equation reduces to `Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)`\nThis is all fantastic and I can verify my forward equation works, I'm re-using my eigenvectors, everything is swell.\n\nBut I am having difficulty deriving the `rrule`, at least according to the  \"match trace expressions\" trick. The sticking point here is `Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)` . I need to move the `Ṗ`  and `Q̇` to the end within the overall expression, but because of the denominator here I can't use the cyclic property of the trace. Is there a different tack I should take to this problem? Or is there some trace identity that is useful here? Any recommendations I should look into?","user":"UETJU4TG8","ts":"1615770363.356500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8sjH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"An rrule derivation question (tldr; are there useful trace identities/tricks for arbitrary einstein summations? Other recommended ways to derive the pullback from the pushforward?):\nI have derived and implemented a working "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" for an equation, as follows:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ω(P, Q) = sqrt(P * Q)","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"using "},{"type":"text","text":"Ω^2 = P*Q","style":{"code":true}},{"type":"text","text":", derive "},{"type":"text","text":"Ω̇ Ω + Ω Ω̇ = Ṗ Q + P Q̇","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"From a previous calculation, I have the eigenvectors "},{"type":"text","text":"ϕ","style":{"code":true}},{"type":"text","text":" and eigenvalues "},{"type":"text","text":"q","style":{"code":true}},{"type":"text","text":" (denoted by a diagonal matrix "},{"type":"text","text":"Λ","style":{"code":true}},{"type":"text","text":")"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So, "},{"type":"text","text":"Ω̇ = ϕ Y ϕ^-1","style":{"code":true}},{"type":"text","text":"  for some "},{"type":"text","text":"Y","style":{"code":true}},{"type":"text","text":", we can derive "},{"type":"text","text":"Y","style":{"code":true}},{"type":"text","text":" by nothing the eigenvectors/values and putting in the above equations "},{"type":"text","text":"ΛY + YΛ = ϕ^-1 (Ṗ Q + P Q̇) ϕ","style":{"code":true}},{"type":"text","text":" . Because these are diagonal matrices, this Sylvester equation reduces to "},{"type":"text","text":"Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)","style":{"code":true}}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"This is all fantastic and I can verify my forward equation works, I'm re-using my eigenvectors, everything is swell.\n\nBut I am having difficulty deriving the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":", at least according to the  \"match trace expressions\" trick. The sticking point here is "},{"type":"text","text":"Y_ij = [ϕ^-1 (Ṗ Q + P Q̇) ϕ]_ij / (q_i + q_j)","style":{"code":true}},{"type":"text","text":" . I need to move the "},{"type":"text","text":"Ṗ","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"Q̇","style":{"code":true}},{"type":"text","text":" to the end within the overall expression, but because of the denominator here I can't use the cyclic property of the trace. Is there a different tack I should take to this problem? Or is there some trace identity that is useful here? Any recommendations I should look into?"}]}]}],"thread_ts":"1615770363.356500","reply_count":10,"reply_users_count":2,"latest_reply":"1615775423.358600","reply_users":["UHDQQ4GN6","UETJU4TG8"],"subscribed":false},{"client_msg_id":"ff26ffad-e9f0-4410-b20c-17a42d5b6903","type":"message","text":"What are `ϕ` and `q`  eigenvectors and eigenvalues of?","user":"UHDQQ4GN6","ts":"1615771108.356700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zNLq1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What are "},{"type":"text","text":"ϕ","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"q","style":{"code":true}},{"type":"text","text":"  eigenvectors and eigenvalues of?"}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"abb33358-d860-42dc-84c3-e7751557d378","type":"message","text":"They are the eigenvalues/vectors of `Ω`  (in the code, we do `eigen(P*Q)` to get `q^2` and `ϕ`)","user":"UETJU4TG8","ts":"1615771544.356900","team":"T68168MUP","edited":{"user":"UETJU4TG8","ts":"1615771611.000000"},"blocks":[{"type":"rich_text","block_id":"th9N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"They are the eigenvalues/vectors of "},{"type":"text","text":"Ω","style":{"code":true}},{"type":"text","text":"  (in the code, we do "},{"type":"text","text":"eigen(P*Q)","style":{"code":true}},{"type":"text","text":" to get "},{"type":"text","text":"q^2","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"ϕ","style":{"code":true}},{"type":"text","text":")"}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"de0779c4-3ae0-401a-8dd8-e484f49c3f92","type":"message","text":"There are a few ways to work this out. Let `A=P*Q` . `sqrt(A)` is a matrix function, which has the magical property that the pushforward is almost the same as the pullback. Specifically, if the pushforward of a matrix function `f` is `f^*: Ȧ ↦ Ω̇` then, the pullback `f_*` is  `f_* = ((f^*)(Ω̄'))'` , that is, the pushforward pre- and post-composed with an adjoint. You might find it useful to look at ChainRules's generic code for rules of matrix functions (<https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.54/src/rulesets/LinearAlgebra/matfun.jl>) or the rule for `sqrt` of a hermitian matrix, which uses the eigendecomposition: <https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.54/src/rulesets/LinearAlgebra/symmetric.jl#L295-L448>.","user":"UHDQQ4GN6","ts":"1615772554.357200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4eNgn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are a few ways to work this out. Let "},{"type":"text","text":"A=P*Q","style":{"code":true}},{"type":"text","text":" . "},{"type":"text","text":"sqrt(A)","style":{"code":true}},{"type":"text","text":" is a matrix function, which has the magical property that the pushforward is almost the same as the pullback. Specifically, if the pushforward of a matrix function "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"f^*: Ȧ ↦ Ω̇","style":{"code":true}},{"type":"text","text":" then, the pullback "},{"type":"text","text":"f_*","style":{"code":true}},{"type":"text","text":" is  "},{"type":"text","text":"f_* = ((f^*)(Ω̄'))'","style":{"code":true}},{"type":"text","text":" , that is, the pushforward pre- and post-composed with an adjoint. You might find it useful to look at ChainRules's generic code for rules of matrix functions ("},{"type":"link","url":"https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.54/src/rulesets/LinearAlgebra/matfun.jl"},{"type":"text","text":") or the rule for "},{"type":"text","text":"sqrt","style":{"code":true}},{"type":"text","text":" of a hermitian matrix, which uses the eigendecomposition: "},{"type":"link","url":"https://github.com/JuliaDiff/ChainRules.jl/blob/v0.7.54/src/rulesets/LinearAlgebra/symmetric.jl#L295-L448"},{"type":"text","text":"."}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"de19a371-74cf-41f3-83d2-588fa6b36567","type":"message","text":"But give me a second to write up a specific answer to your question.","user":"UHDQQ4GN6","ts":"1615772569.357400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FvZzb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But give me a second to write up a specific answer to your question."}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"c3ef5014-1766-4934-9fbf-eeab0aa7533a","type":"message","text":"Thank you! A lot of the motivation for this is to avoid doing the eigendecomposition again (because I already have it). But what you linked should be good inspiration because `eigen!` is the first call in `matfun` , I'll just need to do `matfun_frechet` given my intermediates. It looks like there's a helpful reference in what you linked as well - I'll study that to work through the math. (Honestly, I think the lemma you cited has given me a lot of confidence in seeing this through)","user":"UETJU4TG8","ts":"1615773433.357600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sP2Wy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you! A lot of the motivation for this is to avoid doing the eigendecomposition again (because I already have it). But what you linked should be good inspiration because "},{"type":"text","text":"eigen!","style":{"code":true}},{"type":"text","text":" is the first call in "},{"type":"text","text":"matfun","style":{"code":true}},{"type":"text","text":" , I'll just need to do "},{"type":"text","text":"matfun_frechet","style":{"code":true}},{"type":"text","text":" given my intermediates. It looks like there's a helpful reference in what you linked as well - I'll study that to work through the math. (Honestly, I think the lemma you cited has given me a lot of confidence in seeing this through)"}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"a6aa6a20-30a4-47f5-b8da-a18641cefc02","type":"message","text":"Assuming the expression you've written for the pushforward is correct, you have\n`Ω̇ = ϕ ((ϕ^-1 (Ṗ Q + P Q̇) ϕ) .* F) ϕ^-1`\nwhere `F_ij = 1/(q_i + q_j)`.\nThen, following <https://juliadiff.org/ChainRulesCore.jl/dev/arrays.html#Reverse-mode-rules> (but using the inner product notation which is cleaner and more general:\n```&lt;Ω̄,Ω̇&gt; = &lt;ϕ' Ω̄ ϕ'^-1, (ϕ^-1 (Ṗ Q + P Q̇) ϕ) .* F&gt; \n= &lt;(ϕ' Ω̄ ϕ'^-1) .* F', ϕ^-1 (Ṗ Q + P Q̇) ϕ&gt; \n= &lt;ϕ'^-1 ((ϕ' Ω̄ ϕ'^-1) .* F') ϕ', Ṗ Q + P Q̇&gt; \n= &lt;X̄, Ṗ Q + P Q̇&gt;   # introduce X̄ = ϕ'^-1 ((ϕ' Ω̄ ϕ'^-1) .* F') ϕ'\n= &lt;X̄, Ṗ Q&gt; + &lt;X̄, P Q̇&gt; \n= &lt;X̄ Q', Ṗ&gt; + &lt;P' X̄, Q̇&gt;```\nso\n`X̄ = ϕ'^-1 ((ϕ' Ω̄ ϕ'^-1) .* F') ϕ'`\n`P̄ = X̄ Q'`\n`Q̄ = P' X̄`\nMy apologies if I've made an error somewhere.","user":"UHDQQ4GN6","ts":"1615773704.357800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ku637","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Assuming the expression you've written for the pushforward is correct, you have\n"},{"type":"text","text":"Ω̇ = ϕ ((ϕ^-1 (Ṗ Q + P Q̇) ϕ) .* F) ϕ^-1","style":{"code":true}},{"type":"text","text":"\nwhere "},{"type":"text","text":"F_ij = 1/(q_i + q_j)","style":{"code":true}},{"type":"text","text":".\nThen, following "},{"type":"link","url":"https://juliadiff.org/ChainRulesCore.jl/dev/arrays.html#Reverse-mode-rules"},{"type":"text","text":" (but using the inner product notation which is cleaner and more general:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"<Ω̄,Ω̇> = <ϕ' Ω̄ ϕ'^-1, (ϕ^-1 (Ṗ Q + P Q̇) ϕ) .* F> \n= <(ϕ' Ω̄ ϕ'^-1) .* F', ϕ^-1 (Ṗ Q + P Q̇) ϕ> \n= <ϕ'^-1 ((ϕ' Ω̄ ϕ'^-1) .* F') ϕ', Ṗ Q + P Q̇> \n= <X̄, Ṗ Q + P Q̇>   # introduce X̄ = ϕ'^-1 ((ϕ' Ω̄ ϕ'^-1) .* F') ϕ'\n= <X̄, Ṗ Q> + <X̄, P Q̇> \n= <X̄ Q', Ṗ> + <P' X̄, Q̇>"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"so\n"},{"type":"text","text":"X̄ = ϕ'^-1 ((ϕ' Ω̄ ϕ'^-1) .* F') ϕ'","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"P̄ = X̄ Q'","style":{"code":true}},{"type":"text","text":"\n"},{"type":"text","text":"Q̄ = P' X̄","style":{"code":true}},{"type":"text","text":"\nMy apologies if I've made an error somewhere."}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"ad3a4f5e-ba79-4eca-b1f5-bb9ec9f8ba59","type":"message","text":"Awesome, and you're welcome! Yeah, this is definitely the right approach (that is, reusing the factorization). We use that approach everywhere. If I may ask, does `P*Q` have any special structure? Computing matrix functions and their pushforwards/pullbacks using the eigendecomposition tends to have accuracy and numerical stability issues except when the eigenvectors are unitary and eigenvalues are completely unique. The latter case can be partially solved (see the `_diffquot` code in the above links). But if the eigenvectors are non-unitary, you may have better luck using the Schur decomposition.","user":"UHDQQ4GN6","ts":"1615773954.358000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"47q2l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Awesome, and you're welcome! Yeah, this is definitely the right approach (that is, reusing the factorization). We use that approach everywhere. If I may ask, does "},{"type":"text","text":"P*Q","style":{"code":true}},{"type":"text","text":" have any special structure? Computing matrix functions and their pushforwards/pullbacks using the eigendecomposition tends to have accuracy and numerical stability issues except when the eigenvectors are unitary and eigenvalues are completely unique. The latter case can be partially solved (see the "},{"type":"text","text":"_diffquot","style":{"code":true}},{"type":"text","text":" code in the above links). But if the eigenvectors are non-unitary, you may have better luck using the Schur decomposition."}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"0b6ed930-89b2-4d10-987e-3460d740e4b9","type":"message","text":"Unfortunately `P * Q` is, in general, a non-hermitian non-symmetric complex matrix. The degenerate eigenvalue/eigenvector problem is exactly what this formulation is trying to tip-toe around by avoiding the calculation of the derivatives of the eigenvectors/eigenvalues (what I posed is one of the reformulations on that path).\n\nIn your derivation above, I have a quick question - the `.*` just follows the typical rules? How is `.*` parsed mathematically (in other words, what keywords should I search for?)","user":"UETJU4TG8","ts":"1615774671.358200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UzJL6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Unfortunately "},{"type":"text","text":"P * Q","style":{"code":true}},{"type":"text","text":" is, in general, a non-hermitian non-symmetric complex matrix. The degenerate eigenvalue/eigenvector problem is exactly what this formulation is trying to tip-toe around by avoiding the calculation of the derivatives of the eigenvectors/eigenvalues (what I posed is one of the reformulations on that path).\n\nIn your derivation above, I have a quick question - the "},{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":" just follows the typical rules? How is "},{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":" parsed mathematically (in other words, what keywords should I search for?)"}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"e6ec3e46-ca6e-458c-a83a-e1d89f39ac28","type":"message","text":"`.*` is the julia elementwise product aka hadamard product","user":"UHDQQ4GN6","ts":"1615775265.358400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KpBM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":" is the julia elementwise product aka hadamard product"}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"},{"client_msg_id":"c5b86e09-8bd7-4934-b5d0-fcf418319b51","type":"message","text":"Thanks! Basic question I know but I was blanking on Hadamard product in my searches","user":"UETJU4TG8","ts":"1615775423.358600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mIc1h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks! Basic question I know but I was blanking on Hadamard product in my searches"}]}]}],"thread_ts":"1615770363.356500","parent_user_id":"UETJU4TG8"}]