[{"client_msg_id":"38256337-601f-42c2-8939-400ea0a0c492","type":"message","text":"One day i need to do something with\n```function linearize(f, x...)\n    function pushfoward(ẋ...)\n        y, ẏ = frule(ẋ, f, x...)\n        return ẏ\n    end\n    return pushfoward\nend```\nPossibly a companion package to ChainRules that does this, and other things like pullback via pushforwards and pushforwards via pullback.\nand getting jacobians and directional derivatives and gradients out simply.","user":"U6A936746","ts":"1611845383.058800","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1611845466.000000"},"blocks":[{"type":"rich_text","block_id":"Y5qj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One day i need to do something with\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function linearize(f, x...)\n    function pushfoward(ẋ...)\n        y, ẏ = frule(ẋ, f, x...)\n        return ẏ\n    end\n    return pushfoward\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nPossibly a companion package to ChainRules that does this, and other things like pullback via pushforwards and pushforwards via pullback.\nand getting jacobians and directional derivatives and gradients out simply."}]}]}],"thread_ts":"1611845383.058800","reply_count":6,"reply_users_count":2,"latest_reply":"1611911267.070700","reply_users":["U6A936746","UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"bfc391c7-3725-44a2-95ec-31d434770705","type":"message","text":"also it should do\n<https://julialang.slack.com/archives/C677F4ABD/p1611844521065200>","user":"U6A936746","ts":"1611857803.067300","team":"T68168MUP","attachments":[{"from_url":"https://julialang.slack.com/archives/C677F4ABD/p1611844521065200","fallback":"[January 28th, 2021 6:35 AM] oxinabox: Given a linear operator expressed as a function mapping a vector to a vector,\nis there a standard method for finding its matrix representation?\nIs there something like just applying it to a basis one column at a time, and then concatenating the output?","ts":"1611844521.065200","author_id":"U6A936746","author_subname":"Lyndon White","channel_id":"C677F4ABD","channel_name":"linear-algebra","is_msg_unfurl":true,"is_thread_root_unfurl":true,"text":"Given a linear operator expressed as a function mapping a vector to a vector,\nis there a standard method for finding its matrix representation?\nIs there something like just applying it to a basis one column at a time, and then concatenating the output?","author_name":"Lyndon White","author_link":"https://julialang.slack.com/team/U6A936746","author_icon":"https://avatars.slack-edge.com/2017-07-25/216502576448_36aaf550196bfa49acdc_48.jpg","mrkdwn_in":["text"],"id":1,"original_url":"https://julialang.slack.com/archives/C677F4ABD/p1611844521065200","footer":"Thread in #linear-algebra"}],"blocks":[{"type":"rich_text","block_id":"rFE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"also it should do\n"},{"type":"link","url":"https://julialang.slack.com/archives/C677F4ABD/p1611844521065200"}]}]}],"thread_ts":"1611845383.058800","parent_user_id":"U6A936746"},{"client_msg_id":"7cc31a9f-b3b1-4882-9304-d165c3425bb5","type":"message","text":"&gt; pullback via pushforwards and pushforwards via pullback\nWould this be using the inner product identity to find the adjoint operator somehow?","user":"UHDQQ4GN6","ts":"1611860640.068100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B9R5o","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"pullback via pushforwards and pushforwards via pullback"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Would this be using the inner product identity to find the adjoint operator somehow?"}]}]}],"thread_ts":"1611845383.058800","parent_user_id":"U6A936746"},{"client_msg_id":"7dce2ed5-6071-471e-9501-7c84bdc0e3f2","type":"message","text":"yeah something like that.\nOr if it comes to it materialising the jacobian outright.\n\nIt mostly would not be fast except for single input single output functions.\n\nThough there is a fast way, that :jax: does that is a source code transformation.\n(still not certain to be fast since forward or reverse is going to be the fast one)","user":"U6A936746","ts":"1611861019.069200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ILV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah something like that.\nOr if it comes to it materialising the jacobian outright.\n\nIt mostly would not be fast except for single input single output functions.\n\nThough there is a fast way, that "},{"type":"emoji","name":"jax"},{"type":"text","text":" does that is a source code transformation.\n(still not certain to be fast since forward or reverse is going to be the fast one)"}]}]}],"thread_ts":"1611845383.058800","parent_user_id":"U6A936746"},{"client_msg_id":"c0d0a562-881c-4cf0-8cf7-4764c6a5a0a3","type":"message","text":"It would be cool to have a :jax: -like approach. For the cases where I'm too lazy to derive the `rrule` from the `frule` .","user":"UHDQQ4GN6","ts":"1611862319.069900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TT2bH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It would be cool to have a "},{"type":"emoji","name":"jax"},{"type":"text","text":" -like approach. For the cases where I'm too lazy to derive the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" from the "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1611845383.058800","parent_user_id":"U6A936746","reactions":[{"name":"heavy_check_mark","users":["U6A936746"],"count":1}]},{"client_msg_id":"1f5d25eb-7071-4b40-b868-be3e2bd197d5","type":"message","text":"Be able to do it only on rules and serialize it out as julia-code that could be hand-tweaked.\nand then we wouldn’t need to worry about how well the compiler constant folds.","user":"U6A936746","ts":"1611863357.070200","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1611863362.000000"},"blocks":[{"type":"rich_text","block_id":"ZDy0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Be able to do it only on rules and serialize it out as julia-code that could be hand-tweaked.\nand then we wouldn’t need to worry about how well the compiler constant folds."}]}]}],"thread_ts":"1611845383.058800","parent_user_id":"U6A936746","reactions":[{"name":"+1","users":["UHDQQ4GN6"],"count":1}]},{"client_msg_id":"3dca673e-b2e1-4970-a0ec-c03ac82a4f21","type":"message","text":"That would be totally sick. I want it now.\n\nReferencing <https://popl21.sigplan.org/details/lafi-2021-papers/9/Decomposing-reverse-mode-automatic-differentiation>, a JAX-like approach would partially evaluate an `frule` to create a new primal and a `pushforward` containing only linear operations (at some level). Then we could generate the `pullback` by reversing the order of operations in the pushforward and replacing each by its adjoint operator (or if its adjoint is unknown, I guess recurring until all adjoints are known, though if we're just emitting code for the user to tweak, it could just highlight where it failed to adjoint).\n\nThat sounds pretty complicated.","user":"UHDQQ4GN6","ts":"1611911267.070700","team":"T68168MUP","edited":{"user":"UHDQQ4GN6","ts":"1611911279.000000"},"attachments":[{"title":"Decomposing reverse-mode automatic differentiation (LAFI 2021) - POPL 2021","title_link":"https://popl21.sigplan.org/details/lafi-2021-papers/9/Decomposing-reverse-mode-automatic-differentiation","text":"Inference concerns re-calibrating program parameters based on observed data, and has gained wide traction in machine learning and data science. Inference can be driven by probabilistic analysis and simulation, and through back-propagation and differentiation. Languages for inference offer built-in support for expressing probabilistic models and inference methods as programs, to ease reasoning, use, and reuse. The recent rise of practical implementations as well as research activity in inference-based programming has renewed the need for semantics to help us share insights and innovations. ...","fallback":"Decomposing reverse-mode automatic differentiation (LAFI 2021) - POPL 2021","image_url":"https://popl21.sigplan.org/getImage/carousel/Winter13_Photo_Thomas_H%C3%B8yrup_Christensen-1600px.jpg?1606914947000","from_url":"https://popl21.sigplan.org/details/lafi-2021-papers/9/Decomposing-reverse-mode-automatic-differentiation","image_width":444,"image_height":250,"image_bytes":311278,"service_icon":"https://popl21.sigplan.org/favicon.ico","service_name":"popl21.sigplan.org","id":1,"original_url":"https://popl21.sigplan.org/details/lafi-2021-papers/9/Decomposing-reverse-mode-automatic-differentiation"}],"blocks":[{"type":"rich_text","block_id":"kjFyx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That would be totally sick. I want it now.\n\nReferencing "},{"type":"link","url":"https://popl21.sigplan.org/details/lafi-2021-papers/9/Decomposing-reverse-mode-automatic-differentiation"},{"type":"text","text":", a JAX-like approach would partially evaluate an "},{"type":"text","text":"frule","style":{"code":true}},{"type":"text","text":" to create a new primal and a "},{"type":"text","text":"pushforward","style":{"code":true}},{"type":"text","text":" containing only linear operations (at some level). Then we could generate the "},{"type":"text","text":"pullback","style":{"code":true}},{"type":"text","text":" by reversing the order of operations in the pushforward and replacing each by its adjoint operator (or if its adjoint is unknown, I guess recurring until all adjoints are known, though if we're just emitting code for the user to tweak, it could just highlight where it failed to adjoint).\n\nThat sounds pretty complicated."}]}]}],"thread_ts":"1611845383.058800","parent_user_id":"U6A936746","reactions":[{"name":"+1","users":["U6A936746"],"count":1}]}]