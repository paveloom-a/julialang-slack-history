[{"client_msg_id":"b4dd4e54-6b89-496c-b330-985c0655a2cb","type":"message","text":"Hi. I'm trying understand AD starting from the basics. Right now I am going through <https://github.com/MikeInnes/diff-zoo/blob/notebooks/intro.ipynb> , which is super helpful btw! :)\nThere is an example comparing interpolated expressions and non-interpolated expressions in their behaviour in the following code. My question is this: Given `y2` and `y3` as below, how do I actually distinguish them from each other in general?\n```julia&gt; printstructure(x, _, _) = x\nprintstructure (generic function with 1 method)\n\njulia&gt; function printstructure(ex::Expr, cache = IdDict(), n = Ref(0))\n         haskey(cache, ex) &amp;&amp; return cache[ex]\n         args = map(x -&gt; printstructure(x, cache, n), ex.args)\n         cache[ex] = sym = Symbol(:y, n[] += 1)\n         println(:($sym = $(Expr(ex.head, args...))))\n         return sym\n       end\nprintstructure (generic function with 4 methods)\n\njulia&gt; y1 = :(1 * 2)\n:(1 * 2)\n\njulia&gt; y2 = :($y1 + $y1 + $y1 + $y1)\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia&gt; printstructure(y2);\ny1 = 1 * 2\ny2 = y1 + y1 + y1 + y1\n\njulia&gt; y3 = :($(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)))\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia&gt; y2 == y3\ntrue\n\njulia&gt; y2 === y3\nfalse\n\njulia&gt; printstructure(y3);\ny1 = 1 * 2\ny2 = 1 * 2\ny3 = 1 * 2\ny4 = 1 * 2\ny5 = y1 + y2 + y3 + y4\n\njulia&gt;```\nAlso, can someone explain the following strange behaviour? Why is `y1.args` bigger than `y1` itself?\n```julia&gt; sizeof(y1)\n16\n\njulia&gt; sizeof(y1.args)\n24```","user":"U0190AJCYK0","ts":"1614434572.134500","team":"T68168MUP","edited":{"user":"U0190AJCYK0","ts":"1614434989.000000"},"blocks":[{"type":"rich_text","block_id":"IR5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi. I'm trying understand AD starting from the basics. Right now I am going through "},{"type":"link","url":"https://github.com/MikeInnes/diff-zoo/blob/notebooks/intro.ipynb"},{"type":"text","text":" , which is super helpful btw! :)\nThere is an example comparing interpolated expressions and non-interpolated expressions in their behaviour in the following code. My question is this: Given "},{"type":"text","text":"y2","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"y3","style":{"code":true}},{"type":"text","text":" as below, how do I actually distinguish them from each other in general?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> printstructure(x, _, _) = x\nprintstructure (generic function with 1 method)\n\njulia> function printstructure(ex::Expr, cache = IdDict(), n = Ref(0))\n         haskey(cache, ex) && return cache[ex]\n         args = map(x -> printstructure(x, cache, n), ex.args)\n         cache[ex] = sym = Symbol(:y, n[] += 1)\n         println(:($sym = $(Expr(ex.head, args...))))\n         return sym\n       end\nprintstructure (generic function with 4 methods)\n\njulia> y1 = :(1 * 2)\n:(1 * 2)\n\njulia> y2 = :($y1 + $y1 + $y1 + $y1)\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia> printstructure(y2);\ny1 = 1 * 2\ny2 = y1 + y1 + y1 + y1\n\njulia> y3 = :($(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)))\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia> y2 == y3\ntrue\n\njulia> y2 === y3\nfalse\n\njulia> printstructure(y3);\ny1 = 1 * 2\ny2 = 1 * 2\ny3 = 1 * 2\ny4 = 1 * 2\ny5 = y1 + y2 + y3 + y4\n\njulia>"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Also, can someone explain the following strange behaviour? Why is "},{"type":"text","text":"y1.args","style":{"code":true}},{"type":"text","text":" bigger than "},{"type":"text","text":"y1","style":{"code":true}},{"type":"text","text":" itself?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> sizeof(y1)\n16\n\njulia> sizeof(y1.args)\n24"}]}]}],"thread_ts":"1614434572.134500","reply_count":7,"reply_users_count":2,"latest_reply":"1614446560.136200","reply_users":["U6A936746","U0190AJCYK0"],"subscribed":false},{"client_msg_id":"5f158f7d-93aa-4028-9eac-733c037b263b","type":"message","text":"`sizeof` does not recursive into references. For that you need `Base.summarysize`","user":"U6A936746","ts":"1614435223.134700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ohvu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sizeof","style":{"code":true}},{"type":"text","text":" does not recursive into references. For that you need "},{"type":"text","text":"Base.summarysize","style":{"code":true}}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"eaa47b05-6bd0-4bbc-b360-96bc7332b3af","type":"message","text":"What do you mean distinguish y2 from y3?\nThey are equal in content (`==`), but different instance (`===`)","user":"U6A936746","ts":"1614435436.134900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614435442.000000"},"blocks":[{"type":"rich_text","block_id":"w1Owx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do you mean distinguish y2 from y3?\nThey are equal in content ("},{"type":"text","text":"==","style":{"code":true}},{"type":"text","text":"), but different instance ("},{"type":"text","text":"===","style":{"code":true}},{"type":"text","text":")"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"23381add-7683-4aa3-b15e-2b4441b28358","type":"message","text":"&gt; `sizeof` does not recursive into references. For that you need `Base.summarysize` \nI see. Could you please clarify as to why does `Base.summarysize(y1.head)` return `0` whereas `sizeof(y1.head)` is `4`? Also, `Base.summarysize(y1.head) + Base.summarysize(y1.args)` does not sum to `Base.summarysize(y1)`\n```julia&gt; Base.summarysize(y1.head)\n0\n\njulia&gt; Base.summarysize(y1.args)\n80\n\njulia&gt; Base.summarysize(y1)\n96\n\njulia&gt; sizeof(y1.head)\n4```","user":"U0190AJCYK0","ts":"1614445966.135300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s9dti","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"sizeof","style":{"code":true}},{"type":"text","text":" does not recursive into references. For that you need "},{"type":"text","text":"Base.summarysize","style":{"code":true}},{"type":"text","text":" "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I see. Could you please clarify as to why does "},{"type":"text","text":"Base.summarysize(y1.head)","style":{"code":true}},{"type":"text","text":" return "},{"type":"text","text":"0","style":{"code":true}},{"type":"text","text":" whereas "},{"type":"text","text":"sizeof(y1.head)","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"4","style":{"code":true}},{"type":"text","text":"? Also, "},{"type":"text","text":"Base.summarysize(y1.head) + Base.summarysize(y1.args)","style":{"code":true}},{"type":"text","text":" does not sum to "},{"type":"text","text":"Base.summarysize(y1)","style":{"code":true}},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Base.summarysize(y1.head)\n0\n\njulia> Base.summarysize(y1.args)\n80\n\njulia> Base.summarysize(y1)\n96\n\njulia> sizeof(y1.head)\n4"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"5a833d3a-5757-4ca6-af38-a0fe4a36cfeb","type":"message","text":"&gt; What do you mean distinguish y2 from y3?\nI meant that given references to y2 and y3 present in my runtime, how can I distinguish which one of them uses references of y1 and which one uses copies inside? In other words, how can I predict the behavior of calling `printstructure` on y2 and y3 without actually calling it.?","user":"U0190AJCYK0","ts":"1614446112.135500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"njc3G","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"What do you mean distinguish y2 from y3?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I meant that given references to y2 and y3 present in my runtime, how can I distinguish which one of them uses references of y1 and which one uses copies inside? In other words, how can I predict the behavior of calling "},{"type":"text","text":"printstructure","style":{"code":true}},{"type":"text","text":" on y2 and y3 without actually calling it.?"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"50643869-fc0b-4389-867a-2ea74f1f670c","type":"message","text":"96 = 80 + 8 + 8\n\nThe 80 for the content of args.\n8 each of the pointers to head and args.\nThose 2 pointers are why `size` returns 16\n\nhead is zero because Symbols are weird. I guess it is special cases to return zero since it is interned","user":"U6A936746","ts":"1614446197.135700","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614446606.000000"},"blocks":[{"type":"rich_text","block_id":"TGiGA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"96 = 80 + 8 + 8\n\nThe 80 for the content of args.\n8 each of the pointers to head and args.\nThose 2 pointers are why "},{"type":"text","text":"size ","style":{"code":true}},{"type":"text","text":"returns 16\n\nhead is zero because Symbols are weird. I guess it is special cases to return zero since it is interned"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"da210a07-26fd-4ac7-9182-a9b95b7f4bee","type":"message","text":"&gt; how can I distinguish which one of them uses references of y1 and which one uses copies inside?\n\nFor mutable types `===` Returns true if they are the same reference. You can also check `objectid` on mutable objects.\nSo one option is `all(a-&gt;a===y1, y3.args)`","user":"U6A936746","ts":"1614446492.135900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614446509.000000"},"blocks":[{"type":"rich_text","block_id":"bIO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> how can I distinguish which one of them uses references of y1 and which one uses copies inside?\n\nFor mutable types "},{"type":"text","text":"===","style":{"code":true}},{"type":"text","text":" Returns true if they are the same reference. You can also check "},{"type":"text","text":"objectid","style":{"code":true}},{"type":"text","text":" on mutable objects.\nSo one option is "},{"type":"text","text":"all(a->a===y1, y3.args)","style":{"code":true}}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"77453e92-5dc5-41c4-b605-49781ef0ed3b","type":"message","text":"&gt; In other words, how can I predict the behavior of calling printstructure on y2 and y3 without actually calling it.?\n\nI am not entirely clear what you want to do.\nBut you can write a varient of it that doesn't print","user":"U6A936746","ts":"1614446560.136200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eser","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> In other words, how can I predict the behavior of calling printstructure on y2 and y3 without actually calling it.?\n\nI am not entirely clear what you want to do.\nBut you can write a varient of it that doesn't print"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"}]