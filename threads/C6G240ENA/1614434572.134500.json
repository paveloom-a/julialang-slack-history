[{"client_msg_id":"b4dd4e54-6b89-496c-b330-985c0655a2cb","type":"message","text":"Hi. I'm trying understand AD starting from the basics. Right now I am going through <https://github.com/MikeInnes/diff-zoo/blob/notebooks/intro.ipynb> , which is super helpful btw! :)\nThere is an example comparing interpolated expressions and non-interpolated expressions in their behaviour in the following code. My question is this: Given `y2` and `y3` as below, how do I actually distinguish them from each other in general?\n```julia&gt; printstructure(x, _, _) = x\nprintstructure (generic function with 1 method)\n\njulia&gt; function printstructure(ex::Expr, cache = IdDict(), n = Ref(0))\n         haskey(cache, ex) &amp;&amp; return cache[ex]\n         args = map(x -&gt; printstructure(x, cache, n), ex.args)\n         cache[ex] = sym = Symbol(:y, n[] += 1)\n         println(:($sym = $(Expr(ex.head, args...))))\n         return sym\n       end\nprintstructure (generic function with 4 methods)\n\njulia&gt; y1 = :(1 * 2)\n:(1 * 2)\n\njulia&gt; y2 = :($y1 + $y1 + $y1 + $y1)\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia&gt; printstructure(y2);\ny1 = 1 * 2\ny2 = y1 + y1 + y1 + y1\n\njulia&gt; y3 = :($(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)))\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia&gt; y2 == y3\ntrue\n\njulia&gt; y2 === y3\nfalse\n\njulia&gt; printstructure(y3);\ny1 = 1 * 2\ny2 = 1 * 2\ny3 = 1 * 2\ny4 = 1 * 2\ny5 = y1 + y2 + y3 + y4\n\njulia&gt;```\nAlso, can someone explain the following strange behaviour? Why is `y1.args` bigger than `y1` itself?\n```julia&gt; sizeof(y1)\n16\n\njulia&gt; sizeof(y1.args)\n24```","user":"U0190AJCYK0","ts":"1614434572.134500","team":"T68168MUP","edited":{"user":"U0190AJCYK0","ts":"1614434989.000000"},"blocks":[{"type":"rich_text","block_id":"IR5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi. I'm trying understand AD starting from the basics. Right now I am going through "},{"type":"link","url":"https://github.com/MikeInnes/diff-zoo/blob/notebooks/intro.ipynb"},{"type":"text","text":" , which is super helpful btw! :)\nThere is an example comparing interpolated expressions and non-interpolated expressions in their behaviour in the following code. My question is this: Given "},{"type":"text","text":"y2","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"y3","style":{"code":true}},{"type":"text","text":" as below, how do I actually distinguish them from each other in general?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> printstructure(x, _, _) = x\nprintstructure (generic function with 1 method)\n\njulia> function printstructure(ex::Expr, cache = IdDict(), n = Ref(0))\n         haskey(cache, ex) && return cache[ex]\n         args = map(x -> printstructure(x, cache, n), ex.args)\n         cache[ex] = sym = Symbol(:y, n[] += 1)\n         println(:($sym = $(Expr(ex.head, args...))))\n         return sym\n       end\nprintstructure (generic function with 4 methods)\n\njulia> y1 = :(1 * 2)\n:(1 * 2)\n\njulia> y2 = :($y1 + $y1 + $y1 + $y1)\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia> printstructure(y2);\ny1 = 1 * 2\ny2 = y1 + y1 + y1 + y1\n\njulia> y3 = :($(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)) + $(:(1 * 2)))\n:(1 * 2 + 1 * 2 + 1 * 2 + 1 * 2)\n\njulia> y2 == y3\ntrue\n\njulia> y2 === y3\nfalse\n\njulia> printstructure(y3);\ny1 = 1 * 2\ny2 = 1 * 2\ny3 = 1 * 2\ny4 = 1 * 2\ny5 = y1 + y2 + y3 + y4\n\njulia>"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Also, can someone explain the following strange behaviour? Why is "},{"type":"text","text":"y1.args","style":{"code":true}},{"type":"text","text":" bigger than "},{"type":"text","text":"y1","style":{"code":true}},{"type":"text","text":" itself?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> sizeof(y1)\n16\n\njulia> sizeof(y1.args)\n24"}]}]}],"thread_ts":"1614434572.134500","reply_count":16,"reply_users_count":2,"latest_reply":"1614447682.138600","reply_users":["U6A936746","U0190AJCYK0"],"subscribed":false},{"client_msg_id":"5f158f7d-93aa-4028-9eac-733c037b263b","type":"message","text":"`sizeof` does not recursive into references. For that you need `Base.summarysize`","user":"U6A936746","ts":"1614435223.134700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ohvu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sizeof","style":{"code":true}},{"type":"text","text":" does not recursive into references. For that you need "},{"type":"text","text":"Base.summarysize","style":{"code":true}}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"eaa47b05-6bd0-4bbc-b360-96bc7332b3af","type":"message","text":"What do you mean distinguish y2 from y3?\nThey are equal in content (`==`), but different instance (`===`)","user":"U6A936746","ts":"1614435436.134900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614435442.000000"},"blocks":[{"type":"rich_text","block_id":"w1Owx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What do you mean distinguish y2 from y3?\nThey are equal in content ("},{"type":"text","text":"==","style":{"code":true}},{"type":"text","text":"), but different instance ("},{"type":"text","text":"===","style":{"code":true}},{"type":"text","text":")"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"23381add-7683-4aa3-b15e-2b4441b28358","type":"message","text":"&gt; `sizeof` does not recursive into references. For that you need `Base.summarysize` \nI see. Could you please clarify as to why does `Base.summarysize(y1.head)` return `0` whereas `sizeof(y1.head)` is `4`? Also, `Base.summarysize(y1.head) + Base.summarysize(y1.args)` does not sum to `Base.summarysize(y1)`\n```julia&gt; Base.summarysize(y1.head)\n0\n\njulia&gt; Base.summarysize(y1.args)\n80\n\njulia&gt; Base.summarysize(y1)\n96\n\njulia&gt; sizeof(y1.head)\n4```","user":"U0190AJCYK0","ts":"1614445966.135300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s9dti","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"sizeof","style":{"code":true}},{"type":"text","text":" does not recursive into references. For that you need "},{"type":"text","text":"Base.summarysize","style":{"code":true}},{"type":"text","text":" "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I see. Could you please clarify as to why does "},{"type":"text","text":"Base.summarysize(y1.head)","style":{"code":true}},{"type":"text","text":" return "},{"type":"text","text":"0","style":{"code":true}},{"type":"text","text":" whereas "},{"type":"text","text":"sizeof(y1.head)","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"4","style":{"code":true}},{"type":"text","text":"? Also, "},{"type":"text","text":"Base.summarysize(y1.head) + Base.summarysize(y1.args)","style":{"code":true}},{"type":"text","text":" does not sum to "},{"type":"text","text":"Base.summarysize(y1)","style":{"code":true}},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Base.summarysize(y1.head)\n0\n\njulia> Base.summarysize(y1.args)\n80\n\njulia> Base.summarysize(y1)\n96\n\njulia> sizeof(y1.head)\n4"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"5a833d3a-5757-4ca6-af38-a0fe4a36cfeb","type":"message","text":"&gt; What do you mean distinguish y2 from y3?\nI meant that given references to y2 and y3 present in my runtime, how can I distinguish which one of them uses references of y1 and which one uses copies inside? In other words, how can I predict the behavior of calling `printstructure` on y2 and y3 without actually calling it.?","user":"U0190AJCYK0","ts":"1614446112.135500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"njc3G","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"What do you mean distinguish y2 from y3?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I meant that given references to y2 and y3 present in my runtime, how can I distinguish which one of them uses references of y1 and which one uses copies inside? In other words, how can I predict the behavior of calling "},{"type":"text","text":"printstructure","style":{"code":true}},{"type":"text","text":" on y2 and y3 without actually calling it.?"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"50643869-fc0b-4389-867a-2ea74f1f670c","type":"message","text":"96 = 80 + 8 + 8\n\nThe 80 for the content of args.\n8 each of the pointers to head and args.\nThose 2 pointers are why `size` returns 16\n\nhead is zero because Symbols are weird. I guess it is special cases to return zero since it is interned","user":"U6A936746","ts":"1614446197.135700","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614446606.000000"},"blocks":[{"type":"rich_text","block_id":"TGiGA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"96 = 80 + 8 + 8\n\nThe 80 for the content of args.\n8 each of the pointers to head and args.\nThose 2 pointers are why "},{"type":"text","text":"size ","style":{"code":true}},{"type":"text","text":"returns 16\n\nhead is zero because Symbols are weird. I guess it is special cases to return zero since it is interned"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"da210a07-26fd-4ac7-9182-a9b95b7f4bee","type":"message","text":"&gt; how can I distinguish which one of them uses references of y1 and which one uses copies inside?\n\nFor mutable types `===` Returns true if they are the same reference. You can also check `objectid` on mutable objects.\nSo one option is `all(a-&gt;a===y1, y3.args)`","user":"U6A936746","ts":"1614446492.135900","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614446509.000000"},"blocks":[{"type":"rich_text","block_id":"bIO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> how can I distinguish which one of them uses references of y1 and which one uses copies inside?\n\nFor mutable types "},{"type":"text","text":"===","style":{"code":true}},{"type":"text","text":" Returns true if they are the same reference. You can also check "},{"type":"text","text":"objectid","style":{"code":true}},{"type":"text","text":" on mutable objects.\nSo one option is "},{"type":"text","text":"all(a->a===y1, y3.args)","style":{"code":true}}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"77453e92-5dc5-41c4-b605-49781ef0ed3b","type":"message","text":"&gt; In other words, how can I predict the behavior of calling printstructure on y2 and y3 without actually calling it.?\n\nI am not entirely clear what you want to do.\nBut you can write a varient of it that doesn't print","user":"U6A936746","ts":"1614446560.136200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eser","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> In other words, how can I predict the behavior of calling printstructure on y2 and y3 without actually calling it.?\n\nI am not entirely clear what you want to do.\nBut you can write a varient of it that doesn't print"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"4a039ef9-bf67-44db-a249-ffe3c8ca2591","type":"message","text":"&gt; I am not entirely clear what you want to do.\nOk. Let me elaborate.\n```julia&gt; printstructure(y2);\ny1 = 1 * 2\ny2 = y1 + y1 + y1 + y1\n\njulia&gt; printstructure(y3);\ny1 = 1 * 2\ny2 = 1 * 2\ny3 = 1 * 2\ny4 = 1 * 2\ny5 = y1 + y2 + y3 + y4```\nSo `printstructure(y2)` and `printstructure(y3)` have different outputs. But y2 and y3 themselves appear alike to me\n```julia&gt; y2\n:(1 * 2 + 1 * 2)\n\njulia&gt; y3\n:(1 * 2 + 1 * 2)```\nSo I wanted to know if I can know which one of them contains pointers to within (because this is preferrable one) as opposed to copies (not good) without actually having to call `printstructure` on both","user":"U0190AJCYK0","ts":"1614446988.136500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"U3QY","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"I am not entirely clear what you want to do."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Ok. Let me elaborate.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> printstructure(y2);\ny1 = 1 * 2\ny2 = y1 + y1 + y1 + y1\n\njulia> printstructure(y3);\ny1 = 1 * 2\ny2 = 1 * 2\ny3 = 1 * 2\ny4 = 1 * 2\ny5 = y1 + y2 + y3 + y4"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So "},{"type":"text","text":"printstructure(y2)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"printstructure(y3)","style":{"code":true}},{"type":"text","text":" have different outputs. But y2 and y3 themselves appear alike to me\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> y2\n:(1 * 2 + 1 * 2)\n\njulia> y3\n:(1 * 2 + 1 * 2)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So I wanted to know if I can know which one of them contains pointers to within (because this is preferrable one) as opposed to copies (not good) without actually having to call "},{"type":"text","text":"printstructure","style":{"code":true}},{"type":"text","text":" on both"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"932a63fb-dea2-430c-823f-ba5ae9b1a9e0","type":"message","text":"&gt; The 80 for the content of args.\n&gt; 8 each of the pointers to head and args.\n&gt; Those 2 pointers are why `size` returns 16\nI see. Thanks","user":"U0190AJCYK0","ts":"1614447023.136700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZKP","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"The 80 for the content of args.\n8 each of the pointers to head and args.\nThose 2 pointers are why "},{"type":"text","text":"size ","style":{"code":true}},{"type":"text","text":"returns 16"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I see. Thanks"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"2df99219-318c-40bf-b38c-68dfeebb07dd","type":"message","text":"Why is copies not good?\nPerhaps `length(unique(objectid, y.args))`","user":"U6A936746","ts":"1614447139.136900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rhYDH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why is copies not good?\nPerhaps "},{"type":"text","text":"length(unique(objectid, y.args))","style":{"code":true}}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"17127aba-5ac7-408c-992e-3fb5c170900c","type":"message","text":"&gt; So one option is `all(a-&gt;a===y1, y3.args)` \nThis would work `all(a-&gt;a===y1, y3.args[2:end]` . But what if I just want to know which is the pointer one (as opposed to the copy one)  without necessarily having a reference to y1?","user":"U0190AJCYK0","ts":"1614447212.137300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z2D=3","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"So one option is "},{"type":"text","text":"all(a->a===y1, y3.args)","style":{"code":true}},{"type":"text","text":" "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"This would work "},{"type":"text","text":"all(a->a===y1, y3.args[2:end]","style":{"code":true}},{"type":"text","text":" . But what if I just want to know which is the pointer one (as opposed to the copy one)  without necessarily having a reference to y1?"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"a993097a-9b12-439f-ae2d-7bac6c3943b5","type":"message","text":"Probably check `objectid.(y.args)`","user":"U6A936746","ts":"1614447263.137600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dyff","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Probably check `objectid.(y.args)`"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"7950c989-0e5e-4620-9231-fc1c92348c2c","type":"message","text":"&gt; Why is copies not good?\nQuoting from <https://github.com/MikeInnes/diff-zoo/blob/notebooks/intro.ipynb>\n&gt; Calculator notation – expressions without variable bindings – is a terrible format for anything, and will tend to blow up in size whether you differentiate it or not. Symbolic differentiation is commonly criticised for its susceptability to \"expression swell\"...","user":"U0190AJCYK0","ts":"1614447270.137800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hrbW","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Why is copies not good?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Quoting from "},{"type":"link","url":"https://github.com/MikeInnes/diff-zoo/blob/notebooks/intro.ipynb"},{"type":"text","text":"\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"Calculator notation – expressions without variable bindings – is a terrible format for anything, and will tend to blow up in size whether you differentiate it or not. Symbolic differentiation is commonly criticised for its susceptability to \"expression swell\"..."}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"b8d8cd87-eb15-4290-97f0-9ef29717fe9d","type":"message","text":"&gt; Probably check `objectid.(y.args)`\nThis is nice.","user":"U0190AJCYK0","ts":"1614447368.138000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"COPK","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Probably check `objectid.(y.args)`"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"This is nice."}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"3b0fc006-726a-46d5-8adf-1ce79a2f1910","type":"message","text":"Oh this is symbolic stuff.\nThis is probably not something particular useful to spend too much time focusing on, I think it is just illustrating a side point.\nSomething about why symbolic differentiation doesn't work on nontrivial programs. I think.\n\nIt's interesting but\nIt's not the destination of the story AFAIK","user":"U6A936746","ts":"1614447407.138200","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1614447557.000000"},"blocks":[{"type":"rich_text","block_id":"Reg7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh this is symbolic stuff.\nThis is probably not something particular useful to spend too much time focusing on, I think it is just illustrating a side point.\nSomething about why symbolic differentiation doesn't work on nontrivial programs. I think.\n\nIt's interesting but\nIt's not the destination of the story AFAIK"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"},{"client_msg_id":"760cf8e7-58b4-4f56-9890-519886797a88","type":"message","text":"Ok. I am looking to understand AD from scratch and stumbled upon this. Anyways.. Thanks for you help :smile:","user":"U0190AJCYK0","ts":"1614447682.138600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jZLI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok. I am looking to understand AD from scratch and stumbled upon this. Anyways.. Thanks for you help "},{"type":"emoji","name":"smile"}]}]}],"thread_ts":"1614434572.134500","parent_user_id":"U0190AJCYK0"}]