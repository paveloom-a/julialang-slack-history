[{"client_msg_id":"55ed46d0-d6c2-42a1-ac00-af2160a30e73","type":"message","text":"I think it’s best to wait for my PR to have something concrete to discuss.","user":"U85JBUGGP","ts":"1612613378.263700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HV9J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it’s best to wait for my PR to have something concrete to discuss."}]}]}],"thread_ts":"1612613378.263700","reply_count":51,"reply_users_count":4,"latest_reply":"1612810615.334000","reply_users":["U6A936746","U85JBUGGP","UMDEUKM29","U6PQP41C3"],"subscribed":false,"reactions":[{"name":"ok_hand","users":["U6A936746","UKG4WF8PJ"],"count":2}]},{"client_msg_id":"d08d7ecc-3d27-47bb-8504-69046a44db20","type":"message","text":"Yeah. We can iterate on things as we go,\nFun as it is to discuss, often getting things out is better","user":"U6A936746","ts":"1612613437.264000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BdX72","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah. We can iterate on things as we go,\nFun as it is to discuss, often getting things out is better"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"sweat_smile","users":["U85JBUGGP","UKG4WF8PJ"],"count":2},{"name":"100","users":["U85JBUGGP"],"count":1}]},{"client_msg_id":"620eaf5f-ec3f-4b4a-a238-fb5d56cd6180","type":"message","text":"Though a lot of the API conclusions for ChainRulesCore was <@U6PQP41C3> and I drinking :whisky:  and waxing philosophical until 1am.","user":"U6A936746","ts":"1612613495.264400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gWK8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Though a lot of the API conclusions for ChainRulesCore was "},{"type":"user","user_id":"U6PQP41C3"},{"type":"text","text":" and I drinking "},{"type":"emoji","name":"whisky"},{"type":"text","text":"  and waxing philosophical until 1am."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"joy","users":["U85JBUGGP","UKG4WF8PJ","UN45LV5K6"],"count":3},{"name":"whisky-glass","users":["U6PQP41C3"],"count":1}]},{"type":"message","subtype":"thread_broadcast","text":"The implementation turned out to be larger than I was hoping but here it is <https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1>. Any feedback is welcome.","user":"U85JBUGGP","ts":"1612802252.313600","thread_ts":"1612613378.263700","root":{"client_msg_id":"55ed46d0-d6c2-42a1-ac00-af2160a30e73","type":"message","text":"I think it’s best to wait for my PR to have something concrete to discuss.","user":"U85JBUGGP","ts":"1612613378.263700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HV9J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it’s best to wait for my PR to have something concrete to discuss."}]}]}],"thread_ts":"1612613378.263700","reply_count":51,"reply_users_count":4,"latest_reply":"1612810615.334000","reply_users":["U6A936746","U85JBUGGP","UMDEUKM29","U6PQP41C3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"V2I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The implementation turned out to be larger than I was hoping but here it is "},{"type":"link","url":"https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1"},{"type":"text","text":". Any feedback is welcome."}]}]}],"client_msg_id":"89481e1d-8226-4cb4-a6a7-df7a5b1e3c57"},{"client_msg_id":"7163b206-9d7a-488b-9663-2bfea3ae0cf4","type":"message","text":"I am super naive about these things but jacobian assumes a specific representation of vectors and matrices as arrays right? Wouldn't it make more sense to have as primitives jvp+vjp, and then define jacobians as the matrix representation of those? Then it also works for non-Array input?","user":"UMDEUKM29","ts":"1612802709.313900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+xs=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am super naive about these things but jacobian assumes a specific representation of vectors and matrices as arrays right? Wouldn't it make more sense to have as primitives jvp+vjp, and then define jacobians as the matrix representation of those? Then it also works for non-Array input?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"0f92777d-5757-487c-90a4-c4a979eefe4a","type":"message","text":"or do you mean that `jacobian` returns a lazy object?","user":"UMDEUKM29","ts":"1612802727.314100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eI9r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or do you mean that "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" returns a lazy object?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"edc8a044-7fc3-46c9-b0b5-21f5ec1ed90a","type":"message","text":"`jacobian` can return anything, I don’t really restrict its output","user":"U85JBUGGP","ts":"1612802765.314300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qQ+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" can return anything, I don’t really restrict its output"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"5f7c3471-43d5-4853-b362-16adf4ff6bae","type":"message","text":"I want to implement the API for Zygote, ForwardDiff, Nabla, etc. to properly test the API.","user":"U85JBUGGP","ts":"1612802823.314500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fbNh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want to implement the API for Zygote, ForwardDiff, Nabla, etc. to properly test the API."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"0b22bdbe-0886-4e96-ada1-c2683787b520","type":"message","text":"I may run into representation issues but the way the code is structured is quite generic. So `jacobian` can return a tuple of Jacobians or anything Jacobian-like.","user":"U85JBUGGP","ts":"1612802881.314700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"U3C","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I may run into representation issues but the way the code is structured is quite generic. So "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" can return a tuple of Jacobians or anything Jacobian-like."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"674c6f7e-2dc7-4ebd-8e3e-fa394d6b4a3e","type":"message","text":"I only have tests for finite difference so far.","user":"U85JBUGGP","ts":"1612803029.315000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FrRP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I only have tests for finite difference so far."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"7a9d247f-5c82-4be8-a82f-0ade1c84fcbf","type":"message","text":"yeah but do you expect `jacobian` to actually run the computation for all derivatives? Then it's wasteful if you just want to do a jvp in one direction","user":"UMDEUKM29","ts":"1612803305.315200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YE5aQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah but do you expect "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" to actually run the computation for all derivatives? Then it's wasteful if you just want to do a jvp in one direction"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"e3bfd9dd-b238-4fcc-8f24-58ccdb620801","type":"message","text":"Not quite, see the definition of `pushforward_function` as the jacobian of a different function (<https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1/files#diff-d7c294969900dd9ee883b2a071307ff4c6346f08aa0c4bc4829fbaa22cd42e7fR128>). I don’t compute the full jacobian of the original function. It’s still a little wasteful because of this encoding overhead so a package author can define `jvp` directly by overloading `pushforward_function`.","user":"U85JBUGGP","ts":"1612804339.317400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9ryKD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not quite, see the definition of "},{"type":"text","text":"pushforward_function","style":{"code":true}},{"type":"text","text":" as the jacobian of a different function ("},{"type":"link","url":"https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1/files#diff-d7c294969900dd9ee883b2a071307ff4c6346f08aa0c4bc4829fbaa22cd42e7fR128"},{"type":"text","text":"). I don’t compute the full jacobian of the original function. It’s still a little wasteful because of this encoding overhead so a package author can define "},{"type":"text","text":"jvp","style":{"code":true}},{"type":"text","text":" directly by overloading "},{"type":"text","text":"pushforward_function","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"b5f8354f-11f7-4008-ad7d-409682d7c15c","type":"message","text":"right but that does prevent you taking jvp wrt structs or namedtuples or what","user":"UMDEUKM29","ts":"1612805073.318200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SFQL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"right but that does prevent you taking jvp wrt structs or namedtuples or what"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"bab2e931-5e80-4e6c-a70d-e892c7e27d18","type":"message","text":"compared to using jvp and vjp as your basic blocks and defining jacobian from there","user":"UMDEUKM29","ts":"1612805105.318400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WOCX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"compared to using jvp and vjp as your basic blocks and defining jacobian from there"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"6ec4ace0-94eb-4570-9041-047146f90561","type":"message","text":"&gt; structs or namedtuples\nAs long as they have vector semantics, it’s fine. I only use scalar multiplication and addition. But yes there are limitations. But again, one can always define the jvp and vjp functions for the backend. Nothing stops you.","user":"U85JBUGGP","ts":"1612805321.318600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pxg","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"structs or namedtuples"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"As long as they have vector semantics, it’s fine. I only use scalar multiplication and addition. But yes there are limitations. But again, one can always define the jvp and vjp functions for the backend. Nothing stops you."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"6c331526-323e-4629-9614-90c8f38c7a83","type":"message","text":"It’s a question of defaults. I went with the more convenient default for vector-like inputs but that may have been a wrong choice.","user":"U85JBUGGP","ts":"1612805402.318800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bNDF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s a question of defaults. I went with the more convenient default for vector-like inputs but that may have been a wrong choice."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"78c99221-7854-4636-b6b8-5f5b5c9a254b","type":"message","text":"I think one can argue that if you are asking for the Jacobian/derivative of a function wrt its input, then that input must have vector semantics. Otherwise, calculus (as I know it) kind of doesn’t work. You need to be able to define what it means to infinitesimally change the input. I think this may have been one of the motivations of the differential type in ChainRules. Correct me if I am wrong <@U6A936746>.","user":"U85JBUGGP","ts":"1612805726.319000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7R9cL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think one can argue that if you are asking for the Jacobian/derivative of a function wrt its input, then that input must have vector semantics. Otherwise, calculus (as I know it) kind of doesn’t work. You need to be able to define what it means to infinitesimally change the input. I think this may have been one of the motivations of the differential type in ChainRules. Correct me if I am wrong "},{"type":"user","user_id":"U6A936746"},{"type":"text","text":"."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"de89e924-e83c-4f2c-8c2d-b66340e2fce6","type":"message","text":"That is the motivation of the `Composite` differential (or more broadly of differentials not being the same as primals) to begin with yes.\nGotta define `+` and `zero`,\nto make things easy should define `*` with real scalar, and  `dot`  and other linear operators","user":"U6A936746","ts":"1612805857.319200","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1612805916.000000"},"blocks":[{"type":"rich_text","block_id":"zVza","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is the motivation of the "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" differential (or more broadly of differentials not being the same as primals) to begin with yes.\nGotta define "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"zero","style":{"code":true}},{"type":"text","text":",\nto make things easy should define "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" with real scalar, and  "},{"type":"text","text":"dot","style":{"code":true}},{"type":"text","text":"  and other linear operators"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"+1","users":["U85JBUGGP"],"count":1}]},{"client_msg_id":"276bc9da-af59-4562-aad8-e962ccedd9f0","type":"message","text":"For convenience when it makes more sense to define the pushforward (pullback), I can have a macro that automatically defines the Jacobian and pullback (pushforward) for that backend using the defined pushforward (pullback).","user":"U85JBUGGP","ts":"1612806046.319800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wBs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For convenience when it makes more sense to define the pushforward (pullback), I can have a macro that automatically defines the Jacobian and pullback (pushforward) for that backend using the defined pushforward (pullback)."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"heart","users":["U6A936746"],"count":1}]},{"client_msg_id":"66bb3fe9-cf9b-473e-86d4-4ef7f961eb44","type":"message","text":"To make everyone happy","user":"U85JBUGGP","ts":"1612806062.320000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"edI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To make everyone happy"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"6d8bd9e9-d451-41fc-ad72-e60ca971bcac","type":"message","text":"As you say every backend can just overload all functions if they want so it's not too much of a problem, I was just thinking that there are cases where jvp is naturally well defined but jacobian is not","user":"UMDEUKM29","ts":"1612806457.320300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QHx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As you say every backend can just overload all functions if they want so it's not too much of a problem, I was just thinking that there are cases where jvp is naturally well defined but jacobian is not"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"4e61ccb5-4dbb-43c6-a621-01a256279a2c","type":"message","text":"Eg struct A a b end ; f(x::A) = x.a","user":"UMDEUKM29","ts":"1612806487.320500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AwUVB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Eg struct A a b end ; f(x::A) = x.a"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"41ad0d12-ac4b-4b04-baa0-08f118525d40","type":"message","text":"Where the jvp can take a `A` but the jacobian would need to commit to a representation for \"map from A to real\"","user":"UMDEUKM29","ts":"1612806521.320700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hQean","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Where the jvp can take a `A` but the jacobian would need to commit to a representation for \"map from A to real\""}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"ff1d316a-0901-4407-9a22-72d5b64fd83f","type":"message","text":"Another interesting example is: what should the type of the Jacobian of a function `f: A -&gt; A` be?","user":"U6PQP41C3","ts":"1612806936.320900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IFe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Another interesting example is: what should the type of the Jacobian of a function "},{"type":"text","text":"f: A -> A","style":{"code":true}},{"type":"text","text":" be?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"73e12138-b19c-4944-8234-c51a648f5aa4","type":"message","text":"I think it is a vector of Composites,\nbut unfortunately it is a different vector of Composites depend on if you got it via forward or reverse.","user":"U6A936746","ts":"1612807016.321100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Dfpf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it is a vector of Composites,\nbut unfortunately it is a different vector of Composites depend on if you got it via forward or reverse."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"5905d452-0c86-48d0-8660-8b8f2059997f","type":"message","text":"Ah, right, but if you do that you must have committed to a particular “flat” representation of `A` somehow. Assuming that you’ve accumulated in reverse, I assume that the vector you’re referring to contains a cotangent for each element of the output of `f`, but the output of `f` is an `A`, not a `Vector`.","user":"U6PQP41C3","ts":"1612807147.321400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J8W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, right, but if you do that you must have committed to a particular “flat” representation of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" somehow. Assuming that you’ve accumulated in reverse, I assume that the vector you’re referring to contains a cotangent for each element of the output of "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":", but the output of "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" is an "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":", not a "},{"type":"text","text":"Vector","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"2cf406c0-e05e-49c3-9c41-36c891db4e02","type":"message","text":"You can of course commit to a particular flat representation, but it’s not clear to me that there’s an obvious canonical choice in the same way that there appears to be for tangents and cotangents.","user":"U6PQP41C3","ts":"1612807223.321600","team":"T68168MUP","edited":{"user":"U6PQP41C3","ts":"1612807233.000000"},"blocks":[{"type":"rich_text","block_id":"UkEvx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can of course commit to a particular flat representation, but it’s not clear to me that there’s an obvious canonical choice in the same way that there appears to be for tangents and cotangents."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"ccc8fdea-a210-4907-9655-1562e955366c","type":"message","text":"Oh true.\nIs it a Composite of Composites then?","user":"U6A936746","ts":"1612807386.321900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tqyC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh true.\nIs it a Composite of Composites then?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"1ad18f69-cf01-4573-9107-964649f3d99f","type":"message","text":"A natural choice seems like a `Composite` of `Composite`s — but as you say you would naturally arrive at a different representation depending on whether you accumulate in forwards-mode or reverse.","user":"U6PQP41C3","ts":"1612807390.322100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KZn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A natural choice seems like a "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" of "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":"s — but as you say you would naturally arrive at a different representation depending on whether you accumulate in forwards-mode or reverse."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"efacb9f0-2884-45c0-bc4e-ea79a9890dce","type":"message","text":"Yeah, you beat me to it.","user":"U6PQP41C3","ts":"1612807395.322300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JoE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, you beat me to it."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"74c2c606-8c86-4f94-a116-0ce7c18c26ad","type":"message","text":"Although they’re presumably isomorphic to one another.","user":"U6PQP41C3","ts":"1612807453.322500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YPy5t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Although they’re presumably isomorphic to one another."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"heavy_check_mark","users":["U6A936746"],"count":1}]},{"client_msg_id":"81dd582a-5b9f-4e0a-9799-f95ca714a285","type":"message","text":"Maybe it isn’t so bad that we have a different one for forward vs reverse. We already deal with that for multiple differentials.\n\nPossibly it shouldn’t be a `Composite` but something new, a `JacComposite`\nwhich is a Jacobial :tm:  rather than a Differential.\nand which needs to define matrix multiplication.","user":"U6A936746","ts":"1612807507.322800","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1612807527.000000"},"blocks":[{"type":"rich_text","block_id":"3/gz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe it isn’t so bad that we have a different one for forward vs reverse. We already deal with that for multiple differentials.\n\nPossibly it shouldn’t be a "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" but something new, a "},{"type":"text","text":"JacComposite","style":{"code":true}},{"type":"text","text":"\nwhich is a Jacobial "},{"type":"emoji","name":"tm"},{"type":"text","text":"  rather than a Differential.\nand which needs to define matrix multiplication."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"729ce88a-9b1a-412c-bace-10f174e24a46","type":"message","text":"Yeah, this seems reasonable. Someone who knows more geometry than me should work through exactly what spaces the jacobian should map between (thinking about it as a function).","user":"U6PQP41C3","ts":"1612807928.323200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PNKUb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, this seems reasonable. Someone who knows more geometry than me should work through exactly what spaces the jacobian should map between (thinking about it as a function)."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"fafd3621-8367-467a-b689-04a97107d4da","type":"message","text":"Presumably this is a thing that someone has done already…","user":"U6PQP41C3","ts":"1612807958.323400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X28","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Presumably this is a thing that someone has done already…"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"point_up","users":["U6A936746","UKG4WF8PJ"],"count":2}]},{"client_msg_id":"1343f9c4-3c85-4749-be11-38328a53f7f5","type":"message","text":"again knowing nothing about AD implementation, the way I would define it is : a differential/jvp/pushforward of a function A -&gt; B would take as input a type dA (representing infinitesimal differences between two objects of type A) and output a type dB. The adjoint differential/vjp/pullback takes a dB and outputs a dA. The jacobian requires a \"flattening\" of A and B into vectors of size nA and nB, and is a nB x nA matrix, but as long as you don't talk about jacobian you never need to commit the \"flattening crime\". (As a rule whenever you can avoid flattening something you should, and julia is very nice at not forcing you to flatten so much (you can pass array of arrays, multidimensional arrays and so on to a solver and it will not complain too much)). Now what is dA? Well you can define it recursively, getting back to scalar types. If A is discrete (int, bool), then dA is nothing, and if A is real, then A is real.","user":"UMDEUKM29","ts":"1612808887.323900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gSCC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"again knowing nothing about AD implementation, the way I would define it is : a differential/jvp/pushforward of a function A -> B would take as input a type dA (representing infinitesimal differences between two objects of type A) and output a type dB. The adjoint differential/vjp/pullback takes a dB and outputs a dA. The jacobian requires a \"flattening\" of A and B into vectors of size nA and nB, and is a nB x nA matrix, but as long as you don't talk about jacobian you never need to commit the \"flattening crime\". (As a rule whenever you can avoid flattening something you should, and julia is very nice at not forcing you to flatten so much (you can pass array of arrays, multidimensional arrays and so on to a solver and it will not complain too much)). Now what is dA? Well you can define it recursively, getting back to scalar types. If A is discrete (int, bool), then dA is nothing, and if A is real, then A is real."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"2886d1f8-b5be-4917-8789-4d3eca546d66","type":"message","text":"so if you just ignore non-real leaf types, you can just represent dA by A","user":"UMDEUKM29","ts":"1612809097.325600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"noS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so if you just ignore non-real leaf types, you can just represent dA by A"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"4ddf6faa-5931-4ba6-9257-b51a19ceb132","type":"message","text":"Well at some point you may want to get the jacobian of a function from the pushforward or pullback. This function can have non-array inputs or non-array outputs. So there is no avoiding the “flattening crime” in this case. But this is all a representation issue. Semantically, an `AbstractArray` or not, if you are differentiating it or differentiating wrt it, it is vector-like.","user":"U85JBUGGP","ts":"1612809617.327300","team":"T68168MUP","edited":{"user":"U85JBUGGP","ts":"1612809663.000000"},"blocks":[{"type":"rich_text","block_id":"3r0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well at some point you may want to get the jacobian of a function from the pushforward or pullback. This function can have non-array inputs or non-array outputs. So there is no avoiding the “flattening crime” in this case. But this is all a representation issue. Semantically, an "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" or not, if you are differentiating it or differentiating wrt it, it is vector-like."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"ee5f93f3-6d12-4018-bc45-1747e5e1a0c3","type":"message","text":"Ah, yes — so we do indeed define `dA` recursively, but we have a special `Composite` type handle `struct`s. The problem with using `A` to represent tangents is that we always need tangents to form a vector space, and we’re not allowed to define `+` and `*` on existing types.\n\nSo I completely agree that if you don’t need to talk about Jacobians then what you’re proposing works. My impression is that there are people here who _do_ want to be able to talk about explicitly representing Jacobians though — I’m not entirely clear why one would need them though.","user":"U6PQP41C3","ts":"1612809635.327500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UB+OL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, yes — so we do indeed define "},{"type":"text","text":"dA","style":{"code":true}},{"type":"text","text":" recursively, but we have a special "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" type handle "},{"type":"text","text":"struct","style":{"code":true}},{"type":"text","text":"s. The problem with using "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" to represent tangents is that we always need tangents to form a vector space, and we’re not allowed to define "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" on existing types.\n\nSo I completely agree that if you don’t need to talk about Jacobians then what you’re proposing works. My impression is that there are people here who "},{"type":"text","text":"do","style":{"italic":true}},{"type":"text","text":" want to be able to talk about explicitly representing Jacobians though — I’m not entirely clear why one would need them though."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"680eb07c-de25-4178-9d0d-5ad1023c7b09","type":"message","text":"&gt;  So there is no avoiding the “flattening crime” in this case.\nIt’s not clear to me that this is the case. As per my discussion with Lyndon above, a structured representation of a Jacobian might work.","user":"U6PQP41C3","ts":"1612809683.327800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ROV","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" So there is no avoiding the “flattening crime” in this case."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It’s not clear to me that this is the case. As per my discussion with Lyndon above, a structured representation of a Jacobian might work."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"e1a8a2e9-7fd9-43ae-b70b-23245fbe915b","type":"message","text":"Yes I think that’s possible. But if we assume it’s not, then whether we choose to define the pushforward/pullback or jacobian as primitive we run into the same issue once we need an actual jacobian.","user":"U85JBUGGP","ts":"1612809772.328400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"821cV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes I think that’s possible. But if we assume it’s not, then whether we choose to define the pushforward/pullback or jacobian as primitive we run into the same issue once we need an actual jacobian."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"e8246621-97e6-4a13-879c-0e4cb661e920","type":"message","text":"I’m confused — what exactly do you mean by an actual Jacoabian?","user":"U6PQP41C3","ts":"1612809827.328600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4PsI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m confused — what exactly do you mean by an actual Jacoabian?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"030a3816-f736-463f-99e4-c9013839584b","type":"message","text":"And why do you need it?","user":"U6PQP41C3","ts":"1612809844.328800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gnov+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And why do you need it?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"249b56b7-63fe-41a7-834e-4f24bd566973","type":"message","text":"that's an outside API thing though, no? If you \"solve\" the general case of differentiating a function f : A -&gt; B and if A and B turn out to be vectors, you get the jacobian by doing the jvp on basis vectors","user":"UMDEUKM29","ts":"1612809888.329000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lfce","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that's an outside API thing though, no? If you \"solve\" the general case of differentiating a function f : A -> B and if A and B turn out to be vectors, you get the jacobian by doing the jvp on basis vectors"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"point_up","users":["U6PQP41C3"],"count":1}]},{"client_msg_id":"4b3c4075-45d3-466d-a9bb-024a4d1e5ba1","type":"message","text":"&gt;  The problem with using `A` to represent tangents is that we always need tangents to form a vector space, and we’re not allowed to define `+` and `*` on existing types.","user":"UMDEUKM29","ts":"1612809910.329300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sLwOD","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" The problem with using "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" to represent tangents is that we always need tangents to form a vector space, and we’re not allowed to define "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" on existing types."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"d752a4c4-6ce9-44bb-b58f-897c42487db8","type":"message","text":"that makes a lot of sense","user":"UMDEUKM29","ts":"1612809913.329500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AnEfD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that makes a lot of sense"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"cc32f05a-77e5-4d7b-b4ad-b51920c973d2","type":"message","text":"&gt; I’m confused — what exactly do you mean by an actual Jacoabian?\nBy actual Jacobian, I mean all the rates of change of all the outputs wrt all the inputs whatever representation you choose.","user":"U85JBUGGP","ts":"1612809943.329700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RH=3=","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"I’m confused — what exactly do you mean by an actual Jacoabian?"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"By actual Jacobian, I mean all the rates of change of all the outputs wrt all the inputs whatever representation you choose."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"94bcf070-672b-4dcc-978b-b06a33d75e39","type":"message","text":"Oh I see — that’s fair enough.","user":"U6PQP41C3","ts":"1612809962.329900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OTMSh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh I see — that’s fair enough."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"9d585088-cd8a-4f40-83ef-05dd48bd5ef4","type":"message","text":"And in practice, some people need the Jacobian, e.g. to analyse rates of change or to do constrained optimisation. Some optimisation algorithms require the Jacobian of the constraint violations wrt the decision variables. “Flattening” the decision variables and the constraints is pretty standard in this case because it avoids the whole representation dilemma we are in right now.","user":"U85JBUGGP","ts":"1612810097.330700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Qco","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And in practice, some people need the Jacobian, e.g. to analyse rates of change or to do constrained optimisation. Some optimisation algorithms require the Jacobian of the constraint violations wrt the decision variables. “Flattening” the decision variables and the constraints is pretty standard in this case because it avoids the whole representation dilemma we are in right now."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"95bb2ceb-f071-45df-a987-2ed35202cde2","type":"message","text":"My perspective on this is based on the following:\na) we know (with a fairly high degree of certainty) how to define tangents / cotangents w.r.t. pretty arbitrary things, and therefore what the semantics of pushforwards / pullbacks should be,\nb) we don’t know for sure what a good way to represent Jacobians in general is, but\nc) we do know a good representation for `Vector{&lt;:Real} -&gt; Vector{&lt;:Real}` functions. Finally\nd) we know that, however we wind up defining Jacobians, we’ll be using pushforwards / pullbacks to compute them, because they are the basic functions that all AD tools implement.\n\nSo why don’t we just implement Jacobians for the cases that we understand well for now, and address the bigger question of how they should work in general after doing some thinking?","user":"U6PQP41C3","ts":"1612810406.333300","team":"T68168MUP","edited":{"user":"U6PQP41C3","ts":"1612810444.000000"},"blocks":[{"type":"rich_text","block_id":"Frc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My perspective on this is based on the following:\na) we know (with a fairly high degree of certainty) how to define tangents / cotangents w.r.t. pretty arbitrary things, and therefore what the semantics of pushforwards / pullbacks should be,\nb) we don’t know for sure what a good way to represent Jacobians in general is, but\nc) we do know a good representation for "},{"type":"text","text":"Vector{<:Real} -> Vector{<:Real}","style":{"code":true}},{"type":"text","text":" functions. Finally\nd) we know that, however we wind up defining Jacobians, we’ll be using pushforwards / pullbacks to compute them, because they are the basic functions that all AD tools implement.\n\nSo why don’t we just implement Jacobians for the cases that we understand well for now, and address the bigger question of how they should work in general after doing some thinking?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"7a40e07e-d8c2-401b-b6a4-19add7f98538","type":"message","text":"Fair enough. With the macro idea above, you can define whatever makes sense `v'jp`, `jvp`, or `jacobian` and `AbstractDifferentiation` will try to define something reasonable for the rest that at least works for arrays and can (hopefully) work for structs whatever representation we end up choosing.","user":"U85JBUGGP","ts":"1612810576.333600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"h/W2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fair enough. With the macro idea above, you can define whatever makes sense "},{"type":"text","text":"v'jp","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"jvp","style":{"code":true}},{"type":"text","text":", or "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"AbstractDifferentiation","style":{"code":true}},{"type":"text","text":" will try to define something reasonable for the rest that at least works for arrays and can (hopefully) work for structs whatever representation we end up choosing."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"f9c03b69-082e-4b3d-9d48-fbc6fbbb48e6","type":"message","text":"I don’t really enforce types or representations in `AbstractDifferentiation` as much as possible.","user":"U85JBUGGP","ts":"1612810596.333800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zEH70","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t really enforce types or representations in "},{"type":"text","text":"AbstractDifferentiation","style":{"code":true}},{"type":"text","text":" as much as possible."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"+1","users":["U6PQP41C3"],"count":1}]},{"client_msg_id":"b50beda4-7fb0-4786-ae6d-b02c2b84d88c","type":"message","text":"It’s just an interface","user":"U85JBUGGP","ts":"1612810615.334000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m+q5R","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s just an interface"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"}]