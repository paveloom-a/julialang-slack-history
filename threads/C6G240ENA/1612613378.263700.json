[{"client_msg_id":"55ed46d0-d6c2-42a1-ac00-af2160a30e73","type":"message","text":"I think it’s best to wait for my PR to have something concrete to discuss.","user":"U85JBUGGP","ts":"1612613378.263700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HV9J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it’s best to wait for my PR to have something concrete to discuss."}]}]}],"thread_ts":"1612613378.263700","reply_count":25,"reply_users_count":4,"latest_reply":"1612807147.321400","reply_users":["U6A936746","U85JBUGGP","UMDEUKM29","U6PQP41C3"],"subscribed":false,"reactions":[{"name":"ok_hand","users":["U6A936746","UKG4WF8PJ"],"count":2}]},{"client_msg_id":"d08d7ecc-3d27-47bb-8504-69046a44db20","type":"message","text":"Yeah. We can iterate on things as we go,\nFun as it is to discuss, often getting things out is better","user":"U6A936746","ts":"1612613437.264000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BdX72","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah. We can iterate on things as we go,\nFun as it is to discuss, often getting things out is better"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"sweat_smile","users":["U85JBUGGP","UKG4WF8PJ"],"count":2},{"name":"100","users":["U85JBUGGP"],"count":1}]},{"client_msg_id":"620eaf5f-ec3f-4b4a-a238-fb5d56cd6180","type":"message","text":"Though a lot of the API conclusions for ChainRulesCore was <@U6PQP41C3> and I drinking :whisky:  and waxing philosophical until 1am.","user":"U6A936746","ts":"1612613495.264400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gWK8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Though a lot of the API conclusions for ChainRulesCore was "},{"type":"user","user_id":"U6PQP41C3"},{"type":"text","text":" and I drinking "},{"type":"emoji","name":"whisky"},{"type":"text","text":"  and waxing philosophical until 1am."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"joy","users":["U85JBUGGP","UKG4WF8PJ","UN45LV5K6"],"count":3},{"name":"whisky-glass","users":["U6PQP41C3"],"count":1}]},{"type":"message","subtype":"thread_broadcast","text":"The implementation turned out to be larger than I was hoping but here it is <https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1>. Any feedback is welcome.","user":"U85JBUGGP","ts":"1612802252.313600","thread_ts":"1612613378.263700","root":{"client_msg_id":"55ed46d0-d6c2-42a1-ac00-af2160a30e73","type":"message","text":"I think it’s best to wait for my PR to have something concrete to discuss.","user":"U85JBUGGP","ts":"1612613378.263700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HV9J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it’s best to wait for my PR to have something concrete to discuss."}]}]}],"thread_ts":"1612613378.263700","reply_count":25,"reply_users_count":4,"latest_reply":"1612807147.321400","reply_users":["U6A936746","U85JBUGGP","UMDEUKM29","U6PQP41C3"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"V2I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The implementation turned out to be larger than I was hoping but here it is "},{"type":"link","url":"https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1"},{"type":"text","text":". Any feedback is welcome."}]}]}],"client_msg_id":"89481e1d-8226-4cb4-a6a7-df7a5b1e3c57"},{"client_msg_id":"7163b206-9d7a-488b-9663-2bfea3ae0cf4","type":"message","text":"I am super naive about these things but jacobian assumes a specific representation of vectors and matrices as arrays right? Wouldn't it make more sense to have as primitives jvp+vjp, and then define jacobians as the matrix representation of those? Then it also works for non-Array input?","user":"UMDEUKM29","ts":"1612802709.313900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+xs=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am super naive about these things but jacobian assumes a specific representation of vectors and matrices as arrays right? Wouldn't it make more sense to have as primitives jvp+vjp, and then define jacobians as the matrix representation of those? Then it also works for non-Array input?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"0f92777d-5757-487c-90a4-c4a979eefe4a","type":"message","text":"or do you mean that `jacobian` returns a lazy object?","user":"UMDEUKM29","ts":"1612802727.314100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eI9r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or do you mean that "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" returns a lazy object?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"edc8a044-7fc3-46c9-b0b5-21f5ec1ed90a","type":"message","text":"`jacobian` can return anything, I don’t really restrict its output","user":"U85JBUGGP","ts":"1612802765.314300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qQ+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" can return anything, I don’t really restrict its output"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"5f7c3471-43d5-4853-b362-16adf4ff6bae","type":"message","text":"I want to implement the API for Zygote, ForwardDiff, Nabla, etc. to properly test the API.","user":"U85JBUGGP","ts":"1612802823.314500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fbNh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want to implement the API for Zygote, ForwardDiff, Nabla, etc. to properly test the API."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"0b22bdbe-0886-4e96-ada1-c2683787b520","type":"message","text":"I may run into representation issues but the way the code is structured is quite generic. So `jacobian` can return a tuple of Jacobians or anything Jacobian-like.","user":"U85JBUGGP","ts":"1612802881.314700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"U3C","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I may run into representation issues but the way the code is structured is quite generic. So "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" can return a tuple of Jacobians or anything Jacobian-like."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"674c6f7e-2dc7-4ebd-8e3e-fa394d6b4a3e","type":"message","text":"I only have tests for finite difference so far.","user":"U85JBUGGP","ts":"1612803029.315000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FrRP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I only have tests for finite difference so far."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"7a9d247f-5c82-4be8-a82f-0ade1c84fcbf","type":"message","text":"yeah but do you expect `jacobian` to actually run the computation for all derivatives? Then it's wasteful if you just want to do a jvp in one direction","user":"UMDEUKM29","ts":"1612803305.315200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YE5aQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah but do you expect "},{"type":"text","text":"jacobian","style":{"code":true}},{"type":"text","text":" to actually run the computation for all derivatives? Then it's wasteful if you just want to do a jvp in one direction"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"e3bfd9dd-b238-4fcc-8f24-58ccdb620801","type":"message","text":"Not quite, see the definition of `pushforward_function` as the jacobian of a different function (<https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1/files#diff-d7c294969900dd9ee883b2a071307ff4c6346f08aa0c4bc4829fbaa22cd42e7fR128>). I don’t compute the full jacobian of the original function. It’s still a little wasteful because of this encoding overhead so a package author can define `jvp` directly by overloading `pushforward_function`.","user":"U85JBUGGP","ts":"1612804339.317400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9ryKD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not quite, see the definition of "},{"type":"text","text":"pushforward_function","style":{"code":true}},{"type":"text","text":" as the jacobian of a different function ("},{"type":"link","url":"https://github.com/JuliaDiff/AbstractDifferentiation.jl/pull/1/files#diff-d7c294969900dd9ee883b2a071307ff4c6346f08aa0c4bc4829fbaa22cd42e7fR128"},{"type":"text","text":"). I don’t compute the full jacobian of the original function. It’s still a little wasteful because of this encoding overhead so a package author can define "},{"type":"text","text":"jvp","style":{"code":true}},{"type":"text","text":" directly by overloading "},{"type":"text","text":"pushforward_function","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"b5f8354f-11f7-4008-ad7d-409682d7c15c","type":"message","text":"right but that does prevent you taking jvp wrt structs or namedtuples or what","user":"UMDEUKM29","ts":"1612805073.318200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SFQL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"right but that does prevent you taking jvp wrt structs or namedtuples or what"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"bab2e931-5e80-4e6c-a70d-e892c7e27d18","type":"message","text":"compared to using jvp and vjp as your basic blocks and defining jacobian from there","user":"UMDEUKM29","ts":"1612805105.318400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WOCX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"compared to using jvp and vjp as your basic blocks and defining jacobian from there"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"6ec4ace0-94eb-4570-9041-047146f90561","type":"message","text":"&gt; structs or namedtuples\nAs long as they have vector semantics, it’s fine. I only use scalar multiplication and addition. But yes there are limitations. But again, one can always define the jvp and vjp functions for the backend. Nothing stops you.","user":"U85JBUGGP","ts":"1612805321.318600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pxg","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"structs or namedtuples"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"As long as they have vector semantics, it’s fine. I only use scalar multiplication and addition. But yes there are limitations. But again, one can always define the jvp and vjp functions for the backend. Nothing stops you."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"6c331526-323e-4629-9614-90c8f38c7a83","type":"message","text":"It’s a question of defaults. I went with the more convenient default for vector-like inputs but that may have been a wrong choice.","user":"U85JBUGGP","ts":"1612805402.318800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bNDF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It’s a question of defaults. I went with the more convenient default for vector-like inputs but that may have been a wrong choice."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"78c99221-7854-4636-b6b8-5f5b5c9a254b","type":"message","text":"I think one can argue that if you are asking for the Jacobian/derivative of a function wrt its input, then that input must have vector semantics. Otherwise, calculus (as I know it) kind of doesn’t work. You need to be able to define what it means to infinitesimally change the input. I think this may have been one of the motivations of the differential type in ChainRules. Correct me if I am wrong <@U6A936746>.","user":"U85JBUGGP","ts":"1612805726.319000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7R9cL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think one can argue that if you are asking for the Jacobian/derivative of a function wrt its input, then that input must have vector semantics. Otherwise, calculus (as I know it) kind of doesn’t work. You need to be able to define what it means to infinitesimally change the input. I think this may have been one of the motivations of the differential type in ChainRules. Correct me if I am wrong "},{"type":"user","user_id":"U6A936746"},{"type":"text","text":"."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"de89e924-e83c-4f2c-8c2d-b66340e2fce6","type":"message","text":"That is the motivation of the `Composite` differential (or more broadly of differentials not being the same as primals) to begin with yes.\nGotta define `+` and `zero`,\nto make things easy should define `*` with real scalar, and  `dot`  and other linear operators","user":"U6A936746","ts":"1612805857.319200","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1612805916.000000"},"blocks":[{"type":"rich_text","block_id":"zVza","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is the motivation of the "},{"type":"text","text":"Composite","style":{"code":true}},{"type":"text","text":" differential (or more broadly of differentials not being the same as primals) to begin with yes.\nGotta define "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"zero","style":{"code":true}},{"type":"text","text":",\nto make things easy should define "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" with real scalar, and  "},{"type":"text","text":"dot","style":{"code":true}},{"type":"text","text":"  and other linear operators"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"+1","users":["U85JBUGGP"],"count":1}]},{"client_msg_id":"276bc9da-af59-4562-aad8-e962ccedd9f0","type":"message","text":"For convenience when it makes more sense to define the pushforward (pullback), I can have a macro that automatically defines the Jacobian and pullback (pushforward) for that backend using the defined pushforward (pullback).","user":"U85JBUGGP","ts":"1612806046.319800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wBs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For convenience when it makes more sense to define the pushforward (pullback), I can have a macro that automatically defines the Jacobian and pullback (pushforward) for that backend using the defined pushforward (pullback)."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP","reactions":[{"name":"heart","users":["U6A936746"],"count":1}]},{"client_msg_id":"66bb3fe9-cf9b-473e-86d4-4ef7f961eb44","type":"message","text":"To make everyone happy","user":"U85JBUGGP","ts":"1612806062.320000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"edI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To make everyone happy"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"6d8bd9e9-d451-41fc-ad72-e60ca971bcac","type":"message","text":"As you say every backend can just overload all functions if they want so it's not too much of a problem, I was just thinking that there are cases where jvp is naturally well defined but jacobian is not","user":"UMDEUKM29","ts":"1612806457.320300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QHx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As you say every backend can just overload all functions if they want so it's not too much of a problem, I was just thinking that there are cases where jvp is naturally well defined but jacobian is not"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"4e61ccb5-4dbb-43c6-a621-01a256279a2c","type":"message","text":"Eg struct A a b end ; f(x::A) = x.a","user":"UMDEUKM29","ts":"1612806487.320500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AwUVB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Eg struct A a b end ; f(x::A) = x.a"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"41ad0d12-ac4b-4b04-baa0-08f118525d40","type":"message","text":"Where the jvp can take a `A` but the jacobian would need to commit to a representation for \"map from A to real\"","user":"UMDEUKM29","ts":"1612806521.320700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hQean","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Where the jvp can take a `A` but the jacobian would need to commit to a representation for \"map from A to real\""}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"ff1d316a-0901-4407-9a22-72d5b64fd83f","type":"message","text":"Another interesting example is: what should the type of the Jacobian of a function `f: A -&gt; A` be?","user":"U6PQP41C3","ts":"1612806936.320900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IFe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Another interesting example is: what should the type of the Jacobian of a function "},{"type":"text","text":"f: A -> A","style":{"code":true}},{"type":"text","text":" be?"}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"73e12138-b19c-4944-8234-c51a648f5aa4","type":"message","text":"I think it is a vector of Composites,\nbut unfortunately it is a different vector of Composites depend on if you got it via forward or reverse.","user":"U6A936746","ts":"1612807016.321100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Dfpf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it is a vector of Composites,\nbut unfortunately it is a different vector of Composites depend on if you got it via forward or reverse."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"},{"client_msg_id":"5905d452-0c86-48d0-8660-8b8f2059997f","type":"message","text":"Ah, right, but if you do that you must have committed to a particular “flat” representation of `A` somehow. Assuming that you’ve accumulated in reverse, I assume that the vector you’re referring to contains a cotangent for each element of the output of `f`, but the output of `f` is an `A`, not a `Vector`.","user":"U6PQP41C3","ts":"1612807147.321400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J8W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, right, but if you do that you must have committed to a particular “flat” representation of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" somehow. Assuming that you’ve accumulated in reverse, I assume that the vector you’re referring to contains a cotangent for each element of the output of "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":", but the output of "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" is an "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":", not a "},{"type":"text","text":"Vector","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1612613378.263700","parent_user_id":"U85JBUGGP"}]