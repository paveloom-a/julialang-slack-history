[{"client_msg_id":"059063ad-f890-4f00-854e-d71ad776461b","type":"message","text":"Really wishing there was something like `mul!` in LinearAlgebra that respected sparsity. e.g. when writing a ChainRules `rrule` for a linear operator `A` that includes a function `y = A x`, the inplace-able pullback is `mul!(∂A, Δy, x, true, true)` , but if `A` is a sparse matrix, and its differential is represented as a sparse matrix, this will make it dense when it should be sparse. So what we need is a function like `mul_sparse!(∂A, Δy, x, true, true)`, that would keep `∂A` sparse, only computing the parts of the outer product needed to fill those sparse elements, which would also preserve the time complexity of the pullback. This would allow authors to implement functions that only assume arguments satisfy LinearAlgebra's interface for linear operators along with custom `rrule`s that preserve the time and storage complexity of the primal in the pullback. Thoughts?","user":"UHDQQ4GN6","ts":"1608702389.252200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/i8t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Really wishing there was something like "},{"type":"text","text":"mul!","style":{"code":true}},{"type":"text","text":" in LinearAlgebra that respected sparsity. e.g. when writing a ChainRules "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" for a linear operator "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" that includes a function "},{"type":"text","text":"y = A x","style":{"code":true}},{"type":"text","text":", the inplace-able pullback is "},{"type":"text","text":"mul!(∂A, Δy, x, true, true)","style":{"code":true}},{"type":"text","text":" , but if "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" is a sparse matrix, and its differential is represented as a sparse matrix, this will make it dense when it should be sparse. So what we need is a function like "},{"type":"text","text":"mul_sparse!(∂A, Δy, x, true, true)","style":{"code":true}},{"type":"text","text":", that would keep "},{"type":"text","text":"∂A","style":{"code":true}},{"type":"text","text":" sparse, only computing the parts of the outer product needed to fill those sparse elements, which would also preserve the time complexity of the pullback. This would allow authors to implement functions that only assume arguments satisfy LinearAlgebra's interface for linear operators along with custom "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":"s that preserve the time and storage complexity of the primal in the pullback. Thoughts?"}]}]}],"thread_ts":"1608702389.252200","reply_count":1,"reply_users_count":1,"latest_reply":"1608702457.252300","reply_users":["UHDQQ4GN6"],"subscribed":false},{"client_msg_id":"9847212d-9348-4bdc-8272-e0acc0a6b742","type":"message","text":"motivated by thinking how to define rules for `ExponentialUtilities.expv` , which allows a linear operator that only has certain methods defined, including `mul!(y, A, x)` .","user":"UHDQQ4GN6","ts":"1608702457.252300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P=y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"motivated by thinking how to define rules for "},{"type":"text","text":"ExponentialUtilities.expv","style":{"code":true}},{"type":"text","text":" , which allows a linear operator that only has certain methods defined, including "},{"type":"text","text":"mul!(y, A, x)","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1608702389.252200","parent_user_id":"UHDQQ4GN6"}]