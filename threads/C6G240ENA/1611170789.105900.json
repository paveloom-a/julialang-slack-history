[{"client_msg_id":"d39721e7-179d-4417-8f28-c5ab49234a33","type":"message","text":"I'm trying to use ForwardDiff on a function that takes a `FieldVector` (from StaticArrays) as input but without succes. Here's a MWE:\n```using StaticArrays\nusing ForwardDiff\n\nstruct MyType{T} &lt;: FieldVector{2,T}\n    a::T\n    b::T\nend\n\nStaticArrays.similar_type(p::Type{&lt;:MyType}, ::Type{T}, size::Size{(2,)}) where T = MyType{T}\n\nf(x) = x.a * x.b\nx = MyType(1.0, 2.0)\n\nForwardDiff.jacobian(f, x) ```\nwhich gives me the error\n```julia&gt; ForwardDiff.jacobian(f, x)\nERROR: type SArray has no field a\nStacktrace:\n [1] getproperty(x::SVector{2, ForwardDiff.Dual{ForwardDiff.Tag{typeof(f), Float64}, Float64, 2}}, f::Symbol)\n   @ Base ./Base.jl:33\n [2] f(x::SVector{2, ForwardDiff.Dual{ForwardDiff.Tag{typeof(f), Float64}, Float64, 2}})\n   @ Main ./REPL[6]:1\n [3] static_dual_eval(#unused#::Type{ForwardDiff.Tag{typeof(f), Float64}}, f::typeof(f), x::MyType{Float64})\n   @ ForwardDiff ~/.julia/packages/ForwardDiff/kU1ce/src/apiutils.jl:32\n [4] vector_mode_jacobian(f::Function, x::MyType{Float64})\n   @ ForwardDiff ~/.julia/packages/ForwardDiff/kU1ce/src/jacobian.jl:181\n [5] jacobian(f::Function, x::MyType{Float64})\n   @ ForwardDiff ~/.julia/packages/ForwardDiff/kU1ce/src/jacobian.jl:85\n [6] top-level scope\n   @ REPL[8]:1```\nAfter searching around a bit I noticed there is a open pull request to add FieldVector support to ForwardDiff but it is three years old already. I tried to follow the discussion in that pull request but it is outside my area of expertise. Anyone here who maybe knows how to get the MWE working (without replacing the `x.a` by `x[1]` and `x.b` by `x[2]` because that would beat the purpose of using FieldVectors)?","user":"UCT34GL7M","ts":"1611170789.105900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NEmT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm trying to use ForwardDiff on a function that takes a "},{"type":"text","text":"FieldVector","style":{"code":true}},{"type":"text","text":" (from StaticArrays) as input but without succes. Here's a MWE:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using StaticArrays\nusing ForwardDiff\n\nstruct MyType{T} <: FieldVector{2,T}\n    a::T\n    b::T\nend\n\nStaticArrays.similar_type(p::Type{<:MyType}, ::Type{T}, size::Size{(2,)}) where T = MyType{T}\n\nf(x) = x.a * x.b\nx = MyType(1.0, 2.0)\n\nForwardDiff.jacobian(f, x) "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"which gives me the error\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> ForwardDiff.jacobian(f, x)\nERROR: type SArray has no field a\nStacktrace:\n [1] getproperty(x::SVector{2, ForwardDiff.Dual{ForwardDiff.Tag{typeof(f), Float64}, Float64, 2}}, f::Symbol)\n   @ Base ./Base.jl:33\n [2] f(x::SVector{2, ForwardDiff.Dual{ForwardDiff.Tag{typeof(f), Float64}, Float64, 2}})\n   @ Main ./REPL[6]:1\n [3] static_dual_eval(#unused#::Type{ForwardDiff.Tag{typeof(f), Float64}}, f::typeof(f), x::MyType{Float64})\n   @ ForwardDiff ~/.julia/packages/ForwardDiff/kU1ce/src/apiutils.jl:32\n [4] vector_mode_jacobian(f::Function, x::MyType{Float64})\n   @ ForwardDiff ~/.julia/packages/ForwardDiff/kU1ce/src/jacobian.jl:181\n [5] jacobian(f::Function, x::MyType{Float64})\n   @ ForwardDiff ~/.julia/packages/ForwardDiff/kU1ce/src/jacobian.jl:85\n [6] top-level scope\n   @ REPL[8]:1"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"After searching around a bit I noticed there is a open pull request to add FieldVector support to ForwardDiff but it is three years old already. I tried to follow the discussion in that pull request but it is outside my area of expertise. Anyone here who maybe knows how to get the MWE working (without replacing the "},{"type":"text","text":"x.a","style":{"code":true}},{"type":"text","text":" by "},{"type":"text","text":"x[1]","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"x.b","style":{"code":true}},{"type":"text","text":" by "},{"type":"text","text":"x[2]","style":{"code":true}},{"type":"text","text":" because that would beat the purpose of using FieldVectors)?"}]}]}],"thread_ts":"1611170789.105900","reply_count":6,"reply_users_count":3,"latest_reply":"1611233159.006700","reply_users":["UD0NS8PDF","U9AHT3YM7","UCT34GL7M"],"subscribed":false},{"client_msg_id":"b651ff4a-9747-449f-b6c5-11500470778f","type":"message","text":"Haven’t looked at the PR, but somehow it must make vector of duals from your `x`, and from the stacktrace this ends up being an SVector. But things like `x .+ Dual(0)` seem to preserve the type. Maybe you could figure out what function ForwardDiff is using to generate this perturbed x?","user":"UD0NS8PDF","ts":"1611171396.106000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ce/Yy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Haven’t looked at the PR, but somehow it must make vector of duals from your "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":", and from the stacktrace this ends up being an SVector. But things like "},{"type":"text","text":"x .+ Dual(0)","style":{"code":true}},{"type":"text","text":" seem to preserve the type. Maybe you could figure out what function ForwardDiff is using to generate this perturbed x?"}]}]}],"thread_ts":"1611170789.105900","parent_user_id":"UCT34GL7M"},{"client_msg_id":"57b9b841-0636-4010-9ccf-6ec367fc172b","type":"message","text":"I think this problem is a combination of two things.\n1. `f` should return an array `f(x) = SA[x.a * x.b]`\n2. `ForwardDiff.dualize` calls `StaticArrays.similar_type` at generation time, not call time, which means new methods of that function may or may not be picked (like the one you've added). This modification solves it:\n```@generated function ForwardDiff.dualize(::Type{T}, x::StaticArray) where T\n    N = length(x)\n    dx = Expr(:tuple, [:(ForwardDiff.Dual{T}(x[$i], chunk, Val{$i}())) for i in 1:N]...)\n    return quote\n        $(Expr(:meta, :inline))\n        chunk = ForwardDiff.Chunk{$N}()\n        V = StaticArrays.similar_type($x, $(ForwardDiff.Dual{T,eltype(x),N}))\n        return V($(dx))\n    end\nend```\n","user":"U9AHT3YM7","ts":"1611174126.106200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iW1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this problem is a combination of two things.\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" should return an array "},{"type":"text","text":"f(x) = SA[x.a * x.b]","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"ForwardDiff.dualize","style":{"code":true}},{"type":"text","text":" calls "},{"type":"text","text":"StaticArrays.similar_type","style":{"code":true}},{"type":"text","text":" at generation time, not call time, which means new methods of that function may or may not be picked (like the one you've added). This modification solves it:"}]}],"style":"ordered","indent":0},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@generated function ForwardDiff.dualize(::Type{T}, x::StaticArray) where T\n    N = length(x)\n    dx = Expr(:tuple, [:(ForwardDiff.Dual{T}(x[$i], chunk, Val{$i}())) for i in 1:N]...)\n    return quote\n        $(Expr(:meta, :inline))\n        chunk = ForwardDiff.Chunk{$N}()\n        V = StaticArrays.similar_type($x, $(ForwardDiff.Dual{T,eltype(x),N}))\n        return V($(dx))\n    end\nend"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1611170789.105900","parent_user_id":"UCT34GL7M"},{"client_msg_id":"fc23bf57-6421-40c3-b34d-5b266392613a","type":"message","text":"Thanks a lot. Defining the `similar_type` *before* `using ForwardDiff` did the trick (and I actually meant to use ForwardDiff.gradient instead of ForwardDiff.jacobian so I don't have to make `f` return an array in that case). But","user":"UCT34GL7M","ts":"1611179300.108200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Ap","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks a lot. Defining the "},{"type":"text","text":"similar_type","style":{"code":true}},{"type":"text","text":" "},{"type":"text","text":"before","style":{"bold":true}},{"type":"text","text":" "},{"type":"text","text":"using ForwardDiff","style":{"code":true}},{"type":"text","text":" did the trick (and I actually meant to use ForwardDiff.gradient instead of ForwardDiff.jacobian so I don't have to make "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" return an array in that case). But"}]}]}],"thread_ts":"1611170789.105900","parent_user_id":"UCT34GL7M"},{"client_msg_id":"1fe5656d-77df-4940-9217-1f032b4511d6","type":"message","text":"<@U9AHT3YM7> Do you think it would make sense to propose the above generated function as a solution in the open PR? (<https://github.com/JuliaDiff/ForwardDiff.jl/pull/307>). I have zero experience with generated functions so I find it difficult to judge what other implications it has.","user":"UCT34GL7M","ts":"1611229622.005200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vsb","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U9AHT3YM7"},{"type":"text","text":" Do you think it would make sense to propose the above generated function as a solution in the open PR? ("},{"type":"link","url":"https://github.com/JuliaDiff/ForwardDiff.jl/pull/307"},{"type":"text","text":"). I have zero experience with generated functions so I find it difficult to judge what other implications it has."}]}]}],"thread_ts":"1611170789.105900","parent_user_id":"UCT34GL7M"},{"client_msg_id":"70cf70d3-972e-456c-94fa-8509772cbce2","type":"message","text":"I think this should be fine. I'd say my version is safer than the one currently present in ForwardDiff but both the current one and mine are a bit less safe then what was desired in that PR (per jrevel's comments0.","user":"U9AHT3YM7","ts":"1611232891.006500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0+kxp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this should be fine. I'd say my version is safer than the one currently present in ForwardDiff but both the current one and mine are a bit less safe then what was desired in that PR (per jrevel's comments0."}]}]}],"thread_ts":"1611170789.105900","parent_user_id":"UCT34GL7M"},{"client_msg_id":"f063e354-4779-4e71-9c92-82296a118954","type":"message","text":"I really doubt anyone would overload `eltype` or `length` for a subtype of `FieldVector` but that's actually where it's a bit unsafe","user":"U9AHT3YM7","ts":"1611233159.006700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QoAC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I really doubt anyone would overload "},{"type":"text","text":"eltype","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"length","style":{"code":true}},{"type":"text","text":" for a subtype of "},{"type":"text","text":"FieldVector","style":{"code":true}},{"type":"text","text":" but that's actually where it's a bit unsafe"}]}]}],"thread_ts":"1611170789.105900","parent_user_id":"UCT34GL7M"}]