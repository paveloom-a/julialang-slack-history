[{"client_msg_id":"9bb3b39f-906a-4cd0-9560-45daaa610907","type":"message","text":"Hi Folks, was wondering if I could pick y'alls brains on how to do autodiff with our code packages for RL and control. Our higher level code is structured similar to a Markov decision process where we have functions like `setstate`, `getobs`, or `step`, which abstracts away the lower level dynamics (i.e. how does the state evolve). Everything works great if we define the dynamics in Julia, but the complication is that for a lot of deepRL for robotics, the lower level dynamics is handled by a physics simulator not implemented in Julia (in our case <http://mujoco.org/|MuJoCo> which is the standard currently). The following is an example of what I used before for a neuralODE project where we learn policy parameters\n\n```function f(u,p,t)\n    # env is a struct, in the following, representing the dynamical environment\n    setstate(env, u[1:end-1])\n    o = getobs(env)\n    a = policy(o, p) # handled by something like flux if using a neural network\n    setaction!(env, a)\n  \n    du = _dustep!(env)\n    cost = -getreward(env)\n\n    vcat(du..., cost)\nend```\nYou can see that if `env` is a julia struct that has vectors to store the state, action, etc., everything is great. However, if `env` contains references to c-structs in an external library such as in the case with MuJoCo, we have a problem. For example, `getobs` might grab some values from the referenced c-structs, but should return a pullback representing `d-obs/d-state` ostensibly. Moving forward, it would be nice to define `rrules` for the above functions (`getobs`etc.) but *one issue* I face is that in code most functions have `env` as an input, but mathematically, we are differentiating w.r.t. state/actions that are not fields in `env` due to state/action being in the c-library -- even if we did make them fields, we would need to know how the simulator changes the fields, so that's a no-go, unless I can prompt autodiff to specify the function's inputs and outputs differently. MuJoCo was designed for finite-differencing, so we can efficiently differentiate forward and inverse dynamics, (as well as observations, rewards, etc.) so there's no problem there (this also has to be done manually since there's quaternions to deal with).\n\nThe way I got around this before was to define an adjoint for the whole function `f` and that was fine, but lacked re-use and flexibility. That let me write the adjoint for `f(u,p,t)`  inputs directly, but I'd like to give folks more options in the future. Any advice would be appreciated!","user":"U9NH09E58","ts":"1616699578.087300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cqP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi Folks, was wondering if I could pick y'alls brains on how to do autodiff with our code packages for RL and control. Our higher level code is structured similar to a Markov decision process where we have functions like "},{"type":"text","text":"setstate","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":", or "},{"type":"text","text":"step","style":{"code":true}},{"type":"text","text":", which abstracts away the lower level dynamics (i.e. how does the state evolve). Everything works great if we define the dynamics in Julia, but the complication is that for a lot of deepRL for robotics, the lower level dynamics is handled by a physics simulator not implemented in Julia (in our case "},{"type":"link","url":"http://mujoco.org/","text":"MuJoCo"},{"type":"text","text":" which is the standard currently). The following is an example of what I used before for a neuralODE project where we learn policy parameters\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f(u,p,t)\n    # env is a struct, in the following, representing the dynamical environment\n    setstate(env, u[1:end-1])\n    o = getobs(env)\n    a = policy(o, p) # handled by something like flux if using a neural network\n    setaction!(env, a)\n  \n    du = _dustep!(env)\n    cost = -getreward(env)\n\n    vcat(du..., cost)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"You can see that if "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" is a julia struct that has vectors to store the state, action, etc., everything is great. However, if "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" contains references to c-structs in an external library such as in the case with MuJoCo, we have a problem. For example, "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":" might grab some values from the referenced c-structs, but should return a pullback representing "},{"type":"text","text":"d-obs/d-state","style":{"code":true}},{"type":"text","text":" ostensibly. Moving forward, it would be nice to define "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for the above functions ("},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":"etc.) but "},{"type":"text","text":"one issue","style":{"bold":true}},{"type":"text","text":" I face is that in code most functions have "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" as an input, but mathematically, we are differentiating w.r.t. state/actions that are not fields in "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" due to state/action being in the c-library -- even if we did make them fields, we would need to know how the simulator changes the fields, so that's a no-go, unless I can prompt autodiff to specify the function's inputs and outputs differently. MuJoCo was designed for finite-differencing, so we can efficiently differentiate forward and inverse dynamics, (as well as observations, rewards, etc.) so there's no problem there (this also has to be done manually since there's quaternions to deal with).\n\nThe way I got around this before was to define an adjoint for the whole function "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" and that was fine, but lacked re-use and flexibility. That let me write the adjoint for "},{"type":"text","text":"f(u,p,t)","style":{"code":true}},{"type":"text","text":"  inputs directly, but I'd like to give folks more options in the future. Any advice would be appreciated!"}]}]}],"thread_ts":"1616699578.087300","reply_count":3,"reply_users_count":2,"latest_reply":"1616705788.088000","reply_users":["U6A936746","U9NH09E58"],"is_locked":false,"subscribed":false},{"client_msg_id":"907381b2-d9a5-42c2-a110-e6380684bc7c","type":"message","text":"I have never used it but\nLike I thought MuJoCo wasn’t finite differencing but actall AD\nIn theory:\nMuJoCo should be able to give gradients directly.\nbecause that is its thing.\nit’s the O.G. differentiable programming language, its just highly domain specific.\n(as I understand it MuJoCo people laugh at us when we say “Catpole in 1 generation” since they did the same thing via the same method a decade ago)\n\nIs there a MuJoCo.jl julia library that wraps it, so we can just write `rrules` for that?","user":"U6A936746","ts":"1616700223.087400","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1616700266.000000"},"blocks":[{"type":"rich_text","block_id":"SGYrV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have never used it but\nLike I thought MuJoCo wasn’t finite differencing but actall AD\nIn theory:\nMuJoCo should be able to give gradients directly.\nbecause that is its thing.\nit’s the O.G. differentiable programming language, its just highly domain specific.\n(as I understand it MuJoCo people laugh at us when we say “Catpole in 1 generation” since they did the same thing via the same method a decade ago)\n\nIs there a MuJoCo.jl julia library that wraps it, so we can just write "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for that?"}]}]}],"thread_ts":"1616699578.087300","parent_user_id":"U9NH09E58"},{"client_msg_id":"b7ba3639-b989-4dbf-8e7f-e09e7cd8e45f","type":"message","text":"A problem is we don’t do mutating state very well.\nIn theory ChainRules supports it (though I am yet to write the docs).\nIn practice we don’t allow it since Zygote is the main consumer of ChainRules rules and it doesn’t support it and it is annoying to tell it to ignore rules (we are going to fix that with traits on the rules at some point)\nAnd the way to handle that generally is to write a rule around the greater function that does the mutating, like you are doing for `f`","user":"U6A936746","ts":"1616700422.087700","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1616700426.000000"},"blocks":[{"type":"rich_text","block_id":"Orz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A problem is we don’t do mutating state very well.\nIn theory ChainRules supports it (though I am yet to write the docs).\nIn practice we don’t allow it since Zygote is the main consumer of ChainRules rules and it doesn’t support it and it is annoying to tell it to ignore rules (we are going to fix that with traits on the rules at some point)\nAnd the way to handle that generally is to write a rule around the greater function that does the mutating, like you are doing for "},{"type":"text","text":"f","style":{"code":true}}]}]}],"thread_ts":"1616699578.087300","parent_user_id":"U9NH09E58"},{"client_msg_id":"8fd7fc48-65c8-4207-9874-437a319fb97c","type":"message","text":"MuJoCo was built with a special definition for contact functions such that derivatives are defined everywhere; finite differencing is the way to access such gradients (<http://mujoco.org/book/programming.html#saDerivative>). The next piece of software built on MuJoCo will have this functionality built in to extract the gradients, but will be analytical or finite-differenced where needed.\n<https://github.com/Lyceum/MuJoCo.jl> is the wrapper we made that is a nice zero-overhead port, but defining `rrules` for it is still tricky. If we wanted to do forward dynamics, `mj_forward(mj_model, mj_data)` is the function signature of the c-library, and it returns nothing. The forward function that would play nicely with autodiff, as far as I understand, would be something like `nextstate = forward(state, action, mj_model, mj_data)` and we just ignore the pullbacks for the mj_model/mj_data structs; nominally state and action would just point to fields in the mj_data c-struct, but autodiff can't see when mujoco changes those fields... Doing this for all MuJoCo functions one might want to use would be tricky, tedious, and error prone, and requires defining a different API.\n\nDoing this at the higher level (Lyceum*'s level) then it would be easier for users. I suppose the core issue is that the things we want to get gradients for are not accessible to autodiff as they're hidden in the `env` structs, but mathematically the functions are well defined. Specifying the `rrules` still relies on the function inputs and outputs, but I wonder if I could somehow re-define what the inputs and outputs would be while keeping the same API?\n\ntaking something like `getobs(env)`  for example; in the analytical model case, this should reduce to `getobs(state::Vector)` but in the MuJoCo case this function is allowed to pull from whatever mujoco fields it would like; the mujoco env is a function of state internally but autodiff wouldn't see this. To tie this in with why it would be hard to do rrules for MuJoCo.jl, `getobs` might just pull from arbitrary mujoco fields, not as a mujoco function; `getobs` would need the `rrule` at that point.","user":"U9NH09E58","ts":"1616705788.088000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hqf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"MuJoCo was built with a special definition for contact functions such that derivatives are defined everywhere; finite differencing is the way to access such gradients ("},{"type":"link","url":"http://mujoco.org/book/programming.html#saDerivative"},{"type":"text","text":"). The next piece of software built on MuJoCo will have this functionality built in to extract the gradients, but will be analytical or finite-differenced where needed.\n"},{"type":"link","url":"https://github.com/Lyceum/MuJoCo.jl"},{"type":"text","text":" is the wrapper we made that is a nice zero-overhead port, but defining "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for it is still tricky. If we wanted to do forward dynamics, "},{"type":"text","text":"mj_forward(mj_model, mj_data)","style":{"code":true}},{"type":"text","text":" is the function signature of the c-library, and it returns nothing. The forward function that would play nicely with autodiff, as far as I understand, would be something like "},{"type":"text","text":"nextstate = forward(state, action, mj_model, mj_data)","style":{"code":true}},{"type":"text","text":" and we just ignore the pullbacks for the mj_model/mj_data structs; nominally state and action would just point to fields in the mj_data c-struct, but autodiff can't see when mujoco changes those fields... Doing this for all MuJoCo functions one might want to use would be tricky, tedious, and error prone, and requires defining a different API.\n\nDoing this at the higher level (Lyceum*'s level) then it would be easier for users. I suppose the core issue is that the things we want to get gradients for are not accessible to autodiff as they're hidden in the "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" structs, but mathematically the functions are well defined. Specifying the "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" still relies on the function inputs and outputs, but I wonder if I could somehow re-define what the inputs and outputs would be while keeping the same API?\n\ntaking something like "},{"type":"text","text":"getobs(env)","style":{"code":true}},{"type":"text","text":"  for example; in the analytical model case, this should reduce to "},{"type":"text","text":"getobs(state::Vector)","style":{"code":true}},{"type":"text","text":" but in the MuJoCo case this function is allowed to pull from whatever mujoco fields it would like; the mujoco env is a function of state internally but autodiff wouldn't see this. To tie this in with why it would be hard to do rrules for MuJoCo.jl, "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":" might just pull from arbitrary mujoco fields, not as a mujoco function; "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":" would need the "},{"type":"text","text":"rrule","style":{"code":true}},{"type":"text","text":" at that point."}]}]}],"thread_ts":"1616699578.087300","parent_user_id":"U9NH09E58"}]