[{"client_msg_id":"9bb3b39f-906a-4cd0-9560-45daaa610907","type":"message","text":"Hi Folks, was wondering if I could pick y'alls brains on how to do autodiff with our code packages for RL and control. Our higher level code is structured similar to a Markov decision process where we have functions like `setstate`, `getobs`, or `step`, which abstracts away the lower level dynamics (i.e. how does the state evolve). Everything works great if we define the dynamics in Julia, but the complication is that for a lot of deepRL for robotics, the lower level dynamics is handled by a physics simulator not implemented in Julia (in our case <http://mujoco.org/|MuJoCo> which is the standard currently). The following is an example of what I used before for a neuralODE project where we learn policy parameters\n\n```function f(u,p,t)\n    # env is a struct, in the following, representing the dynamical environment\n    setstate(env, u[1:end-1])\n    o = getobs(env)\n    a = policy(o, p) # handled by something like flux if using a neural network\n    setaction!(env, a)\n  \n    du = _dustep!(env)\n    cost = -getreward(env)\n\n    vcat(du..., cost)\nend```\nYou can see that if `env` is a julia struct that has vectors to store the state, action, etc., everything is great. However, if `env` contains references to c-structs in an external library such as in the case with MuJoCo, we have a problem. For example, `getobs` might grab some values from the referenced c-structs, but should return a pullback representing `d-obs/d-state` ostensibly. Moving forward, it would be nice to define `rrules` for the above functions (`getobs`etc.) but *one issue* I face is that in code most functions have `env` as an input, but mathematically, we are differentiating w.r.t. state/actions that are not fields in `env` due to state/action being in the c-library -- even if we did make them fields, we would need to know how the simulator changes the fields, so that's a no-go, unless I can prompt autodiff to specify the function's inputs and outputs differently. MuJoCo was designed for finite-differencing, so we can efficiently differentiate forward and inverse dynamics, (as well as observations, rewards, etc.) so there's no problem there (this also has to be done manually since there's quaternions to deal with).\n\nThe way I got around this before was to define an adjoint for the whole function `f` and that was fine, but lacked re-use and flexibility. That let me write the adjoint for `f(u,p,t)`  inputs directly, but I'd like to give folks more options in the future. Any advice would be appreciated!","user":"U9NH09E58","ts":"1616699578.087300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cqP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi Folks, was wondering if I could pick y'alls brains on how to do autodiff with our code packages for RL and control. Our higher level code is structured similar to a Markov decision process where we have functions like "},{"type":"text","text":"setstate","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":", or "},{"type":"text","text":"step","style":{"code":true}},{"type":"text","text":", which abstracts away the lower level dynamics (i.e. how does the state evolve). Everything works great if we define the dynamics in Julia, but the complication is that for a lot of deepRL for robotics, the lower level dynamics is handled by a physics simulator not implemented in Julia (in our case "},{"type":"link","url":"http://mujoco.org/","text":"MuJoCo"},{"type":"text","text":" which is the standard currently). The following is an example of what I used before for a neuralODE project where we learn policy parameters\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f(u,p,t)\n    # env is a struct, in the following, representing the dynamical environment\n    setstate(env, u[1:end-1])\n    o = getobs(env)\n    a = policy(o, p) # handled by something like flux if using a neural network\n    setaction!(env, a)\n  \n    du = _dustep!(env)\n    cost = -getreward(env)\n\n    vcat(du..., cost)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"You can see that if "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" is a julia struct that has vectors to store the state, action, etc., everything is great. However, if "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" contains references to c-structs in an external library such as in the case with MuJoCo, we have a problem. For example, "},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":" might grab some values from the referenced c-structs, but should return a pullback representing "},{"type":"text","text":"d-obs/d-state","style":{"code":true}},{"type":"text","text":" ostensibly. Moving forward, it would be nice to define "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for the above functions ("},{"type":"text","text":"getobs","style":{"code":true}},{"type":"text","text":"etc.) but "},{"type":"text","text":"one issue","style":{"bold":true}},{"type":"text","text":" I face is that in code most functions have "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" as an input, but mathematically, we are differentiating w.r.t. state/actions that are not fields in "},{"type":"text","text":"env","style":{"code":true}},{"type":"text","text":" due to state/action being in the c-library -- even if we did make them fields, we would need to know how the simulator changes the fields, so that's a no-go, unless I can prompt autodiff to specify the function's inputs and outputs differently. MuJoCo was designed for finite-differencing, so we can efficiently differentiate forward and inverse dynamics, (as well as observations, rewards, etc.) so there's no problem there (this also has to be done manually since there's quaternions to deal with).\n\nThe way I got around this before was to define an adjoint for the whole function "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" and that was fine, but lacked re-use and flexibility. That let me write the adjoint for "},{"type":"text","text":"f(u,p,t)","style":{"code":true}},{"type":"text","text":"  inputs directly, but I'd like to give folks more options in the future. Any advice would be appreciated!"}]}]}],"thread_ts":"1616699578.087300","reply_count":2,"reply_users_count":1,"latest_reply":"1616700422.087700","reply_users":["U6A936746"],"is_locked":false,"subscribed":false},{"client_msg_id":"907381b2-d9a5-42c2-a110-e6380684bc7c","type":"message","text":"I have never used it but\nLike I thought MuJoCo wasn’t finite differencing but actall AD\nIn theory:\nMuJoCo should be able to give gradients directly.\nbecause that is its thing.\nit’s the O.G. differentiable programming language, its just highly domain specific.\n(as I understand it MuJoCo people laugh at us when we say “Catpole in 1 generation” since they did the same thing via the same method a decade ago)\n\nIs there a MuJoCo.jl julia library that wraps it, so we can just write `rrules` for that?","user":"U6A936746","ts":"1616700223.087400","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1616700266.000000"},"blocks":[{"type":"rich_text","block_id":"SGYrV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have never used it but\nLike I thought MuJoCo wasn’t finite differencing but actall AD\nIn theory:\nMuJoCo should be able to give gradients directly.\nbecause that is its thing.\nit’s the O.G. differentiable programming language, its just highly domain specific.\n(as I understand it MuJoCo people laugh at us when we say “Catpole in 1 generation” since they did the same thing via the same method a decade ago)\n\nIs there a MuJoCo.jl julia library that wraps it, so we can just write "},{"type":"text","text":"rrules","style":{"code":true}},{"type":"text","text":" for that?"}]}]}],"thread_ts":"1616699578.087300","parent_user_id":"U9NH09E58"},{"client_msg_id":"b7ba3639-b989-4dbf-8e7f-e09e7cd8e45f","type":"message","text":"A problem is we don’t do mutating state very well.\nIn theory ChainRules supports it (though I am yet to write the docs).\nIn practice we don’t allow it since Zygote is the main consumer of ChainRules rules and it doesn’t support it and it is annoying to tell it to ignore rules (we are going to fix that with traits on the rules at some point)\nAnd the way to handle that generally is to write a rule around the greater function that does the mutating, like you are doing for `f`","user":"U6A936746","ts":"1616700422.087700","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1616700426.000000"},"blocks":[{"type":"rich_text","block_id":"Orz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A problem is we don’t do mutating state very well.\nIn theory ChainRules supports it (though I am yet to write the docs).\nIn practice we don’t allow it since Zygote is the main consumer of ChainRules rules and it doesn’t support it and it is annoying to tell it to ignore rules (we are going to fix that with traits on the rules at some point)\nAnd the way to handle that generally is to write a rule around the greater function that does the mutating, like you are doing for "},{"type":"text","text":"f","style":{"code":true}}]}]}],"thread_ts":"1616699578.087300","parent_user_id":"U9NH09E58"}]