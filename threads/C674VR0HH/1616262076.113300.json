[{"client_msg_id":"b097635c-3e75-4abc-a2e3-2ad2340e46df","type":"message","text":"&lt;<https://github.com/JuliaData/Arrow.jl/pull/150%7Cdefine> caller-overloadable arrownameof(T) to allow callers to specify preferred Julia &lt;-&gt; Arrow type matching behavior&gt;\n\nan easily replaceable stopgap to enable some custom (de)serialization behaviors until something like <@U681ELA87>'s plan <https://julialang.slack.com/archives/C674VR0HH/p1615846377461400?thread_ts=1615681758.430500&amp;cid=C674VR0HH|here> lands","user":"U674T0Y9Z","ts":"1616262076.113300","team":"T68168MUP","attachments":[{"from_url":"https://julialang.slack.com/archives/C674VR0HH/p1615846377461400?thread_ts=1615681758.430500&amp;cid=C674VR0HH","fallback":"[March 15th, 2021 3:12 PM] quinnj: <@U674T0Y9Z>, for deserialization, what you think about ditching the *_MAPPING Dicts and instead parsing a metadata type name of the form `JuliaLang.UUID` as `(Val(:JuliaLang), Val(:UUID))`, or maybe just `Val(:JuliaLang.UUID)`. so you’d overload something like:\n```function Arrow.ArrowTypes.fromarrow(::Val{:JuliaLang.UUID}, x...)\n\nend```\nwhere `x…` would be the deserialized fields. There’d be generic definitions something like `fromarrow(V, x…) = nothing` and if there’s no overload, then we’d just return a NamedTuple..\n\nOn the serialization side, we’d have:\n• `Arrow.ArrowTypes.toarrow(x) = x`, and `Arrow.ArrowTypes.arrowname(::Type{T})` which would be overloadable for custom types where you’d return the arrow object to serialize, and `arrowname` would be the field metadata type name. By default `arrowname(T) = Symbol()`, so we wouldn’t name it, so you’d only get a NamedTuple out unless you overload. \nMy biggest question then is if this would really work for parametric types. You could serialize using `nameof` in `arrowname`, but then in `fromarrow`, you’d have to be able to build your type. I think it gets awkward if you have non-field-based type parameters that you don’t necessarily want to serialize in `arrowname`, but maybe that’s just a pill you have to swallow. If you can’t infer the type parameters from the data itself, you’ll need to serialize it in the `arrowname` and pull it back out somehow.","ts":"1615846377.461400","author_id":"U681ELA87","author_subname":"Jacob Quinn","channel_id":"C674VR0HH","channel_name":"data","is_msg_unfurl":true,"is_reply_unfurl":true,"text":"<@U674T0Y9Z>, for deserialization, what you think about ditching the *_MAPPING Dicts and instead parsing a metadata type name of the form `JuliaLang.UUID` as `(Val(:JuliaLang), Val(:UUID))`, or maybe just `Val(:JuliaLang.UUID)`. so you’d overload something like:\n```function Arrow.ArrowTypes.fromarrow(::Val{:JuliaLang.UUID}, x...)\n\nend```\nwhere `x…` would be the deserialized fields. There’d be generic definitions something like `fromarrow(V, x…) = nothing` and if there’s no overload, then we’d just return a NamedTuple..\n\nOn the serialization side, we’d have:\n• `Arrow.ArrowTypes.toarrow(x) = x`, and `Arrow.ArrowTypes.arrowname(::Type{T})` which would be overloadable for custom types where you’d return the arrow object to serialize, and `arrowname` would be the field metadata type name. By default `arrowname(T) = Symbol()`, so we wouldn’t name it, so you’d only get a NamedTuple out unless you overload. \nMy biggest question then is if this would really work for parametric types. You could serialize using `nameof` in `arrowname`, but then in `fromarrow`, you’d have to be able to build your type. I think it gets awkward if you have non-field-based type parameters that you don’t necessarily want to serialize in `arrowname`, but maybe that’s just a pill you have to swallow. If you can’t infer the type parameters from the data itself, you’ll need to serialize it in the `arrowname` and pull it back out somehow.","author_name":"Jacob Quinn","author_link":"https://julialang.slack.com/team/U681ELA87","author_icon":"https://secure.gravatar.com/avatar/d788bf7fd037ebef5798d8881c5faa2f.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0024-48.png","mrkdwn_in":["text"],"id":1,"original_url":"https://julialang.slack.com/archives/C674VR0HH/p1615846377461400?thread_ts=1615681758.430500&amp;cid=C674VR0HH","footer":"From a thread in #data"}],"blocks":[{"type":"rich_text","block_id":"Qld+/","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/pull/150","text":"define caller-overloadable arrownameof(T) to allow callers to specify preferred Julia <-> Arrow type matching behavior"},{"type":"text","text":"\n\nan easily replaceable stopgap to enable some custom (de)serialization behaviors until something like "},{"type":"user","user_id":"U681ELA87"},{"type":"text","text":"'s plan "},{"type":"link","url":"https://julialang.slack.com/archives/C674VR0HH/p1615846377461400?thread_ts=1615681758.430500&cid=C674VR0HH","text":"here"},{"type":"text","text":" lands"}]}]}],"thread_ts":"1616262076.113300","reply_count":18,"reply_users_count":2,"latest_reply":"1616566354.211700","reply_users":["U681ELA87","U674T0Y9Z"],"is_locked":false,"subscribed":false},{"client_msg_id":"8239892f-dc37-40e4-9d2a-5358f31ebd45","type":"message","text":"Sorry for being a ghost here. I’ve been slowly churning through the work I outlined here. I’ve gotten pretty far, but need to thread through the changes on the reading side now. Feel free to take a look and let me know if you see any concerns. <https://github.com/JuliaData/Arrow.jl/compare/jq/newarrowtypes?expand=1>","user":"U681ELA87","ts":"1616452160.192300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bup","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry for being a ghost here. I’ve been slowly churning through the work I outlined here. I’ve gotten pretty far, but need to thread through the changes on the reading side now. Feel free to take a look and let me know if you see any concerns. "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/compare/jq/newarrowtypes?expand=1"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"117f1059-c0d0-42fb-ab89-db77c85402d8","type":"message","text":"I’m also probably over-worrying about how breaking this is and if there’s anything we can do to lessen the blow, but I can’t help it :stuck_out_tongue:","user":"U681ELA87","ts":"1616452395.192500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Isr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m also probably over-worrying about how breaking this is and if there’s anything we can do to lessen the blow, but I can’t help it "},{"type":"emoji","name":"stuck_out_tongue"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"1160cc9b-6b1e-44b5-8863-2da068f09d8b","type":"message","text":"Ok, cleaned things up some more. I added a bunch of docs for the new interface functions in the arrowtypes.jl file. I think the serialization story is pretty rock solid now. I think we should even be able to be mostly non-breaking, at least for the `registertype!` use-case, which is what I think almost everyone has been using.\n\nStill need to update the actual code on the deserialization side, but I don’t anticipate running into anything major.","user":"U681ELA87","ts":"1616479073.192700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Pi3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, cleaned things up some more. I added a bunch of docs for the new interface functions in the arrowtypes.jl file. I think the serialization story is pretty rock solid now. I think we should even be able to be mostly non-breaking, at least for the "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":" use-case, which is what I think almost everyone has been using.\n\nStill need to update the actual code on the deserialization side, but I don’t anticipate running into anything major."}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z","reactions":[{"name":"bananadance","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"1ac3c493-5e21-4f12-8dcb-678c6a697bb0","type":"message","text":"oh this is awesome, only skimming now but :heart_eyes:","user":"U674T0Y9Z","ts":"1616505710.195400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aisEU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh this is awesome, only skimming now but "},{"type":"emoji","name":"heart_eyes"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"75695068-0f3f-498b-b054-23c22d6b73e8","type":"message","text":"I can try stress-testing this interface on <https://github.com/beacon-biosignals/Onda.jl/pull/68>","user":"U674T0Y9Z","ts":"1616505741.195600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Oo7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I can try stress-testing this interface on "},{"type":"link","url":"https://github.com/beacon-biosignals/Onda.jl/pull/68"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"d865df99-9025-4c02-b728-6ef8779fe64c","type":"message","text":"Well shoot, I’ve got all the tests passing except one. ZonedDateTime. The problem is because ZonedDateTime isn’t parameterized by the actual timezone, we can’t define a static `ArrowTypes.ArrowType` definition; the arrow definition _is_ parameterized by the timezone (i.e. a column must all use/have the same timezone). Currently, `ArrowTypes.ArrowType` relies on being able to statically define a one-to-one mapping of Julia type to fully defined arrow type.","user":"U681ELA87","ts":"1616534735.202500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R8sTq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well shoot, I’ve got all the tests passing except one. ZonedDateTime. The problem is because ZonedDateTime isn’t parameterized by the actual timezone, we can’t define a static "},{"type":"text","text":"ArrowTypes.ArrowType","style":{"code":true}},{"type":"text","text":" definition; the arrow definition "},{"type":"text","text":"is","style":{"italic":true}},{"type":"text","text":" parameterized by the timezone (i.e. a column must all use/have the same timezone). Currently, "},{"type":"text","text":"ArrowTypes.ArrowType","style":{"code":true}},{"type":"text","text":" relies on being able to statically define a one-to-one mapping of Julia type to fully defined arrow type."}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"d346ea3a-2ea8-425b-a80b-8988710731f0","type":"message","text":"This begs the more general problem of what to do in the case of abstract type eltypes for columns we’re trying to convert to arrow format. It’s pretty strict that column types need to be concrete/fully known. Otherwise, you need to encode the variable data into the struct itself as an additional field.","user":"U681ELA87","ts":"1616534825.202700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ojVz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This begs the more general problem of what to do in the case of abstract type eltypes for columns we’re trying to convert to arrow format. It’s pretty strict that column types need to be concrete/fully known. Otherwise, you need to encode the variable data into the struct itself as an additional field."}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"71c32263-2c57-4225-b1a2-a1a9959bd801","type":"message","text":"I think it's fine to say that we expect the output of `ArrowType(T)` to be concrete (regardless of what the input is), and take on all the implications of that (that if there's not a corresponding concrete output for a given `T`, you're going to get an error if you try to auto-(de)serialize it with Arrow.jl)","user":"U674T0Y9Z","ts":"1616539973.202900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rgs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think it's fine to say that we expect the output of "},{"type":"text","text":"ArrowType(T)","style":{"code":true}},{"type":"text","text":" to be concrete (regardless of what the input is), and take on all the implications of that (that if there's not a corresponding concrete output for a given "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":", you're going to get an error if you try to auto-(de)serialize it with Arrow.jl)"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"65cfba59-f211-4fd1-8eda-d8c4f79bce52","type":"message","text":"e.g. it's up to the caller to refine their column eltypes into something that maps concretely to an arrow type if their expectation is to have Arrow.jl auto-(de)serialize it","user":"U674T0Y9Z","ts":"1616540043.203100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"01T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"e.g. it's up to the caller to refine their column eltypes into something that maps concretely to an arrow type if their expectation is to have Arrow.jl auto-(de)serialize it"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"f657ac68-03f0-434d-a537-a8ef3aeba55b","type":"message","text":"For the ZonedDateTime issue; isn't the new strategy at least sufficient to express whatever the existing ZonedDateTime behavior on `main` ?\n\nah I see <https://github.com/JuliaData/Arrow.jl/blob/2cacbe5384d3494bb49d929a8b386514f0111c74/src/arraytypes/arraytypes.jl#L77> now, it was pulling from the first value and just guessing","user":"U674T0Y9Z","ts":"1616540196.203300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+Z=5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For the ZonedDateTime issue; isn't the new strategy at least sufficient to express whatever the existing ZonedDateTime behavior on "},{"type":"text","text":"main","style":{"code":true}},{"type":"text","text":" ?\n\nah I see "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/blob/2cacbe5384d3494bb49d929a8b386514f0111c74/src/arraytypes/arraytypes.jl#L77"},{"type":"text","text":" now, it was pulling from the first value and just guessing"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"00bdb238-6c1f-42f0-b541-0ce40ca12fa4","type":"message","text":"Here are some options for this scenario, sticking with the new ArrowType approach:\n\n1. serialize it as a struct instead of an Arrow timestamp, since ZonedDateTimes arguably don't structurally map to Arrow's zoned timestamp (i.e. a ZonedDateTime's zone is a dynamic field value, while an Arrow timestamp has the zone as a statically known type parameter of the column)\n2. upstream a change to ZonedDateTimes to surface the zone as a type parameter\n3. provide a `Arrow.ToTimestamp{zone}` wrapper struct (could pick better name) that callers can wrap values in to generically expose the value's `zone` based on the type, and provide a default constructor that accepts ZonedDateTimes (aka a compositional approach). Benefit here is that it could be overloaded for new types\n4. pick a common timezone to convert things to upon serialization (i'd prefer `3` to this approach, since dropping timezone information seems hostile when the user is going out of their way to encode it)\n","user":"U674T0Y9Z","ts":"1616540972.203500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GSXCH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here are some options for this scenario, sticking with the new ArrowType approach:\n\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"serialize it as a struct instead of an Arrow timestamp, since ZonedDateTimes arguably don't structurally map to Arrow's zoned timestamp (i.e. a ZonedDateTime's zone is a dynamic field value, while an Arrow timestamp has the zone as a statically known type parameter of the column)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"upstream a change to ZonedDateTimes to surface the zone as a type parameter"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"provide a "},{"type":"text","text":"Arrow.ToTimestamp{zone}","style":{"code":true}},{"type":"text","text":" wrapper struct (could pick better name) that callers can wrap values in to generically expose the value's "},{"type":"text","text":"zone","style":{"code":true}},{"type":"text","text":" based on the type, and provide a default constructor that accepts ZonedDateTimes (aka a compositional approach). Benefit here is that it could be overloaded for new types"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"pick a common timezone to convert things to upon serialization (i'd prefer "},{"type":"text","text":"3","style":{"code":true}},{"type":"text","text":" to this approach, since dropping timezone information seems hostile when the user is going out of their way to encode it)"}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"116e5a6a-bd2d-4f88-9f09-144dc8098a52","type":"message","text":"otherwise, another option here seems to be loosen the constraint that output of `ArrowType(T)` has to be concrete, but then implement a more dynamic slowpath in the serialization code for when `!isconcretetype(ArrowType(T))` , e.g. a path where type-widening logic is employed that uses the first result of `toarrow` to guess the concrete type, and expands as it loops through more elements\n\ni'm not convinced that's worth it though","user":"U674T0Y9Z","ts":"1616541210.203700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bqwl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"otherwise, another option here seems to be loosen the constraint that output of "},{"type":"text","text":"ArrowType(T)","style":{"code":true}},{"type":"text","text":" has to be concrete, but then implement a more dynamic slowpath in the serialization code for when "},{"type":"text","text":"!isconcretetype(ArrowType(T))","style":{"code":true}},{"type":"text","text":" , e.g. a path where type-widening logic is employed that uses the first result of "},{"type":"text","text":"toarrow","style":{"code":true}},{"type":"text","text":" to guess the concrete type, and expands as it loops through more elements\n\ni'm not convinced that's worth it though"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"3b2288af-3abd-4ca2-afae-8ea5be306841","type":"message","text":"So that’s actually the approach I’m looking at right now","user":"U681ELA87","ts":"1616541855.203900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WWXn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So that’s actually the approach I’m looking at right now"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"92b84c84-0ae0-4c4d-8d1e-8793c7f5be9b","type":"message","text":"Here’s what I”m thinking: <https://github.com/JuliaData/Arrow.jl/compare/jq/newarrowtypes?expand=1#diff-6845bed3d3292eb415f4c0cfa6c35313b4172b6f2b85195028d9d45e6792a6e4R266-R295|https://github.com/JuliaData/Arrow.jl/compare/jq/newarrowtypes?expand=1#diff-6845bed3d3292eb415f4c0cfa6c3531[…]2b6f2b85195028d9d45e6792a6e4R266-R295>","user":"U681ELA87","ts":"1616541924.204100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+y=l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here’s what I”m thinking: "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/compare/jq/newarrowtypes?expand=1#diff-6845bed3d3292eb415f4c0cfa6c35313b4172b6f2b85195028d9d45e6792a6e4R266-R295","text":"https://github.com/JuliaData/Arrow.jl/compare/jq/newarrowtypes?expand=1#diff-6845bed3d3292eb415f4c0cfa6c3531[…]2b6f2b85195028d9d45e6792a6e4R266-R295"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"f0d85675-885e-47b6-9f3a-2bc6105f18d3","type":"message","text":"The idea is that if a type defines `ArrowTypes.toarrow` and the result of applying that over the entire vector is concrete, then everything’s fine and we’ll just accumulate that concrete type to tag our `ToArrow{T}` with.","user":"U681ELA87","ts":"1616541976.204300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+fcQD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The idea is that if a type defines "},{"type":"text","text":"ArrowTypes.toarrow","style":{"code":true}},{"type":"text","text":" and the result of applying that over the entire vector is concrete, then everything’s fine and we’ll just accumulate that concrete type to tag our "},{"type":"text","text":"ToArrow{T}","style":{"code":true}},{"type":"text","text":" with."}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"67b1a915-db91-426f-987f-90400a0c52b8","type":"message","text":"Probably a little slow and we can maybe make it a tad faster, but it actually helps more than just ZonedDateTime; but any abstract input we get","user":"U681ELA87","ts":"1616542003.204500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KS9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Probably a little slow and we can maybe make it a tad faster, but it actually helps more than just ZonedDateTime; but any abstract input we get"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"2b77a26d-7d89-4e7d-843f-5bebe1ae6504","type":"message","text":"But for ZonedDateTime specifically, I think I like your idea of point 3); i.e. providing a `ToTimestamp` guy where the timezone can be encoded","user":"U681ELA87","ts":"1616542042.204700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"atQ6w","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But for ZonedDateTime specifically, I think I like your idea of point 3); i.e. providing a "},{"type":"text","text":"ToTimestamp","style":{"code":true}},{"type":"text","text":" guy where the timezone can be encoded"}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"aad2726d-131c-483e-8ffe-a1fe237013df","type":"message","text":"Ok, PR is up: <https://github.com/JuliaData/Arrow.jl/pull/156>. For now, it just includes the `ToArrow` functionality where it “accumulates” the most concrete type for an abstract typed array. I want to clean that up a bit and add some unit tests around the behavior to make sure there aren’t any funny cases. Otherwise, I’m going to noodle a little more on the `ToTimestamp` idea.","user":"U681ELA87","ts":"1616566354.211700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QDc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, PR is up: "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/pull/156"},{"type":"text","text":". For now, it just includes the "},{"type":"text","text":"ToArrow","style":{"code":true}},{"type":"text","text":" functionality where it “accumulates” the most concrete type for an abstract typed array. I want to clean that up a bit and add some unit tests around the behavior to make sure there aren’t any funny cases. Otherwise, I’m going to noodle a little more on the "},{"type":"text","text":"ToTimestamp","style":{"code":true}},{"type":"text","text":" idea."}]}]}],"thread_ts":"1616262076.113300","parent_user_id":"U674T0Y9Z"}]