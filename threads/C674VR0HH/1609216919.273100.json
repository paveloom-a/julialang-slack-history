[{"client_msg_id":"a2193933-96c3-48a2-b32f-0a3b8af7a2ab","type":"message","text":"a question that has confused me for a while: What is SentinelArrays when we read in a data via CSV or Arrow, and should we convert it to regular Vector?","user":"USTUBS9ED","ts":"1609216919.273100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"H0vDa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"a question that has confused me for a while: What is SentinelArrays when we read in a data via CSV or Arrow, and should we convert it to regular Vector?"}]}]}],"thread_ts":"1609216919.273100","reply_count":1,"reply_users_count":1,"latest_reply":"1609220146.273300","reply_users":["U681ELA87"],"subscribed":false},{"client_msg_id":"7fd05d9a-d821-452a-98cc-ec378e7769b3","type":"message","text":"No need to convert to a regular vector. For CSV.jl, when Julia is run w/ multiple threads, it will parse large files in chunks on different threads; the different chunks are then combined lazily in a `SentinelArrays.ChainedVector`, which treats several vectors as a single, long vector. Similar to the `ChunkedArray` in the arrow c++ project. Arrow.jl uses `ChainedVector` similarly when an arrow file has multiple data \"batches\"; each batch is parsed in a separate thread and all the batches are combined as a single `ChainedVector` column. This also follows the pattern that `pyarrow` and other arrow projects use.\n\nHave plans eventually to implement automatic multithreading support on `ChainedVector` so things like `map(f, ::ChainedVector)` and `filter` automatically use multiple threads.","user":"U681ELA87","ts":"1609220146.273300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"utB8q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No need to convert to a regular vector. For CSV.jl, when Julia is run w/ multiple threads, it will parse large files in chunks on different threads; the different chunks are then combined lazily in a "},{"type":"text","text":"SentinelArrays.ChainedVector","style":{"code":true}},{"type":"text","text":", which treats several vectors as a single, long vector. Similar to the "},{"type":"text","text":"ChunkedArray","style":{"code":true}},{"type":"text","text":" in the arrow c++ project. Arrow.jl uses "},{"type":"text","text":"ChainedVector","style":{"code":true}},{"type":"text","text":" similarly when an arrow file has multiple data \"batches\"; each batch is parsed in a separate thread and all the batches are combined as a single "},{"type":"text","text":"ChainedVector","style":{"code":true}},{"type":"text","text":" column. This also follows the pattern that "},{"type":"text","text":"pyarrow","style":{"code":true}},{"type":"text","text":" and other arrow projects use.\n\nHave plans eventually to implement automatic multithreading support on "},{"type":"text","text":"ChainedVector","style":{"code":true}},{"type":"text","text":" so things like "},{"type":"text","text":"map(f, ::ChainedVector)","style":{"code":true}},{"type":"text","text":" and `filter` automatically use multiple threads."}]}]}],"thread_ts":"1609216919.273100","parent_user_id":"USTUBS9ED"}]