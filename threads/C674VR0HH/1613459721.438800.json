[{"client_msg_id":"4e22010d-729e-4169-aaa7-ea02cb6d6794","type":"message","text":"I'm thinking of experimenting with something we could potentially do to make untyped tables/dataframes fast for operations like `map(f, eachrow(df))` - we can use reflection to look inside `f`, determine which fields are required, and make a temporary, narrow, named tuple iterator and `map` over that instead. For simple anonymous functions like `f = row -&gt; row.x + row.y` it should be pretty easy to determine from the IR we only need columns `:x`  and `:y`. Whenever it gets too hard to determine we could bail and just use whatever currently happens.\n\nIt turns out you can do all kinds of magic in generated functions and add custom backedges to make sure it stays in sync, like this:\n\n<https://github.com/oxinabox/Tricks.jl/blob/master/src/Tricks.jl>","user":"U66QZ3QF3","ts":"1613459721.438800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5BY/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm thinking of experimenting with something we could potentially do to make untyped tables/dataframes fast for operations like "},{"type":"text","text":"map(f, eachrow(df))","style":{"code":true}},{"type":"text","text":" - we can use reflection to look inside "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":", determine which fields are required, and make a temporary, narrow, named tuple iterator and "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" over that instead. For simple anonymous functions like "},{"type":"text","text":"f = row -> row.x + row.y","style":{"code":true}},{"type":"text","text":" it should be pretty easy to determine from the IR we only need columns "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":":y","style":{"code":true}},{"type":"text","text":". Whenever it gets too hard to determine we could bail and just use whatever currently happens.\n\nIt turns out you can do all kinds of magic in generated functions and add custom backedges to make sure it stays in sync, like this:\n\n"},{"type":"link","url":"https://github.com/oxinabox/Tricks.jl/blob/master/src/Tricks.jl"}]}]}],"thread_ts":"1613459721.438800","reply_count":12,"reply_users_count":5,"latest_reply":"1613516790.488900","reply_users":["U6A936746","U66QZ3QF3","U01GXNFKY6R","UBF9YRB6H","U67431ELR"],"subscribed":false},{"client_msg_id":"24cd88c4-2388-4b1f-bb0d-1b9b077de571","type":"message","text":"I should not have unleashed this upon the world.","user":"U6A936746","ts":"1613466721.439200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SulU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I should not have unleashed this upon the world."}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"8c7acadd-d90c-4a8c-9787-1c2182026e8b","type":"message","text":"Lol. Yes - you are to blame :slightly_smiling_face:","user":"U66QZ3QF3","ts":"1613466933.439400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MxKpv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Lol. Yes - you are to blame "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"f9bb7af5-3266-40c3-9691-401f22eec5df","type":"message","text":"Tricks seems nice. I should resurrect Traitor while we are at it!","user":"U66QZ3QF3","ts":"1613467029.439600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YX=K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tricks seems nice. I should resurrect Traitor while we are at it!"}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3","reactions":[{"name":"heart","users":["UDGT4PM41","U6A936746"],"count":2},{"name":"dagger_knife","users":["U6A936746"],"count":1}]},{"client_msg_id":"c19990ad-141c-4984-af5a-720300a21191","type":"message","text":"Sometimes broadcasting works much better","user":"U01GXNFKY6R","ts":"1613473655.440300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8LoIR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sometimes broadcasting works much better"}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"87514171-040e-47f5-a829-94c4ba6681a2","type":"message","text":"f.(df.x, df.y) for example","user":"U01GXNFKY6R","ts":"1613473689.440500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o7N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"f.(df.x, df.y) for example"}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"fea2e101-ad41-4f82-a8d6-a65dd1c8c72f","type":"message","text":"because it introduces a function barrier.","user":"U6A936746","ts":"1613473887.440700","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1613473894.000000"},"blocks":[{"type":"rich_text","block_id":"87j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"because it introduces a function barrier."}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"type":"message","subtype":"thread_broadcast","text":"DataFramesMeta's `@eachrow` does basically exactly this!","user":"UBF9YRB6H","ts":"1613486592.442600","thread_ts":"1613459721.438800","root":{"client_msg_id":"4e22010d-729e-4169-aaa7-ea02cb6d6794","type":"message","text":"I'm thinking of experimenting with something we could potentially do to make untyped tables/dataframes fast for operations like `map(f, eachrow(df))` - we can use reflection to look inside `f`, determine which fields are required, and make a temporary, narrow, named tuple iterator and `map` over that instead. For simple anonymous functions like `f = row -&gt; row.x + row.y` it should be pretty easy to determine from the IR we only need columns `:x`  and `:y`. Whenever it gets too hard to determine we could bail and just use whatever currently happens.\n\nIt turns out you can do all kinds of magic in generated functions and add custom backedges to make sure it stays in sync, like this:\n\n<https://github.com/oxinabox/Tricks.jl/blob/master/src/Tricks.jl>","user":"U66QZ3QF3","ts":"1613459721.438800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5BY/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm thinking of experimenting with something we could potentially do to make untyped tables/dataframes fast for operations like "},{"type":"text","text":"map(f, eachrow(df))","style":{"code":true}},{"type":"text","text":" - we can use reflection to look inside "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":", determine which fields are required, and make a temporary, narrow, named tuple iterator and "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" over that instead. For simple anonymous functions like "},{"type":"text","text":"f = row -> row.x + row.y","style":{"code":true}},{"type":"text","text":" it should be pretty easy to determine from the IR we only need columns "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":":y","style":{"code":true}},{"type":"text","text":". Whenever it gets too hard to determine we could bail and just use whatever currently happens.\n\nIt turns out you can do all kinds of magic in generated functions and add custom backedges to make sure it stays in sync, like this:\n\n"},{"type":"link","url":"https://github.com/oxinabox/Tricks.jl/blob/master/src/Tricks.jl"}]}]}],"thread_ts":"1613459721.438800","reply_count":12,"reply_users_count":5,"latest_reply":"1613516790.488900","reply_users":["U6A936746","U66QZ3QF3","U01GXNFKY6R","UBF9YRB6H","U67431ELR"],"subscribed":false},"blocks":[{"type":"rich_text","block_id":"ZfIr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFramesMeta's "},{"type":"text","text":"@eachrow","style":{"code":true}},{"type":"text","text":" does basically exactly this!"}]}]}],"client_msg_id":"d5c1f60e-9f01-47f0-b5a3-3e3b572b2882"},{"client_msg_id":"fed266b6-56e6-4e62-9801-17f196150589","type":"message","text":"One of the benefits of the somewhat heavy-handed requirement to use `:x` and `:y` everywhere is that you don't have to do anything as complicated as is in Tricks.jl.","user":"UBF9YRB6H","ts":"1613487580.443000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Wrol","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One of the benefits of the somewhat heavy-handed requirement to use "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":":y","style":{"code":true}},{"type":"text","text":" everywhere is that you don't have to do anything as complicated as is in Tricks.jl."}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"7d9b5b4d-c037-44be-9c51-8589ac76a346","type":"message","text":"s/complicated/complicated-and-evil/g","user":"U6A936746","ts":"1613488468.443400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uEc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"s/complicated/complicated-and-evil/g"}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"463f43f8-f223-4d50-8788-027036ae4e3f","type":"message","text":"Interesting. In a similar (but less involved) spirit, I had suggested using the names of arguments for that, e.g. `f(x, y) = x + y`.","user":"U67431ELR","ts":"1613497008.459800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P8lA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Interesting. In a similar (but less involved) spirit, I had suggested using the names of arguments for that, e.g. "},{"type":"text","text":"f(x, y) = x + y","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"61480a93-079e-4e87-a8c5-aca0a650c11e","type":"message","text":"I take it back. This is *not* feasible with DataFramesMeta but should be.","user":"UBF9YRB6H","ts":"1613508432.487500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i+v5l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I take it back. This is "},{"type":"text","text":"not","style":{"bold":true}},{"type":"text","text":" feasible with DataFramesMeta but should be."}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"},{"client_msg_id":"eb79b6d6-ad25-4aa2-9db7-f639ff0f1867","type":"message","text":"Yes, the macro approach in DataFramesMeta and elsewhere is good and useful, but you can't pass your row to some funciton defined elsewhere and have it magically figure it out.\n\nUsing the names of function arguments `f(x, y)` is also really cool, and would probably require similar reflection techniques. The \"generic\" function like `map` underneath would iterate rows, while perhaps a `maprows(f, df)` would (semantically at least) call `f(; row...)` for each `row` while `f` could intercept that as `f(; x, y) = x + y`? Or perhaps it's also alternative for the macro forms, instead of using `:x + :y` use `(x, y) -&gt; x + y`?\n\nOne I like to use with `DataFrame`s is `filter!` and it would be nice if `filter!(df, row -&gt; row.a &gt; 0)` was fast.","user":"U66QZ3QF3","ts":"1613516790.488900","team":"T68168MUP","edited":{"user":"U66QZ3QF3","ts":"1613516855.000000"},"blocks":[{"type":"rich_text","block_id":"v=ul","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, the macro approach in DataFramesMeta and elsewhere is good and useful, but you can't pass your row to some funciton defined elsewhere and have it magically figure it out.\n\nUsing the names of function arguments "},{"type":"text","text":"f(x, y)","style":{"code":true}},{"type":"text","text":" is also really cool, and would probably require similar reflection techniques. The \"generic\" function like "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" underneath would iterate rows, while perhaps a "},{"type":"text","text":"maprows(f, df)","style":{"code":true}},{"type":"text","text":" would (semantically at least) call "},{"type":"text","text":"f(; row...)","style":{"code":true}},{"type":"text","text":" for each "},{"type":"text","text":"row","style":{"code":true}},{"type":"text","text":" while "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" could intercept that as "},{"type":"text","text":"f(; x, y) = x + y","style":{"code":true}},{"type":"text","text":"? Or perhaps it's also alternative for the macro forms, instead of using "},{"type":"text","text":":x + :y","style":{"code":true}},{"type":"text","text":" use "},{"type":"text","text":"(x, y) -> x + y","style":{"code":true}},{"type":"text","text":"?\n\nOne I like to use with "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":"s is "},{"type":"text","text":"filter!","style":{"code":true}},{"type":"text","text":" and it would be nice if "},{"type":"text","text":"filter!(df, row -> row.a > 0)","style":{"code":true}},{"type":"text","text":" was fast."}]}]}],"thread_ts":"1613459721.438800","parent_user_id":"U66QZ3QF3"}]