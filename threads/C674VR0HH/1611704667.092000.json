[{"client_msg_id":"d1eee205-90a0-43b2-a3b3-d578d583decf","type":"message","text":"In\n```julia&gt; using DBInterface, SQLite, Tables\n\njulia&gt; db = DBInterface.connect(SQLite.DB, \"db.sqlite\");\n\njulia&gt; DBInterface.execute(db, \"CREATE TABLE testtable (col1, col2);\");\n\njulia&gt; DBInterface.execute(db, \"SELECT * FROM testtable;\") |&gt; Tables.columntable\n(q = SQLite.Query[],)\n\njulia&gt; DBInterface.execute(db, \"INSERT INTO testtable VALUES (1, 2);\");\n\njulia&gt; DBInterface.execute(db, \"SELECT * FROM testtable;\") |&gt; Tables.columntable\n(col1 = [1], col2 = [2])```\nwhy do I not get `(col1 = [], col2 = [])` for the first select? The information seems to be there.","user":"U67SCG4HG","ts":"1611704667.092000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4yJp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using DBInterface, SQLite, Tables\n\njulia> db = DBInterface.connect(SQLite.DB, \"db.sqlite\");\n\njulia> DBInterface.execute(db, \"CREATE TABLE testtable (col1, col2);\");\n\njulia> DBInterface.execute(db, \"SELECT * FROM testtable;\") |> Tables.columntable\n(q = SQLite.Query[],)\n\njulia> DBInterface.execute(db, \"INSERT INTO testtable VALUES (1, 2);\");\n\njulia> DBInterface.execute(db, \"SELECT * FROM testtable;\") |> Tables.columntable\n(col1 = [1], col2 = [2])"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"why do I not get "},{"type":"text","text":"(col1 = [], col2 = [])","style":{"code":true}},{"type":"text","text":" for the first select? The information seems to be there."}]}]}],"thread_ts":"1611704667.092000","reply_count":1,"reply_users_count":1,"latest_reply":"1611764231.099200","reply_users":["U681ELA87"],"subscribed":false},{"client_msg_id":"4f2a6d69-a539-4771-ab84-3e0bb8d0942a","type":"message","text":"Yeah, this is a bit unfortunate. The problem is that we used to provide `Tables.schema` defined on `SQLite.Query`, but it had it's own set of problems because sqlite is so squirrely on typing things. It solved a lot of problems by removing the `Tables.schema` definition and letting sinks \"infer\" the schema while iterating results. But then obviously that leads to cases like this. We've <https://github.com/JuliaDatabases/SQLite.jl/issues/224|talked about> allowing users to provide their own schema in order to guarantee speed and stricter typing. We might be able to at least provide a simple schema in the empty case in order to avoid these kinds of results.","user":"U681ELA87","ts":"1611764231.099200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HnK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, this is a bit unfortunate. The problem is that we used to provide "},{"type":"text","text":"Tables.schema","style":{"code":true}},{"type":"text","text":" defined on "},{"type":"text","text":"SQLite.Query","style":{"code":true}},{"type":"text","text":", but it had it's own set of problems because sqlite is so squirrely on typing things. It solved a lot of problems by removing the "},{"type":"text","text":"Tables.schema","style":{"code":true}},{"type":"text","text":" definition and letting sinks \"infer\" the schema while iterating results. But then obviously that leads to cases like this. We've "},{"type":"link","url":"https://github.com/JuliaDatabases/SQLite.jl/issues/224","text":"talked about"},{"type":"text","text":" allowing users to provide their own schema in order to guarantee speed and stricter typing. We might be able to at least provide a simple schema in the empty case in order to avoid these kinds of results."}]}]}],"thread_ts":"1611704667.092000","parent_user_id":"U67SCG4HG"}]