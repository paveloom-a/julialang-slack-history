[{"client_msg_id":"880416d4-d850-4479-a355-dcb361c3c4a8","type":"message","text":"I'm reading a CSV that has some columns with values like `[0.13936621 0.16367522 0.10260016]`. The function `CSV.File()`  assigns the String type to those columns by default and I end up with values like `\"[0.13936621 0.16367522 0.10260016]\"` . Is there a way to parse those values as Julia Arrays with CSV.File? I tried passing to the keyword argument `types`  a vector of types where some of them were `Array{Float64,2}`  but it didn't work.","user":"U013E7K55QT","ts":"1610404385.414200","team":"T68168MUP","edited":{"user":"U013E7K55QT","ts":"1610404470.000000"},"blocks":[{"type":"rich_text","block_id":"W4PG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm reading a CSV that has some columns with values like "},{"type":"text","text":"[0.13936621 0.16367522 0.10260016]","style":{"code":true}},{"type":"text","text":". The function "},{"type":"text","text":"CSV.File()","style":{"code":true}},{"type":"text","text":"  assigns the String type to those columns by default and I end up with values like "},{"type":"text","text":"\"[0.13936621 0.16367522 0.10260016]\"","style":{"code":true}},{"type":"text","text":" . Is there a way to parse those values as Julia Arrays with CSV.File? I tried passing to the keyword argument "},{"type":"text","text":"types","style":{"code":true}},{"type":"text","text":"  a vector of types where some of them were "},{"type":"text","text":"Array{Float64,2}","style":{"code":true}},{"type":"text","text":"  but it didn't work."}]}]}],"thread_ts":"1610404385.414200","reply_count":2,"reply_users_count":2,"latest_reply":"1610405376.414800","reply_users":["U681ELA87","U013E7K55QT"],"subscribed":false},{"client_msg_id":"6451d75e-eed1-4ec9-b58e-6f8df086dc3d","type":"message","text":"There’s not currently a builtin way to do this, but here’s a solution I suggested not too long ago: <https://github.com/JuliaData/CSV.jl/issues/740#issuecomment-695128156>","user":"U681ELA87","ts":"1610405174.414600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=e9c0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There’s not currently a builtin way to do this, but here’s a solution I suggested not too long ago: "},{"type":"link","url":"https://github.com/JuliaData/CSV.jl/issues/740#issuecomment-695128156"}]}]}],"thread_ts":"1610404385.414200","parent_user_id":"U013E7K55QT"},{"client_msg_id":"5d28aaa0-c769-4d1e-9e88-dfd15056cd2b","type":"message","text":"Thanks. I came up with a hack too. Passed the output of CSV.File to a DataFrame and used `eval.(Meta.parse.(df.column))`","user":"U013E7K55QT","ts":"1610405376.414800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k53Be","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks. I came up with a hack too. Passed the output of CSV.File to a DataFrame and used "},{"type":"text","text":"eval.(Meta.parse.(df.column))","style":{"code":true}}]}]}],"thread_ts":"1610404385.414200","parent_user_id":"U013E7K55QT"}]