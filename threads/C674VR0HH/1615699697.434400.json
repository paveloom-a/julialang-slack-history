[{"client_msg_id":"aa72022e-cc0c-400b-a690-e9a6d5ca564a","type":"message","text":"<https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/>","user":"UDGT4PM41","ts":"1615699697.434400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FGe","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/"}]}]}],"thread_ts":"1615699697.434400","reply_count":11,"reply_users_count":3,"latest_reply":"1615711841.437500","reply_users":["UBF9YRB6H","U8JAMQGQY","UC7AF7NSU"],"subscribed":false},{"client_msg_id":"825ab950-f164-411d-a259-18d23d53ceed","type":"message","text":"Just a note, a lot of the slowdown in Julia's DataFrames will be fixed with a few things that are in the pipeline:\n\nFaster `groupby`:\n     <https://github.com/JuliaData/DataFrames.jl/pull/2610>\n     <https://github.com/JuliaData/DataFrames.jl/pull/2592> (maybe not as relevant)\n\nMultithreading\n    <https://github.com/JuliaData/DataFrames.jl/pull/2588>\n    <https://github.com/JuliaData/DataFrames.jl/pull/2491>\n    <https://github.com/JuliaData/DataFrames.jl/pull/2647>\n\nThe multi-threading ones will be the most relevant with those 50GB tests, when the cost of new threads is negligible compared to the rest of the operation.","user":"UBF9YRB6H","ts":"1615700380.434500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ieSsG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just a note, a lot of the slowdown in Julia's DataFrames will be fixed with a few things that are in the pipeline:\n\nFaster "},{"type":"text","text":"groupby","style":{"code":true}},{"type":"text","text":":\n     "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/pull/2610"},{"type":"text","text":"\n     "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/pull/2592"},{"type":"text","text":" (maybe not as relevant)\n\nMultithreading\n    "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/pull/2588"},{"type":"text","text":"\n    "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/pull/2491"},{"type":"text","text":"\n    "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/pull/2647"},{"type":"text","text":"\n\nThe multi-threading ones will be the most relevant with those 50GB tests, when the cost of new threads is negligible compared to the rest of the operation."}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"52f79360-34af-4ac5-a0c3-5ad38c9d91b3","type":"message","text":"The only major piece we are missing is multithreaded `AbstractDict`. We could use the approach of Polars, where items are distributed over multiple dicts based on remainder of hash. This would also allow for a deeper pool sharing in PooledArrays.jl. <@UC7AF7NSU> do you have experience/comments on such data structure?","user":"U8JAMQGQY","ts":"1615708452.434900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kgg9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The only major piece we are missing is multithreaded "},{"type":"text","text":"AbstractDict","style":{"code":true}},{"type":"text","text":". We could use the approach of Polars, where items are distributed over multiple dicts based on remainder of hash. This would also allow for a deeper pool sharing in PooledArrays.jl. "},{"type":"user","user_id":"UC7AF7NSU"},{"type":"text","text":" do you have experience/comments on such data structure?"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"04428418-935b-49fd-b7d6-e890e69e21cd","type":"message","text":"Making a data structure data race-free (\"thread safe\"/multi-threaded in some sense) is almost always a bad decision for performance of *parallel* programs (it is, of course, required for the correctness of some *concurrent* programs like web servers). If you want to squeeze out the performance this way, I think you might need to go all the way down to lock-free programming.","user":"UC7AF7NSU","ts":"1615710167.435100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NBpP2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Making a data structure data race-free (\"thread safe\"/multi-threaded in some sense) is almost always a bad decision for performance of "},{"type":"text","text":"parallel","style":{"bold":true}},{"type":"text","text":" programs (it is, of course, required for the correctness of some "},{"type":"text","text":"concurrent","style":{"bold":true}},{"type":"text","text":" programs like web servers). If you want to squeeze out the performance this way, I think you might need to go all the way down to lock-free programming."}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"41a9c6e4-960f-44da-ab18-194772b0f103","type":"message","text":"oh, \"5.2 Parallel hashing\" of the blog post discusses this, too. apparently, they have lock-free dict","user":"UC7AF7NSU","ts":"1615710326.435300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0Mm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh, \"5.2 Parallel hashing\" of the blog post discusses this, too. apparently, they have lock-free dict"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"902862a6-8802-4564-a9dc-fcd054e1269b","type":"message","text":"But this is exactly what I am asking about - do you know if lock-free hashing dict is implemented for Julia somewhere and if not is it worth implementing it and how much overhead it would have?","user":"U8JAMQGQY","ts":"1615710641.435500","team":"T68168MUP","edited":{"user":"U8JAMQGQY","ts":"1615710709.000000"},"blocks":[{"type":"rich_text","block_id":"3uep","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But this is exactly what I am asking about - do you know if lock-free hashing dict is implemented for Julia somewhere and if not is it worth implementing it and how much overhead it would have?"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"0c291e0f-f310-4c60-891c-f6cbd6ee53f6","type":"message","text":"I don't know if there's any lock-free data containers in Julia","user":"UC7AF7NSU","ts":"1615710823.435800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3dbk3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't know if there's any lock-free data containers in Julia"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"be3411c5-2785-488f-8b47-60b7263516f0","type":"message","text":"I also don't understand how they resolve collision in a data race-free manner","user":"UC7AF7NSU","ts":"1615710828.436000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DeVA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I also don't understand how they resolve collision in a data race-free manner"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"92a80975-da1a-41c4-9d23-7670a3c95d32","type":"message","text":"Assume you have 4 threads. You create 4 `Dict`s each assigned to two lowest bits of hash value. Then you are sure that any operation of addition, deletion and lookup is done on the same thread. This works assuming that two lowest bits of hash are uniformly distributed but I guess this is an OK assumption.","user":"U8JAMQGQY","ts":"1615711165.436300","team":"T68168MUP","edited":{"user":"U8JAMQGQY","ts":"1615711190.000000"},"blocks":[{"type":"rich_text","block_id":"pK1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Assume you have 4 threads. You create 4 "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":"s each assigned to two lowest bits of hash value. Then you are sure that any operation of addition, deletion and lookup is done on the same thread. This works assuming that two lowest bits of hash are uniformly distributed but I guess this is an OK assumption."}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"cef8a0f0-049f-4c2c-83c2-a7984db8ed8e","type":"message","text":"There two things I don't understand about their approach: (1) even if you salt the hash with thread id, if your bucket is too small, isn't it possible to get collision? (2) even if you can \"partition\" the bucket by including the thread id, then I don't see the difference to the multiple dictionary approach","user":"UC7AF7NSU","ts":"1615711716.437100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M/oaJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There two things I don't understand about their approach: (1) even if you salt the hash with thread id, if your bucket is too small, isn't it possible to get collision? (2) even if you can \"partition\" the bucket by including the thread id, then I don't see the difference to the multiple dictionary approach"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"6dbed17d-55d9-4e62-99e7-6eb4dcbf2b2c","type":"message","text":"but I saw another study about groupby on GPU using using lock-free approach. so I guess there's some way to make it work...?","user":"UC7AF7NSU","ts":"1615711821.437300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8+e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but I saw another study about groupby on GPU using using lock-free approach. so I guess there's some way to make it work...?"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"},{"client_msg_id":"23ab4188-9700-49b6-bb27-b7b5640af15e","type":"message","text":"anyway, I'm sorry, I'm a noob here","user":"UC7AF7NSU","ts":"1615711841.437500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1JO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"anyway, I'm sorry, I'm a noob here"}]}]}],"thread_ts":"1615699697.434400","parent_user_id":"UDGT4PM41"}]