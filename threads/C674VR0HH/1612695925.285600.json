[{"client_msg_id":"8512db2a-438c-4cf0-9a2b-b6bd21db6dcb","type":"message","text":"Just discovered an interesting problem that I don't see an immediate solution for: in Tables.jl, when a row-oriented input doesn't have a defined schema, but columns are requested, we have a fallback routine that \"builds columns\" by iterating rows and widening column vectors as necessary. There is a lot of code overlap with `collect`, but we're building up a whole set of columns instead of just one collection. The problem is <https://github.com/JuliaData/Tables.jl/blob/bdde6d343a9717cf78c7b442d142a9699688dbdc/src/fallbacks.jl#L146|here>: to check if we need to widen a vector, we check if the next element `isa T`, and if not, widen. This leads to an issue in the case I ran into locally where one element was a `Float64`, while a bunch of subsequent elements were `Int64`. The `Int64` were not `isa Float64`, so it attempted to widen, but `promote_type(Int64, Float64) === Float64`, so it's not really widening, we're just reallocating a new `Float64` vector for no reason.\n\nWhat's the best way to handle this? Ideally, our `val isa T` check would instead be something like `val is convertible to T` because `setindex!` will call `convert(T, val)` for us, but I'm not sure something like that exists? Just wondering if anyone has any ideas; cc: <@U67431ELR> <@U8JAMQGQY> <@U6740K1SP>","user":"U681ELA87","ts":"1612695925.285600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FjXck","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just discovered an interesting problem that I don't see an immediate solution for: in Tables.jl, when a row-oriented input doesn't have a defined schema, but columns are requested, we have a fallback routine that \"builds columns\" by iterating rows and widening column vectors as necessary. There is a lot of code overlap with "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":", but we're building up a whole set of columns instead of just one collection. The problem is "},{"type":"link","url":"https://github.com/JuliaData/Tables.jl/blob/bdde6d343a9717cf78c7b442d142a9699688dbdc/src/fallbacks.jl#L146","text":"here"},{"type":"text","text":": to check if we need to widen a vector, we check if the next element "},{"type":"text","text":"isa T","style":{"code":true}},{"type":"text","text":", and if not, widen. This leads to an issue in the case I ran into locally where one element was a "},{"type":"text","text":"Float64","style":{"code":true}},{"type":"text","text":", while a bunch of subsequent elements were "},{"type":"text","text":"Int64","style":{"code":true}},{"type":"text","text":". The "},{"type":"text","text":"Int64","style":{"code":true}},{"type":"text","text":" were not "},{"type":"text","text":"isa Float64","style":{"code":true}},{"type":"text","text":", so it attempted to widen, but "},{"type":"text","text":"promote_type(Int64, Float64) === Float64","style":{"code":true}},{"type":"text","text":", so it's not really widening, we're just reallocating a new "},{"type":"text","text":"Float64","style":{"code":true}},{"type":"text","text":" vector for no reason.\n\nWhat's the best way to handle this? Ideally, our "},{"type":"text","text":"val isa T","style":{"code":true}},{"type":"text","text":" check would instead be something like "},{"type":"text","text":"val is convertible to T","style":{"code":true}},{"type":"text","text":" because "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" will call "},{"type":"text","text":"convert(T, val)","style":{"code":true}},{"type":"text","text":" for us, but I'm not sure something like that exists? Just wondering if anyone has any ideas; cc: "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" "},{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" "},{"type":"user","user_id":"U6740K1SP"}]}]}],"thread_ts":"1612695925.285600","reply_count":13,"reply_users_count":4,"latest_reply":"1612701281.290700","reply_users":["U681ELA87","UM30MT6RF","U67431ELR","U017JTQFNEQ"],"subscribed":false},{"client_msg_id":"93b6b998-3afa-4e17-94e0-00ca1aa4a356","type":"message","text":"As a follow up, I don't quite understand if or how `collect` manages to avoid this, since it seems to follow the same logic: <https://github.com/JuliaLang/julia/blob/5dfd826a4137498e9f9dc8a77d72b9bda3721c7a/base/array.jl#L727>","user":"U681ELA87","ts":"1612696040.285700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P1d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As a follow up, I don't quite understand if or how "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":" manages to avoid this, since it seems to follow the same logic: "},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/5dfd826a4137498e9f9dc8a77d72b9bda3721c7a/base/array.jl#L727"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"c5abb023-5088-4dba-bc59-b16bc16fd0b0","type":"message","text":"Why not just change the condition `val isa T` to `val isa T || promote_type(typeof(val), T) &lt;: T`?","user":"UM30MT6RF","ts":"1612696168.285900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4eqO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why not just change the condition "},{"type":"text","text":"val isa T","style":{"code":true}},{"type":"text","text":" to "},{"type":"text","text":"val isa T || promote_type(typeof(val), T) <: T","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"cc933ae3-a31a-49ee-99ae-920b18fa193d","type":"message","text":"Hmmm, yeah, that seems like it would work. I also figured out that `collect` is using `promote_typejoin` instead of `promote_type` which gives a slightly different answer that means it doesn't run into this same problem:\n```julia&gt; Base.promote_typejoin(Int64, Float64)\nReal```\n","user":"U681ELA87","ts":"1612696271.286100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w=/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmmm, yeah, that seems like it would work. I also figured out that "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":" is using "},{"type":"text","text":"promote_typejoin","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" which gives a slightly different answer that means it doesn't run into this same problem:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Base.promote_typejoin(Int64, Float64)\nReal"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"acf654b7-8f7f-442f-9afd-62ebfc87d639","type":"message","text":"Yes I think <@UM30MT6RF> is right. Also using `promote_type` sounds better for Tables as it gives concrete types more often.","user":"U67431ELR","ts":"1612696347.286300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kla","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes I think "},{"type":"user","user_id":"UM30MT6RF"},{"type":"text","text":" is right. Also using "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" sounds better for Tables as it gives concrete types more often."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"86192fec-35b7-48b0-a275-2e0d1e9124b1","type":"message","text":"See this example in DataFrames: <https://github.com/JuliaData/DataFrames.jl/blob/2e3f1b00151fb633edf06ba82806053da0904f24/src/groupeddataframe/fastaggregates.jl#L149>","user":"U67431ELR","ts":"1612696412.286500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e2tN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"See this example in DataFrames: "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/blob/2e3f1b00151fb633edf06ba82806053da0904f24/src/groupeddataframe/fastaggregates.jl#L149"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"d3773e17-21f8-4b36-9eab-b3d6d11051e8","type":"message","text":"Or this one: <https://github.com/JuliaData/DataFrames.jl/blob/2e3f1b00151fb633edf06ba82806053da0904f24/src/groupeddataframe/complextransforms.jl#L86>","user":"U67431ELR","ts":"1612696469.286700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lUHB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or this one: "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/blob/2e3f1b00151fb633edf06ba82806053da0904f24/src/groupeddataframe/complextransforms.jl#L86"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"bf8dce40-d828-41e8-8f78-73c9d7ec7531","type":"message","text":"It does make me wonder if there are still cases where `val` is convertible to `T`, but where `!(promote_type(typeof(val), T) &lt;: T)`? I can't think of any, but it makes me wonder.","user":"U681ELA87","ts":"1612697117.286900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d7yE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It does make me wonder if there are still cases where "},{"type":"text","text":"val","style":{"code":true}},{"type":"text","text":" is convertible to "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":", but where "},{"type":"text","text":"!(promote_type(typeof(val), T) <: T)","style":{"code":true}},{"type":"text","text":"? I can't think of any, but it makes me wonder."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"47accc95-ac01-44aa-acb6-ed7e9765537c","type":"message","text":"Even if that happened, if `promote_type` returns a different type, we should use it. Otherwise the resulting type will depend on the order of values.","user":"U67431ELR","ts":"1612697194.287100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dWd3o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Even if that happened, if "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" returns a different type, we should use it. Otherwise the resulting type will depend on the order of values."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"bb9bdb48-dba6-4e40-ae62-92ba8ecb07ab","type":"message","text":"Yes, that can happen, e.g. `val = Int` and `T = Type{Int}`","user":"UM30MT6RF","ts":"1612697290.287300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WZba","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, that can happen, e.g. "},{"type":"text","text":"val = Int","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"T = Type{Int}","style":{"code":true}}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"40a30eab-a055-493d-b434-1f8a85b4345f","type":"message","text":"Yeah, I see what you mean. This does imply the assumption that if `S = promote_type(typeof(val), T)`, then `convert(S, val)` must work, but I think that's a fairly safe/good assumption.","user":"U681ELA87","ts":"1612697388.287500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FbGY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I see what you mean. This does imply the assumption that if "},{"type":"text","text":"S = promote_type(typeof(val), T)","style":{"code":true}},{"type":"text","text":", then "},{"type":"text","text":"convert(S, val)","style":{"code":true}},{"type":"text","text":" must work, but I think that's a fairly safe/good assumption."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"c305bc68-cdb6-46a3-a450-2ebe3a95f090","type":"message","text":"I guess that's kind of the whole point of the promotion machinery anyway; you wouldn't define a promotion rule if a type wasn't convertible to the other.","user":"U681ELA87","ts":"1612697562.287700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UER","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess that's kind of the whole point of the promotion machinery anyway; you wouldn't define a promotion rule if a type wasn't convertible to the other."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"d68e9882-c12a-4d57-9f65-d821a9660411","type":"message","text":"Yeah. Though it's true that documentation isn't very explicit. Recently for threading support in DataFrames we wondered whether `promote_type` was guaranteed to be associative. That sounds obvious but it's not documented.","user":"U67431ELR","ts":"1612697771.287900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"byn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah. Though it's true that documentation isn't very explicit. Recently for threading support in DataFrames we wondered whether "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" was guaranteed to be associative. That sounds obvious but it's not documented."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"1314ef10-80cc-4465-848e-9a2d615a3e38","type":"message","text":"Hopefully not off topic: but isn’t a column with a union type bad for performance? Should there be some kind of warning when promotion is not possible?","user":"U017JTQFNEQ","ts":"1612701281.290700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KGV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hopefully not off topic: but isn’t a column with a union type bad for performance? Should there be some kind of warning when promotion is not possible?"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"}]