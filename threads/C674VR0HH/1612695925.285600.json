[{"client_msg_id":"8512db2a-438c-4cf0-9a2b-b6bd21db6dcb","type":"message","text":"Just discovered an interesting problem that I don't see an immediate solution for: in Tables.jl, when a row-oriented input doesn't have a defined schema, but columns are requested, we have a fallback routine that \"builds columns\" by iterating rows and widening column vectors as necessary. There is a lot of code overlap with `collect`, but we're building up a whole set of columns instead of just one collection. The problem is <https://github.com/JuliaData/Tables.jl/blob/bdde6d343a9717cf78c7b442d142a9699688dbdc/src/fallbacks.jl#L146|here>: to check if we need to widen a vector, we check if the next element `isa T`, and if not, widen. This leads to an issue in the case I ran into locally where one element was a `Float64`, while a bunch of subsequent elements were `Int64`. The `Int64` were not `isa Float64`, so it attempted to widen, but `promote_type(Int64, Float64) === Float64`, so it's not really widening, we're just reallocating a new `Float64` vector for no reason.\n\nWhat's the best way to handle this? Ideally, our `val isa T` check would instead be something like `val is convertible to T` because `setindex!` will call `convert(T, val)` for us, but I'm not sure something like that exists? Just wondering if anyone has any ideas; cc: <@U67431ELR> <@U8JAMQGQY> <@U6740K1SP>","user":"U681ELA87","ts":"1612695925.285600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FjXck","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Just discovered an interesting problem that I don't see an immediate solution for: in Tables.jl, when a row-oriented input doesn't have a defined schema, but columns are requested, we have a fallback routine that \"builds columns\" by iterating rows and widening column vectors as necessary. There is a lot of code overlap with "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":", but we're building up a whole set of columns instead of just one collection. The problem is "},{"type":"link","url":"https://github.com/JuliaData/Tables.jl/blob/bdde6d343a9717cf78c7b442d142a9699688dbdc/src/fallbacks.jl#L146","text":"here"},{"type":"text","text":": to check if we need to widen a vector, we check if the next element "},{"type":"text","text":"isa T","style":{"code":true}},{"type":"text","text":", and if not, widen. This leads to an issue in the case I ran into locally where one element was a "},{"type":"text","text":"Float64","style":{"code":true}},{"type":"text","text":", while a bunch of subsequent elements were "},{"type":"text","text":"Int64","style":{"code":true}},{"type":"text","text":". The "},{"type":"text","text":"Int64","style":{"code":true}},{"type":"text","text":" were not "},{"type":"text","text":"isa Float64","style":{"code":true}},{"type":"text","text":", so it attempted to widen, but "},{"type":"text","text":"promote_type(Int64, Float64) === Float64","style":{"code":true}},{"type":"text","text":", so it's not really widening, we're just reallocating a new "},{"type":"text","text":"Float64","style":{"code":true}},{"type":"text","text":" vector for no reason.\n\nWhat's the best way to handle this? Ideally, our "},{"type":"text","text":"val isa T","style":{"code":true}},{"type":"text","text":" check would instead be something like "},{"type":"text","text":"val is convertible to T","style":{"code":true}},{"type":"text","text":" because "},{"type":"text","text":"setindex!","style":{"code":true}},{"type":"text","text":" will call "},{"type":"text","text":"convert(T, val)","style":{"code":true}},{"type":"text","text":" for us, but I'm not sure something like that exists? Just wondering if anyone has any ideas; cc: "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" "},{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" "},{"type":"user","user_id":"U6740K1SP"}]}]}],"thread_ts":"1612695925.285600","reply_count":5,"reply_users_count":3,"latest_reply":"1612696412.286500","reply_users":["U681ELA87","UM30MT6RF","U67431ELR"],"subscribed":false},{"client_msg_id":"93b6b998-3afa-4e17-94e0-00ca1aa4a356","type":"message","text":"As a follow up, I don't quite understand if or how `collect` manages to avoid this, since it seems to follow the same logic: <https://github.com/JuliaLang/julia/blob/5dfd826a4137498e9f9dc8a77d72b9bda3721c7a/base/array.jl#L727>","user":"U681ELA87","ts":"1612696040.285700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"P1d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As a follow up, I don't quite understand if or how "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":" manages to avoid this, since it seems to follow the same logic: "},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/5dfd826a4137498e9f9dc8a77d72b9bda3721c7a/base/array.jl#L727"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"c5abb023-5088-4dba-bc59-b16bc16fd0b0","type":"message","text":"Why not just change the condition `val isa T` to `val isa T || promote_type(typeof(val), T) &lt;: T`?","user":"UM30MT6RF","ts":"1612696168.285900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4eqO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why not just change the condition "},{"type":"text","text":"val isa T","style":{"code":true}},{"type":"text","text":" to "},{"type":"text","text":"val isa T || promote_type(typeof(val), T) <: T","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"cc933ae3-a31a-49ee-99ae-920b18fa193d","type":"message","text":"Hmmm, yeah, that seems like it would work. I also figured out that `collect` is using `promote_typejoin` instead of `promote_type` which gives a slightly different answer that means it doesn't run into this same problem:\n```julia&gt; Base.promote_typejoin(Int64, Float64)\nReal```\n","user":"U681ELA87","ts":"1612696271.286100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w=/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmmm, yeah, that seems like it would work. I also figured out that "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":" is using "},{"type":"text","text":"promote_typejoin","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" which gives a slightly different answer that means it doesn't run into this same problem:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> Base.promote_typejoin(Int64, Float64)\nReal"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"acf654b7-8f7f-442f-9afd-62ebfc87d639","type":"message","text":"Yes I think <@UM30MT6RF> is right. Also using `promote_type` sounds better for Tables as it gives concrete types more often.","user":"U67431ELR","ts":"1612696347.286300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kla","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes I think "},{"type":"user","user_id":"UM30MT6RF"},{"type":"text","text":" is right. Also using "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" sounds better for Tables as it gives concrete types more often."}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"},{"client_msg_id":"86192fec-35b7-48b0-a275-2e0d1e9124b1","type":"message","text":"See this example in DataFrames: <https://github.com/JuliaData/DataFrames.jl/blob/2e3f1b00151fb633edf06ba82806053da0904f24/src/groupeddataframe/fastaggregates.jl#L149>","user":"U67431ELR","ts":"1612696412.286500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e2tN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"See this example in DataFrames: "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/blob/2e3f1b00151fb633edf06ba82806053da0904f24/src/groupeddataframe/fastaggregates.jl#L149"}]}]}],"thread_ts":"1612695925.285600","parent_user_id":"U681ELA87"}]