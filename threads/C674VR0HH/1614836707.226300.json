[{"client_msg_id":"fd814d31-85de-4331-98dc-fbc02ff25578","type":"message","text":"So I am encountering a very strange bug while trying to implement the Multi Armed Bandit problem. My code randomly will say `ERROR: KeyError: key NamedTuple[(Arm = \"C\",)] not found`  but it breaks randomly on an iteration of the loop, and I can't figure out why that would happen considering that its clearly able to find the key in previous iterations but it can't find it all the time? This is very strange and I don't know whats going on or how to debug an error that happens randomly in an iteration but not others. Its all simulated data and basically my function Learn!(band,20) is randomly breaking. I wonder if its related to the hash <@U9VG1AYSG> mentioned before?\n\n```using Statistics, StatsBase, Distributions \nusing DataFrames\n\nmutable struct Bandit\n    QN::Dict{NamedTuple,Dict{Symbol,Real}}\n    Y::Dict{NamedTuple,Array{Float64,1}}\n    keylist::Vector{NamedTuple}\nend \n\nfunction CreateBandit(data,groups,response)\n    gdf = groupby(data,groups)\n    QN = Dict{NamedTuple,Dict{Symbol,Real}}()\n    Y = Dict{NamedTuple,Array{Float64,1}}()\n    for key in keys(gdf)\n        QN[NamedTuple(key)] = Dict(:Q=&gt;rand(Uniform(0,1e-10)),:n=&gt;0)\n        Y[NamedTuple(key)] = gdf[key][:,response]\n    end \n    return(Bandit(QN,Y,collect(keys(QN))))\nend \n\nBase.getindex(bandit::Bandit,key) = Base.getindex(bandit.QN,key)\n\nfunction Base.argmax(bandit::Bandit)\n    keylist = bandit.keylist\n    idx = argmax(getindex.(values(bandit.QN),:Q))\n    return(keylist[idx])\nend \n\nfunction Learn!(bandit::Bandit,steps;ϵ=0.05,η=nothing)\n    lrn = ifelse(isnothing(η),0,1)\n    for i=1:steps\n        u = rand(Uniform(0,1))\n        if u &lt;= ϵ\n            action = sample(bandit.keylist,1)\n        else\n            action = argmax(bandit)\n        end \n        Qcurrent = bandit[action][:Q]\n        Reward = sample(bandit.Y[action],1)[1]\n        diff = Reward - Qcurrent\n        curr = bandit[action]\n        curr[:n] += 1\n        if lrn == 0 \n            curr[:Q] += 1/curr[:n] .* diff\n        else\n            curr[:Q] += η .* diff\n        end\n    end\n    return(bandit)\nend \n\n#Simulate Data \nn = 100\nA= rand(Normal(0,1),n)\nB= rand(Normal(1,1),n)\nC = rand(Normal(-1,1),n)\nD = rand(Normal(0.5,1),n)\n\nsimdata = DataFrame(Arm = vcat(fill(\"A\",n),fill(\"B\",n),fill(\"C\",n),fill(\"D\",n)),\n                    Y = vcat(A,B,C,D))\n\n#Use Bandit \n\nband=CreateBandit(simdata,:Arm,:Y)            \nLearn!(band,20) #This breaks randomly on an iteration ```","user":"U01EF0QVAB0","ts":"1614836707.226300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J23yu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I am encountering a very strange bug while trying to implement the Multi Armed Bandit problem. My code randomly will say "},{"type":"text","text":"ERROR: KeyError: key NamedTuple[(Arm = \"C\",)] not found","style":{"code":true}},{"type":"text","text":"  but it breaks randomly on an iteration of the loop, and I can't figure out why that would happen considering that its clearly able to find the key in previous iterations but it can't find it all the time? This is very strange and I don't know whats going on or how to debug an error that happens randomly in an iteration but not others. Its all simulated data and basically my function Learn!(band,20) is randomly breaking. I wonder if its related to the hash "},{"type":"user","user_id":"U9VG1AYSG"},{"type":"text","text":" mentioned before?\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Statistics, StatsBase, Distributions \nusing DataFrames\n\nmutable struct Bandit\n    QN::Dict{NamedTuple,Dict{Symbol,Real}}\n    Y::Dict{NamedTuple,Array{Float64,1}}\n    keylist::Vector{NamedTuple}\nend \n\nfunction CreateBandit(data,groups,response)\n    gdf = groupby(data,groups)\n    QN = Dict{NamedTuple,Dict{Symbol,Real}}()\n    Y = Dict{NamedTuple,Array{Float64,1}}()\n    for key in keys(gdf)\n        QN[NamedTuple(key)] = Dict(:Q=>rand(Uniform(0,1e-10)),:n=>0)\n        Y[NamedTuple(key)] = gdf[key][:,response]\n    end \n    return(Bandit(QN,Y,collect(keys(QN))))\nend \n\nBase.getindex(bandit::Bandit,key) = Base.getindex(bandit.QN,key)\n\nfunction Base.argmax(bandit::Bandit)\n    keylist = bandit.keylist\n    idx = argmax(getindex.(values(bandit.QN),:Q))\n    return(keylist[idx])\nend \n\nfunction Learn!(bandit::Bandit,steps;ϵ=0.05,η=nothing)\n    lrn = ifelse(isnothing(η),0,1)\n    for i=1:steps\n        u = rand(Uniform(0,1))\n        if u <= ϵ\n            action = sample(bandit.keylist,1)\n        else\n            action = argmax(bandit)\n        end \n        Qcurrent = bandit[action][:Q]\n        Reward = sample(bandit.Y[action],1)[1]\n        diff = Reward - Qcurrent\n        curr = bandit[action]\n        curr[:n] += 1\n        if lrn == 0 \n            curr[:Q] += 1/curr[:n] .* diff\n        else\n            curr[:Q] += η .* diff\n        end\n    end\n    return(bandit)\nend \n\n#Simulate Data \nn = 100\nA= rand(Normal(0,1),n)\nB= rand(Normal(1,1),n)\nC = rand(Normal(-1,1),n)\nD = rand(Normal(0.5,1),n)\n\nsimdata = DataFrame(Arm = vcat(fill(\"A\",n),fill(\"B\",n),fill(\"C\",n),fill(\"D\",n)),\n                    Y = vcat(A,B,C,D))\n\n#Use Bandit \n\nband=CreateBandit(simdata,:Arm,:Y)            \nLearn!(band,20) #This breaks randomly on an iteration "}]}]}],"thread_ts":"1614836707.226300","reply_count":1,"reply_users_count":1,"latest_reply":"1614844137.226400","reply_users":["U8JAMQGQY"],"subscribed":false},{"client_msg_id":"df0a349b-f72f-43cb-ab05-ac989076ab17","type":"message","text":"change one line to:\n```action = sample(bandit.keylist)```\nAs a general remark - the code you use is not type stable so it will not be super efficient, as you use collections with abstract parameters, see <https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container>.","user":"U8JAMQGQY","ts":"1614844137.226400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GsVA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"change one line to:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"action = sample(bandit.keylist)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"As a general remark - the code you use is not type stable so it will not be super efficient, as you use collections with abstract parameters, see "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container"},{"type":"text","text":"."}]}]}],"thread_ts":"1614836707.226300","parent_user_id":"U01EF0QVAB0"}]