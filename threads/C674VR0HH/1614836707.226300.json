[{"client_msg_id":"fd814d31-85de-4331-98dc-fbc02ff25578","type":"message","text":"So I am encountering a very strange bug while trying to implement the Multi Armed Bandit problem. My code randomly will say `ERROR: KeyError: key NamedTuple[(Arm = \"C\",)] not found`  but it breaks randomly on an iteration of the loop, and I can't figure out why that would happen considering that its clearly able to find the key in previous iterations but it can't find it all the time? This is very strange and I don't know whats going on or how to debug an error that happens randomly in an iteration but not others. Its all simulated data and basically my function Learn!(band,20) is randomly breaking. I wonder if its related to the hash <@U9VG1AYSG> mentioned before?\n\n```using Statistics, StatsBase, Distributions \nusing DataFrames\n\nmutable struct Bandit\n    QN::Dict{NamedTuple,Dict{Symbol,Real}}\n    Y::Dict{NamedTuple,Array{Float64,1}}\n    keylist::Vector{NamedTuple}\nend \n\nfunction CreateBandit(data,groups,response)\n    gdf = groupby(data,groups)\n    QN = Dict{NamedTuple,Dict{Symbol,Real}}()\n    Y = Dict{NamedTuple,Array{Float64,1}}()\n    for key in keys(gdf)\n        QN[NamedTuple(key)] = Dict(:Q=&gt;rand(Uniform(0,1e-10)),:n=&gt;0)\n        Y[NamedTuple(key)] = gdf[key][:,response]\n    end \n    return(Bandit(QN,Y,collect(keys(QN))))\nend \n\nBase.getindex(bandit::Bandit,key) = Base.getindex(bandit.QN,key)\n\nfunction Base.argmax(bandit::Bandit)\n    keylist = bandit.keylist\n    idx = argmax(getindex.(values(bandit.QN),:Q))\n    return(keylist[idx])\nend \n\nfunction Learn!(bandit::Bandit,steps;ϵ=0.05,η=nothing)\n    lrn = ifelse(isnothing(η),0,1)\n    for i=1:steps\n        u = rand(Uniform(0,1))\n        if u &lt;= ϵ\n            action = sample(bandit.keylist,1)\n        else\n            action = argmax(bandit)\n        end \n        Qcurrent = bandit[action][:Q]\n        Reward = sample(bandit.Y[action],1)[1]\n        diff = Reward - Qcurrent\n        curr = bandit[action]\n        curr[:n] += 1\n        if lrn == 0 \n            curr[:Q] += 1/curr[:n] .* diff\n        else\n            curr[:Q] += η .* diff\n        end\n    end\n    return(bandit)\nend \n\n#Simulate Data \nn = 100\nA= rand(Normal(0,1),n)\nB= rand(Normal(1,1),n)\nC = rand(Normal(-1,1),n)\nD = rand(Normal(0.5,1),n)\n\nsimdata = DataFrame(Arm = vcat(fill(\"A\",n),fill(\"B\",n),fill(\"C\",n),fill(\"D\",n)),\n                    Y = vcat(A,B,C,D))\n\n#Use Bandit \n\nband=CreateBandit(simdata,:Arm,:Y)            \nLearn!(band,20) #This breaks randomly on an iteration ```","user":"U01EF0QVAB0","ts":"1614836707.226300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J23yu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I am encountering a very strange bug while trying to implement the Multi Armed Bandit problem. My code randomly will say "},{"type":"text","text":"ERROR: KeyError: key NamedTuple[(Arm = \"C\",)] not found","style":{"code":true}},{"type":"text","text":"  but it breaks randomly on an iteration of the loop, and I can't figure out why that would happen considering that its clearly able to find the key in previous iterations but it can't find it all the time? This is very strange and I don't know whats going on or how to debug an error that happens randomly in an iteration but not others. Its all simulated data and basically my function Learn!(band,20) is randomly breaking. I wonder if its related to the hash "},{"type":"user","user_id":"U9VG1AYSG"},{"type":"text","text":" mentioned before?\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Statistics, StatsBase, Distributions \nusing DataFrames\n\nmutable struct Bandit\n    QN::Dict{NamedTuple,Dict{Symbol,Real}}\n    Y::Dict{NamedTuple,Array{Float64,1}}\n    keylist::Vector{NamedTuple}\nend \n\nfunction CreateBandit(data,groups,response)\n    gdf = groupby(data,groups)\n    QN = Dict{NamedTuple,Dict{Symbol,Real}}()\n    Y = Dict{NamedTuple,Array{Float64,1}}()\n    for key in keys(gdf)\n        QN[NamedTuple(key)] = Dict(:Q=>rand(Uniform(0,1e-10)),:n=>0)\n        Y[NamedTuple(key)] = gdf[key][:,response]\n    end \n    return(Bandit(QN,Y,collect(keys(QN))))\nend \n\nBase.getindex(bandit::Bandit,key) = Base.getindex(bandit.QN,key)\n\nfunction Base.argmax(bandit::Bandit)\n    keylist = bandit.keylist\n    idx = argmax(getindex.(values(bandit.QN),:Q))\n    return(keylist[idx])\nend \n\nfunction Learn!(bandit::Bandit,steps;ϵ=0.05,η=nothing)\n    lrn = ifelse(isnothing(η),0,1)\n    for i=1:steps\n        u = rand(Uniform(0,1))\n        if u <= ϵ\n            action = sample(bandit.keylist,1)\n        else\n            action = argmax(bandit)\n        end \n        Qcurrent = bandit[action][:Q]\n        Reward = sample(bandit.Y[action],1)[1]\n        diff = Reward - Qcurrent\n        curr = bandit[action]\n        curr[:n] += 1\n        if lrn == 0 \n            curr[:Q] += 1/curr[:n] .* diff\n        else\n            curr[:Q] += η .* diff\n        end\n    end\n    return(bandit)\nend \n\n#Simulate Data \nn = 100\nA= rand(Normal(0,1),n)\nB= rand(Normal(1,1),n)\nC = rand(Normal(-1,1),n)\nD = rand(Normal(0.5,1),n)\n\nsimdata = DataFrame(Arm = vcat(fill(\"A\",n),fill(\"B\",n),fill(\"C\",n),fill(\"D\",n)),\n                    Y = vcat(A,B,C,D))\n\n#Use Bandit \n\nband=CreateBandit(simdata,:Arm,:Y)            \nLearn!(band,20) #This breaks randomly on an iteration "}]}]}],"thread_ts":"1614836707.226300","reply_count":2,"reply_users_count":2,"latest_reply":"1614906156.235000","reply_users":["U8JAMQGQY","U01EF0QVAB0"],"subscribed":false},{"client_msg_id":"df0a349b-f72f-43cb-ab05-ac989076ab17","type":"message","text":"change one line to:\n```action = sample(bandit.keylist)```\nAs a general remark - the code you use is not type stable so it will not be super efficient, as you use collections with abstract parameters, see <https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container>.","user":"U8JAMQGQY","ts":"1614844137.226400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GsVA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"change one line to:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"action = sample(bandit.keylist)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"As a general remark - the code you use is not type stable so it will not be super efficient, as you use collections with abstract parameters, see "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container"},{"type":"text","text":"."}]}]}],"thread_ts":"1614836707.226300","parent_user_id":"U01EF0QVAB0"},{"client_msg_id":"7ffad606-bc25-44fe-b115-63c3b4fa5b1a","type":"message","text":"Thanks, I am used to R and it seems like I forgot what I had returns a vector with 1 element and Julia that is different than a scalar. Also, `sample()` in R ends up resampling the number of items equal to the total by default which is why I had the 1 there. Seems like  the Real I could just change to Float64 and would that resolve the efficiency? Seems to work pretty quickly already though (at least practically, 1000 steps is 0.003 s)","user":"U01EF0QVAB0","ts":"1614906156.235000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m1s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, I am used to R and it seems like I forgot what I had returns a vector with 1 element and Julia that is different than a scalar. Also, "},{"type":"text","text":"sample()","style":{"code":true}},{"type":"text","text":" in R ends up resampling the number of items equal to the total by default which is why I had the 1 there. Seems like  the Real I could just change to Float64 and would that resolve the efficiency? Seems to work pretty quickly already though (at least practically, 1000 steps is 0.003 s)"}]}]}],"thread_ts":"1614836707.226300","parent_user_id":"U01EF0QVAB0"}]