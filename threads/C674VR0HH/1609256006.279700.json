[{"client_msg_id":"237a8abb-e39c-4691-b12f-82f6571f02e9","type":"message","text":"Is anyone familiar with c++/CxxWrap here? I am trying to find a way to reuse c++ memory in Arrow.jl and I’m running into some roadblocks. Posting details in this thread","user":"U01GXNFKY6R","ts":"1609256006.279700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qbuvi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is anyone familiar with c++/CxxWrap here? I am trying to find a way to reuse c++ memory in Arrow.jl and I’m running into some roadblocks. Posting details in this thread"}]}]}],"thread_ts":"1609256006.279700","reply_count":7,"reply_users_count":2,"latest_reply":"1609258640.283800","reply_users":["U01GXNFKY6R","U681ELA87"],"subscribed":false},{"client_msg_id":"d9b2ffce-75b3-4a44-9602-bcbd09f568c2","type":"message","text":"Why is jlcxx trying to run apply type? This code should happen entirely in c++ land\nCompile error:\n```Undefined symbols for architecture x86_64:\n  \"jlcxx::apply_type(_jl_value_t*, _jl_datatype_t*)\", referenced from:\n      jlcxx::julia_type_factory&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, jlcxx::WrappedPtrTrait&gt;::julia_type() in cpp_link.cpp.o\n  \"parquet::arrow::OpenFile(std::__1::shared_ptr&lt;arrow::io::RandomAccessFile&gt;, arrow::MemoryPool*, std::__1::unique_ptr&lt;parquet::arrow::FileReader, std::__1::default_delete&lt;parquet::arrow::FileReader&gt; &gt;*)\", referenced from:\n      parquet_reader(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) in cpp_link.cpp.o\nld: symbol(s) not found for architecture x86_64```\ncpp code:\n```#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include \"jlcxx/jlcxx.hpp\"\n#include \"parquet/arrow/reader.h\"\n#include \"arrow/io/file.h\"\n#include \"arrow/api.h\"\n\nstd::string greet()\n{\n  std::cout &lt;&lt; \"Hello World!\\n\";\n  return \"hello, world\";\n}\n\n// TODO CxxWrap doesn't know how to return arrow::Table, must write a converter\nint parquet_reader(const std::string &amp;path)\n{\n  arrow::Status st;\n  arrow::MemoryPool* pool = arrow::default_memory_pool();\n  std::shared_ptr&lt;arrow::io::RandomAccessFile&gt; input = arrow::io::ReadableFile::Open(path).ValueOrDie();\n\n  // Open Parquet file reader\n  std::unique_ptr&lt;parquet::arrow::FileReader&gt; arrow_reader;\n  st = parquet::arrow::OpenFile(input, pool, &amp;arrow_reader);\n  if (!st.ok()) {\n    // Handle error instantiating file reader...\n  }\n\n  // Read entire file as a single Arrow table\n  std::shared_ptr&lt;arrow::Table&gt; table;\n  st = arrow_reader-&gt;ReadTable(&amp;table);\n  if (!st.ok()) {\n    // Handle error reading Parquet data...\n  }\n  std::cout &lt;&lt; \"done\\n\";\n  return 1;\n}\n\nJLCXX_MODULE define_julia_module(jlcxx::Module&amp; mod)\n{\n  mod.method(\"read_parquet\", &amp;parquet_reader);\n}```","user":"U01GXNFKY6R","ts":"1609256123.279800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4mf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why is jlcxx trying to run apply type? This code should happen entirely in c++ land\nCompile error:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Undefined symbols for architecture x86_64:\n  \"jlcxx::apply_type(_jl_value_t*, _jl_datatype_t*)\", referenced from:\n      jlcxx::julia_type_factory<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, jlcxx::WrappedPtrTrait>::julia_type() in cpp_link.cpp.o\n  \"parquet::arrow::OpenFile(std::__1::shared_ptr<arrow::io::RandomAccessFile>, arrow::MemoryPool*, std::__1::unique_ptr<parquet::arrow::FileReader, std::__1::default_delete<parquet::arrow::FileReader> >*)\", referenced from:\n      parquet_reader(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) in cpp_link.cpp.o\nld: symbol(s) not found for architecture x86_64"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"cpp code:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"#include <string>\n#include <iostream>\n#include \"jlcxx/jlcxx.hpp\"\n#include \"parquet/arrow/reader.h\"\n#include \"arrow/io/file.h\"\n#include \"arrow/api.h\"\n\nstd::string greet()\n{\n  std::cout << \"Hello World!\\n\";\n  return \"hello, world\";\n}\n\n// TODO CxxWrap doesn't know how to return arrow::Table, must write a converter\nint parquet_reader(const std::string &path)\n{\n  arrow::Status st;\n  arrow::MemoryPool* pool = arrow::default_memory_pool();\n  std::shared_ptr<arrow::io::RandomAccessFile> input = arrow::io::ReadableFile::Open(path).ValueOrDie();\n\n  // Open Parquet file reader\n  std::unique_ptr<parquet::arrow::FileReader> arrow_reader;\n  st = parquet::arrow::OpenFile(input, pool, &arrow_reader);\n  if (!st.ok()) {\n    // Handle error instantiating file reader...\n  }\n\n  // Read entire file as a single Arrow table\n  std::shared_ptr<arrow::Table> table;\n  st = arrow_reader->ReadTable(&table);\n  if (!st.ok()) {\n    // Handle error reading Parquet data...\n  }\n  std::cout << \"done\\n\";\n  return 1;\n}\n\nJLCXX_MODULE define_julia_module(jlcxx::Module& mod)\n{\n  mod.method(\"read_parquet\", &parquet_reader);\n}"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"fe06754e-9f55-419d-8d02-ef0cb829684d","type":"message","text":"I'm not familiar w/ CxxWrap, but to use arbitrary memory w/ Arrow.jl, you'd want to do something like:\n```ptr = ... # some Ptr{UInt8} pointing to arrow memory blob\nblob = unsafe_wrap(Arrow, ptr, nbytes)\ntable = Arrow.Table(blob)```","user":"U681ELA87","ts":"1609256241.280000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5ZPS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not familiar w/ CxxWrap, but to use arbitrary memory w/ Arrow.jl, you'd want to do something like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ptr = ... # some Ptr{UInt8} pointing to arrow memory blob\nblob = unsafe_wrap(Arrow, ptr, nbytes)\ntable = Arrow.Table(blob)"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"c9c43f92-e9f2-4f32-937c-263cf10afb62","type":"message","text":"I suspect this would not be a zero-copy operation, right? Arrow chunks its columns into Buffers AFAIK.","user":"U01GXNFKY6R","ts":"1609257012.280200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GvJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I suspect this would not be a zero-copy operation, right? Arrow chunks its columns into Buffers AFAIK."}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"b980a0a4-bb59-4b2b-9b10-b20cb1a1e9b0","type":"message","text":"Would be nice if I could reuse c++ buffers in Julia. I’m looking through the source code to try and understand how it works at the moment","user":"U01GXNFKY6R","ts":"1609257098.280400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=T6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Would be nice if I could reuse c++ buffers in Julia. I’m looking through the source code to try and understand how it works at the moment"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"38d7d847-026d-44b8-8540-4d4f0fce67e7","type":"message","text":"Maybe <@U6V6FEY1L> would have an idea for the original problem?","user":"U01GXNFKY6R","ts":"1609257751.281800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ni+uo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe "},{"type":"user","user_id":"U6V6FEY1L"},{"type":"text","text":" would have an idea for the original problem?"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"0f92069e-ce47-4712-bb07-21dc1cab3f15","type":"message","text":"I mean, if the `ptr` in my example is just a pointer to the entire arrow memory blob, then yes, it's zero copy, i.e. `unsafe_wrap(Array, ptr, nbytes)` doesn't make a copy, but just wraps a memory blob as a `Vector{UInt8}`.","user":"U681ELA87","ts":"1609258139.282700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UbIc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, if the "},{"type":"text","text":"ptr","style":{"code":true}},{"type":"text","text":" in my example is just a pointer to the entire arrow memory blob, then yes, it's zero copy, i.e. "},{"type":"text","text":"unsafe_wrap(Array, ptr, nbytes)","style":{"code":true}},{"type":"text","text":" doesn't make a copy, but just wraps a memory blob as a "},{"type":"text","text":"Vector{UInt8}","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"c670d16b-9ba5-4515-acd4-c36bdee20b36","type":"message","text":"That’s good to know! Either way I’m not far enough to implement that yet. Still running into that compile error in cpp. Will try this out when I get the compilation to work :slightly_smiling_face:","user":"U01GXNFKY6R","ts":"1609258640.283800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Efr2b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s good to know! Either way I’m not far enough to implement that yet. Still running into that compile error in cpp. Will try this out when I get the compilation to work "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"}]