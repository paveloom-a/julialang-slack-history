[{"client_msg_id":"237a8abb-e39c-4691-b12f-82f6571f02e9","type":"message","text":"Is anyone familiar with c++/CxxWrap here? I am trying to find a way to reuse c++ memory in Arrow.jl and I’m running into some roadblocks. Posting details in this thread","user":"U01GXNFKY6R","ts":"1609256006.279700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qbuvi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is anyone familiar with c++/CxxWrap here? I am trying to find a way to reuse c++ memory in Arrow.jl and I’m running into some roadblocks. Posting details in this thread"}]}]}],"thread_ts":"1609256006.279700","reply_count":18,"reply_users_count":3,"latest_reply":"1609494557.295100","reply_users":["U01GXNFKY6R","U681ELA87","U6V6FEY1L"],"subscribed":false},{"client_msg_id":"d9b2ffce-75b3-4a44-9602-bcbd09f568c2","type":"message","text":"Why is jlcxx trying to run apply type? This code should happen entirely in c++ land\nCompile error:\n```Undefined symbols for architecture x86_64:\n  \"jlcxx::apply_type(_jl_value_t*, _jl_datatype_t*)\", referenced from:\n      jlcxx::julia_type_factory&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, jlcxx::WrappedPtrTrait&gt;::julia_type() in cpp_link.cpp.o\n  \"parquet::arrow::OpenFile(std::__1::shared_ptr&lt;arrow::io::RandomAccessFile&gt;, arrow::MemoryPool*, std::__1::unique_ptr&lt;parquet::arrow::FileReader, std::__1::default_delete&lt;parquet::arrow::FileReader&gt; &gt;*)\", referenced from:\n      parquet_reader(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) in cpp_link.cpp.o\nld: symbol(s) not found for architecture x86_64```\ncpp code:\n```#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include \"jlcxx/jlcxx.hpp\"\n#include \"parquet/arrow/reader.h\"\n#include \"arrow/io/file.h\"\n#include \"arrow/api.h\"\n\nstd::string greet()\n{\n  std::cout &lt;&lt; \"Hello World!\\n\";\n  return \"hello, world\";\n}\n\n// TODO CxxWrap doesn't know how to return arrow::Table, must write a converter\nint parquet_reader(const std::string &amp;path)\n{\n  arrow::Status st;\n  arrow::MemoryPool* pool = arrow::default_memory_pool();\n  std::shared_ptr&lt;arrow::io::RandomAccessFile&gt; input = arrow::io::ReadableFile::Open(path).ValueOrDie();\n\n  // Open Parquet file reader\n  std::unique_ptr&lt;parquet::arrow::FileReader&gt; arrow_reader;\n  st = parquet::arrow::OpenFile(input, pool, &amp;arrow_reader);\n  if (!st.ok()) {\n    // Handle error instantiating file reader...\n  }\n\n  // Read entire file as a single Arrow table\n  std::shared_ptr&lt;arrow::Table&gt; table;\n  st = arrow_reader-&gt;ReadTable(&amp;table);\n  if (!st.ok()) {\n    // Handle error reading Parquet data...\n  }\n  std::cout &lt;&lt; \"done\\n\";\n  return 1;\n}\n\nJLCXX_MODULE define_julia_module(jlcxx::Module&amp; mod)\n{\n  mod.method(\"read_parquet\", &amp;parquet_reader);\n}```","user":"U01GXNFKY6R","ts":"1609256123.279800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4mf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why is jlcxx trying to run apply type? This code should happen entirely in c++ land\nCompile error:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Undefined symbols for architecture x86_64:\n  \"jlcxx::apply_type(_jl_value_t*, _jl_datatype_t*)\", referenced from:\n      jlcxx::julia_type_factory<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, jlcxx::WrappedPtrTrait>::julia_type() in cpp_link.cpp.o\n  \"parquet::arrow::OpenFile(std::__1::shared_ptr<arrow::io::RandomAccessFile>, arrow::MemoryPool*, std::__1::unique_ptr<parquet::arrow::FileReader, std::__1::default_delete<parquet::arrow::FileReader> >*)\", referenced from:\n      parquet_reader(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) in cpp_link.cpp.o\nld: symbol(s) not found for architecture x86_64"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"cpp code:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"#include <string>\n#include <iostream>\n#include \"jlcxx/jlcxx.hpp\"\n#include \"parquet/arrow/reader.h\"\n#include \"arrow/io/file.h\"\n#include \"arrow/api.h\"\n\nstd::string greet()\n{\n  std::cout << \"Hello World!\\n\";\n  return \"hello, world\";\n}\n\n// TODO CxxWrap doesn't know how to return arrow::Table, must write a converter\nint parquet_reader(const std::string &path)\n{\n  arrow::Status st;\n  arrow::MemoryPool* pool = arrow::default_memory_pool();\n  std::shared_ptr<arrow::io::RandomAccessFile> input = arrow::io::ReadableFile::Open(path).ValueOrDie();\n\n  // Open Parquet file reader\n  std::unique_ptr<parquet::arrow::FileReader> arrow_reader;\n  st = parquet::arrow::OpenFile(input, pool, &arrow_reader);\n  if (!st.ok()) {\n    // Handle error instantiating file reader...\n  }\n\n  // Read entire file as a single Arrow table\n  std::shared_ptr<arrow::Table> table;\n  st = arrow_reader->ReadTable(&table);\n  if (!st.ok()) {\n    // Handle error reading Parquet data...\n  }\n  std::cout << \"done\\n\";\n  return 1;\n}\n\nJLCXX_MODULE define_julia_module(jlcxx::Module& mod)\n{\n  mod.method(\"read_parquet\", &parquet_reader);\n}"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"fe06754e-9f55-419d-8d02-ef0cb829684d","type":"message","text":"I'm not familiar w/ CxxWrap, but to use arbitrary memory w/ Arrow.jl, you'd want to do something like:\n```ptr = ... # some Ptr{UInt8} pointing to arrow memory blob\nblob = unsafe_wrap(Arrow, ptr, nbytes)\ntable = Arrow.Table(blob)```","user":"U681ELA87","ts":"1609256241.280000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5ZPS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not familiar w/ CxxWrap, but to use arbitrary memory w/ Arrow.jl, you'd want to do something like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ptr = ... # some Ptr{UInt8} pointing to arrow memory blob\nblob = unsafe_wrap(Arrow, ptr, nbytes)\ntable = Arrow.Table(blob)"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"c9c43f92-e9f2-4f32-937c-263cf10afb62","type":"message","text":"I suspect this would not be a zero-copy operation, right? Arrow chunks its columns into Buffers AFAIK.","user":"U01GXNFKY6R","ts":"1609257012.280200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GvJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I suspect this would not be a zero-copy operation, right? Arrow chunks its columns into Buffers AFAIK."}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"b980a0a4-bb59-4b2b-9b10-b20cb1a1e9b0","type":"message","text":"Would be nice if I could reuse c++ buffers in Julia. I’m looking through the source code to try and understand how it works at the moment","user":"U01GXNFKY6R","ts":"1609257098.280400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=T6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Would be nice if I could reuse c++ buffers in Julia. I’m looking through the source code to try and understand how it works at the moment"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"38d7d847-026d-44b8-8540-4d4f0fce67e7","type":"message","text":"Maybe <@U6V6FEY1L> would have an idea for the original problem?","user":"U01GXNFKY6R","ts":"1609257751.281800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ni+uo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe "},{"type":"user","user_id":"U6V6FEY1L"},{"type":"text","text":" would have an idea for the original problem?"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"0f92069e-ce47-4712-bb07-21dc1cab3f15","type":"message","text":"I mean, if the `ptr` in my example is just a pointer to the entire arrow memory blob, then yes, it's zero copy, i.e. `unsafe_wrap(Array, ptr, nbytes)` doesn't make a copy, but just wraps a memory blob as a `Vector{UInt8}`.","user":"U681ELA87","ts":"1609258139.282700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UbIc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, if the "},{"type":"text","text":"ptr","style":{"code":true}},{"type":"text","text":" in my example is just a pointer to the entire arrow memory blob, then yes, it's zero copy, i.e. "},{"type":"text","text":"unsafe_wrap(Array, ptr, nbytes)","style":{"code":true}},{"type":"text","text":" doesn't make a copy, but just wraps a memory blob as a "},{"type":"text","text":"Vector{UInt8}","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"c670d16b-9ba5-4515-acd4-c36bdee20b36","type":"message","text":"That’s good to know! Either way I’m not far enough to implement that yet. Still running into that compile error in cpp. Will try this out when I get the compilation to work :slightly_smiling_face:","user":"U01GXNFKY6R","ts":"1609258640.283800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Efr2b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s good to know! Either way I’m not far enough to implement that yet. Still running into that compile error in cpp. Will try this out when I get the compilation to work "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"b8d95fc6-d050-442a-a09e-37e542b29cab","type":"message","text":"Hi, I think the compile error is because you are not linking to libcxxwrap and libjulia?","user":"U6V6FEY1L","ts":"1609323339.289300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Hb4A","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi, I think the compile error is because you are not linking to libcxxwrap and libjulia?"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"b057f373-02df-4d85-9101-77490e6559a2","type":"message","text":"calling apply_type is needed to obtain or create a concrete Julia type with a parameter","user":"U6V6FEY1L","ts":"1609323392.289500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6TaG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"calling apply_type is needed to obtain or create a concrete Julia type with a parameter"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"91ecf891-ed71-412a-8494-1715c4d38a23","type":"message","text":"<@U01GXNFKY6R>","user":"U6V6FEY1L","ts":"1609323411.289700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2E0mq","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01GXNFKY6R"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"7d2f417c-91c2-47d7-97ff-d4b295455d55","type":"message","text":"Thanks for the response <@U6V6FEY1L> (and <@U681ELA87> as well!). I believe I am linking libcxxwrap and libjulia but I could be wrong. What do you think?\n\nThis is my CMakeLists\n```cmake_minimum_required(VERSION 3.18)\n\nproject(jarl_cpp)\n\nset(OPENSSL_INCLUDE_DIR \"/usr/local/Cellar/openssl@1.1/1.1.1h/lib/\")\nset(CMAKE_PREFIX_PATH \"/Users/s.kapadia/.julia/artifacts/0eb6ffcbe0cde10007a2678013611da80643b728/;/usr/local/Cellar/apache-arrow/2.0.0_1/lib/\")\nset(Parquet_DIR \"/usr/local/Cellar/apache-arrow/2.0.0_1/lib/cmake/arrow\")\n\n\ninclude_directories( \n\t/usr/local/Cellar/apache-arrow/2.0.0_1/include/\n\t/Users/s.kapadia/libs/libcxxwrap-julia/include/\n\t/Applications/Julia-1.5.app/Contents/Resources/julia/include/\n\t/Users/s.kapadia/.julia/artifacts/0eb6ffcbe0cde10007a2678013611da80643b728/include\n)\n\nfind_package(Arrow REQUIRED)\nfind_package(Parquet REQUIRED)\nfind_package(JlCxx REQUIRED)\n\nget_target_property(JlCxx_location JlCxx::cxxwrap_julia LOCATION)\nget_filename_component(JlCxx_location ${JlCxx_location} DIRECTORY)\nset(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib;${JlCxx_location}\")\n\nmessage(STATUS \"Found JlCxx at ${JlCxx_location}\")\n\nadd_library(\"${PROJECT_NAME}\" SHARED cpp_link.cpp)\ntarget_link_libraries(\"${PROJECT_NAME}\" arrow_shared JlCxx::cxxwrap_julia) ```\nand this is its output\n```[main] Configuring folder: Jarl \n[proc] Executing command: /usr/local/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/local/bin/x86_64-apple-darwin19-gcc-10.2.0 -H/Users/s.kapadia/work/Jarl/cpp/src -B/Users/s.kapadia/work/Jarl/cpp/build -G \"Unix Makefiles\"\n[cmake] Not searching for unused variables given on the command line.\n[cmake] -- Found Julia executable: /usr/local/bin/julia\n[cmake] -- Julia_VERSION_STRING: 1.5.2\n[cmake] -- Julia_INCLUDE_DIRS:   /Applications/Julia-1.5.app/Contents/Resources/julia/include/julia\n[cmake] -- Julia_LIBRARY_DIR:    /Applications/Julia-1.5.app/Contents/Resources/julia/lib\n[cmake] -- Julia_LIBRARY:        /Applications/Julia-1.5.app/Contents/Resources/julia/lib/libjulia.1.5.dylib\n[cmake] -- JULIA_HOME:           /Applications/Julia-1.5.app/Contents/Resources/julia/bin\n[cmake] -- Julia_LLVM_VERSION:   v9.0.1\n[cmake] -- Julia_WORD_SIZE:      64\n[cmake] -- Found JlCxx at /Users/s.kapadia/.julia/artifacts/0eb6ffcbe0cde10007a2678013611da80643b728/lib\n[cmake] -- Configuring done\n[cmake] -- Generating done\n[cmake] -- Build files have been written to: /Users/s.kapadia/work/Jarl/cpp/build```\n","user":"U01GXNFKY6R","ts":"1609340869.290300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JMvdp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the response "},{"type":"user","user_id":"U6V6FEY1L"},{"type":"text","text":" (and "},{"type":"user","user_id":"U681ELA87"},{"type":"text","text":" as well!). I believe I am linking libcxxwrap and libjulia but I could be wrong. What do you think?\n\nThis is my CMakeLists\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"cmake_minimum_required(VERSION 3.18)\n\nproject(jarl_cpp)\n\nset(OPENSSL_INCLUDE_DIR \"/usr/local/Cellar/openssl@1.1/1.1.1h/lib/\")\nset(CMAKE_PREFIX_PATH \"/Users/s.kapadia/.julia/artifacts/0eb6ffcbe0cde10007a2678013611da80643b728/;/usr/local/Cellar/apache-arrow/2.0.0_1/lib/\")\nset(Parquet_DIR \"/usr/local/Cellar/apache-arrow/2.0.0_1/lib/cmake/arrow\")\n\n\ninclude_directories( \n\t/usr/local/Cellar/apache-arrow/2.0.0_1/include/\n\t/Users/s.kapadia/libs/libcxxwrap-julia/include/\n\t/Applications/Julia-1.5.app/Contents/Resources/julia/include/\n\t/Users/s.kapadia/.julia/artifacts/0eb6ffcbe0cde10007a2678013611da80643b728/include\n)\n\nfind_package(Arrow REQUIRED)\nfind_package(Parquet REQUIRED)\nfind_package(JlCxx REQUIRED)\n\nget_target_property(JlCxx_location JlCxx::cxxwrap_julia LOCATION)\nget_filename_component(JlCxx_location ${JlCxx_location} DIRECTORY)\nset(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib;${JlCxx_location}\")\n\nmessage(STATUS \"Found JlCxx at ${JlCxx_location}\")\n\nadd_library(\"${PROJECT_NAME}\" SHARED cpp_link.cpp)\ntarget_link_libraries(\"${PROJECT_NAME}\" arrow_shared JlCxx::cxxwrap_julia) "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and this is its output\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"[main] Configuring folder: Jarl \n[proc] Executing command: /usr/local/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/local/bin/x86_64-apple-darwin19-gcc-10.2.0 -H/Users/s.kapadia/work/Jarl/cpp/src -B/Users/s.kapadia/work/Jarl/cpp/build -G \"Unix Makefiles\"\n[cmake] Not searching for unused variables given on the command line.\n[cmake] -- Found Julia executable: /usr/local/bin/julia\n[cmake] -- Julia_VERSION_STRING: 1.5.2\n[cmake] -- Julia_INCLUDE_DIRS:   /Applications/Julia-1.5.app/Contents/Resources/julia/include/julia\n[cmake] -- Julia_LIBRARY_DIR:    /Applications/Julia-1.5.app/Contents/Resources/julia/lib\n[cmake] -- Julia_LIBRARY:        /Applications/Julia-1.5.app/Contents/Resources/julia/lib/libjulia.1.5.dylib\n[cmake] -- JULIA_HOME:           /Applications/Julia-1.5.app/Contents/Resources/julia/bin\n[cmake] -- Julia_LLVM_VERSION:   v9.0.1\n[cmake] -- Julia_WORD_SIZE:      64\n[cmake] -- Found JlCxx at /Users/s.kapadia/.julia/artifacts/0eb6ffcbe0cde10007a2678013611da80643b728/lib\n[cmake] -- Configuring done\n[cmake] -- Generating done\n[cmake] -- Build files have been written to: /Users/s.kapadia/work/Jarl/cpp/build"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"995f1625-f826-427e-a7b2-3e553a17345a","type":"message","text":"<@U01GXNFKY6R> right, this is indeed correct. I think the problem is compatibility between your compiler and the compiler the libcxxwrap-julia binaries are built with. The best way around that is to compile libcxxwrap-julia from source with the same compiler, and then link to that. See the README here: <https://github.com/JuliaInterop/libcxxwrap-julia>","user":"U6V6FEY1L","ts":"1609349823.290500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4ja","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01GXNFKY6R"},{"type":"text","text":" right, this is indeed correct. I think the problem is compatibility between your compiler and the compiler the libcxxwrap-julia binaries are built with. The best way around that is to compile libcxxwrap-julia from source with the same compiler, and then link to that. See the README here: "},{"type":"link","url":"https://github.com/JuliaInterop/libcxxwrap-julia"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"2e00f011-0424-4845-9627-bdef842dcc11","type":"message","text":"Okay thank you. Total c++ noob here so it's good that i have something to try. What compiler are the cxxwrap binaries made with? I don't have any restrictions for selecting compilers","user":"U01GXNFKY6R","ts":"1609360896.290700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"08yf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Okay thank you. Total c++ noob here so it's good that i have something to try. What compiler are the cxxwrap binaries made with? I don't have any restrictions for selecting compilers"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"8687a887-3d4d-4379-b565-82794967fe68","type":"message","text":"They are built using BinaryBuilder, using cross-compilation. You can see a recent example of a working BinaryBuilder script here: <https://github.com/JuliaPackaging/Yggdrasil/tree/master/L/libsingular_julia>","user":"U6V6FEY1L","ts":"1609407782.292400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7pMv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"They are built using BinaryBuilder, using cross-compilation. You can see a recent example of a working BinaryBuilder script here: "},{"type":"link","url":"https://github.com/JuliaPackaging/Yggdrasil/tree/master/L/libsingular_julia"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"6677eca9-5783-4100-ae2e-1ddb44bc2486","type":"message","text":"But for development, it is cumbersome to launch BinaryBuilder every time, it’s much easier to build everything using your compiler of choice and then set up an overrides file.","user":"U6V6FEY1L","ts":"1609407925.292600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5mV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But for development, it is cumbersome to launch BinaryBuilder every time, it’s much easier to build everything using your compiler of choice and then set up an overrides file."}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"75a09341-1916-4155-9b6e-7f4911953033","type":"message","text":"The whole procedure for building a working package based on CxxWrap is explained here: <https://live.juliacon.org/talk/NNVQQF>","user":"U6V6FEY1L","ts":"1609407945.292800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PIvR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The whole procedure for building a working package based on CxxWrap is explained here: "},{"type":"link","url":"https://live.juliacon.org/talk/NNVQQF"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R","reactions":[{"name":"eyes","users":["U01GXNFKY6R"],"count":1},{"name":"raised_hands","users":["U01GXNFKY6R"],"count":1}]},{"client_msg_id":"71906be9-e675-44d1-91a6-5efbe1093c1a","type":"message","text":"Cool, will check out the talk. Thank you very much!","user":"U01GXNFKY6R","ts":"1609494528.294900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QgvQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Cool, will check out the talk. Thank you very much!"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"},{"client_msg_id":"3f3fdcb7-7eab-4782-9202-1fef31766b29","type":"message","text":"Happy new year :slightly_smiling_face: <@U6V6FEY1L> and <@U681ELA87>!","user":"U01GXNFKY6R","ts":"1609494557.295100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EYj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Happy new year "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":" "},{"type":"user","user_id":"U6V6FEY1L"},{"type":"text","text":" and "},{"type":"user","user_id":"U681ELA87"},{"type":"text","text":"!"}]}]}],"thread_ts":"1609256006.279700","parent_user_id":"U01GXNFKY6R"}]