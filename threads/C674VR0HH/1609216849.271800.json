[{"client_msg_id":"085a18ff-b49e-40dd-87a7-1794056397bb","type":"message","text":"So I noticed with the MLJ.jl package, it seems that when you use PCA through it, it can't take in Matrix and the object must be a DataFrame? But then when you use MLJ.transform(PC, X) then X can be either a DataFrame or Matrix but using a DataFrame appears to be extremely inefficient. As in taking 450 seconds as opposed to 11 s. If you put in a DataFrame, it seems to return a DataFrame but if you put in a Matrix it returns something else but that can be coerced to a DF then Matrix and give the right result and this was 11s . Seems strange - any ideas why its inconsistent like this where you have to fit the model on a DF but then its better to use transform on a matrix then coerce it? I was wondering how matrix multiplication (which is what PCA is after its been fit already) could be so slow. My Input to the PCA is 640 x 327.5K and output is 640 x 100","user":"U01EF0QVAB0","ts":"1609216849.271800","team":"T68168MUP","edited":{"user":"U01EF0QVAB0","ts":"1609217057.000000"},"blocks":[{"type":"rich_text","block_id":"gBr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I noticed with the MLJ.jl package, it seems that when you use PCA through it, it can't take in Matrix and the object must be a DataFrame? But then when you use MLJ.transform(PC, X) then X can be either a DataFrame or Matrix but using a DataFrame appears to be extremely inefficient. As in taking 450 seconds as opposed to 11 s. If you put in a DataFrame, it seems to return a DataFrame but if you put in a Matrix it returns something else but that can be coerced to a DF then Matrix and give the right result and this was 11s . Seems strange - any ideas why its inconsistent like this where you have to fit the model on a DF but then its better to use transform on a matrix then coerce it? I was wondering how matrix multiplication (which is what PCA is after its been fit already) could be so slow. My Input to the PCA is 640 x 327.5K and output is 640 x 100"}]}]}],"thread_ts":"1609216849.271800","reply_count":1,"reply_users_count":1,"latest_reply":"1609234603.273700","reply_users":["UAZP7LJLU"],"subscribed":false},{"client_msg_id":"8fcdbd66-0a66-4ef5-9590-05136b530e20","type":"message","text":"I recommend you also ask this question at <#CC57ZE7EY|mlj> channel.\n\nFor now `MLJ.transform(PCAmach, X)` works with `X` either being a `Matrix` or any other compatible `Tables.jl` inputs. `Matrix` inputs may no longer be supported in the future.\nI recommend using a  `MatrixTable` instead of `Matrix` as it's a `Tables.jl` compatible source.\n Calling `MLJ.transform(PCAmach, X)` with `X` as `Matrix` or `MatrixTable` is only slightly faster that with `X` as `DataFrame` because of the  reduced allocations involved when calling the method. But it shouldn't be as bad as `11s` to `450s` .(Benchmarking on my PC with a `(1000x1000)` `DatraFrame` and `Matrix` shows no significant difference between the two asides allocation time.)\nPlease open an issue at <https://github.com/alan-turing-institute/MLJ.jl|MLJ> showing the code and benchmarks. (Are you bench-marking the coercion ?)\nGenerally if you already have a matrix lying around just construct a `MatrixTable` which just wraps the matrix as a `Tables.jl` compatible source but if you have a `DataFrame` maybe from reading a csv file, just use the `DataFrame` directly as converting to a `MatrixTable` would require first creating a matrix which involves a slight allocation cost.\n\n*Note:*\nConversion of `DataFrame`, `MatrixTables` and other `Tables.jl` sources to a matrix is done internally when  `MLJ.transform(PCA, X)` is called and involves some allocations except in the case that `X` is a `MatrixTable` .","user":"UAZP7LJLU","ts":"1609234603.273700","team":"T68168MUP","edited":{"user":"UAZP7LJLU","ts":"1609234895.000000"},"blocks":[{"type":"rich_text","block_id":"szLt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I recommend you also ask this question at "},{"type":"channel","channel_id":"CC57ZE7EY"},{"type":"text","text":" channel.\n\nFor now "},{"type":"text","text":"MLJ.transform(PCAmach, X)","style":{"code":true}},{"type":"text","text":" works with "},{"type":"text","text":"X","style":{"code":true}},{"type":"text","text":" either being a `Matrix` or any other compatible `Tables.jl` inputs. "},{"type":"text","text":"Matrix","style":{"code":true}},{"type":"text","text":" inputs may no longer be supported in the future.\nI recommend using a  "},{"type":"text","text":"MatrixTable","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":"Matrix","style":{"code":true}},{"type":"text","text":" as it's a "},{"type":"text","text":"Tables.jl","style":{"code":true}},{"type":"text","text":" compatible source.\n Calling "},{"type":"text","text":"MLJ.transform(PCAmach, X)","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"X","style":{"code":true}},{"type":"text","text":" as "},{"type":"text","text":"Matrix","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"MatrixTable","style":{"code":true}},{"type":"text","text":" is only slightly faster that with "},{"type":"text","text":"X","style":{"code":true}},{"type":"text","text":" as "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":" because of the  reduced allocations involved when calling the method. But it shouldn't be as bad as "},{"type":"text","text":"11s","style":{"code":true}},{"type":"text","text":" to "},{"type":"text","text":"450s","style":{"code":true}},{"type":"text","text":" .(Benchmarking on my PC with a "},{"type":"text","text":"(1000x1000)","style":{"code":true}},{"type":"text","text":" "},{"type":"text","text":"DatraFrame","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Matrix","style":{"code":true}},{"type":"text","text":" shows no significant difference between the two asides allocation time.)\nPlease open an issue at "},{"type":"link","url":"https://github.com/alan-turing-institute/MLJ.jl","text":"MLJ"},{"type":"text","text":" showing the code and benchmarks. (Are you bench-marking the coercion ?)\nGenerally if you already have a matrix lying around just construct a "},{"type":"text","text":"MatrixTable","style":{"code":true}},{"type":"text","text":" which just wraps the matrix as a "},{"type":"text","text":"Tables.jl","style":{"code":true}},{"type":"text","text":" compatible source but if you have a "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":" maybe from reading a csv file, just use the "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":" directly as converting to a "},{"type":"text","text":"MatrixTable","style":{"code":true}},{"type":"text","text":" would require first creating a matrix which involves a slight allocation cost.\n\n"},{"type":"text","text":"Note:","style":{"bold":true}},{"type":"text","text":"\nConversion of "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"MatrixTables","style":{"code":true}},{"type":"text","text":" and other "},{"type":"text","text":"Tables.jl","style":{"code":true}},{"type":"text","text":" sources to a matrix is done internally when  "},{"type":"text","text":"MLJ.transform(PCA, X)","style":{"code":true}},{"type":"text","text":" is called and involves some allocations except in the case that "},{"type":"text","text":"X","style":{"code":true}},{"type":"text","text":" is a "},{"type":"text","text":"MatrixTable","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1609216849.271800","parent_user_id":"U01EF0QVAB0"}]