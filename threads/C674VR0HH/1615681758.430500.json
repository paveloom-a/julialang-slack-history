[{"client_msg_id":"8d32632d-cf05-4c50-a996-bbc3446bee2a","type":"message","text":"What I haven't quite worked out the details on is still serializing the metadata of the pre-lowered struct so you can still get it back out automatically..","user":"U681ELA87","ts":"1615681758.430500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M4V8B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What I haven't quite worked out the details on is still serializing the metadata of the pre-lowered struct so you can still get it back out automatically.."}]}]}],"thread_ts":"1615681758.430500","reply_count":6,"reply_users_count":2,"latest_reply":"1615701593.434700","reply_users":["U674T0Y9Z","U681ELA87"],"subscribed":false},{"client_msg_id":"5534064d-4dbe-46e3-ae1f-40366111e1b2","type":"message","text":"IMO if a user overloads `lower` they should also overload a corresponding deserialization hook, automatically reversing a custom `lower` hook seems...difficult :stuck_out_tongue:\n\nor maybe I'm misunderstanding? do you mean the equivalent of `registertype!` so that e.g. you'd know to deserialize `raw` as `raise(Foo, raw)` if `raw` was serialized as `lower(Foo(...))`?\n\nseems like some form of registration would still be needed then. From a metadata serialization perspective, it could happen at the same time/place as it does now with the `\"JuliaLang.*\"` extensions we have via `registertype!`?","user":"U674T0Y9Z","ts":"1615682229.430800","team":"T68168MUP","edited":{"user":"U674T0Y9Z","ts":"1615682258.000000"},"blocks":[{"type":"rich_text","block_id":"yFur","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"IMO if a user overloads "},{"type":"text","text":"lower","style":{"code":true}},{"type":"text","text":" they should also overload a corresponding deserialization hook, automatically reversing a custom `lower` hook seems...difficult "},{"type":"emoji","name":"stuck_out_tongue"},{"type":"text","text":"\n\nor maybe I'm misunderstanding? do you mean the equivalent of "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":" so that e.g. you'd know to deserialize "},{"type":"text","text":"raw","style":{"code":true}},{"type":"text","text":" as "},{"type":"text","text":"raise(Foo, raw)","style":{"code":true}},{"type":"text","text":" if "},{"type":"text","text":"raw","style":{"code":true}},{"type":"text","text":" was serialized as "},{"type":"text","text":"lower(Foo(...))","style":{"code":true}},{"type":"text","text":"?\n\nseems like some form of registration would still be needed then. From a metadata serialization perspective, it could happen at the same time/place as it does now with the "},{"type":"text","text":"\"JuliaLang.*\"","style":{"code":true}},{"type":"text","text":" extensions we have via "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"F7A8FF4E-6835-45B5-AE52-BD9B75064DCB","type":"message","text":"Sorry, just running out to get food, but I'll hop on later with more thoughts","user":"U681ELA87","ts":"1615682467.432800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"n35+3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry, just running out to get food, but I'll hop on later with more thoughts"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87","reactions":[{"name":"shallow_pan_of_food","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"23251228-c789-4a8d-9b75-3123016bcdcb","type":"message","text":"Hmmmm, looking back over things, it seems like we already do have `arrowconvert` that should go both ways, i.e. be useful for serializing and deserializing","user":"U681ELA87","ts":"1615693329.433600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aKuO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmmmm, looking back over things, it seems like we already do have "},{"type":"text","text":"arrowconvert","style":{"code":true}},{"type":"text","text":" that should go both ways, i.e. be useful for serializing and deserializing"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"1cbfee04-bfa0-4db3-ae49-be6f35b9e291","type":"message","text":"Clearly I need to go back over the whole custom type serial/deserial architecture in Arrow.jl. I can’t even remember all the details.","user":"U681ELA87","ts":"1615693369.433800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6sB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Clearly I need to go back over the whole custom type serial/deserial architecture in Arrow.jl. I can’t even remember all the details."}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"a6745b17-aeaa-40b5-a267-051c1c1ac939","type":"message","text":"Ok, a (little) more thoughtful, spelled out plan for moving custom type serialization/deserialization forward in Arrow.jl: <https://github.com/JuliaData/Arrow.jl/issues/88#issuecomment-798834233>. cc: <@U679T6QF7>","user":"U681ELA87","ts":"1615698687.434000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PuBmW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, a (little) more thoughtful, spelled out plan for moving custom type serialization/deserialization forward in Arrow.jl: "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/issues/88#issuecomment-798834233"},{"type":"text","text":". cc: "},{"type":"user","user_id":"U679T6QF7"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"0a9276eb-3805-485e-9939-bf16ac162f6b","type":"message","text":"My current struggle is we have this weird split between the `ArrowTypes.ArrowType(T)` definitions and `ArrowTypes.registertype!`. They’re both used in different way currently for serializing/deserializing. `registertype!` doesn’t work well for parametric/abstract types, but only concrete. But the `ArrowTypes.ArrowType` approach doesn’t work well for deserializing because at some point, we have to try and go from column metadata as a string to an actual Julia type object, without doing some kind of `@eval` hack. I’m still noodling, but I wonder if there’s a better way to join these two approaches to have a single system for _all_ the type conversions/serializing we do, including all the TimeTypes, which are currently special-cased, and the current set of supported native arrow types.","user":"U681ELA87","ts":"1615701593.434700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SHid","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My current struggle is we have this weird split between the "},{"type":"text","text":"ArrowTypes.ArrowType(T)","style":{"code":true}},{"type":"text","text":" definitions and "},{"type":"text","text":"ArrowTypes.registertype!","style":{"code":true}},{"type":"text","text":". They’re both used in different way currently for serializing/deserializing. "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":" doesn’t work well for parametric/abstract types, but only concrete. But the "},{"type":"text","text":"ArrowTypes.ArrowType","style":{"code":true}},{"type":"text","text":" approach doesn’t work well for deserializing because at some point, we have to try and go from column metadata as a string to an actual Julia type object, without doing some kind of "},{"type":"text","text":"@eval","style":{"code":true}},{"type":"text","text":" hack. I’m still noodling, but I wonder if there’s a better way to join these two approaches to have a single system for "},{"type":"text","text":"all","style":{"italic":true}},{"type":"text","text":" the type conversions/serializing we do, including all the TimeTypes, which are currently special-cased, and the current set of supported native arrow types."}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87","reactions":[{"name":"+1","users":["U6A936746","UDXST8ARK"],"count":2}]}]