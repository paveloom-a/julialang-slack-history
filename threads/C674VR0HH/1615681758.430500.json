[{"client_msg_id":"8d32632d-cf05-4c50-a996-bbc3446bee2a","type":"message","text":"What I haven't quite worked out the details on is still serializing the metadata of the pre-lowered struct so you can still get it back out automatically..","user":"U681ELA87","ts":"1615681758.430500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M4V8B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What I haven't quite worked out the details on is still serializing the metadata of the pre-lowered struct so you can still get it back out automatically.."}]}]}],"thread_ts":"1615681758.430500","reply_count":10,"reply_users_count":2,"latest_reply":"1615847382.461700","reply_users":["U674T0Y9Z","U681ELA87"],"subscribed":false},{"client_msg_id":"5534064d-4dbe-46e3-ae1f-40366111e1b2","type":"message","text":"IMO if a user overloads `lower` they should also overload a corresponding deserialization hook, automatically reversing a custom `lower` hook seems...difficult :stuck_out_tongue:\n\nor maybe I'm misunderstanding? do you mean the equivalent of `registertype!` so that e.g. you'd know to deserialize `raw` as `raise(Foo, raw)` if `raw` was serialized as `lower(Foo(...))`?\n\nseems like some form of registration would still be needed then. From a metadata serialization perspective, it could happen at the same time/place as it does now with the `\"JuliaLang.*\"` extensions we have via `registertype!`?","user":"U674T0Y9Z","ts":"1615682229.430800","team":"T68168MUP","edited":{"user":"U674T0Y9Z","ts":"1615682258.000000"},"blocks":[{"type":"rich_text","block_id":"yFur","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"IMO if a user overloads "},{"type":"text","text":"lower","style":{"code":true}},{"type":"text","text":" they should also overload a corresponding deserialization hook, automatically reversing a custom `lower` hook seems...difficult "},{"type":"emoji","name":"stuck_out_tongue"},{"type":"text","text":"\n\nor maybe I'm misunderstanding? do you mean the equivalent of "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":" so that e.g. you'd know to deserialize "},{"type":"text","text":"raw","style":{"code":true}},{"type":"text","text":" as "},{"type":"text","text":"raise(Foo, raw)","style":{"code":true}},{"type":"text","text":" if "},{"type":"text","text":"raw","style":{"code":true}},{"type":"text","text":" was serialized as "},{"type":"text","text":"lower(Foo(...))","style":{"code":true}},{"type":"text","text":"?\n\nseems like some form of registration would still be needed then. From a metadata serialization perspective, it could happen at the same time/place as it does now with the "},{"type":"text","text":"\"JuliaLang.*\"","style":{"code":true}},{"type":"text","text":" extensions we have via "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"F7A8FF4E-6835-45B5-AE52-BD9B75064DCB","type":"message","text":"Sorry, just running out to get food, but I'll hop on later with more thoughts","user":"U681ELA87","ts":"1615682467.432800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"n35+3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sorry, just running out to get food, but I'll hop on later with more thoughts"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87","reactions":[{"name":"shallow_pan_of_food","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"23251228-c789-4a8d-9b75-3123016bcdcb","type":"message","text":"Hmmmm, looking back over things, it seems like we already do have `arrowconvert` that should go both ways, i.e. be useful for serializing and deserializing","user":"U681ELA87","ts":"1615693329.433600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aKuO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmmmm, looking back over things, it seems like we already do have "},{"type":"text","text":"arrowconvert","style":{"code":true}},{"type":"text","text":" that should go both ways, i.e. be useful for serializing and deserializing"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"1cbfee04-bfa0-4db3-ae49-be6f35b9e291","type":"message","text":"Clearly I need to go back over the whole custom type serial/deserial architecture in Arrow.jl. I can’t even remember all the details.","user":"U681ELA87","ts":"1615693369.433800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6sB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Clearly I need to go back over the whole custom type serial/deserial architecture in Arrow.jl. I can’t even remember all the details."}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"a6745b17-aeaa-40b5-a267-051c1c1ac939","type":"message","text":"Ok, a (little) more thoughtful, spelled out plan for moving custom type serialization/deserialization forward in Arrow.jl: <https://github.com/JuliaData/Arrow.jl/issues/88#issuecomment-798834233>. cc: <@U679T6QF7>","user":"U681ELA87","ts":"1615698687.434000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PuBmW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, a (little) more thoughtful, spelled out plan for moving custom type serialization/deserialization forward in Arrow.jl: "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/issues/88#issuecomment-798834233"},{"type":"text","text":". cc: "},{"type":"user","user_id":"U679T6QF7"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"0a9276eb-3805-485e-9939-bf16ac162f6b","type":"message","text":"My current struggle is we have this weird split between the `ArrowTypes.ArrowType(T)` definitions and `ArrowTypes.registertype!`. They’re both used in different way currently for serializing/deserializing. `registertype!` doesn’t work well for parametric/abstract types, but only concrete. But the `ArrowTypes.ArrowType` approach doesn’t work well for deserializing because at some point, we have to try and go from column metadata as a string to an actual Julia type object, without doing some kind of `@eval` hack. I’m still noodling, but I wonder if there’s a better way to join these two approaches to have a single system for _all_ the type conversions/serializing we do, including all the TimeTypes, which are currently special-cased, and the current set of supported native arrow types.","user":"U681ELA87","ts":"1615701593.434700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SHid","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My current struggle is we have this weird split between the "},{"type":"text","text":"ArrowTypes.ArrowType(T)","style":{"code":true}},{"type":"text","text":" definitions and "},{"type":"text","text":"ArrowTypes.registertype!","style":{"code":true}},{"type":"text","text":". They’re both used in different way currently for serializing/deserializing. "},{"type":"text","text":"registertype!","style":{"code":true}},{"type":"text","text":" doesn’t work well for parametric/abstract types, but only concrete. But the "},{"type":"text","text":"ArrowTypes.ArrowType","style":{"code":true}},{"type":"text","text":" approach doesn’t work well for deserializing because at some point, we have to try and go from column metadata as a string to an actual Julia type object, without doing some kind of "},{"type":"text","text":"@eval","style":{"code":true}},{"type":"text","text":" hack. I’m still noodling, but I wonder if there’s a better way to join these two approaches to have a single system for "},{"type":"text","text":"all","style":{"italic":true}},{"type":"text","text":" the type conversions/serializing we do, including all the TimeTypes, which are currently special-cased, and the current set of supported native arrow types."}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87","reactions":[{"name":"+1","users":["U6A936746","UDXST8ARK","U674T0Y9Z"],"count":3}]},{"client_msg_id":"3bab8321-2426-4df9-ae10-ae59683b5eeb","type":"message","text":"&gt;  But the `ArrowTypes.ArrowType` approach doesn’t work well for deserializing because at some point, we have to try and go from column metadata as a string to an actual Julia type object, without doing some kind of `@eval` hack.\nJust musing but could we make the `*_MAPPING` Dict go from extension string =&gt; Julia function? Basically hiding Julia's \"smart dispatch\" behind a \"dumb dispatch\" tier :grin:\n\nThat way the mapping would be clear/resolvable without `eval` but callers could take advantage of Julia's dispatch for e.g. allowing full use of type parameters","user":"U674T0Y9Z","ts":"1615738153.442300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6dk","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" But the "},{"type":"text","text":"ArrowTypes.ArrowType","style":{"code":true}},{"type":"text","text":" approach doesn’t work well for deserializing because at some point, we have to try and go from column metadata as a string to an actual Julia type object, without doing some kind of "},{"type":"text","text":"@eval","style":{"code":true}},{"type":"text","text":" hack."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nJust musing but could we make the "},{"type":"text","text":"*_MAPPING","style":{"code":true}},{"type":"text","text":" Dict go from extension string => Julia function? Basically hiding Julia's \"smart dispatch\" behind a \"dumb dispatch\" tier "},{"type":"emoji","name":"grin"},{"type":"text","text":"\n\nThat way the mapping would be clear/resolvable without "},{"type":"text","text":"eval","style":{"code":true}},{"type":"text","text":" but callers could take advantage of Julia's dispatch for e.g. allowing full use of type parameters"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"02c1115d-77f3-4754-be16-5f3d6cf89db5","type":"message","text":"I put some thoughts down here and reopened the issue: <https://github.com/JuliaData/Arrow.jl/issues/88#issuecomment-798932283>","user":"U674T0Y9Z","ts":"1615738184.442500","team":"T68168MUP","edited":{"user":"U674T0Y9Z","ts":"1615738190.000000"},"blocks":[{"type":"rich_text","block_id":"TQh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I put some thoughts down here and reopened the issue: "},{"type":"link","url":"https://github.com/JuliaData/Arrow.jl/issues/88#issuecomment-798932283"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"},{"client_msg_id":"180d1962-0390-4450-adcc-7f94a635ef97","type":"message","text":"<@U674T0Y9Z>, for deserialization, what you think about ditching the *_MAPPING Dicts and instead parsing a metadata type name of the form `JuliaLang.UUID` as `(Val(:JuliaLang), Val(:UUID))`, or maybe just `Val(:JuliaLang.UUID)`. so you’d overload something like:\n```function Arrow.ArrowTypes.fromarrow(::Val{:JuliaLang.UUID}, x...)\n\nend```\nwhere `x…` would be the deserialized fields. There’d be generic definitions something like `fromarrow(V, x…) = nothing` and if there’s no overload, then we’d just return a NamedTuple..\n\nOn the serialization side, we’d have:\n• `Arrow.ArrowTypes.toarrow(x) = x`, and `Arrow.ArrowTypes.arrowname(::Type{T})` which would be overloadable for custom types where you’d return the arrow object to serialize, and `arrowname` would be the field metadata type name. By default `arrowname(T) = Symbol()`, so we wouldn’t name it, so you’d only get a NamedTuple out unless you overload. \nMy biggest question then is if this would really work for parametric types. You could serialize using `nameof` in `arrowname`, but then in `fromarrow`, you’d have to be able to build your type. I think it gets awkward if you have non-field-based type parameters that you don’t necessarily want to serialize in `arrowname`, but maybe that’s just a pill you have to swallow. If you can’t infer the type parameters from the data itself, you’ll need to serialize it in the `arrowname` and pull it back out somehow.","user":"U681ELA87","ts":"1615846377.461400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vfQ","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U674T0Y9Z"},{"type":"text","text":", for deserialization, what you think about ditching the *_MAPPING Dicts and instead parsing a metadata type name of the form "},{"type":"text","text":"JuliaLang.UUID","style":{"code":true}},{"type":"text","text":" as "},{"type":"text","text":"(Val(:JuliaLang), Val(:UUID))","style":{"code":true}},{"type":"text","text":", or maybe just "},{"type":"text","text":"Val(:JuliaLang.UUID)","style":{"code":true}},{"type":"text","text":". so you’d overload something like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function Arrow.ArrowTypes.fromarrow(::Val{:JuliaLang.UUID}, x...)\n\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"where "},{"type":"text","text":"x…","style":{"code":true}},{"type":"text","text":" would be the deserialized fields. There’d be generic definitions something like "},{"type":"text","text":"fromarrow(V, x…) = nothing","style":{"code":true}},{"type":"text","text":" and if there’s no overload, then we’d just return a NamedTuple..\n\nOn the serialization side, we’d have:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Arrow.ArrowTypes.toarrow(x) = x","style":{"code":true}},{"type":"text","text":", and "},{"type":"text","text":"Arrow.ArrowTypes.arrowname(::Type{T})","style":{"code":true}},{"type":"text","text":" which would be overloadable for custom types where you’d return the arrow object to serialize, and "},{"type":"text","text":"arrowname","style":{"code":true}},{"type":"text","text":" would be the field metadata type name. By default "},{"type":"text","text":"arrowname(T) = Symbol()","style":{"code":true}},{"type":"text","text":", so we wouldn’t name it, so you’d only get a NamedTuple out unless you overload. "}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"\nMy biggest question then is if this would really work for parametric types. You could serialize using "},{"type":"text","text":"nameof","style":{"code":true}},{"type":"text","text":" in "},{"type":"text","text":"arrowname","style":{"code":true}},{"type":"text","text":", but then in "},{"type":"text","text":"fromarrow","style":{"code":true}},{"type":"text","text":", you’d have to be able to build your type. I think it gets awkward if you have non-field-based type parameters that you don’t necessarily want to serialize in "},{"type":"text","text":"arrowname","style":{"code":true}},{"type":"text","text":", but maybe that’s just a pill you have to swallow. If you can’t infer the type parameters from the data itself, you’ll need to serialize it in the "},{"type":"text","text":"arrowname","style":{"code":true}},{"type":"text","text":" and pull it back out somehow."}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87","reactions":[{"name":"party_wizard","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"82679808-40f4-4ffb-952c-50becb923a75","type":"message","text":"ooohh that feels really elegant from my perspective at least :slightly_smiling_face:\n\n&gt; I think it gets awkward if you have non-field-based type parameters that you don’t necessarily want to serialize in `arrowname`, but maybe that’s just a pill you have to swallow. If you can’t infer the type parameters from the data itself, you’ll need to serialize it in the `arrowname` and pull it back out somehow.\nI'd be perfectly happy to say the burden for deciding how to handle this kind of thing is rests on the serializer/caller. though might be good to construct a toy example just to make sure","user":"U674T0Y9Z","ts":"1615847382.461700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nttO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ooohh that feels really elegant from my perspective at least "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":"\n\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"I think it gets awkward if you have non-field-based type parameters that you don’t necessarily want to serialize in "},{"type":"text","text":"arrowname","style":{"code":true}},{"type":"text","text":", but maybe that’s just a pill you have to swallow. If you can’t infer the type parameters from the data itself, you’ll need to serialize it in the "},{"type":"text","text":"arrowname","style":{"code":true}},{"type":"text","text":" and pull it back out somehow."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI'd be perfectly happy to say the burden for deciding how to handle this kind of thing is rests on the serializer/caller. though might be good to construct a toy example just to make sure"}]}]}],"thread_ts":"1615681758.430500","parent_user_id":"U681ELA87"}]