[{"client_msg_id":"569e3ae4-8017-4157-a830-ae6a4fd22fd5","type":"message","text":"I migrated from Stata to R/Python/Julia and there is a bit of natural data management syntax which I have not been able to find in these languages. That is the end of line `if` within a DataFrame. For example lets say you have variables (columns) `:X` and `:Y`  and you want to create a new column `:Z` but only if `:X` if greater than `:Y` the rest will get `missing` values. In Stata I could write `gen Z = X + Y if X &gt; Y`. Is there something equivalent I could do in Julia. Say `@where!(df, :X &gt; :Y, Z = :X + :Y)` ?\nThis would leave the DataFrame unchanged except in creating the new column `Z`.\nIn Stata such a rule would typically be followed by a rule on how to manage other values such as ``replace Z = X - Y if X &lt; Y``","user":"ULNHYTCJC","ts":"1617168626.332500","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617168849.000000"},"blocks":[{"type":"rich_text","block_id":"dcTsM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I migrated from Stata to R/Python/Julia and there is a bit of natural data management syntax which I have not been able to find in these languages. That is the end of line "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" within a DataFrame. For example lets say you have variables (columns) "},{"type":"text","text":":X","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":":Y","style":{"code":true}},{"type":"text","text":"  and you want to create a new column "},{"type":"text","text":":Z","style":{"code":true}},{"type":"text","text":" but only if "},{"type":"text","text":":X","style":{"code":true}},{"type":"text","text":" if greater than "},{"type":"text","text":":Y","style":{"code":true}},{"type":"text","text":" the rest will get "},{"type":"text","text":"missing","style":{"code":true}},{"type":"text","text":" values. In Stata I could write "},{"type":"text","text":"gen Z = X + Y if X > Y","style":{"code":true}},{"type":"text","text":". Is there something equivalent I could do in Julia. Say "},{"type":"text","text":"@where!(df, :X > :Y, Z = :X + :Y)","style":{"code":true}},{"type":"text","text":" ?\nThis would leave the DataFrame unchanged except in creating the new column "},{"type":"text","text":"Z","style":{"code":true}},{"type":"text","text":".\nIn Stata such a rule would typically be followed by a rule on how to manage other values such as `"},{"type":"text","text":"replace Z = X - Y if X < Y`","style":{"code":true}}]}]}],"thread_ts":"1617168626.332500","reply_count":12,"reply_users_count":5,"latest_reply":"1617249302.350500","reply_users":["ULNHYTCJC","US8V7JSKB","U8JAMQGQY","U7JQGPGCQ","UBF9YRB6H"],"is_locked":false,"subscribed":false,"reactions":[{"name":"+1","users":["UBF9YRB6H"],"count":1}]},{"client_msg_id":"0464ca8a-3b34-4632-aec0-8645283e8a08","type":"message","text":"Backstory, I have a large data Wrangling project with mappings from 15 different databases into a common database structure and I need the syntax to be a readable as possible for working with those with minimal programming experience.","user":"ULNHYTCJC","ts":"1617169014.332800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pJT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Backstory, I have a large data Wrangling project with mappings from 15 different databases into a common database structure and I need the syntax to be a readable as possible for working with those with minimal programming experience."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"26ad7ba6-17b6-4a59-95b6-29ff53a5dced","type":"message","text":"I don’t know about dataframesmeta, but you should able to use the transform function in DataFrames.jl (with `ByRow` )","user":"US8V7JSKB","ts":"1617171602.333000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8s4jG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know about dataframesmeta, but you should able to use the transform function in DataFrames.jl (with "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":" )"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"23231fba-1009-4c33-94e6-5785abf4bc3d","type":"message","text":"`transform!(df, [:X,:Y] =&gt; ByRow((x,y) -&gt; x &lt; y ? x - y : missing =&gt; :Z)`","user":"U8JAMQGQY","ts":"1617173633.333200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XgcF0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"transform!(df, [:X,:Y] => ByRow((x,y) -> x < y ? x - y : missing => :Z)","style":{"code":true}}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["U7JQGPGCQ"],"count":1}]},{"client_msg_id":"7664e94a-6b2b-497c-bfce-b3feba5f64f8","type":"message","text":"or `df.Z = ifelse.(df.X .&gt; df.Y, df.X .+ df.Y, missing)`","user":"U7JQGPGCQ","ts":"1617183845.333600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pco","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or "},{"type":"text","text":"df.Z = ifelse.(df.X .> df.Y, df.X .+ df.Y, missing)","style":{"code":true}}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"90cbb2be-476d-47d7-90df-dc53e9009062","type":"message","text":"Glad you are doing data cleaning and analysis in Julia!\n\nI agree this is a bit of a shortcoming at the moment though.\n\n1. The `ByRow` solution means you can't use the whole column easily, like `mean(x)`\n2. The `ifelse` solution will always materialize both vectors.\n\nPlus both solutions are not ideal with missing values. There has been lots of discussion about this (mostly from economists and stata users) <https://github.com/JuliaData/DataFrames.jl/issues/2211>\n\nI actually really like your `@where` idea, and it's not something I had thought of. Would you mind filing an issue at DataFramesMeta so we can keep track of it?","user":"UBF9YRB6H","ts":"1617206143.334400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QWt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Glad you are doing data cleaning and analysis in Julia!\n\nI agree this is a bit of a shortcoming at the moment though.\n\n1. The "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":" solution means you can't use the whole column easily, like "},{"type":"text","text":"mean(x)","style":{"code":true}},{"type":"text","text":"\n2. The "},{"type":"text","text":"ifelse","style":{"code":true}},{"type":"text","text":" solution will always materialize both vectors.\n\nPlus both solutions are not ideal with missing values. There has been lots of discussion about this (mostly from economists and stata users) "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/issues/2211"},{"type":"text","text":"\n\nI actually really like your "},{"type":"text","text":"@where","style":{"code":true}},{"type":"text","text":" idea, and it's not something I had thought of. Would you mind filing an issue at DataFramesMeta so we can keep track of it?"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["U8JAMQGQY"],"count":1}]},{"client_msg_id":"87f2ca94-1c97-455b-a962-2febc7d20933","type":"message","text":"As a comment `ifelse` will materialize only the final vector","user":"U8JAMQGQY","ts":"1617215113.338800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uam","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As a comment "},{"type":"text","text":"ifelse","style":{"code":true}},{"type":"text","text":" will materialize only the final vector"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"d5189c96-8e89-439d-8a04-959c9687e907","type":"message","text":"I really appreciate everybody's response on this matter. I believe that Julia utilizes syntax in a powerful way more-so than any other language I have used.\n\nHowever, awareness of this kind of easy to read syntax employed by commercial programming languages such as Stata, SAS, or SPSS could be considered important. In my personal experience, working with US Government and economic research thinktanks very few people have the commitment to learning a language if the syntax turns them off.\n\nMy hope would be to write some articles on Data Wrangling that I can pass on to my colleagues to help them get their foot in the door with Julia.\n\nUnfortunately a statement like:`df.Z = ifelse.(df.X .&gt; df.Y, df.X .+ df.Y, missing)` is really a non-starter.","user":"ULNHYTCJC","ts":"1617240409.348200","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617240654.000000"},"blocks":[{"type":"rich_text","block_id":"=ZzT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I really appreciate everybody's response on this matter. I believe that Julia utilizes syntax in a powerful way more-so than any other language I have used.\n\nHowever, awareness of this kind of easy to read syntax employed by commercial programming languages such as Stata, SAS, or SPSS could be considered important. In my personal experience, working with US Government and economic research thinktanks very few people have the commitment to learning a language if the syntax turns them off.\n\nMy hope would be to write some articles on Data Wrangling that I can pass on to my colleagues to help them get their foot in the door with Julia.\n\nUnfortunately a statement like:"},{"type":"text","text":"df.Z = ifelse.(df.X .> df.Y, df.X .+ df.Y, missing)","style":{"code":true}},{"type":"text","text":" is really a non-starter."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"eec9fa61-3d44-4454-b0ac-fbb59d5a78b9","type":"message","text":"I wouldn't be so quick to declare that a non-starter. For one, it's identical to what you would do in R or dplyr, which has pretty wide industry acceptance. Compare\n\n```@transform df z = ifelse.(:X  .&gt; :Y, :X .+ :Y, missing)```\nand\n\n```generate z = x + y if x &gt; y```\nThe `:` is annoying, and the dots, for sure. But those are relatively small prices to pay for using a \"real\" programming language instead of stata.","user":"UBF9YRB6H","ts":"1617241606.348900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CL5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wouldn't be so quick to declare that a non-starter. For one, it's identical to what you would do in R or dplyr, which has pretty wide industry acceptance. Compare\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = ifelse.(:X  .> :Y, :X .+ :Y, missing)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nand\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"generate z = x + y if x > y"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThe "},{"type":"text","text":":","style":{"code":true}},{"type":"text","text":" is annoying, and the dots, for sure. But those are relatively small prices to pay for using a \"real\" programming language instead of stata."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["US8V7JSKB"],"count":1}]},{"client_msg_id":"d8c59fdc-27dd-485b-91de-353865b11f25","type":"message","text":"fwiw. First year Masters in Public Policy student with no programming experience hoping to get a job that involves moderate data analysis skills in government or non-profit sector is the kind of person i think about most when trying to decide what a good API is for DataFramesMeta.","user":"UBF9YRB6H","ts":"1617245190.349400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Nze","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"fwiw. First year Masters in Public Policy student with no programming experience hoping to get a job that involves moderate data analysis skills in government or non-profit sector is the kind of person i think about most when trying to decide what a good API is for DataFramesMeta."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["US8V7JSKB"],"count":1}]},{"client_msg_id":"fd442eb9-48fc-4277-811b-103ea7056b87","type":"message","text":"The thing is `generate` while helpful is complimented to the `replace` command which also takes the trailing `if` syntax. (As for R, it is considered to be a \"difficult\" to learn language with a steep learning curve. I would not aim to make common data transformations much more complex than R if we are hoping for widespread adoption.)\n\nA. My ideal syntax: 56 characters\n```@within df\nz = x * y if x &gt; y\nz = x - y if x &lt;= y\nend\n```\nB. Nearly unreadable syntax: 114 characters\n```df = @transform df z = ifelse.(:X  .&gt;  :Y, :X .* :Y, missing)\n@transform df z = ifelse.(:X  .&lt;= :Y, :X .- :Y, :z)\n```\nI don't like this because most of the syntax is unnecessary eye distractions.\n\nC. Something a little more readable though still cluttered: 104 characters\n```df[!, :z] .= 0.0\n@eachrow df begin \n    (:x &gt; :y) &amp;&amp; (:z = :x * :y)\n    (:x &lt; :y) &amp;&amp; (:z = :x - :y)\nend\n```\nThough I haven't been able to figure out how to start `:z` as missing then map numbers to it. I am sure something to do with types.","user":"ULNHYTCJC","ts":"1617245473.349600","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617247257.000000"},"blocks":[{"type":"rich_text","block_id":"1bVj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The thing is "},{"type":"text","text":"generate","style":{"code":true}},{"type":"text","text":" while helpful is complimented to the "},{"type":"text","text":"replace","style":{"code":true}},{"type":"text","text":" command which also takes the trailing "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" syntax. (As for R, it is considered to be a \"difficult\" to learn language with a steep learning curve. I would not aim to make common data transformations much more complex than R if we are hoping for widespread adoption.)\n\nA. My ideal syntax: 56 characters\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@within df\nz = x * y if x > y\nz = x - y if x <= y\nend\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nB. Nearly unreadable syntax: 114 characters\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df = @transform df z = ifelse.(:X  .>  :Y, :X .* :Y, missing)\n@transform df z = ifelse.(:X  .<= :Y, :X .- :Y, :z)\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I don't like this because most of the syntax is unnecessary eye distractions.\n\nC. Something a little more readable though still cluttered: 104 characters\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df[!, :z] .= 0.0\n@eachrow df begin \n    (:x > :y) && (:z = :x * :y)\n    (:x < :y) && (:z = :x - :y)\nend\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Though I haven't been able to figure out how to start "},{"type":"text","text":":z","style":{"code":true}},{"type":"text","text":" as missing then map numbers to it. I am sure something to do with types."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"5c3f912f-f022-4a50-912b-9d5b4727a58a","type":"message","text":"Can the `@.` help with reducing the number of dots?","user":"US8V7JSKB","ts":"1617248614.350300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ub4XC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can the "},{"type":"text","text":"@.","style":{"code":true}},{"type":"text","text":" help with reducing the number of dots?"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"74cfd458-f5d5-47f9-909e-4417a2113777","type":"message","text":"This is really helpful feedback, I appreciate it. In what follows, I'm going to give some explanation for why things are the way they are, but I don't want to dismiss your concerns. They are totally correct and we should improve the package to make this easier.\n\nw.r.t. `:x` vs `x`. This is something that we have been debating a lot. See here: <https://github.com/JuliaData/DataFramesMeta.jl/issues/168>\n\nUltimately, I there are two problems\n\n1. We want to be able to distinguish between columns in a data frame and outside variables, which `:x` makes very easy. This is not a problem that Stata has, since every reference to `x` is a column in the data and its (relatively) rarer to see a variable that's not a column compared to julia. Though of course Stata has locals.\n2. If we do `x`, we need to make sure we parse everything properly. For example, we need to know that `missing` is a value and not a column named `missing`. This is a hard problem that is to some extent Julia-specific. We don't know know what the names of columns are when DataFramesMeta does all it's stuff (before compile time).\n\nYou might want to try Volcanito.jl, which uses `x` instead of `:x`, but at the cost of using some heuristics that I'm not sure are 100% pinned down.\n\nNext, there is the problem of `x` as scalar vs. `x` as vector. In the snippet below:\n\n```@within df\nz = x * y if x &gt; y\nz = x - y if x &lt;= y\nend```\nWhat if you wanted to call `mean(x)`? You are treating `x` like a scalar above (you can't use `*` on vectors). That's why we have dots everywhere, as DataFramesMeta treats `:x` as a vector. This gives you the flexibility to do `mean(:x)`.\n\nAgain, Volcanito makes a different design choice. It treats `x` as a scalar and requires special syntax to treat `x` as a vector. So you might want to check that out.\n\nIn the future, this problem will probably be solved with the `@byrow` macro so that you would do.\n\n```@transform df z = @byrow :X &lt;= :Y ?  :X .* :Y : missing```\nStill not as simple as you want. And yet another syntax for someone (a bewildered master's student who is encountering programming for the first time and just wants to pass their stats class) to learn. But it's not horrible. At least it tells the reader that things are operating \"by row\".\n\nAnother would be to add an `if` keyword argument to `transform` which might allow\n\n```@transform df z = :X .* :Y @if :X .&lt; :Y```\nThis is totally feasible with some work to `transform` that (I think ) we have an issue tracking. If we end up going with `x` instead of `:X` then we would have\n\n```@transform df z = X .* Y @if X .&lt; Y```\nwhich is basically Stata!\n\nFinally, for `@eachrow` . I agree this is pretty egregious.\n\n```df[!, :z] .= 0.0\n@eachrow df begin \n    (:x &gt; :y) &amp;&amp; (:z = :x * :y)\n    (:x &lt; :y) &amp;&amp; (:z = :x - :y)\nend```\nThe syntax for this currently is\n\n```julia&gt; @eachrow df begin \n       @newcol z::Vector{Union{Float64, Missing}} # ugly\n       :z = :x &gt; :y ? :x * :y : :x - :y\n       end```\nThe `@newcol z::Vector{Union{Float64, Missing}}` is very ugly.\n\nI think this is also fixable. But would probably require writing a new specialized array type. The main reason for this difficulty is, again, we don't know that `:z` is not in the data frame when this code is transformed using metaprogramming. But it's also fixable.\n\nIf these things don't have issues for them already, I will add them tomorrow!\n\nOnce again, glad you are using DataFramesMeta! Thanks for working through these frustrating idiosyncracies while we hammer down the API.","user":"UBF9YRB6H","ts":"1617249302.350500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9fD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is really helpful feedback, I appreciate it. In what follows, I'm going to give some explanation for why things are the way they are, but I don't want to dismiss your concerns. They are totally correct and we should improve the package to make this easier.\n\nw.r.t. "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" vs "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":". This is something that we have been debating a lot. See here: "},{"type":"link","url":"https://github.com/JuliaData/DataFramesMeta.jl/issues/168"},{"type":"text","text":"\n\nUltimately, I there are two problems\n\n1. We want to be able to distinguish between columns in a data frame and outside variables, which "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" makes very easy. This is not a problem that Stata has, since every reference to "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is a column in the data and its (relatively) rarer to see a variable that's not a column compared to julia. Though of course Stata has locals.\n2. If we do "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":", we need to make sure we parse everything properly. For example, we need to know that "},{"type":"text","text":"missing","style":{"code":true}},{"type":"text","text":" is a value and not a column named "},{"type":"text","text":"missing","style":{"code":true}},{"type":"text","text":". This is a hard problem that is to some extent Julia-specific. We don't know know what the names of columns are when DataFramesMeta does all it's stuff (before compile time).\n\nYou might want to try Volcanito.jl, which uses "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":", but at the cost of using some heuristics that I'm not sure are 100% pinned down.\n\nNext, there is the problem of "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as scalar vs. "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as vector. In the snippet below:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@within df\nz = x * y if x > y\nz = x - y if x <= y\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nWhat if you wanted to call "},{"type":"text","text":"mean(x)","style":{"code":true}},{"type":"text","text":"? You are treating "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" like a scalar above (you can't use "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" on vectors). That's why we have dots everywhere, as DataFramesMeta treats "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" as a vector. This gives you the flexibility to do "},{"type":"text","text":"mean(:x)","style":{"code":true}},{"type":"text","text":".\n\nAgain, Volcanito makes a different design choice. It treats "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as a scalar and requires special syntax to treat "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as a vector. So you might want to check that out.\n\nIn the future, this problem will probably be solved with the "},{"type":"text","text":"@byrow","style":{"code":true}},{"type":"text","text":" macro so that you would do.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = @byrow :X <= :Y ?  :X .* :Y : missing"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nStill not as simple as you want. And yet another syntax for someone (a bewildered master's student who is encountering programming for the first time and just wants to pass their stats class) to learn. But it's not horrible. At least it tells the reader that things are operating \"by row\".\n\nAnother would be to add an "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" keyword argument to "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" which might allow\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = :X .* :Y @if :X .< :Y"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThis is totally feasible with some work to "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" that (I think ) we have an issue tracking. If we end up going with "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":":X","style":{"code":true}},{"type":"text","text":" then we would have\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = X .* Y @if X .< Y"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nwhich is basically Stata!\n\nFinally, for "},{"type":"text","text":"@eachrow","style":{"code":true}},{"type":"text","text":" . I agree this is pretty egregious.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df[!, :z] .= 0.0\n@eachrow df begin \n    (:x > :y) && (:z = :x * :y)\n    (:x < :y) && (:z = :x - :y)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThe syntax for this currently is\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @eachrow df begin \n       @newcol z::Vector{Union{Float64, Missing}} # ugly\n       :z = :x > :y ? :x * :y : :x - :y\n       end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThe "},{"type":"text","text":"@newcol z::Vector{Union{Float64, Missing}}","style":{"code":true}},{"type":"text","text":" is very ugly.\n\nI think this is also fixable. But would probably require writing a new specialized array type. The main reason for this difficulty is, again, we don't know that "},{"type":"text","text":":z","style":{"code":true}},{"type":"text","text":" is not in the data frame when this code is transformed using metaprogramming. But it's also fixable.\n\nIf these things don't have issues for them already, I will add them tomorrow!\n\nOnce again, glad you are using DataFramesMeta! Thanks for working through these frustrating idiosyncracies while we hammer down the API."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"heart","users":["U8JAMQGQY"],"count":1}]}]