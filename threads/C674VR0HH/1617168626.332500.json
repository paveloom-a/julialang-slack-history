[{"client_msg_id":"569e3ae4-8017-4157-a830-ae6a4fd22fd5","type":"message","text":"I migrated from Stata to R/Python/Julia and there is a bit of natural data management syntax which I have not been able to find in these languages. That is the end of line `if` within a DataFrame. For example lets say you have variables (columns) `:X` and `:Y`  and you want to create a new column `:Z` but only if `:X` if greater than `:Y` the rest will get `missing` values. In Stata I could write `gen Z = X + Y if X &gt; Y`. Is there something equivalent I could do in Julia. Say `@where!(df, :X &gt; :Y, Z = :X + :Y)` ?\nThis would leave the DataFrame unchanged except in creating the new column `Z`.\nIn Stata such a rule would typically be followed by a rule on how to manage other values such as ``replace Z = X - Y if X &lt; Y``","user":"ULNHYTCJC","ts":"1617168626.332500","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617168849.000000"},"blocks":[{"type":"rich_text","block_id":"dcTsM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I migrated from Stata to R/Python/Julia and there is a bit of natural data management syntax which I have not been able to find in these languages. That is the end of line "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" within a DataFrame. For example lets say you have variables (columns) "},{"type":"text","text":":X","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":":Y","style":{"code":true}},{"type":"text","text":"  and you want to create a new column "},{"type":"text","text":":Z","style":{"code":true}},{"type":"text","text":" but only if "},{"type":"text","text":":X","style":{"code":true}},{"type":"text","text":" if greater than "},{"type":"text","text":":Y","style":{"code":true}},{"type":"text","text":" the rest will get "},{"type":"text","text":"missing","style":{"code":true}},{"type":"text","text":" values. In Stata I could write "},{"type":"text","text":"gen Z = X + Y if X > Y","style":{"code":true}},{"type":"text","text":". Is there something equivalent I could do in Julia. Say "},{"type":"text","text":"@where!(df, :X > :Y, Z = :X + :Y)","style":{"code":true}},{"type":"text","text":" ?\nThis would leave the DataFrame unchanged except in creating the new column "},{"type":"text","text":"Z","style":{"code":true}},{"type":"text","text":".\nIn Stata such a rule would typically be followed by a rule on how to manage other values such as `"},{"type":"text","text":"replace Z = X - Y if X < Y`","style":{"code":true}}]}]}],"thread_ts":"1617168626.332500","reply_count":23,"reply_users_count":6,"latest_reply":"1617435045.384300","reply_users":["ULNHYTCJC","US8V7JSKB","U8JAMQGQY","U7JQGPGCQ","UBF9YRB6H","U9Q2CBDMZ"],"is_locked":false,"subscribed":false,"reactions":[{"name":"+1","users":["UBF9YRB6H"],"count":1}]},{"client_msg_id":"0464ca8a-3b34-4632-aec0-8645283e8a08","type":"message","text":"Backstory, I have a large data Wrangling project with mappings from 15 different databases into a common database structure and I need the syntax to be a readable as possible for working with those with minimal programming experience.","user":"ULNHYTCJC","ts":"1617169014.332800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pJT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Backstory, I have a large data Wrangling project with mappings from 15 different databases into a common database structure and I need the syntax to be a readable as possible for working with those with minimal programming experience."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"26ad7ba6-17b6-4a59-95b6-29ff53a5dced","type":"message","text":"I don’t know about dataframesmeta, but you should able to use the transform function in DataFrames.jl (with `ByRow` )","user":"US8V7JSKB","ts":"1617171602.333000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8s4jG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don’t know about dataframesmeta, but you should able to use the transform function in DataFrames.jl (with "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":" )"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"23231fba-1009-4c33-94e6-5785abf4bc3d","type":"message","text":"`transform!(df, [:X,:Y] =&gt; ByRow((x,y) -&gt; x &lt; y ? x - y : missing =&gt; :Z)`","user":"U8JAMQGQY","ts":"1617173633.333200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XgcF0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"transform!(df, [:X,:Y] => ByRow((x,y) -> x < y ? x - y : missing => :Z)","style":{"code":true}}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["U7JQGPGCQ"],"count":1}]},{"client_msg_id":"7664e94a-6b2b-497c-bfce-b3feba5f64f8","type":"message","text":"or `df.Z = ifelse.(df.X .&gt; df.Y, df.X .+ df.Y, missing)`","user":"U7JQGPGCQ","ts":"1617183845.333600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pco","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"or "},{"type":"text","text":"df.Z = ifelse.(df.X .> df.Y, df.X .+ df.Y, missing)","style":{"code":true}}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"90cbb2be-476d-47d7-90df-dc53e9009062","type":"message","text":"Glad you are doing data cleaning and analysis in Julia!\n\nI agree this is a bit of a shortcoming at the moment though.\n\n1. The `ByRow` solution means you can't use the whole column easily, like `mean(x)`\n2. The `ifelse` solution will always materialize both vectors.\n\nPlus both solutions are not ideal with missing values. There has been lots of discussion about this (mostly from economists and stata users) <https://github.com/JuliaData/DataFrames.jl/issues/2211>\n\nI actually really like your `@where` idea, and it's not something I had thought of. Would you mind filing an issue at DataFramesMeta so we can keep track of it?","user":"UBF9YRB6H","ts":"1617206143.334400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QWt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Glad you are doing data cleaning and analysis in Julia!\n\nI agree this is a bit of a shortcoming at the moment though.\n\n1. The "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":" solution means you can't use the whole column easily, like "},{"type":"text","text":"mean(x)","style":{"code":true}},{"type":"text","text":"\n2. The "},{"type":"text","text":"ifelse","style":{"code":true}},{"type":"text","text":" solution will always materialize both vectors.\n\nPlus both solutions are not ideal with missing values. There has been lots of discussion about this (mostly from economists and stata users) "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/issues/2211"},{"type":"text","text":"\n\nI actually really like your "},{"type":"text","text":"@where","style":{"code":true}},{"type":"text","text":" idea, and it's not something I had thought of. Would you mind filing an issue at DataFramesMeta so we can keep track of it?"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["U8JAMQGQY"],"count":1}]},{"client_msg_id":"87f2ca94-1c97-455b-a962-2febc7d20933","type":"message","text":"As a comment `ifelse` will materialize only the final vector","user":"U8JAMQGQY","ts":"1617215113.338800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uam","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As a comment "},{"type":"text","text":"ifelse","style":{"code":true}},{"type":"text","text":" will materialize only the final vector"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"d5189c96-8e89-439d-8a04-959c9687e907","type":"message","text":"I really appreciate everybody's response on this matter. I believe that Julia utilizes syntax in a powerful way more-so than any other language I have used.\n\nHowever, awareness of this kind of easy to read syntax employed by commercial programming languages such as Stata, SAS, or SPSS could be considered important. In my personal experience, working with US Government and economic research thinktanks very few people have the commitment to learning a language if the syntax turns them off.\n\nMy hope would be to write some articles on Data Wrangling that I can pass on to my colleagues to help them get their foot in the door with Julia.\n\nUnfortunately a statement like:`df.Z = ifelse.(df.X .&gt; df.Y, df.X .+ df.Y, missing)` is really a non-starter.","user":"ULNHYTCJC","ts":"1617240409.348200","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617240654.000000"},"blocks":[{"type":"rich_text","block_id":"=ZzT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I really appreciate everybody's response on this matter. I believe that Julia utilizes syntax in a powerful way more-so than any other language I have used.\n\nHowever, awareness of this kind of easy to read syntax employed by commercial programming languages such as Stata, SAS, or SPSS could be considered important. In my personal experience, working with US Government and economic research thinktanks very few people have the commitment to learning a language if the syntax turns them off.\n\nMy hope would be to write some articles on Data Wrangling that I can pass on to my colleagues to help them get their foot in the door with Julia.\n\nUnfortunately a statement like:"},{"type":"text","text":"df.Z = ifelse.(df.X .> df.Y, df.X .+ df.Y, missing)","style":{"code":true}},{"type":"text","text":" is really a non-starter."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"eec9fa61-3d44-4454-b0ac-fbb59d5a78b9","type":"message","text":"I wouldn't be so quick to declare that a non-starter. For one, it's identical to what you would do in R or dplyr, which has pretty wide industry acceptance. Compare\n\n```@transform df z = ifelse.(:X  .&gt; :Y, :X .+ :Y, missing)```\nand\n\n```generate z = x + y if x &gt; y```\nThe `:` is annoying, and the dots, for sure. But those are relatively small prices to pay for using a \"real\" programming language instead of stata.","user":"UBF9YRB6H","ts":"1617241606.348900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CL5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wouldn't be so quick to declare that a non-starter. For one, it's identical to what you would do in R or dplyr, which has pretty wide industry acceptance. Compare\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = ifelse.(:X  .> :Y, :X .+ :Y, missing)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nand\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"generate z = x + y if x > y"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThe "},{"type":"text","text":":","style":{"code":true}},{"type":"text","text":" is annoying, and the dots, for sure. But those are relatively small prices to pay for using a \"real\" programming language instead of stata."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["US8V7JSKB"],"count":1}]},{"client_msg_id":"d8c59fdc-27dd-485b-91de-353865b11f25","type":"message","text":"fwiw. First year Masters in Public Policy student with no programming experience hoping to get a job that involves moderate data analysis skills in government or non-profit sector is the kind of person i think about most when trying to decide what a good API is for DataFramesMeta.","user":"UBF9YRB6H","ts":"1617245190.349400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Nze","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"fwiw. First year Masters in Public Policy student with no programming experience hoping to get a job that involves moderate data analysis skills in government or non-profit sector is the kind of person i think about most when trying to decide what a good API is for DataFramesMeta."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["US8V7JSKB"],"count":1}]},{"client_msg_id":"fd442eb9-48fc-4277-811b-103ea7056b87","type":"message","text":"The thing is `generate` while helpful is complimented to the `replace` command which also takes the trailing `if` syntax. (As for R, it is considered to be a \"difficult\" to learn language with a steep learning curve. I would not aim to make common data transformations much more complex than R if we are hoping for widespread adoption.)\n\nA. My ideal syntax: 56 characters\n```@within df\nz = x * y if x &gt; y\nz = x - y if x &lt;= y\nend\n```\nB. Nearly unreadable syntax: 114 characters\n```df = @transform df z = ifelse.(:X  .&gt;  :Y, :X .* :Y, missing)\n@transform df z = ifelse.(:X  .&lt;= :Y, :X .- :Y, :z)\n```\nI don't like this because most of the syntax is unnecessary eye distractions.\n\nC. Something a little more readable though still cluttered: 104 characters\n```df[!, :z] .= 0.0\n@eachrow df begin \n    (:x &gt; :y) &amp;&amp; (:z = :x * :y)\n    (:x &lt; :y) &amp;&amp; (:z = :x - :y)\nend\n```\nThough I haven't been able to figure out how to start `:z` as missing then map numbers to it. I am sure something to do with types.","user":"ULNHYTCJC","ts":"1617245473.349600","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617247257.000000"},"blocks":[{"type":"rich_text","block_id":"1bVj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The thing is "},{"type":"text","text":"generate","style":{"code":true}},{"type":"text","text":" while helpful is complimented to the "},{"type":"text","text":"replace","style":{"code":true}},{"type":"text","text":" command which also takes the trailing "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" syntax. (As for R, it is considered to be a \"difficult\" to learn language with a steep learning curve. I would not aim to make common data transformations much more complex than R if we are hoping for widespread adoption.)\n\nA. My ideal syntax: 56 characters\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@within df\nz = x * y if x > y\nz = x - y if x <= y\nend\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nB. Nearly unreadable syntax: 114 characters\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df = @transform df z = ifelse.(:X  .>  :Y, :X .* :Y, missing)\n@transform df z = ifelse.(:X  .<= :Y, :X .- :Y, :z)\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I don't like this because most of the syntax is unnecessary eye distractions.\n\nC. Something a little more readable though still cluttered: 104 characters\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df[!, :z] .= 0.0\n@eachrow df begin \n    (:x > :y) && (:z = :x * :y)\n    (:x < :y) && (:z = :x - :y)\nend\n"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Though I haven't been able to figure out how to start "},{"type":"text","text":":z","style":{"code":true}},{"type":"text","text":" as missing then map numbers to it. I am sure something to do with types."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"5c3f912f-f022-4a50-912b-9d5b4727a58a","type":"message","text":"Can the `@.` help with reducing the number of dots?","user":"US8V7JSKB","ts":"1617248614.350300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ub4XC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can the "},{"type":"text","text":"@.","style":{"code":true}},{"type":"text","text":" help with reducing the number of dots?"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"74cfd458-f5d5-47f9-909e-4417a2113777","type":"message","text":"This is really helpful feedback, I appreciate it. In what follows, I'm going to give some explanation for why things are the way they are, but I don't want to dismiss your concerns. They are totally correct and we should improve the package to make this easier.\n\nw.r.t. `:x` vs `x`. This is something that we have been debating a lot. See here: <https://github.com/JuliaData/DataFramesMeta.jl/issues/168>\n\nUltimately, I there are two problems\n\n1. We want to be able to distinguish between columns in a data frame and outside variables, which `:x` makes very easy. This is not a problem that Stata has, since every reference to `x` is a column in the data and its (relatively) rarer to see a variable that's not a column compared to julia. Though of course Stata has locals.\n2. If we do `x`, we need to make sure we parse everything properly. For example, we need to know that `missing` is a value and not a column named `missing`. This is a hard problem that is to some extent Julia-specific. We don't know know what the names of columns are when DataFramesMeta does all it's stuff (before compile time).\n\nYou might want to try Volcanito.jl, which uses `x` instead of `:x`, but at the cost of using some heuristics that I'm not sure are 100% pinned down.\n\nNext, there is the problem of `x` as scalar vs. `x` as vector. In the snippet below:\n\n```@within df\nz = x * y if x &gt; y\nz = x - y if x &lt;= y\nend```\nWhat if you wanted to call `mean(x)`? You are treating `x` like a scalar above (you can't use `*` on vectors). That's why we have dots everywhere, as DataFramesMeta treats `:x` as a vector. This gives you the flexibility to do `mean(:x)`.\n\nAgain, Volcanito makes a different design choice. It treats `x` as a scalar and requires special syntax to treat `x` as a vector. So you might want to check that out.\n\nIn the future, this problem will probably be solved with the `@byrow` macro so that you would do.\n\n```@transform df z = @byrow :X &lt;= :Y ?  :X .* :Y : missing```\nStill not as simple as you want. And yet another syntax for someone (a bewildered master's student who is encountering programming for the first time and just wants to pass their stats class) to learn. But it's not horrible. At least it tells the reader that things are operating \"by row\".\n\nAnother would be to add an `if` keyword argument to `transform` which might allow\n\n```@transform df z = :X .* :Y @if :X .&lt; :Y```\nThis is totally feasible with some work to `transform` that (I think ) we have an issue tracking. If we end up going with `x` instead of `:X` then we would have\n\n```@transform df z = X .* Y @if X .&lt; Y```\nwhich is basically Stata!\n\nFinally, for `@eachrow` . I agree this is pretty egregious.\n\n```df[!, :z] .= 0.0\n@eachrow df begin \n    (:x &gt; :y) &amp;&amp; (:z = :x * :y)\n    (:x &lt; :y) &amp;&amp; (:z = :x - :y)\nend```\nThe syntax for this currently is\n\n```julia&gt; @eachrow df begin \n       @newcol z::Vector{Union{Float64, Missing}} # ugly\n       :z = :x &gt; :y ? :x * :y : :x - :y\n       end```\nThe `@newcol z::Vector{Union{Float64, Missing}}` is very ugly.\n\nI think this is also fixable. But would probably require writing a new specialized array type. The main reason for this difficulty is, again, we don't know that `:z` is not in the data frame when this code is transformed using metaprogramming. But it's also fixable.\n\nIf these things don't have issues for them already, I will add them tomorrow!\n\nOnce again, glad you are using DataFramesMeta! Thanks for working through these frustrating idiosyncracies while we hammer down the API.","user":"UBF9YRB6H","ts":"1617249302.350500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9fD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is really helpful feedback, I appreciate it. In what follows, I'm going to give some explanation for why things are the way they are, but I don't want to dismiss your concerns. They are totally correct and we should improve the package to make this easier.\n\nw.r.t. "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" vs "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":". This is something that we have been debating a lot. See here: "},{"type":"link","url":"https://github.com/JuliaData/DataFramesMeta.jl/issues/168"},{"type":"text","text":"\n\nUltimately, I there are two problems\n\n1. We want to be able to distinguish between columns in a data frame and outside variables, which "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" makes very easy. This is not a problem that Stata has, since every reference to "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is a column in the data and its (relatively) rarer to see a variable that's not a column compared to julia. Though of course Stata has locals.\n2. If we do "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":", we need to make sure we parse everything properly. For example, we need to know that "},{"type":"text","text":"missing","style":{"code":true}},{"type":"text","text":" is a value and not a column named "},{"type":"text","text":"missing","style":{"code":true}},{"type":"text","text":". This is a hard problem that is to some extent Julia-specific. We don't know know what the names of columns are when DataFramesMeta does all it's stuff (before compile time).\n\nYou might want to try Volcanito.jl, which uses "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":", but at the cost of using some heuristics that I'm not sure are 100% pinned down.\n\nNext, there is the problem of "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as scalar vs. "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as vector. In the snippet below:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@within df\nz = x * y if x > y\nz = x - y if x <= y\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nWhat if you wanted to call "},{"type":"text","text":"mean(x)","style":{"code":true}},{"type":"text","text":"? You are treating "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" like a scalar above (you can't use "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" on vectors). That's why we have dots everywhere, as DataFramesMeta treats "},{"type":"text","text":":x","style":{"code":true}},{"type":"text","text":" as a vector. This gives you the flexibility to do "},{"type":"text","text":"mean(:x)","style":{"code":true}},{"type":"text","text":".\n\nAgain, Volcanito makes a different design choice. It treats "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as a scalar and requires special syntax to treat "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" as a vector. So you might want to check that out.\n\nIn the future, this problem will probably be solved with the "},{"type":"text","text":"@byrow","style":{"code":true}},{"type":"text","text":" macro so that you would do.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = @byrow :X <= :Y ?  :X .* :Y : missing"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nStill not as simple as you want. And yet another syntax for someone (a bewildered master's student who is encountering programming for the first time and just wants to pass their stats class) to learn. But it's not horrible. At least it tells the reader that things are operating \"by row\".\n\nAnother would be to add an "},{"type":"text","text":"if","style":{"code":true}},{"type":"text","text":" keyword argument to "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" which might allow\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = :X .* :Y @if :X .< :Y"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThis is totally feasible with some work to "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" that (I think ) we have an issue tracking. If we end up going with "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" instead of "},{"type":"text","text":":X","style":{"code":true}},{"type":"text","text":" then we would have\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = X .* Y @if X .< Y"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nwhich is basically Stata!\n\nFinally, for "},{"type":"text","text":"@eachrow","style":{"code":true}},{"type":"text","text":" . I agree this is pretty egregious.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df[!, :z] .= 0.0\n@eachrow df begin \n    (:x > :y) && (:z = :x * :y)\n    (:x < :y) && (:z = :x - :y)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThe syntax for this currently is\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @eachrow df begin \n       @newcol z::Vector{Union{Float64, Missing}} # ugly\n       :z = :x > :y ? :x * :y : :x - :y\n       end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThe "},{"type":"text","text":"@newcol z::Vector{Union{Float64, Missing}}","style":{"code":true}},{"type":"text","text":" is very ugly.\n\nI think this is also fixable. But would probably require writing a new specialized array type. The main reason for this difficulty is, again, we don't know that "},{"type":"text","text":":z","style":{"code":true}},{"type":"text","text":" is not in the data frame when this code is transformed using metaprogramming. But it's also fixable.\n\nIf these things don't have issues for them already, I will add them tomorrow!\n\nOnce again, glad you are using DataFramesMeta! Thanks for working through these frustrating idiosyncracies while we hammer down the API."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"heart","users":["U8JAMQGQY"],"count":1}]},{"client_msg_id":"ddd8d56c-d2c5-428e-9a07-8930ba97ce10","type":"message","text":"Am okay with this:\n```@transform df z = @byrow :X &lt;= :Y ?  :X .* :Y : missing```\nThough\n```@eachrow df begin \n@newcol z::Vector{Union{Float64, Missing}}\n    (:x &gt; :y) &amp;&amp; (:z = :x * :y)\n    (:x &lt; :y) &amp;&amp; (:z = :x - :y)\nend```\nIn my opinion is much better. The issue is that most of my teams work involves mapping other people's data.\n\nA: So a real life example similar to what my team is working on.\n```@eachrow safetyDataMerged begin \n    @newcol eventcat::Vector{Union{String, Missing}}\n    (:eventype == \"Personal Safety\")   &amp;&amp; (:eventcat = \"perssafe\")\n    (:eventype == \"Dropped Object\")    &amp;&amp; (:eventcat = \"perssafe, dropped obj\")\n    (:eventype == \"Person Overboard\")  &amp;&amp; (:eventcat = \"perssafe\")\n    (:eventype == \"Object Overboard\")  &amp;&amp; (:eventcat = \"materiallost\")\n    (:firetype == \"Electrical Fire\")   &amp;&amp; (:eventcat = \"fire\")\n    (:firetype == \"Chemical Fire\")     &amp;&amp; (:eventcat = \"fire\")\n\n    @newcol waveHeight::Vector{Union{Number, Missing}}\n    (:wave !== missing)   &amp;&amp; (:waveHeight = :wave)\n\n# etc. etc... for about 150-300 entries per submitting company with 15 companies and more added every so often.\nend```\nOf course in the ideal world (much like Stata) the DataWrangling package would report how many values are mapped after each expression.\n\nIt would be even more readable if I could:\n```map macro then(x,y) \n  return :($x &amp;&amp; $y) \nend ```\nThen we get something like.\n```(:eventype == \"Personal Safety\") @then (:eventcat = \"perssafe\")```\nB: The alternative syntax is quite clunky.\n```@transform safetyDataMerged @newcol eventcat::Vector{Union{String, Missing}} # Assuming this works.\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Personal Safety\"  ?  :eventcat = \"perssafe\"              : :eventype\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Dropped Object\"   ?  :eventcat = \"perssafe, dropped obj\" : :eventype\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Person Overboard\" ?  :eventcat = \"perssafe\"              : :eventype\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Object Overboard\" ?  :eventcat = \"materiallost\"          : :eventype\n@transform safetyDataMerged eventcat = @byrow :firetype == \"Electrical Fire\"  ?  :eventcat = \"fire\"                  : :eventype\n@transform safetyDataMerged eventcat = @byrow :firetype == \"Chemical Fire\"    ?  :eventcat = \"fire\"                  : :eventype\n\n@transform waveHeight::Vector{Union{Number, Missing}}\n@transform safetyDataMerged eventcat = @byrow :wave !== missing ?  :waveHeight = :wave          : :eventype\n\n# etc. etc... for about 150-300 entries per submitting company with 15 companies and more added every so often.```","user":"ULNHYTCJC","ts":"1617289921.360900","team":"T68168MUP","edited":{"user":"ULNHYTCJC","ts":"1617292215.000000"},"blocks":[{"type":"rich_text","block_id":"SX2s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Am okay with this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform df z = @byrow :X <= :Y ?  :X .* :Y : missing"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Though\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@eachrow df begin \n@newcol z::Vector{Union{Float64, Missing}}\n    (:x > :y) && (:z = :x * :y)\n    (:x < :y) && (:z = :x - :y)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"In my opinion is much better. The issue is that most of my teams work involves mapping other people's data.\n\nA: So a real life example similar to what my team is working on.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@eachrow safetyDataMerged begin \n    @newcol eventcat::Vector{Union{String, Missing}}\n    (:eventype == \"Personal Safety\")   && (:eventcat = \"perssafe\")\n    (:eventype == \"Dropped Object\")    && (:eventcat = \"perssafe, dropped obj\")\n    (:eventype == \"Person Overboard\")  && (:eventcat = \"perssafe\")\n    (:eventype == \"Object Overboard\")  && (:eventcat = \"materiallost\")\n    (:firetype == \"Electrical Fire\")   && (:eventcat = \"fire\")\n    (:firetype == \"Chemical Fire\")     && (:eventcat = \"fire\")\n\n    @newcol waveHeight::Vector{Union{Number, Missing}}\n    (:wave !== missing)   && (:waveHeight = :wave)\n\n# etc. etc... for about 150-300 entries per submitting company with 15 companies and more added every so often.\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Of course in the ideal world (much like Stata) the DataWrangling package would report how many values are mapped after each expression.\n\nIt would be even more readable if I could:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"map macro then(x,y) \n  return :($x && $y) \nend "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThen we get something like.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"(:eventype == \"Personal Safety\") @then (:eventcat = \"perssafe\")"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nB: The alternative syntax is quite clunky.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@transform safetyDataMerged @newcol eventcat::Vector{Union{String, Missing}} # Assuming this works.\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Personal Safety\"  ?  :eventcat = \"perssafe\"              : :eventype\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Dropped Object\"   ?  :eventcat = \"perssafe, dropped obj\" : :eventype\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Person Overboard\" ?  :eventcat = \"perssafe\"              : :eventype\n@transform safetyDataMerged eventcat = @byrow :eventype == \"Object Overboard\" ?  :eventcat = \"materiallost\"          : :eventype\n@transform safetyDataMerged eventcat = @byrow :firetype == \"Electrical Fire\"  ?  :eventcat = \"fire\"                  : :eventype\n@transform safetyDataMerged eventcat = @byrow :firetype == \"Chemical Fire\"    ?  :eventcat = \"fire\"                  : :eventype\n\n@transform waveHeight::Vector{Union{Number, Missing}}\n@transform safetyDataMerged eventcat = @byrow :wave !== missing ?  :waveHeight = :wave          : :eventype\n\n# etc. etc... for about 150-300 entries per submitting company with 15 companies and more added every so often."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"beb04535-f259-415b-87e2-49071772b795","type":"message","text":"Thanks. This is a great real-world example. Indeed that example is very verbose.\n\nUnfortunately your `@then`  macro idea doesn't work due to the way Julia parses macros. They can't \"look backwards\", and can't be treated as binary operators.\n\nI'm going to walk through your ugly block and see if we can make it simpler. As I go, I will introduce more Julia constructs that will, of course, make it harder to standardize. I *really* appreciate stata because of it's opinionated and declarative syntax. It makes it a lot easier to maintain a large code base and especially perform \"archaeology\" on old do-files. Doing this in Stata is my part-time job now (as an RA) and was my full time job for 2 years. I've seen it all.\n\nI don't think a simple \"declarative\" style like Stata is going to be the way forward. There are two reasons. One major reason is performance, your `@transform` calls copy the whole data frame each time, (You should use `@transform!` which was only just released.). More importantly, Julia is a functional language and for consistency with the ecosystem as a whole I would want things in blocks, rather than iteratively modifying things.\n\nUnfortunately, this necessitates heavy use of macros and more \"custom\" ways of doing things. This can cause one data-cleaning script to look very different from another, and this sucks! It's hard enough to understand a do-file in Stata. So when we add more macros that make code hard to reason about, we need discipline and documentation to make sure everyone is doing the same thing. We want to make sure there is *one* way of solving a given problem. This has been the success of Stata and *definitely* the success of `dplyr` and the tidyverse.\n\n1. use `Chain.jl` to prevent having to write `safetyDataMerged` over and over again.\n\n```@chain safetyDataMerged begin \n\t@transform evencat = missing # Assuming this works.\n\t@transform eventcat = @byrow :eventype == \"Personal Safety\"  ?  :eventcat = \"perssafe\"              : :eventype\n\t@transform eventcat = @byrow :eventype == \"Dropped Object\"   ?  :eventcat = \"perssafe, dropped obj\" : :eventype\n\t@transform eventcat = @byrow :eventype == \"Person Overboard\" ?  :eventcat = \"perssafe\"              : :eventype\n\t@transform eventcat = @byrow :eventype == \"Object Overboard\" ?  :eventcat = \"materiallost\"          : :eventype\nend```\n2. Use `map` to do this all in one step\n\n```@chain safetyDataMerged begin \n\t@transform evencat = map(:eventype) do e # New construct, `map`. Do Stata users need it?\n\t\te == missing ? \n\t\t\tmissing :\n\t\te == \"PersonalSafety\" ? \n\t\t\t\"perssafe\" :\n\t\te == \"Dropped Object\" ?\n\t\t\t\"perssafe, dropped obj\" :\n\t\te == \"Person overboard\" ? \n\t\t\t\"perssafe\" :\n\t\te == \"Object overboard\" ? \n\t\t\t\"materiallost\"\n\tend\nend```\n3 Use `@match` from Match.jl\n\n```@chain safetyDataMerged begin \n\t@transform evencat = @byrow @match :eventtype begin \n\t\t\tmissing =&gt; missing \n\t\t\t\"PersonalSafety\" =&gt; \"perssage\"\n\t\t\t\"Dropped Object\" =&gt; \"perssage, droppedobj\"\n\t\t\t\"Person overboard\" =&gt; \"perssafe\"\n\t\t\t\"Object overboard\" =&gt; \"materiallost\" # this can go one forever\n\t\tend\n\tend\nend```\nCan I force people to use Match? Is it really simple and maintained enough for me to pitch is as *the* solution for this kind of problem? I don't know. Maybe with new tutorials and documentation.","user":"UBF9YRB6H","ts":"1617292661.361800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oCdde","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks. This is a great real-world example. Indeed that example is very verbose.\n\nUnfortunately your "},{"type":"text","text":"@then","style":{"code":true}},{"type":"text","text":"  macro idea doesn't work due to the way Julia parses macros. They can't \"look backwards\", and can't be treated as binary operators.\n\nI'm going to walk through your ugly block and see if we can make it simpler. As I go, I will introduce more Julia constructs that will, of course, make it harder to standardize. I "},{"type":"text","text":"really","style":{"bold":true}},{"type":"text","text":" appreciate stata because of it's opinionated and declarative syntax. It makes it a lot easier to maintain a large code base and especially perform \"archaeology\" on old do-files. Doing this in Stata is my part-time job now (as an RA) and was my full time job for 2 years. I've seen it all.\n\nI don't think a simple \"declarative\" style like Stata is going to be the way forward. There are two reasons. One major reason is performance, your "},{"type":"text","text":"@transform","style":{"code":true}},{"type":"text","text":" calls copy the whole data frame each time, (You should use "},{"type":"text","text":"@transform!","style":{"code":true}},{"type":"text","text":" which was only just released.). More importantly, Julia is a functional language and for consistency with the ecosystem as a whole I would want things in blocks, rather than iteratively modifying things.\n\nUnfortunately, this necessitates heavy use of macros and more \"custom\" ways of doing things. This can cause one data-cleaning script to look very different from another, and this sucks! It's hard enough to understand a do-file in Stata. So when we add more macros that make code hard to reason about, we need discipline and documentation to make sure everyone is doing the same thing. We want to make sure there is "},{"type":"text","text":"one","style":{"bold":true}},{"type":"text","text":" way of solving a given problem. This has been the success of Stata and "},{"type":"text","text":"definitely","style":{"bold":true}},{"type":"text","text":" the success of "},{"type":"text","text":"dplyr","style":{"code":true}},{"type":"text","text":" and the tidyverse.\n\n1. use "},{"type":"text","text":"Chain.jl","style":{"code":true}},{"type":"text","text":" to prevent having to write "},{"type":"text","text":"safetyDataMerged","style":{"code":true}},{"type":"text","text":" over and over again.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@chain safetyDataMerged begin \n\t@transform evencat = missing # Assuming this works.\n\t@transform eventcat = @byrow :eventype == \"Personal Safety\"  ?  :eventcat = \"perssafe\"              : :eventype\n\t@transform eventcat = @byrow :eventype == \"Dropped Object\"   ?  :eventcat = \"perssafe, dropped obj\" : :eventype\n\t@transform eventcat = @byrow :eventype == \"Person Overboard\" ?  :eventcat = \"perssafe\"              : :eventype\n\t@transform eventcat = @byrow :eventype == \"Object Overboard\" ?  :eventcat = \"materiallost\"          : :eventype\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n2. Use "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":" to do this all in one step\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@chain safetyDataMerged begin \n\t@transform evencat = map(:eventype) do e # New construct, `map`. Do Stata users need it?\n\t\te == missing ? \n\t\t\tmissing :\n\t\te == \"PersonalSafety\" ? \n\t\t\t\"perssafe\" :\n\t\te == \"Dropped Object\" ?\n\t\t\t\"perssafe, dropped obj\" :\n\t\te == \"Person overboard\" ? \n\t\t\t\"perssafe\" :\n\t\te == \"Object overboard\" ? \n\t\t\t\"materiallost\"\n\tend\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n3 Use "},{"type":"text","text":"@match","style":{"code":true}},{"type":"text","text":" from Match.jl\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@chain safetyDataMerged begin \n\t@transform evencat = @byrow @match :eventtype begin \n\t\t\tmissing => missing \n\t\t\t\"PersonalSafety\" => \"perssage\"\n\t\t\t\"Dropped Object\" => \"perssage, droppedobj\"\n\t\t\t\"Person overboard\" => \"perssafe\"\n\t\t\t\"Object overboard\" => \"materiallost\" # this can go one forever\n\t\tend\n\tend\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nCan I force people to use Match? Is it really simple and maintained enough for me to pitch is as "},{"type":"text","text":"the","style":{"bold":true}},{"type":"text","text":" solution for this kind of problem? I don't know. Maybe with new tutorials and documentation."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"6a55c521-c512-45d5-bd0d-c7620d34260c","type":"message","text":"Oh also, a `replace` macro is totally feasible and would make this declarative style a lot easier. <https://github.com/JuliaData/DataFramesMeta.jl/issues/144>","user":"UBF9YRB6H","ts":"1617292947.362000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7d3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh also, a "},{"type":"text","text":"replace","style":{"code":true}},{"type":"text","text":" macro is totally feasible and would make this declarative style a lot easier. "},{"type":"link","url":"https://github.com/JuliaData/DataFramesMeta.jl/issues/144"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"f4fd4a2a-8a9b-45c8-b2cf-a28f991d525b","type":"message","text":"I'll get back to this. But the above `@match` solution looks quite helpful.","user":"ULNHYTCJC","ts":"1617293200.362200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EaliT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'll get back to this. But the above "},{"type":"text","text":"@match","style":{"code":true}},{"type":"text","text":" solution looks quite helpful."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"7ffca2ed-4fad-4478-8383-0ee75bf47ea9","type":"message","text":"Please file an issue in DataFramesMeta with your thoughts! Would hate to have this lost in the slack hole.\n\nAn outline of your current struggles and the Stata equivalents would be excellent.","user":"UBF9YRB6H","ts":"1617293274.362400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XoXb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Please file an issue in DataFramesMeta with your thoughts! Would hate to have this lost in the slack hole.\n\nAn outline of your current struggles and the Stata equivalents would be excellent."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"bcaef0e7-2149-4276-9447-5f7b02ff16a5","type":"message","text":"Another way to do this with map (which is my preferred style) is something like\n```@chain safetyDataMerged begin \n\t@transform evencat = map(:eventype) do e # New construct, `map`. Do Stata users need it?\n\t\te == missing             &amp;&amp; return missing \n\t\te == \"PersonalSafety\"    &amp;&amp; return \"perssafe\"\n\t\te == \"Dropped Object\"    &amp;&amp; return \"perssafe, dropped obj\" \n\t\te == \"Person overboard\"  &amp;&amp; return \"perssafe\" \n\t\te == \"Object overboard\"  &amp;&amp; return \"materiallost\"\n\tend\nend```\nIt's a bit more verbose, than stata, but not a lot.  I also find that the explicit `return` statements make things very readable","user":"U9Q2CBDMZ","ts":"1617308299.368100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nfqQd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Another way to do this with map (which is my preferred style) is something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@chain safetyDataMerged begin \n\t@transform evencat = map(:eventype) do e # New construct, `map`. Do Stata users need it?\n\t\te == missing             && return missing \n\t\te == \"PersonalSafety\"    && return \"perssafe\"\n\t\te == \"Dropped Object\"    && return \"perssafe, dropped obj\" \n\t\te == \"Person overboard\"  && return \"perssafe\" \n\t\te == \"Object overboard\"  && return \"materiallost\"\n\tend\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"It's a bit more verbose, than stata, but not a lot.  I also find that the explicit "},{"type":"text","text":"return","style":{"code":true}},{"type":"text","text":" statements make things very readable"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"037681aa-43db-4eac-a6a1-c509cc9c9d27","type":"message","text":"I find myself doing a lot of data wrangling in julia, and whenever I have to remap a large number of codes, this is the style that I have settled on.  I've generally been very happy with it","user":"U9Q2CBDMZ","ts":"1617308387.368300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vfy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I find myself doing a lot of data wrangling in julia, and whenever I have to remap a large number of codes, this is the style that I have settled on.  I've generally been very happy with it"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["UBF9YRB6H","US8V7JSKB"],"count":2}]},{"client_msg_id":"3526b531-033e-49b5-92d2-4aa2d3db816e","type":"message","text":"also note: by putting a plain `return missing` at the end, you get the same behavior as stata, where any unhandled cases are set as missing values","user":"U9Q2CBDMZ","ts":"1617308510.368600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xkqh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"also note: by putting a plain "},{"type":"text","text":"return missing","style":{"code":true}},{"type":"text","text":" at the end, you get the same behavior as stata, where any unhandled cases are set as missing values"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"a03179c4-17a7-4da9-bb4c-ebb7edaca9ba","type":"message","text":"Also I think `Match` doesn't work with missing values, unfortunately\n\n```julia&gt; x = [1, 2, 3, missing]\n4-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 3\n  missing\n\njulia&gt; map(x) do xi\n           @match xi begin \n               missing =&gt; 4\n           end\n       end\n4-element Vector{Int64}:\n 4\n 4\n 4\n 4```","user":"UBF9YRB6H","ts":"1617308669.368800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vt6c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also I think "},{"type":"text","text":"Match","style":{"code":true}},{"type":"text","text":" doesn't work with missing values, unfortunately\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> x = [1, 2, 3, missing]\n4-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 3\n  missing\n\njulia> map(x) do xi\n           @match xi begin \n               missing => 4\n           end\n       end\n4-element Vector{Int64}:\n 4\n 4\n 4\n 4"}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"209e238a-5402-499f-aadf-dfd617a63f94","type":"message","text":"What about adding a method: DataFrames.transforms(x::Dataframe, y::bitarray, args...) Which allows a view of x to be acted on. This would allow for a macro, @gen/@replace df @if(bit array expression) args... \n\nWe could make the macro smart and not care where the @if appears. Of course my ideal would be to \"attach\" single Dataframes at a time so that subsequent commands Did not need to specify a name of a Dataframe when using certain macros.","user":"ULNHYTCJC","ts":"1617428289.384000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3052","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What about adding a method: DataFrames.transforms(x::Dataframe, y::bitarray, args...) Which allows a view of x to be acted on. This would allow for a macro, @gen/@replace df @if(bit array expression) args... \n\nWe could make the macro smart and not care where the @if appears. Of course my ideal would be to \"attach\" single Dataframes at a time so that subsequent commands Did not need to specify a name of a Dataframe when using certain macros."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC"},{"client_msg_id":"a2b65dca-9868-45dd-80ba-48b0cf616da2","type":"message","text":"This has been discussed as a `where` keyword argument. However, implementing it in a fully general way is difficult and it will be discussed after 1.0 release.","user":"U8JAMQGQY","ts":"1617435045.384300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t215","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This has been discussed as a "},{"type":"text","text":"where","style":{"code":true}},{"type":"text","text":" keyword argument. However, implementing it in a fully general way is difficult and it will be discussed after 1.0 release."}]}]}],"thread_ts":"1617168626.332500","parent_user_id":"ULNHYTCJC","reactions":[{"name":"+1","users":["UBF9YRB6H"],"count":1}]}]