[{"client_msg_id":"a732e621-a6f4-4e05-9766-53e5a3741123","type":"message","text":"I'm trying to document some nice DataFrames-based patterns for manipulating <https://github.com/beacon-biosignals/Onda.jl|Onda> tabular data and am looking for a concise/performant way to express the following operation:\n\n```\"\"\"\n    f(df)::DataFrame\n\nReturns the rows for which `y - x` is largest in `groupby(df, :id)`\n\"\"\"\nfunction f(df)\n    groups = groupby(transform(df, [:x, :y] =&gt; ((x, y) -&gt; y .- x) =&gt; :n), :id)\n    return DataFrame(map(group -&gt; first(sort(group, :n)), groups))\nend\n\nid = rand(1:10, 100)\nx = rand(0:100, 100)\ny = x .+ rand(0:100, 100)\nz = rand('a':'z', 100)\ndf = DataFrame(; id, x, y, z)\nf(df)```\nI feel like my `f` here is pretty ugly/slow compared to the \"right\" solution :grin:\n\n(my specific use case is grabbing the longest signal in a recording, but I've abstracted that away here for the sake of example)","user":"U674T0Y9Z","ts":"1609877723.335100","team":"T68168MUP","edited":{"user":"U674T0Y9Z","ts":"1609877741.000000"},"blocks":[{"type":"rich_text","block_id":"g2RLL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm trying to document some nice DataFrames-based patterns for manipulating "},{"type":"link","url":"https://github.com/beacon-biosignals/Onda.jl","text":"Onda"},{"type":"text","text":" tabular data and am looking for a concise/performant way to express the following operation:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\"\"\"\n    f(df)::DataFrame\n\nReturns the rows for which `y - x` is largest in `groupby(df, :id)`\n\"\"\"\nfunction f(df)\n    groups = groupby(transform(df, [:x, :y] => ((x, y) -> y .- x) => :n), :id)\n    return DataFrame(map(group -> first(sort(group, :n)), groups))\nend\n\nid = rand(1:10, 100)\nx = rand(0:100, 100)\ny = x .+ rand(0:100, 100)\nz = rand('a':'z', 100)\ndf = DataFrame(; id, x, y, z)\nf(df)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI feel like my `f` here is pretty ugly/slow compared to the \"right\" solution "},{"type":"emoji","name":"grin"},{"type":"text","text":"\n\n(my specific use case is grabbing the longest signal in a recording, but I've abstracted that away here for the sake of example)"}]}]}],"thread_ts":"1609877723.335100","reply_count":9,"reply_users_count":4,"latest_reply":"1609880308.337500","reply_users":["U67431ELR","U680THK2S","U8JAMQGQY","U674T0Y9Z"],"subscribed":false},{"client_msg_id":"d6c92eee-7668-46a5-ac5c-26a66b223e7a","type":"message","text":"Maybe something like this? `res = select(groupby(df, :id), [:x, :y] =&gt; ((x, y) -&gt; eachindex(x) .== argmax(y .- x)) =&gt; :keep); df[res.keep, :]` .","user":"U67431ELR","ts":"1609878445.335300","team":"T68168MUP","edited":{"user":"U67431ELR","ts":"1609878662.000000"},"blocks":[{"type":"rich_text","block_id":"dEBP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe something like this? "},{"type":"text","text":"res = select(groupby(df, :id), [:x, :y] => ((x, y) -> eachindex(x) .== argmax(y .- x)) => :keep); df[res.keep, :]","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z","reactions":[{"name":"heart","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"3394f7b1-ce09-4277-bcef-e215454ea518","type":"message","text":"I guess in the last step in that you'd want `df[res.keep, Not(:keep)]`?","user":"U680THK2S","ts":"1609878852.335600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X/Z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess in the last step in that you'd want "},{"type":"text","text":"df[res.keep, Not(:keep)]","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"ff944037-4335-468c-bb2b-9c561ac839a5","type":"message","text":"It would not keep all the rows that should be kept. This is what I think is a relatively concise and correct solution:\n```f2(df) = combine(groupby(df, :id)) do sdf            \n    z = sdf.x - sdf.y                                \n    return view(sdf, findall(==(maximum(z)), z), :)  \nend                                                  ```\n(<@U674T0Y9Z> - also your solution is incorrect if you want to keep all rows that are matching per-group maximum)","user":"U8JAMQGQY","ts":"1609879392.335800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"veBK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It would not keep all the rows that should be kept. This is what I think is a relatively concise and correct solution:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"f2(df) = combine(groupby(df, :id)) do sdf            \n    z = sdf.x - sdf.y                                \n    return view(sdf, findall(==(maximum(z)), z), :)  \nend                                                  "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"("},{"type":"user","user_id":"U674T0Y9Z"},{"type":"text","text":" - also your solution is incorrect if you want to keep all rows that are matching per-group maximum)"}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z","reactions":[{"name":"heart","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"8bfe1dca-58d3-4558-a3bb-ed2337a6fc69","type":"message","text":"if you want to keep just one row per group (and in case of ties picking the first row that meets the maximum condition) then do e.g.:\n```combine(sdf -&gt; sdf[argmax(sdf.y .- sdf.y), :], groupby(df, :id))```\n","user":"U8JAMQGQY","ts":"1609879531.336000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YH9UF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you want to keep just one row per group (and in case of ties picking the first row that meets the maximum condition) then do e.g.:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"combine(sdf -> sdf[argmax(sdf.y .- sdf.y), :], groupby(df, :id))"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z","reactions":[{"name":"heart","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"a29bf892-08e9-4b21-8308-53c76f8a1541","type":"message","text":"(here I am showing concise implementations; if you are really pressed with performance then more complex patterns could be used similar to what <@U67431ELR> proposed)","user":"U8JAMQGQY","ts":"1609879599.336200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zHK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(here I am showing concise implementations; if you are really pressed with performance then more complex patterns could be used similar to what "},{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" proposed)"}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z","reactions":[{"name":"+1","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"17ff49fb-aff9-4820-8eb6-53f9a9f9ea68","type":"message","text":"What would you consider \"best practice,\" or what you would show e.g. a student who isn't intimately familiar with the DataFrames API?","user":"U680THK2S","ts":"1609879698.336400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"quFDs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What would you consider \"best practice,\" or what you would show e.g. a student who isn't intimately familiar with the DataFrames API?"}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"03407188-a29d-4ac9-8463-d585bab5dc63","type":"message","text":"I would consider a \"best practice\" to show the `combine(function, grouped_data_frame)` API to start (what I have shown). It is easiest to explain to someone who knows `map`. Then one can introduce `src =&gt; fun =&gt; dst` pattern as: a) more flexible, b) faster.","user":"U8JAMQGQY","ts":"1609879805.336600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1ENS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would consider a \"best practice\" to show the "},{"type":"text","text":"combine(function, grouped_data_frame)","style":{"code":true}},{"type":"text","text":" API to start (what I have shown). It is easiest to explain to someone who knows "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":". Then one can introduce "},{"type":"text","text":"src => fun => dst","style":{"code":true}},{"type":"text","text":" pattern as: a) more flexible, b) faster."}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z","reactions":[{"name":"heart","users":["U680THK2S","U674T0Y9Z"],"count":2}]},{"client_msg_id":"2691db3f-b1fc-4558-9e51-b46b0013e28d","type":"message","text":"This is exactly the reason I thought of keeping this API (also it is the legacy API, which means that it came to the minds of DataFrames.jl creators first)","user":"U8JAMQGQY","ts":"1609879857.336900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rrBnO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is exactly the reason I thought of keeping this API (also it is the legacy API, which means that it came to the minds of DataFrames.jl creators first)"}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z"},{"client_msg_id":"144d7246-566e-4920-9f02-ccfb25fc39dd","type":"message","text":"&gt;  if you want to keep just one row per group (and in case of ties picking the first row that meets the maximum condition)\nyup!\n\nThanks ya'll, this is super helpful :slightly_smiling_face: the `combine` approach seems nicest for intro docs purposes, and can also show the `select`-based approach afterward as an alternative","user":"U674T0Y9Z","ts":"1609880308.337500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xygt","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":" if you want to keep just one row per group (and in case of ties picking the first row that meets the maximum condition)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nyup!\n\nThanks ya'll, this is super helpful "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":" the "},{"type":"text","text":"combine","style":{"code":true}},{"type":"text","text":" approach seems nicest for intro docs purposes, and can also show the "},{"type":"text","text":"select","style":{"code":true}},{"type":"text","text":"-based approach afterward as an alternative"}]}]}],"thread_ts":"1609877723.335100","parent_user_id":"U674T0Y9Z","reactions":[{"name":"+1","users":["U680THK2S","U8JAMQGQY"],"count":2}]}]