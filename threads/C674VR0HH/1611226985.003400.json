[{"client_msg_id":"51905396-ee1f-4062-8d7d-43320ef5c455","type":"message","text":"Are there packages similar to Query.jl but with less \"macro magic\"? I mean manipulation of table-like objects (mostly Vector{NamedTuple}) such as examples at <https://www.queryverse.org/Query.jl/stable/standalonequerycommands/>.","user":"UGTUKUHLN","ts":"1611226985.003400","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611227156.000000"},"blocks":[{"type":"rich_text","block_id":"pV0v","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Are there packages similar to Query.jl but with less \"macro magic\"? I mean manipulation of table-like objects (mostly Vector{NamedTuple}) such as examples at "},{"type":"link","url":"https://www.queryverse.org/Query.jl/stable/standalonequerycommands/"},{"type":"text","text":"."}]}]}],"thread_ts":"1611226985.003400","reply_count":42,"reply_users_count":8,"latest_reply":"1611349416.032200","reply_users":["UBF9YRB6H","U01GXNFKY6R","U681ELA87","UGTUKUHLN","U6A936746","UDGT4PM41","U01JRKTSL2U","U68UUUFPS"],"subscribed":false},{"client_msg_id":"2a6426c7-98b1-4091-98b9-dc0e0adb7a19","type":"message","text":"DataFramesMeta is one. There is a lot less macro magic, but still some.\n\nAlso just base DataFrames is very strong for manipulating tabular data.\n\nBut neither of these works lazily with vectors of named tuples.","user":"UBF9YRB6H","ts":"1611240061.003600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pha=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFramesMeta is one. There is a lot less macro magic, but still some.\n\nAlso just base DataFrames is very strong for manipulating tabular data.\n\nBut neither of these works lazily with vectors of named tuples."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"7550463a-c03e-4446-81db-0a0222f37676","type":"message","text":"Are you familiar with DataFrames?","user":"U01GXNFKY6R","ts":"1611240208.004000","team":"T68168MUP","edited":{"user":"U01GXNFKY6R","ts":"1611240220.000000"},"blocks":[{"type":"rich_text","block_id":"KsgMB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Are you familiar with DataFrames?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"6FC4812B-BDE4-478F-A94F-D4DDB9379CC4","type":"message","text":"TableOperations.jl has some of the same functionality, but not everything Query has. It would be a good up for grabs project if someone wanted to fill in the missing gaps","user":"U681ELA87","ts":"1611241311.006100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"poJTh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"TableOperations.jl has some of the same functionality, but not everything Query has. It would be a good up for grabs project if someone wanted to fill in the missing gaps"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"fc1246aa-5a18-4b21-86b8-a0a27b62e1b6","type":"message","text":"DataFrames are convenient only for the case of \"flat\" tables, while named tuples are way more general. Also the dataframes ecosystem doesn't seem to play well with regular data structures like dicts. I typically have code like `data |&gt; @filter(_.a.b &gt; 1 || f1(_.a, _.c.c)) |&gt; @map((; _.a..., d=_.c.c))) |&gt; @groupby(_.b[1]) |&gt; @map(key(_) =&gt; mean(_.d)) |&gt; Dict` , and didn't manage to reasonably rewrite it in \"dataframes way\" when I tried.","user":"UGTUKUHLN","ts":"1611242791.006300","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611242984.000000"},"blocks":[{"type":"rich_text","block_id":"TadF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFrames are convenient only for the case of \"flat\" tables, while named tuples are way more general. Also the dataframes ecosystem doesn't seem to play well with regular data structures like dicts. I typically have code like "},{"type":"text","text":"data |> @filter(_.a.b > 1 || f1(_.a, _.c.c)) |> @map((; _.a..., d=_.c.c))) |> @groupby(_.b[1]) |> @map(key(_) => mean(_.d)) |> Dict","style":{"code":true}},{"type":"text","text":" , and didn't manage to reasonably rewrite it in \"dataframes way\" when I tried."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"29102f7b-e714-43fa-a984-5854c144454c","type":"message","text":"SplitApplyCombine.jl may also be an option.","user":"U6A936746","ts":"1611242872.006600","team":"T68168MUP","edited":{"user":"U6A936746","ts":"1611243057.000000"},"blocks":[{"type":"rich_text","block_id":"EcG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"SplitApplyCombine.jl may also be an option."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"006bc077-c6f2-44df-8fe2-993a10d39cf5","type":"message","text":"<@U68UUUFPS> has told me that it is actually possibly to use `Query.jl` without most of the macros.\nThough I might have misunderstood.","user":"U6A936746","ts":"1611242908.006800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L8d6","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U68UUUFPS"},{"type":"text","text":" has told me that it is actually possibly to use "},{"type":"text","text":"Query.jl","style":{"code":true}},{"type":"text","text":" without most of the macros.\nThough I might have misunderstood."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"6dfc8c12-db25-4bc1-8a4d-8d7b7dcb0251","type":"message","text":"Looks like SplitApplyCombine together with a pipe macro can be an alternative...","user":"UGTUKUHLN","ts":"1611243169.007300","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611243186.000000"},"blocks":[{"type":"rich_text","block_id":"HjK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Looks like SplitApplyCombine together with a pipe macro can be an alternative..."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"a4f4852f-1d62-41ad-8db6-f7b0a1cbfa91","type":"message","text":"Everything up until the `Dict` part is super easy to do in DataFramesMeta. How are named tuples more general, exactly?","user":"UBF9YRB6H","ts":"1611243421.007600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L/M","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Everything up until the "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":" part is super easy to do in DataFramesMeta. How are named tuples more general, exactly?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"cb4719ad-12f1-4a3e-8569-1313ec6937a4","type":"message","text":"ah, the nested structure, I see. Yeah with DataFrames you would want tidy data generally, though with ByRow that's all very feasible","user":"UBF9YRB6H","ts":"1611243501.007800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"n0x","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah, the nested structure, I see. Yeah with DataFrames you would want tidy data generally, though with ByRow that's all very feasible"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"5655d6e0-cd05-4372-bdca-64b45486d432","type":"message","text":"if you post an MWE I would be happy to try and write some code in DataFrames and DataFramesMeta that works well","user":"UBF9YRB6H","ts":"1611243537.008000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sPn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you post an MWE I would be happy to try and write some code in DataFrames and DataFramesMeta that works well"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"32d3c564-1ff7-408f-9f65-6168283a1a7e","type":"message","text":"Data manipulation in julia was like a breath of fresh air after having to fit into a flat structure of pandas. Nested structure is very convenient, and I didn't find a simple way to do that in dataframes. Didn't look into DataFrames*Meta* yet","user":"UGTUKUHLN","ts":"1611243647.008200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yKTFW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Data manipulation in julia was like a breath of fresh air after having to fit into a flat structure of pandas. Nested structure is very convenient, and I didn't find a simple way to do that in dataframes. Didn't look into DataFrames"},{"type":"text","text":"Meta","style":{"bold":true}},{"type":"text","text":" yet"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"b6b749c5-af04-47d1-af34-f54e2cf8a21d","type":"message","text":"DataFramesMeta might be hard because currently things only act on Vectors, whereas it looks like query acts by row. We need to add a `@ByRow` macro for making broadcasting easier.\n\nThat said, base DataFrames allows for that and it's very very powerful. just construct anonymous functions and you will be good to go","user":"UBF9YRB6H","ts":"1611243755.008400","team":"T68168MUP","edited":{"user":"UBF9YRB6H","ts":"1611243762.000000"},"blocks":[{"type":"rich_text","block_id":"gnBQf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFramesMeta might be hard because currently things only act on Vectors, whereas it looks like query acts by row. We need to add a "},{"type":"text","text":"@ByRow","style":{"code":true}},{"type":"text","text":" macro for making broadcasting easier.\n\nThat said, base DataFrames allows for that and it's very very powerful. just construct anonymous functions and you will be good to go"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"0a0219cc-ef23-41ec-ab55-69ad2a24407f","type":"message","text":"As I understand, DataFrames at the core are just the \"canonical\" column-oriented table format - same as Vector{NamedTuple} is for row-oriented. The column-orientation happens only at the top level and nested structure is still kept row-oriented in a sense. So I'm not sure what the advantage for storing nested data in dataframes is?","user":"UGTUKUHLN","ts":"1611243987.008700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3SS=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As I understand, DataFrames at the core are just the \"canonical\" column-oriented table format - same as Vector{NamedTuple} is for row-oriented. The column-orientation happens only at the top level and nested structure is still kept row-oriented in a sense. So I'm not sure what the advantage for storing nested data in dataframes is?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"b9890355-96e2-4a4f-8769-bdb261d7f9bd","type":"message","text":"I'm indeed curious how it should look like in \"dataframes\" system. MWE that returns a table instead of dict:","user":"UGTUKUHLN","ts":"1611244170.008900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZtIt0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm indeed curious how it should look like in \"dataframes\" system. MWE that returns a table instead of dict:"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"9794c87a-37ec-4c30-829a-68be95f100cb","type":"message","text":"```using Query\ndata = [\n\t(a=(b=[2, 3],), c=(c=1,)),\n\t(a=(b=[1, 3],), c=(c=10,)),\n]\nf1(a, c) = true\nf2(A) = sum(x.d for x in A)\ndata |&gt;\n  @filter(_.a.b[1] &gt; 1 || f1(_.a, _.c.c)) |&gt;\n  @map((; _.a..., d=_.c.c)) |&gt;\n  @groupby(_.b[1]) |&gt;\n  @map((k=key(_), v=f2(_))) |&gt;\n  collect\n# result: [(k = 2, v = 1), (k = 1, v = 10)]```","user":"UGTUKUHLN","ts":"1611244190.009100","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611244609.000000"},"blocks":[{"type":"rich_text","block_id":"HRk","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Query\ndata = [\n\t(a=(b=[2, 3],), c=(c=1,)),\n\t(a=(b=[1, 3],), c=(c=10,)),\n]\nf1(a, c) = true\nf2(A) = sum(x.d for x in A)\ndata |>\n  @filter(_.a.b[1] > 1 || f1(_.a, _.c.c)) |>\n  @map((; _.a..., d=_.c.c)) |>\n  @groupby(_.b[1]) |>\n  @map((k=key(_), v=f2(_))) |>\n  collect\n# result: [(k = 2, v = 1), (k = 1, v = 10)]"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN","reactions":[{"name":"white_check_mark","users":["U01JRKTSL2U"],"count":1}]},{"client_msg_id":"e74362cf-2da6-484e-94a6-6cf0ea9b57c2","type":"message","text":"I would say that how the data is stored is an implementation detail (as long as your data isn't so huge that converting between the two is not a problem)\n\nThe advantage for storing nested data in a dataframe is that dataframes are super easy to use and very robust.\n\nThere are plenty of ways to work with a DataFrame row-wise and not pretend it's a collection of vectors at all. For instance in `transform` you can use `ByRow`. In DataFramesMeta you can use `@eachrow`.\n\nThe following is definitely way more verbose, but with a `@ByRow` macro will be easy in DataFramesMeta eventually i guess","user":"UBF9YRB6H","ts":"1611245079.009700","team":"T68168MUP","edited":{"user":"UBF9YRB6H","ts":"1611245102.000000"},"blocks":[{"type":"rich_text","block_id":"nUQB3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would say that how the data is stored is an implementation detail (as long as your data isn't so huge that converting between the two is not a problem)\n\nThe advantage for storing nested data in a dataframe is that dataframes are super easy to use and very robust.\n\nThere are plenty of ways to work with a DataFrame row-wise and not pretend it's a collection of vectors at all. For instance in "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" you can use "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":". In DataFramesMeta you can use "},{"type":"text","text":"@eachrow","style":{"code":true}},{"type":"text","text":".\n\nThe following is definitely way more verbose, but with a "},{"type":"text","text":"@ByRow","style":{"code":true}},{"type":"text","text":" macro will be easy in DataFramesMeta eventually i guess"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"447ddcb2-edf6-4f4f-a328-9a8c73c41c80","type":"message","text":"```julia&gt; data = [\n               (a=(b=[2, 3],), c=(c=1,)),\n               (a=(b=[1, 3],), c=(c=10,)),\n       ];\n\njulia&gt; f1(a, c) = true;\n\njulia&gt; f2(df) = sum(df.d);\n\njulia&gt; df = DataFrame(data)\n2×2 DataFrame\n Row │ a              c         \n     │ NamedTup…      NamedTup… \n─────┼──────────────────────────\n   1 │ (b = [2, 3],)  (c = 1,)\n   2 │ (b = [1, 3],)  (c = 10,)\n\njulia&gt; using Chain\n\njulia&gt; @chain df begin \n           filter([:a, :c] =&gt; (a, c) -&gt; a.b[1] &gt; 1 || f1(a, c.c), _)\n           transform(:a =&gt; ByRow(a -&gt; (;a...)) =&gt; AsTable, :c =&gt; ByRow(c -&gt; c.c) =&gt; :d)\n           transform(:a =&gt; ByRow(a -&gt; a.b[1]) =&gt; :k) \n           groupby(:k)\n           combine(f2, _) \n       end\n2×2 DataFrame\n Row │ k      x1    \n     │ Int64  Int64 \n─────┼──────────────\n   1 │     2      1\n   2 │     1     10```","user":"UBF9YRB6H","ts":"1611245145.010000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lXIu","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> data = [\n               (a=(b=[2, 3],), c=(c=1,)),\n               (a=(b=[1, 3],), c=(c=10,)),\n       ];\n\njulia> f1(a, c) = true;\n\njulia> f2(df) = sum(df.d);\n\njulia> df = DataFrame(data)\n2×2 DataFrame\n Row │ a              c         \n     │ NamedTup…      NamedTup… \n─────┼──────────────────────────\n   1 │ (b = [2, 3],)  (c = 1,)\n   2 │ (b = [1, 3],)  (c = 10,)\n\njulia> using Chain\n\njulia> @chain df begin \n           filter([:a, :c] => (a, c) -> a.b[1] > 1 || f1(a, c.c), _)\n           transform(:a => ByRow(a -> (;a...)) => AsTable, :c => ByRow(c -> c.c) => :d)\n           transform(:a => ByRow(a -> a.b[1]) => :k) \n           groupby(:k)\n           combine(f2, _) \n       end\n2×2 DataFrame\n Row │ k      x1    \n     │ Int64  Int64 \n─────┼──────────────\n   1 │     2      1\n   2 │     1     10"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"8f297a4e-7b4d-41a0-8909-84694d8fe326","type":"message","text":"This looks similar to what I tried with just `DataFrames` w/o `Meta`. Conciseness really suffers here: e.g. field names are repeated three times (!) in each line. However, interestingly, the DataFrames version works several times faster for small tables...","user":"UGTUKUHLN","ts":"1611245727.010200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vsJGd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This looks similar to what I tried with just "},{"type":"text","text":"DataFrames","style":{"code":true}},{"type":"text","text":" w/o "},{"type":"text","text":"Meta","style":{"code":true}},{"type":"text","text":". Conciseness really suffers here: e.g. field names are repeated three times (!) in each line. However, interestingly, the DataFrames version works several times faster for small tables..."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"3990b98f-9d80-4a89-8457-c80b26261d9d","type":"message","text":"DataFrames are very lightweight in terms of compile time, which is what you are seeing.\n\nI agree that the fieldnames are repeated too much.\n\nI just remembered you can use `ByRow` inside DataFramesMeta, give me one sec","user":"UBF9YRB6H","ts":"1611245883.010400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W2cAg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFrames are very lightweight in terms of compile time, which is what you are seeing.\n\nI agree that the fieldnames are repeated too much.\n\nI just remembered you can use "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":" inside DataFramesMeta, give me one sec"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"92df9280-fcb6-4c18-a352-5f81ad3868a0","type":"message","text":"No, I don't measure compile time, and talk about `@btime` results. 350mus for Query, 60mus for DataFrames.","user":"UGTUKUHLN","ts":"1611245916.010600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8ABB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, I don't measure compile time, and talk about "},{"type":"text","text":"@btime","style":{"code":true}},{"type":"text","text":" results. 350mus for Query, 60mus for DataFrames."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"3b28b01a-27a9-48e8-9cf6-0850aad52ba9","type":"message","text":"Yeah nevermind, also. We dont have a good solution for row-wise operations in DataFramesMeta. so the verbosity is here to stay, for the moment","user":"UBF9YRB6H","ts":"1611245980.010800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tyz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah nevermind, also. We dont have a good solution for row-wise operations in DataFramesMeta. so the verbosity is here to stay, for the moment"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"1bfd39a4-6ed7-4cda-8492-580f4c3745f4","type":"message","text":"But it is planned, as I guess from your attitude? :slightly_smiling_face:","user":"UGTUKUHLN","ts":"1611246009.011000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wdX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it is planned, as I guess from your attitude? "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"8c8906a2-a547-4359-8900-44f32889f657","type":"message","text":"yeah. I have been imagining something like `@where(df, @byrow :a.b &gt; 1)`. Or maybe some syntax for broadcasted getproperty?","user":"UBF9YRB6H","ts":"1611246045.011200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KZ1/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah. I have been imagining something like "},{"type":"text","text":"@where(df, @byrow :a.b > 1)","style":{"code":true}},{"type":"text","text":". Or maybe some syntax for broadcasted getproperty?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"1710ee90-502a-4973-8a7b-971aca8c26bd","type":"message","text":"Also there is a kind of general feeling that the DataFrames ecosystem is a bit separate from common data structures: e.g., functions operating on regular julia vectors or iterators need to be modified, see `f2` in my example and in yours; groups in query.jl `@groupby` can just be iterated over, while the DataFrames `groupby` gives a fancy and more opaque (?) structure. This means one cannot just move from/to dataframes to/from something else: vectors of named tuples, lazy iterators, etc. Is it feasible in principle for all the select/transform/group/... functions mentioned above to accept all tables, not only dataframes?","user":"UGTUKUHLN","ts":"1611246490.011400","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611246515.000000"},"blocks":[{"type":"rich_text","block_id":"S+l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also there is a kind of general feeling that the DataFrames ecosystem is a bit separate from common data structures: e.g., functions operating on regular julia vectors or iterators need to be modified, see "},{"type":"text","text":"f2","style":{"code":true}},{"type":"text","text":" in my example and in yours; groups in query.jl "},{"type":"text","text":"@groupby","style":{"code":true}},{"type":"text","text":" can just be iterated over, while the DataFrames "},{"type":"text","text":"groupby","style":{"code":true}},{"type":"text","text":" gives a fancy and more opaque (?) structure. This means one cannot just move from/to dataframes to/from something else: vectors of named tuples, lazy iterators, etc. Is it feasible in principle for all the select/transform/group/... functions mentioned above to accept all tables, not only dataframes?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"1ab1df1a-5a0f-493e-b80d-98b7b1f78652","type":"message","text":"DataFrames are super lightweight, so I think the answer is that it's not a big deal to convert to DataFrame.\n\nWhat structure does `groupby` get you in Query? It's also opaque, right?\n\nTables has `rowtable` and `columntable` for converting to vectors of named tuples or named tuples of vectors easily, so we defer to Tables for that.\n\nalso, a grouped data frame can be indexed and iterated over.\n\n```julia&gt; df = DataFrame(a = [1, 1, 2, 2], b = rand(4));\n\njulia&gt; gd = groupby(df, :a)\nGroupedDataFrame with 2 groups based on key: a\nFirst Group (2 rows): a = 1\n Row │ a      b        \n     │ Int64  Float64  \n─────┼─────────────────\n   1 │     1  0.12509\n   2 │     1  0.329455\n⋮\nLast Group (2 rows): a = 2\n Row │ a      b        \n     │ Int64  Float64  \n─────┼─────────────────\n   1 │     2  0.964027\n   2 │     2  0.426448\n\njulia&gt; for gdi in gd\n           @show gdi\n       end\ngdi = 2×2 SubDataFrame\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.12509\n   2 │     1  0.329455\ngdi = 2×2 SubDataFrame\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     2  0.964027\n   2 │     2  0.426448\n\njulia&gt; gd[1]\n2×2 SubDataFrame\n Row │ a      b        \n     │ Int64  Float64  \n─────┼─────────────────\n   1 │     1  0.12509\n   2 │     1  0.329455```","user":"UBF9YRB6H","ts":"1611246806.011700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CS1Qp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"DataFrames are super lightweight, so I think the answer is that it's not a big deal to convert to DataFrame.\n\nWhat structure does "},{"type":"text","text":"groupby","style":{"code":true}},{"type":"text","text":" get you in Query? It's also opaque, right?\n\nTables has "},{"type":"text","text":"rowtable","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"columntable","style":{"code":true}},{"type":"text","text":" for converting to vectors of named tuples or named tuples of vectors easily, so we defer to Tables for that.\n\nalso, a grouped data frame can be indexed and iterated over.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> df = DataFrame(a = [1, 1, 2, 2], b = rand(4));\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 2 groups based on key: a\nFirst Group (2 rows): a = 1\n Row │ a      b        \n     │ Int64  Float64  \n─────┼─────────────────\n   1 │     1  0.12509\n   2 │     1  0.329455\n⋮\nLast Group (2 rows): a = 2\n Row │ a      b        \n     │ Int64  Float64  \n─────┼─────────────────\n   1 │     2  0.964027\n   2 │     2  0.426448\n\njulia> for gdi in gd\n           @show gdi\n       end\ngdi = 2×2 SubDataFrame\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.12509\n   2 │     1  0.329455\ngdi = 2×2 SubDataFrame\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     2  0.964027\n   2 │     2  0.426448\n\njulia> gd[1]\n2×2 SubDataFrame\n Row │ a      b        \n     │ Int64  Float64  \n─────┼─────────────────\n   1 │     1  0.12509\n   2 │     1  0.329455"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"e9869218-6ae3-4267-ba40-47163c2bf42d","type":"message","text":"What I mean is the following. First scenario: I have functions that don't depend on any fancy structures (like dataframes): `f(A) = sum(a.b for a in A)`. It can be plugged into `Query` pipelines, or applied to regular arrays, sharedarrays, disk-backed arrays, streaming iterables, etc. Anything, but for dataframes :slightly_smiling_face: Second scenario: I modify the function to work on dataframes, `f(A) = sum(A.b)`. Then I'm immediately tied to dataframes as this function doesn't work with other structures.\nIt would seem such issues should arise somewhat frequently, but maybe they do not?..","user":"UGTUKUHLN","ts":"1611247169.011900","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611247370.000000"},"blocks":[{"type":"rich_text","block_id":"o8HB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What I mean is the following. First scenario: I have functions that don't depend on any fancy structures (like dataframes): "},{"type":"text","text":"f(A) = sum(a.b for a in A)","style":{"code":true}},{"type":"text","text":". It can be plugged into "},{"type":"text","text":"Query","style":{"code":true}},{"type":"text","text":" pipelines, or applied to regular arrays, sharedarrays, disk-backed arrays, streaming iterables, etc. Anything, but for dataframes "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":" Second scenario: I modify the function to work on dataframes, "},{"type":"text","text":"f(A) = sum(A.b)","style":{"code":true}},{"type":"text","text":". Then I'm immediately tied to dataframes as this function doesn't work with other structures.\nIt would seem such issues should arise somewhat frequently, but maybe they do not?.."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"9df2c1f9-83f4-4309-842f-d4ff08a96de4","type":"message","text":"`f(A) = sum(A.b)` is actually quite general. It works on a `NamedTuple` of `Vectors`.\n\nI would add that the `transform` pipeline is even more general, since all the functions used accept vectors. So you can write code that is entirely agnostic of any tables structure at all. Just that it accepts vectors.\n\nIf you use `ByRow` you can write code that doesn't even depend on vectors, just a bunch of scalars.\n\nSo I think it depends what you mean by `general`","user":"UBF9YRB6H","ts":"1611247425.012300","team":"T68168MUP","edited":{"user":"UBF9YRB6H","ts":"1611247480.000000"},"blocks":[{"type":"rich_text","block_id":"XgYn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"f(A) = sum(A.b)","style":{"code":true}},{"type":"text","text":" is actually quite general. It works on a "},{"type":"text","text":"NamedTuple","style":{"code":true}},{"type":"text","text":" of "},{"type":"text","text":"Vectors","style":{"code":true}},{"type":"text","text":".\n\nI would add that the "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" pipeline is even more general, since all the functions used accept vectors. So you can write code that is entirely agnostic of any tables structure at all. Just that it accepts vectors.\n\nIf you use "},{"type":"text","text":"ByRow","style":{"code":true}},{"type":"text","text":" you can write code that doesn't even depend on vectors, just a bunch of scalars.\n\nSo I think it depends what you mean by "},{"type":"text","text":"general","style":{"code":true}}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"4a8d36e0-2a29-4fa0-8026-71ff83ac7fce","type":"message","text":"Hm, didn't know that. So functions from `DataFrames` work not only with `DataFrame`s?","user":"UGTUKUHLN","ts":"1611247490.012600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cKsV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hm, didn't know that. So functions from "},{"type":"text","text":"DataFrames","style":{"code":true}},{"type":"text","text":" work not only with "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":"s?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"8954fbdb-5f31-4cf7-a266-9c0c038a4c9f","type":"message","text":"<https://github.com/andyferris/Dictionaries.jl|https://github.com/andyferris/Dictionaries.jl>","user":"UDGT4PM41","ts":"1611247526.012800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"005","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/andyferris/Dictionaries.jl","text":"https://github.com/andyferris/Dictionaries.jl"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"f599b31d-3cdb-4daa-8b6f-e570c369a6aa","type":"message","text":"no, `transform` etc. only works on dataframes. I am saying that the \"meat\" of your code, i.e. `f1`, `f2` etc. should be written to accept either\n\n1. Vectors\n2. A named tuple of vectors\n\nthe `fun` in your `src =&gt; fun =&gt; dest` structure that forms the basis of `transform` calls","user":"UBF9YRB6H","ts":"1611247576.013000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fu8CN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"no, "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" etc. only works on dataframes. I am saying that the \"meat\" of your code, i.e. "},{"type":"text","text":"f1","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"f2","style":{"code":true}},{"type":"text","text":" etc. should be written to accept either\n\n1. Vectors\n2. A named tuple of vectors\n\nthe "},{"type":"text","text":"fun","style":{"code":true}},{"type":"text","text":" in your "},{"type":"text","text":"src => fun => dest","style":{"code":true}},{"type":"text","text":" structure that forms the basis of "},{"type":"text","text":"transform","style":{"code":true}},{"type":"text","text":" calls"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"0cc65d34-cf68-4aa8-bdcd-eec9f7d1adce","type":"message","text":"Thanks, I see what you meant. Indeed, even though the whole pipeline can only be applied to dataframes, the internal functions can be written in a general way. I just didn't think of `NamedTuple{Vectors}` first because typically it's the other way around.\nBy the way, to you know why the manipulation functions are written specifically for dataframes? It seems easy to naively implement their semantics for any row- or col-based table.","user":"UGTUKUHLN","ts":"1611248006.013200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cUXM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks, I see what you meant. Indeed, even though the whole pipeline can only be applied to dataframes, the internal functions can be written in a general way. I just didn't think of "},{"type":"text","text":"NamedTuple{Vectors}","style":{"code":true}},{"type":"text","text":" first because typically it's the other way around.\nBy the way, to you know why the manipulation functions are written specifically for dataframes? It seems easy to naively implement their semantics for any row- or col-based table."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"47287d09-ae65-4455-a957-bba0139c3c75","type":"message","text":"In theory that should be feasible, with `src =&gt; fun =&gt; dest` being very general. But they have a number of optimizations bakes in, and the code to actually handle all the variations of `src =&gt; fun =&gt; dest` is actually quite complicated. Maybe in the medium term that stuff can be spit out into it's own package. But getting to 1.0 is very important for DataFrames at the moment","user":"UBF9YRB6H","ts":"1611248173.013400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PuV01","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In theory that should be feasible, with "},{"type":"text","text":"src => fun => dest","style":{"code":true}},{"type":"text","text":" being very general. But they have a number of optimizations bakes in, and the code to actually handle all the variations of "},{"type":"text","text":"src => fun => dest","style":{"code":true}},{"type":"text","text":" is actually quite complicated. Maybe in the medium term that stuff can be spit out into it's own package. But getting to 1.0 is very important for DataFrames at the moment"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"a16b8687-dd54-4004-b69f-b06f9a51ec5f","type":"message","text":"Oh, I remembered another operation I struggled to find in dataframes: `[[1, 2], [3, 4, 5]] |&gt; @mapmany(_[2:end], (a=_[1], b=__)) |&gt; collect` results in `[(a = 1, b = 2), (a = 3, b = 4), (a = 3, b = 5)]`. Is there anything like this?","user":"UGTUKUHLN","ts":"1611248315.013600","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611248368.000000"},"blocks":[{"type":"rich_text","block_id":"Lu5z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh, I remembered another operation I struggled to find in dataframes: "},{"type":"text","text":"[[1, 2], [3, 4, 5]] |> @mapmany(_[2:end], (a=_[1], b=__)) |> collect","style":{"code":true}},{"type":"text","text":" results in "},{"type":"text","text":"[(a = 1, b = 2), (a = 3, b = 4), (a = 3, b = 5)]","style":{"code":true}},{"type":"text","text":". Is there anything like this?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"89e77f83-f80b-4020-b4ce-44170e8ffafa","type":"message","text":"yeah you can pass a collection of vectors to the function, `2:end =&gt; fun` etc","user":"UBF9YRB6H","ts":"1611251933.013900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BHM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah you can pass a collection of vectors to the function, "},{"type":"text","text":"2:end => fun","style":{"code":true}},{"type":"text","text":" etc"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"3d9e130d-fe15-4d59-ad9c-1ec88d47afc1","type":"message","text":"I'm not sure what `@mapmany` does, but you can pass a named tuple of vectors to the function with `AsTable([:a, :b, :c]) =&gt; fun` and then you can work with `2:end` of the named tuple","user":"UBF9YRB6H","ts":"1611252173.014100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"msr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure what "},{"type":"text","text":"@mapmany","style":{"code":true}},{"type":"text","text":" does, but you can pass a named tuple of vectors to the function with "},{"type":"text","text":"AsTable([:a, :b, :c]) => fun","style":{"code":true}},{"type":"text","text":" and then you can work with "},{"type":"text","text":"2:end","style":{"code":true}},{"type":"text","text":" of the named tuple"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"cdc84606-fd3c-4921-96b6-6eb6a641a7e4","type":"message","text":"`@mapmany` is basically the `SelectMany` from original C# linq. I'll try to make a more obvious example :slightly_smiling_face:\n```[(a=[1, 2, 3], b=:b1), (a=[4, 5, 6, 7, 8], b=:b2)] |&gt; @mapmany(_.a, (aa=__, b=_.b)) |&gt; collect```\nresults in\n```[(aa = 1, b = :b1), (aa = 2, b = :b1), (aa = 3, b = :b1), (aa = 4, b = :b2), (aa = 5, b = :b2), (aa = 6, b = :b2), (aa = 7, b = :b2), (aa = 8, b = :b2)]```","user":"UGTUKUHLN","ts":"1611252575.014300","team":"T68168MUP","edited":{"user":"UGTUKUHLN","ts":"1611252628.000000"},"blocks":[{"type":"rich_text","block_id":"THXm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"@mapmany","style":{"code":true}},{"type":"text","text":" is basically the "},{"type":"text","text":"SelectMany","style":{"code":true}},{"type":"text","text":" from original C# linq. I'll try to make a more obvious example "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"[(a=[1, 2, 3], b=:b1), (a=[4, 5, 6, 7, 8], b=:b2)] |> @mapmany(_.a, (aa=__, b=_.b)) |> collect"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"results in\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"[(aa = 1, b = :b1), (aa = 2, b = :b1), (aa = 3, b = :b1), (aa = 4, b = :b2), (aa = 5, b = :b2), (aa = 6, b = :b2), (aa = 7, b = :b2), (aa = 8, b = :b2)]"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"3496b8c7-3f3b-48a6-88e1-77c27d61ce81","type":"message","text":"<@UBF9YRB6H> I ran the `@chain df begin...` code above and got errors, i'm in julia 1.5.1 right now. Do you think it is environment difference or maybe syntax in your snippet?\n```ERROR: ArgumentError: Unrecognized column selector: :a =&gt; (ByRow{var\"#68#72\"}(var\"#68#72\"()) =&gt; AsTable)```","user":"U01JRKTSL2U","ts":"1611253830.015200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"skPC","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UBF9YRB6H"},{"type":"text","text":" I ran the "},{"type":"text","text":"@chain df begin...","style":{"code":true}},{"type":"text","text":" code above and got errors, i'm in julia 1.5.1 right now. Do you think it is environment difference or maybe syntax in your snippet?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ERROR: ArgumentError: Unrecognized column selector: :a => (ByRow{var\"#68#72\"}(var\"#68#72\"()) => AsTable)"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"976f20d1-a44c-40d6-8d01-75e4bf0ef70e","type":"message","text":"probably you need to be on the most recent version of DataFrames?","user":"UBF9YRB6H","ts":"1611254570.015400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aPm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"probably you need to be on the most recent version of DataFrames?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"964cabf7-2a4d-4bed-b3f3-5fa527a606a6","type":"message","text":"<@UGTUKUHLN> I think `flatten` would do what you want in DataFrames?","user":"UBF9YRB6H","ts":"1611263006.016100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OwS","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UGTUKUHLN"},{"type":"text","text":" I think "},{"type":"text","text":"flatten","style":{"code":true}},{"type":"text","text":" would do what you want in DataFrames?"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"ed8ca904-c10e-4cd5-b7f4-d4e9e834f46f","type":"message","text":"I think the only reason we have the macros in Query.jl at the moment is to support the underscore syntax for anonymous functions, and `{}` for named tuple creation. If you just don't use those two things, the macro won't do anything and you can think of it entirely as a function call. For example, this here is how I would write something:\n```data |&gt; @map({_.a, _.b})```","user":"U68UUUFPS","ts":"1611349360.031800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m2ZA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the only reason we have the macros in Query.jl at the moment is to support the underscore syntax for anonymous functions, and "},{"type":"text","text":"{}","style":{"code":true}},{"type":"text","text":" for named tuple creation. If you just don't use those two things, the macro won't do anything and you can think of it entirely as a function call. For example, this here is how I would write something:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"data |> @map({_.a, _.b})"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"661b689d-8287-4aa1-a98b-7531fa1fe850","type":"message","text":"But you can also write it as\n```data |&gt; @map(i-&gt;(;i.a, i.b))```","user":"U68UUUFPS","ts":"1611349381.032000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8qO2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But you can also write it as\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"data |> @map(i->(;i.a, i.b))"}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"},{"client_msg_id":"9b6b60b4-1357-435c-9d41-a350f6876c52","type":"message","text":"Essentially all the macro does is transform the first form into the second one. If you don't want that, you can just write the second form right away and the macro won't do any magic.","user":"U68UUUFPS","ts":"1611349416.032200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BxGkz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Essentially all the macro does is transform the first form into the second one. If you don't want that, you can just write the second form right away and the macro won't do any magic."}]}]}],"thread_ts":"1611226985.003400","parent_user_id":"UGTUKUHLN"}]