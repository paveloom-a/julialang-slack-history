[{"client_msg_id":"3dabac93-f1af-4ee1-ab96-f69e91b0b83b","type":"message","text":"It seems to me that Parquet.jl doesn’t work as documented. It says in the readme that:\n```# `tbl` is a Tables.jl compatible table\ntbl = read_parquet(path_to_parquet_file)```\nHowever, it doesn’t satisfy the Tables.jl interface:\n```using Parquet, DataFrames\ndf = DataFrame(ints = rand(Int, 100))\nwrite_parquet(\"tmp.parquet\", df)\ntbl = read_parquet(\"tmp.parquet\")\nTables.istable(tbl)```\nreturns `false`.","user":"U01CQTKB86N","ts":"1609582265.310000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HJsRf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems to me that Parquet.jl doesn’t work as documented. It says in the readme that:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"# `tbl` is a Tables.jl compatible table\ntbl = read_parquet(path_to_parquet_file)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"However, it doesn’t satisfy the Tables.jl interface:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Parquet, DataFrames\ndf = DataFrame(ints = rand(Int, 100))\nwrite_parquet(\"tmp.parquet\", df)\ntbl = read_parquet(\"tmp.parquet\")\nTables.istable(tbl)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"returns "},{"type":"text","text":"false","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1609582265.310000","reply_count":2,"reply_users_count":2,"latest_reply":"1609660018.322800","reply_users":["U6GD6JN2K","U01CQTKB86N"],"subscribed":false},{"client_msg_id":"5cc4c498-45d8-4c33-9b18-29f94bc472ae","type":"message","text":"I see. I wonder what happened there, perhaps the istable function was not overwritten. When I wrote it it was returning a named tuple perhaps now it was returning a custom type.\n\nThe lack of formal interfaces in Julia makes this type of checks harder","user":"U6GD6JN2K","ts":"1609655723.315300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M8s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see. I wonder what happened there, perhaps the istable function was not overwritten. When I wrote it it was returning a named tuple perhaps now it was returning a custom type.\n\nThe lack of formal interfaces in Julia makes this type of checks harder"}]}]}],"thread_ts":"1609582265.310000","parent_user_id":"U01CQTKB86N"},{"client_msg_id":"6DE67EB1-C4B5-4751-A5A7-3914F485C692","type":"message","text":"There _could_ exist a separate package that tests interoperability between pairs of packages implementing an interface. Perhaps it would generate data in a format for package A and test it can be consumed by package B. It would need a limited amount of work per package, namely how to a) generate and b) consume data. \nCompatibility restrictions would make this harder.","user":"U01CQTKB86N","ts":"1609660018.322800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IBNe+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There "},{"type":"text","text":"could","style":{"italic":true}},{"type":"text","text":" exist a separate package that tests interoperability between pairs of packages implementing an interface. Perhaps it would generate data in a format for package A and test it can be consumed by package B. It would need a limited amount of work per package, namely how to a) generate and b) consume data. \nCompatibility restrictions would make this harder."}]}]}],"thread_ts":"1609582265.310000","parent_user_id":"U01CQTKB86N"}]