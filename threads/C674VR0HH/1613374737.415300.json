[{"client_msg_id":"b26db966-9a05-4127-92ec-4362d7dd4501","type":"message","text":"Following up from the previous thread: Is there a discussion somewhere about pros/cons of `TypedTables` vs. `DataFrames` and when to use one or the other? It seems like for the case where one is reading data in from a CSV or SQL query and using that as a read-only data source, `TypedTables` will be more performant.","user":"U017JTQFNEQ","ts":"1613374737.415300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t7k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Following up from the previous thread: Is there a discussion somewhere about pros/cons of "},{"type":"text","text":"TypedTables","style":{"code":true}},{"type":"text","text":" vs. "},{"type":"text","text":"DataFrames","style":{"code":true}},{"type":"text","text":" and when to use one or the other? It seems like for the case where one is reading data in from a CSV or SQL query and using that as a read-only data source, "},{"type":"text","text":"TypedTables","style":{"code":true}},{"type":"text","text":" will be more performant."}]}]}],"thread_ts":"1613374737.415300","reply_count":10,"reply_users_count":6,"latest_reply":"1613422400.418500","reply_users":["U7PGB5DU3","U017JTQFNEQ","U6A936746","U66QZ3QF3","U8JAMQGQY","UBF9YRB6H"],"subscribed":false},{"client_msg_id":"c612b886-5f6c-4012-8b0a-38beef590797","type":"message","text":"do they have the \"same\" features though?","user":"U7PGB5DU3","ts":"1613375624.415700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W8gHg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"do they have the \"same\" features though?"}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ"},{"client_msg_id":"5e78ca96-982e-4d5e-8ba6-fd622478ee36","type":"message","text":"<@U7PGB5DU3> that’s what i’m asking for. A feature comparison.","user":"U017JTQFNEQ","ts":"1613375966.415900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Mui","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U7PGB5DU3"},{"type":"text","text":" that’s what i’m asking for. A feature comparison."}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ"},{"client_msg_id":"39df71b1-51a4-4615-be06-c7e4d6d4cd70","type":"message","text":"sorry, thought you asked about the difference in speeds.","user":"U7PGB5DU3","ts":"1613376529.416100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tu8F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"sorry, thought you asked about the difference in speeds."}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ"},{"client_msg_id":"d918a391-8b34-4f1b-b942-ba38fcf227ba","type":"message","text":"can i have both? :slightly_smiling_face:","user":"U017JTQFNEQ","ts":"1613376560.416300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lwOo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"can i have both? "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ"},{"client_msg_id":"8d4bfd2c-d355-4296-970b-f245290b109c","type":"message","text":"But if they have different functions (like, one is more feature complete than the other) then it's not really fair. In any case, I don't have the stats you need.","user":"U7PGB5DU3","ts":"1613377443.416500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S/OI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But if they have different functions (like, one is more feature complete than the other) then it's not really fair. In any case, I don't have the stats you need."}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ"},{"client_msg_id":"37af1bac-9252-4e13-b7ae-f0141be8c40d","type":"message","text":"How much do you like compiling? TypedTables needs to recompile everything for each \"schema\".\nDataFrames only once","user":"U6A936746","ts":"1613378770.416700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wUq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How much do you like compiling? TypedTables needs to recompile everything for each \"schema\".\nDataFrames only once"}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ"},{"client_msg_id":"926e834e-7f4d-4083-8662-850c9944c094","type":"message","text":"Indeed. :)\n\nTypedTables is a little less \"opinionated\" and let's you manipulate things using `map`,  `filter`, `reduce` and other functions from SplitApplyCombine.jl, etc. It can be faster for some things, but that's not guaranteed, and was meant in a similar spirit to StructArrays, where sometimes you want to think of each row like a strongly-typed struct, and sometimes you want to think of columns of a table, so it's probably ideal for long, narrow tables (it was invented with point clouds and similar in mind). If you feel comforable with `Vector` and `NamedTuple` you'd probably be comfortable with TypedTables. It's seen less maintanence than DataFrames but still is functional and I'd like to push the ideas further (but have limited time).\n\nDataFrames is a larger and more developed framework with I'd say more functionality and to a reasonable extent it's own APIs. It is well maintained and is evolving and there has been recent work to make operations like grouping (done?) and joining (in progress?) much faster. If you've used pandas or R you'd probably feel quite comfortable with it's APIs.\n\nUnless you know you are speed limited I'd focus on which you think has better programmer productivity for what you are doing.","user":"U66QZ3QF3","ts":"1613382415.417300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0pT/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Indeed. :)\n\nTypedTables is a little less \"opinionated\" and let's you manipulate things using "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":",  "},{"type":"text","text":"filter","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"reduce","style":{"code":true}},{"type":"text","text":" and other functions from SplitApplyCombine.jl, etc. It can be faster for some things, but that's not guaranteed, and was meant in a similar spirit to StructArrays, where sometimes you want to think of each row like a strongly-typed struct, and sometimes you want to think of columns of a table, so it's probably ideal for long, narrow tables (it was invented with point clouds and similar in mind). If you feel comforable with "},{"type":"text","text":"Vector","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"NamedTuple","style":{"code":true}},{"type":"text","text":" you'd probably be comfortable with TypedTables. It's seen less maintanence than DataFrames but still is functional and I'd like to push the ideas further (but have limited time).\n\nDataFrames is a larger and more developed framework with I'd say more functionality and to a reasonable extent it's own APIs. It is well maintained and is evolving and there has been recent work to make operations like grouping (done?) and joining (in progress?) much faster. If you've used pandas or R you'd probably feel quite comfortable with it's APIs.\n\nUnless you know you are speed limited I'd focus on which you think has better programmer productivity for what you are doing."}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ","reactions":[{"name":"+1","users":["U8JAMQGQY","U017JTQFNEQ"],"count":2}]},{"client_msg_id":"ccdc5f8c-afcd-48b3-9e15-f571379756aa","type":"message","text":"Also an additional thought - DataFrames.jl has its own API because standard Julia Base API would not be efficient because `DataFrame` is not type stable (and our custom API takes type instability into account and appropriately handles it to make it fast). This is not a problem for TypedTables.jl at the cost that was outlined above. Also have a look at <https://bkamins.github.io/julialang/2021/01/08/typestable.html>. It does not discuss TypedTables.jl in detail but I think it should give you an idea about the consequences of type stability/instability in the design.","user":"U8JAMQGQY","ts":"1613397768.417700","team":"T68168MUP","attachments":[{"service_name":"Blog by Bogumił Kamiński","title":"Why DataFrame is not type stable and when it matters","title_link":"https://bkamins.github.io/julialang/2021/01/08/typestable.html","text":"Introduction","fallback":"Blog by Bogumił Kamiński: Why DataFrame is not type stable and when it matters","ts":1610115095,"from_url":"https://bkamins.github.io/julialang/2021/01/08/typestable.html","service_icon":"https://bkamins.github.io/favicon.ico","id":1,"original_url":"https://bkamins.github.io/julialang/2021/01/08/typestable.html"}],"blocks":[{"type":"rich_text","block_id":"MKUdO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also an additional thought - DataFrames.jl has its own API because standard Julia Base API would not be efficient because "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":" is not type stable (and our custom API takes type instability into account and appropriately handles it to make it fast). This is not a problem for TypedTables.jl at the cost that was outlined above. Also have a look at "},{"type":"link","url":"https://bkamins.github.io/julialang/2021/01/08/typestable.html"},{"type":"text","text":". It does not discuss TypedTables.jl in detail but I think it should give you an idea about the consequences of type stability/instability in the design."}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ","reactions":[{"name":"+1","users":["U66QZ3QF3","UNWE8FN65","U8T0YV7QC"],"count":3}]},{"client_msg_id":"4d6afe94-bbdc-47f8-9417-5fde14739330","type":"message","text":"Adding on to what <@U6A936746> said. If you have a bottleneck in your code, it's very easy to turn the dataframe into a named tuple via `Tables.columntable`. Or write a function that acts on vectors instead of acting on your table. I would stick with data frames and then use those tools when its needed","user":"UBF9YRB6H","ts":"1613399587.418000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v4oT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Adding on to what "},{"type":"user","user_id":"U6A936746"},{"type":"text","text":" said. If you have a bottleneck in your code, it's very easy to turn the dataframe into a named tuple via "},{"type":"text","text":"Tables.columntable","style":{"code":true}},{"type":"text","text":". Or write a function that acts on vectors instead of acting on your table. I would stick with data frames and then use those tools when its needed"}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ","reactions":[{"name":"point_up","users":["U66QZ3QF3"],"count":1},{"name":"ok_hand","users":["U017JTQFNEQ"],"count":1}]},{"client_msg_id":"e9a84a1f-9670-43c8-950e-511892668872","type":"message","text":"One funny thing I noticed with TypedTables in my previous job is I'd use them to pass data from function to function, but within the function I'd just extract the columns I needed and work with a few vectors (of the same dimensions) at a time, often returning a new vector or wrapping it all together in another Table.","user":"U66QZ3QF3","ts":"1613422400.418500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vsi+a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One funny thing I noticed with TypedTables in my previous job is I'd use them to pass data from function to function, but within the function I'd just extract the columns I needed and work with a few vectors (of the same dimensions) at a time, often returning a new vector or wrapping it all together in another Table."}]}]}],"thread_ts":"1613374737.415300","parent_user_id":"U017JTQFNEQ","reactions":[{"name":"+1","users":["UBF9YRB6H"],"count":1}]}]