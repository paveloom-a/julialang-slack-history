[{"client_msg_id":"18c20856-a045-4896-8280-eacbab566be4","type":"message","text":"I know there used to be some talk about adding Pandas-style row indices to `DataFrames.jl`, but it seems that has now been abandoned. Are there any other packages out there that provide this functionality?","user":"UENHZ1M08","ts":"1616172266.066000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xtx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I know there used to be some talk about adding Pandas-style row indices to "},{"type":"text","text":"DataFrames.jl","style":{"code":true}},{"type":"text","text":", but it seems that has now been abandoned. Are there any other packages out there that provide this functionality?"}]}]}],"thread_ts":"1616172266.066000","reply_count":9,"reply_users_count":3,"latest_reply":"1616174925.067900","reply_users":["UBF9YRB6H","U681ELA87","UENHZ1M08"],"subscribed":false},{"client_msg_id":"30fe302f-8256-47aa-bf9e-face66d76e41","type":"message","text":"In DataFrames `groupby(df, :id)` where `:id` is unique is actually pretty fast, but it will return 1-row sub-dataframes.\n\nYou can also use acceleratedarrays to make the indexing fast.\n\nbut no, not that I know of. I would bet some combination of a vector of named tuples and acceleratedarrays would make this pretty easy though.","user":"UBF9YRB6H","ts":"1616172594.066100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M8Y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In DataFrames "},{"type":"text","text":"groupby(df, :id)","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":":id","style":{"code":true}},{"type":"text","text":" is unique is actually pretty fast, but it will return 1-row sub-dataframes.\n\nYou can also use acceleratedarrays to make the indexing fast.\n\nbut no, not that I know of. I would bet some combination of a vector of named tuples and acceleratedarrays would make this pretty easy though."}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"86f090dc-0c32-4038-b081-11f736a7932c","type":"message","text":"I’d be interested to see an extended example of how row indices are useful/how they’re used.","user":"U681ELA87","ts":"1616173418.066300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QZSu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’d be interested to see an extended example of how row indices are useful/how they’re used."}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"cbaad77e-b6b6-4676-a15b-95254f1fcca8","type":"message","text":"Aha, I've been thinking about how to implement this and `AcceleratedArrays` would save me a ton of work. Shouldn't be too hard to whip up an `AbstractDataFrame` based on this.","user":"UENHZ1M08","ts":"1616173540.066500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1E+2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Aha, I've been thinking about how to implement this and "},{"type":"text","text":"AcceleratedArrays","style":{"code":true}},{"type":"text","text":" would save me a ton of work. Shouldn't be too hard to whip up an "},{"type":"text","text":"AbstractDataFrame","style":{"code":true}},{"type":"text","text":" based on this."}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"334af0e1-b431-44df-8314-bd15825d7339","type":"message","text":"Yeah I've seen `GroupedDataFrame` mentioned as a \"replacement\" for Pandas-style indices, but it's really not the same. Besides returning 1-row data frames, you also have to supply the grouped column name when indexing (`gb = groupby(df, :myindex); gb[(myindex=1,)]`), plus there are a whole bunch of other operations it doesn't support.","user":"UENHZ1M08","ts":"1616173716.066700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"G/zA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah I've seen "},{"type":"text","text":"GroupedDataFrame","style":{"code":true}},{"type":"text","text":" mentioned as a \"replacement\" for Pandas-style indices, but it's really not the same. Besides returning 1-row data frames, you also have to supply the grouped column name when indexing ("},{"type":"text","text":"gb = groupby(df, :myindex); gb[(myindex=1,)]","style":{"code":true}},{"type":"text","text":"), plus there are a whole bunch of other operations it doesn't support."}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"4e4ad485-98c3-4399-b01b-dfa49d8b7835","type":"message","text":"&gt; Shouldn't be too hard to whip up an AbstractDataFrame based on this.\nNo this would be an enormous amount of work. the AbstractDataFrame API is enormous and it would take lots of work to implement all the methods for your preferred type, even with the help of `@forward`. Definitely don't go this route.\n\nProbably just do\n\n```getrow(df, var =&gt; value)\n    # assume df[!, var] is an accelerated array\n    ind = findfirst(==(value), df.var)\n    @assert length(ind) == 1 \"Value not uniquely identified\"\n    df[only(ind), :]\nend```","user":"UBF9YRB6H","ts":"1616174204.067100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3CpV","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"Shouldn't be too hard to whip up an AbstractDataFrame based on this."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nNo this would be an enormous amount of work. the AbstractDataFrame API is enormous and it would take lots of work to implement all the methods for your preferred type, even with the help of "},{"type":"text","text":"@forward","style":{"code":true}},{"type":"text","text":". Definitely don't go this route.\n\nProbably just do\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"getrow(df, var => value)\n    # assume df[!, var] is an accelerated array\n    ind = findfirst(==(value), df.var)\n    @assert length(ind) == 1 \"Value not uniquely identified\"\n    df[only(ind), :]\nend"}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"8c62728e-080f-4a8a-8d66-aeb87acc7599","type":"message","text":"You could even make a type for this, like\n\n```struct GetRow\n    var\n    value\nend```\nand override `getindex(df::AbstractDataFrame, ...)` to do this.","user":"UBF9YRB6H","ts":"1616174346.067300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bdus","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You could even make a type for this, like\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct GetRow\n    var\n    value\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nand override "},{"type":"text","text":"getindex(df::AbstractDataFrame, ...)","style":{"code":true}},{"type":"text","text":" to do this."}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"e07a9d1e-5f3d-46e0-86c6-a59ba294a5df","type":"message","text":"I'm pretty OK just implementing the interface partially for now, for my uses I don't think I'll need the complete implementation. Is the interface more than just the functions listed in <https://dataframes.juliadata.org/stable/lib/types/#DataFrames.AbstractDataFrame>?","user":"UENHZ1M08","ts":"1616174524.067500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5tdqt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm pretty OK just implementing the interface partially for now, for my uses I don't think I'll need the complete implementation. Is the interface more than just the functions listed in "},{"type":"link","url":"https://dataframes.juliadata.org/stable/lib/types/#DataFrames.AbstractDataFrame"},{"type":"text","text":"?"}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"6c7e7d2b-b059-4b15-a4b9-2c2bff14ed91","type":"message","text":"yeah i think its a lot more, and undocumented for now.\n\nI still think the `struct` solution is pretty elegant. Would make for a nice package (and maybe a Tables-agnostic one)","user":"UBF9YRB6H","ts":"1616174616.067700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O1o","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah i think its a lot more, and undocumented for now.\n\nI still think the "},{"type":"text","text":"struct","style":{"code":true}},{"type":"text","text":" solution is pretty elegant. Would make for a nice package (and maybe a Tables-agnostic one)"}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"},{"client_msg_id":"ba33453c-7070-447c-93bc-34c45616b513","type":"message","text":"```julia&gt; import Base.getindex\n\njulia&gt; function getindex(df::AbstractDataFrame, gr::GetRow, args...)\n           var = gr.var\n           val = gr.val\n           ind = findfirst(==(val), df[!, var])\n           getindex(df, ind, args...)\n       end\ngetindex (generic function with 305 methods)\n\njulia&gt; df = DataFrame(a = [1, 2, 3, 4], b = rand(4))\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.850983\n   2 │     2  0.119483\n   3 │     3  0.665025\n   4 │     4  0.69825\n\njulia&gt; df[GetRow(:a, 1), :]\nDataFrameRow\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.850983```","user":"UBF9YRB6H","ts":"1616174925.067900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wNnZ","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> import Base.getindex\n\njulia> function getindex(df::AbstractDataFrame, gr::GetRow, args...)\n           var = gr.var\n           val = gr.val\n           ind = findfirst(==(val), df[!, var])\n           getindex(df, ind, args...)\n       end\ngetindex (generic function with 305 methods)\n\njulia> df = DataFrame(a = [1, 2, 3, 4], b = rand(4))\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.850983\n   2 │     2  0.119483\n   3 │     3  0.665025\n   4 │     4  0.69825\n\njulia> df[GetRow(:a, 1), :]\nDataFrameRow\n Row │ a      b\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.850983"}]}]}],"thread_ts":"1616172266.066000","parent_user_id":"UENHZ1M08"}]