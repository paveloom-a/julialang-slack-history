[{"client_msg_id":"83fe2686-5883-4672-b876-6c68a421be70","type":"message","text":"I took part of a discussion of a common pattern the other day: for some struct, say `MyStruct`, you have a DataFrame constructor. Now you end up with a `Vector{MyStruct}` and you’d like to construct a single `DataFrame` with all of them on top of each other, i.e. something like `reduce(vcat, DataFrame.(x))` where `x` is the vector just mentioned. However, you’d like the *implicit* index in the `Vector{MyStruct}` to become a new column in the `DataFrame`. Is there a non-verbose way to do that? It seems to me that it could be generally useful.","user":"U680T6770","ts":"1615152587.280500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"08+oe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I took part of a discussion of a common pattern the other day: for some struct, say "},{"type":"text","text":"MyStruct","style":{"code":true}},{"type":"text","text":", you have a DataFrame constructor. Now you end up with a "},{"type":"text","text":"Vector{MyStruct}","style":{"code":true}},{"type":"text","text":" and you’d like to construct a single "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":" with all of them on top of each other, i.e. something like "},{"type":"text","text":"reduce(vcat, DataFrame.(x))","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is the vector just mentioned. However, you’d like the "},{"type":"text","text":"implicit","style":{"bold":true}},{"type":"text","text":" index in the "},{"type":"text","text":"Vector{MyStruct}","style":{"code":true}},{"type":"text","text":" to become a new column in the "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":". Is there a non-verbose way to do that? It seems to me that it could be generally useful."}]}]}],"thread_ts":"1615152587.280500","reply_count":14,"reply_users_count":5,"latest_reply":"1615330473.316400","reply_users":["UBF9YRB6H","U8JAMQGQY","U681ELA87","U680T6770","UCZ7VBGUD"],"subscribed":false,"reactions":[{"name":"+1","users":["UCZ7VBGUD"],"count":1}]},{"client_msg_id":"5874b8e8-f943-4817-861e-4021bd516ee7","type":"message","text":"&gt; However, you’d like the implicit index in the Vector{MyStruct} to become a new column in the DataFrame. Is there a non-verbose way to do that? It seems to me that it could be generally useful.\nSorry I don't quite understand this last part. Could you clarify?","user":"UBF9YRB6H","ts":"1615156001.280700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hJLy","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"However, you’d like the implicit index in the Vector{MyStruct} to become a new column in the DataFrame. Is there a non-verbose way to do that? It seems to me that it could be generally useful."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nSorry I don't quite understand this last part. Could you clarify?"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"5953be93-d080-45c9-939b-ea9b8add9d2a","type":"message","text":"This feature is up for grabs since 2014. <https://github.com/JuliaData/DataFrames.jl/issues/659>. Can people interested in it comment in this issue on the preferred API and I would implement it. I marked it 1.x but actually it would be nice to have it for 1.0 and it should be (relatively) easy to add.","user":"U8JAMQGQY","ts":"1615156453.280900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CYeU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This feature is up for grabs since 2014. "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/issues/659"},{"type":"text","text":". Can people interested in it comment in this issue on the preferred API and I would implement it. I marked it 1.x but actually it would be nice to have it for 1.0 and it should be (relatively) easy to add."}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"df55776d-03a3-4b79-8ab9-d221cf9fc7d4","type":"message","text":"Sounds like a job for DataFramesMeta","user":"UBF9YRB6H","ts":"1615156529.281100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Azxl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sounds like a job for DataFramesMeta"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"38d54fff-9c4f-415f-845f-68d0a0e893e9","type":"message","text":"Here's the best I can do\n\n```julia&gt; df = DataFrame(id = 1:length(dfs));\n\njulia&gt; gd = groupby(df, :id);\n\njulia&gt; combine(gd) do sdf\n           dfs[first(sdf.id)]\n       end\n20×2 DataFrame\n Row │ id     a      \n     │ Int64  String \n─────┼───────────────\n   1 │     1  a1\n   2 │     1  b1\n   3 │     2  a2\n   4 │     2  b2\n   5 │     3  a3\n   6 │     3  b3\n   7 │     4  a4\n   8 │     4  b4\n   9 │     5  a5\n  10 │     5  b5\n  11 │     6  a6\n  12 │     6  b6\n  13 │     7  a7\n  14 │     7  b7\n  15 │     8  a8\n  16 │     8  b8\n  17 │     9  a9\n  18 │     9  b9\n  19 │    10  a10\n  20 │    10  b10```","user":"UBF9YRB6H","ts":"1615156770.281300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kX2l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here's the best I can do\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> df = DataFrame(id = 1:length(dfs));\n\njulia> gd = groupby(df, :id);\n\njulia> combine(gd) do sdf\n           dfs[first(sdf.id)]\n       end\n20×2 DataFrame\n Row │ id     a      \n     │ Int64  String \n─────┼───────────────\n   1 │     1  a1\n   2 │     1  b1\n   3 │     2  a2\n   4 │     2  b2\n   5 │     3  a3\n   6 │     3  b3\n   7 │     4  a4\n   8 │     4  b4\n   9 │     5  a5\n  10 │     5  b5\n  11 │     6  a6\n  12 │     6  b6\n  13 │     7  a7\n  14 │     7  b7\n  15 │     8  a8\n  16 │     8  b8\n  17 │     9  a9\n  18 │     9  b9\n  19 │    10  a10\n  20 │    10  b10"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"9abca11f-d7c7-4e74-b63a-fb8f8a09e2a0","type":"message","text":"how about this:\n```julia&gt; struct Person\n              id::Int\n              name::String\n              wage::Float64\n              end\n\njulia&gt; input = [Person(1, \"Joe\", 3.14), Person(2, \"Mary\", 5.55)]\n2-element Vector{Person}:\n Person(1, \"Joe\", 3.14)\n Person(2, \"Mary\", 5.55)\n\njulia&gt; function withindex(input)\n       i = 0\n       TableOperations.map(input) do row\n           i += 1\n           return (i=i, id=row.id, name=row.name, wage=row.wage)\n       end\n       end\nwithindex (generic function with 1 method)\n\njulia&gt; df = DataFrame(withindex(input))\n2×4 DataFrame\n Row │ i      id     name    wage\n     │ Int64  Int64  String  Float64\n─────┼───────────────────────────────\n   1 │     1      1  Joe        3.14\n   2 │     2      2  Mary       5.55```","user":"U681ELA87","ts":"1615167625.281500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8Pjsx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"how about this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct Person\n              id::Int\n              name::String\n              wage::Float64\n              end\n\njulia> input = [Person(1, \"Joe\", 3.14), Person(2, \"Mary\", 5.55)]\n2-element Vector{Person}:\n Person(1, \"Joe\", 3.14)\n Person(2, \"Mary\", 5.55)\n\njulia> function withindex(input)\n       i = 0\n       TableOperations.map(input) do row\n           i += 1\n           return (i=i, id=row.id, name=row.name, wage=row.wage)\n       end\n       end\nwithindex (generic function with 1 method)\n\njulia> df = DataFrame(withindex(input))\n2×4 DataFrame\n Row │ i      id     name    wage\n     │ Int64  Int64  String  Float64\n─────┼───────────────────────────────\n   1 │     1      1  Joe        3.14\n   2 │     2      2  Mary       5.55"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770","reactions":[{"name":"heart","users":["UBL1R2BE1"],"count":1}]},{"client_msg_id":"b64d64d3-04c6-4851-b47e-1c6917119aef","type":"message","text":"Thanks for the replies. <@U681ELA87> I might be dense here but doesn’t your solution only work for structs that return a single row?","user":"U680T6770","ts":"1615274766.297700","team":"T68168MUP","edited":{"user":"U680T6770","ts":"1615303000.000000"},"blocks":[{"type":"rich_text","block_id":"=1Rwa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the replies. "},{"type":"user","user_id":"U681ELA87"},{"type":"text","text":" I might be dense here but doesn’t your solution only work for structs that return a single row?"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"c4507812-70a8-4050-aa94-d93e303d1dd6","type":"message","text":"I'm not sure I quite understand <@U680T6770>. But yes, I'm assuming that one `MyStruct` is a single \"row\". Can you explain what else you have in mind?","user":"U681ELA87","ts":"1615302766.298500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OFUXz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure I quite understand "},{"type":"user","user_id":"U680T6770"},{"type":"text","text":". But yes, I'm assuming that one "},{"type":"text","text":"MyStruct","style":{"code":true}},{"type":"text","text":" is a single \"row\". Can you explain what else you have in mind?"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"ed81b47a-c352-4df6-90a5-0bfebedf18fa","type":"message","text":"In the case that motivated the discussion, each element of the vector becomes a dataframe of several individuals with, say `id=[1,2,3]` and then some other random columns so if I have, say two of these elements then I end up with `id=[1,2,3,1,2,3]` in the final dataframe and I’d like to have a simulation id as well that would be `simid=[1,1,1,2,2,2]`","user":"U680T6770","ts":"1615306793.306600","team":"T68168MUP","edited":{"user":"U680T6770","ts":"1615306859.000000"},"blocks":[{"type":"rich_text","block_id":"Bo7n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In the case that motivated the discussion, each element of the vector becomes a dataframe of several individuals with, say "},{"type":"text","text":"id=[1,2,3]","style":{"code":true}},{"type":"text","text":" and then some other random columns so if I have, say two of these elements then I end up with "},{"type":"text","text":"id=[1,2,3,1,2,3]","style":{"code":true}},{"type":"text","text":" in the final dataframe and I’d like to have a simulation id as well that would be "},{"type":"text","text":"simid=[1,1,1,2,2,2]","style":{"code":true}}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"6b164e0c-e68c-42ea-addd-8c2d66a2a5eb","type":"message","text":"hum…….sorry, I’m just having a little hard time following","user":"U681ELA87","ts":"1615307803.307200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8JbT1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hum…….sorry, I’m just having a little hard time following"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"9b3253c8-430d-43a5-9ad2-03095289de37","type":"message","text":"Assume that somebody gave you this vector of DataFrames\n```julia&gt; dfvec = [DataFrame(id=1:3, x=randn(3)) for i in 1:2]\n2-element Vector{DataFrame}:\n 3×2 DataFrame\n│ Row │ id    │ x         │\n│     │ Int64 │ Float64   │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ -0.4682   │\n│ 2   │ 2     │  0.955515 │\n│ 3   │ 3     │  0.810353 │\n 3×2 DataFrame\n│ Row │ id    │ x         │\n│     │ Int64 │ Float64   │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ -1.66871  │\n│ 2   │ 2     │ -0.4972   │\n│ 3   │ 3     │ 0.831393 │```\n(i.e. you are not the one setting up the DataFrame) and you’d like to combine them go get\n```6×3 DataFrame\n│ Row │ simid │ id    │ x        │\n│     │ Int64 │ Int64 │ Float64  │\n├─────┼───────┼───────┼──────────┤\n│ 1   │ 1     │ 1     │ -0.4682  │\n│ 2   │ 1     │ 2     │ 0.955515 │\n│ 3   │ 1     │ 3     │ 0.810353 │\n│ 4   │ 2     │ 1     │ -1.66871 │\n│ 5   │ 2     │ 2     │ -0.4972  │\n│ 6   │ 2     │ 3     │ 0.831393 │```\nbut where the only input is `dfvec`.","user":"U680T6770","ts":"1615318600.312300","team":"T68168MUP","edited":{"user":"U680T6770","ts":"1615318712.000000"},"blocks":[{"type":"rich_text","block_id":"jm1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Assume that somebody gave you this vector of DataFrames\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> dfvec = [DataFrame(id=1:3, x=randn(3)) for i in 1:2]\n2-element Vector{DataFrame}:\n 3×2 DataFrame\n│ Row │ id    │ x         │\n│     │ Int64 │ Float64   │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ -0.4682   │\n│ 2   │ 2     │  0.955515 │\n│ 3   │ 3     │  0.810353 │\n 3×2 DataFrame\n│ Row │ id    │ x         │\n│     │ Int64 │ Float64   │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ -1.66871  │\n│ 2   │ 2     │ -0.4972   │\n│ 3   │ 3     │ 0.831393 │"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"(i.e. you are not the one setting up the DataFrame) and you’d like to combine them go get\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"6×3 DataFrame\n│ Row │ simid │ id    │ x        │\n│     │ Int64 │ Int64 │ Float64  │\n├─────┼───────┼───────┼──────────┤\n│ 1   │ 1     │ 1     │ -0.4682  │\n│ 2   │ 1     │ 2     │ 0.955515 │\n│ 3   │ 1     │ 3     │ 0.810353 │\n│ 4   │ 2     │ 1     │ -1.66871 │\n│ 5   │ 2     │ 2     │ -0.4972  │\n│ 6   │ 2     │ 3     │ 0.831393 │"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but where the only input is "},{"type":"text","text":"dfvec","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"c48dabbc-8b26-420d-a9ce-c570c4af6460","type":"message","text":"To try to add a motivating example, here’s a not-totally-minimal example where this would be useful, based on something from work today:\n```using TrackingTimers, DataFrames, LinearAlgebra\ndatas = [rand(100,100) for _ = 1:100]\nresults = []\ntimers = []\nfor data in datas\n    t = TrackingTimer()\n    push!(results, (; norm = t(norm)(data), sum = t(sum)(data)))\n    push!(timers, t)\nend\n\ntiming_data = DataFrame()\n\nfor (i, t) in enumerate(timers)\n    t_df = DataFrame(t)\n    t_df = select(t_df, [] =&gt; (() -&gt; fill(i, nrow(t_df))) =&gt; :data_index, :)\n    append!(timing_data, t_df, cols=:union)\nend\n\ntiming_data```\nhere, each `TrackingTimer` is a Tables.jl table (of timing data), and I want to vcat them into a big dataframe but also know which rows came from which timer. My current verbose way is via DataFrames, using `select` to add the extra column at the start.","user":"UCZ7VBGUD","ts":"1615325664.315300","team":"T68168MUP","edited":{"user":"UCZ7VBGUD","ts":"1615328251.000000"},"blocks":[{"type":"rich_text","block_id":"Jsrs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To try to add a motivating example, here’s a not-totally-minimal example where this would be useful, based on something from work today:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using TrackingTimers, DataFrames, LinearAlgebra\ndatas = [rand(100,100) for _ = 1:100]\nresults = []\ntimers = []\nfor data in datas\n    t = TrackingTimer()\n    push!(results, (; norm = t(norm)(data), sum = t(sum)(data)))\n    push!(timers, t)\nend\n\ntiming_data = DataFrame()\n\nfor (i, t) in enumerate(timers)\n    t_df = DataFrame(t)\n    t_df = select(t_df, [] => (() -> fill(i, nrow(t_df))) => :data_index, :)\n    append!(timing_data, t_df, cols=:union)\nend\n\ntiming_data"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"here, each "},{"type":"text","text":"TrackingTimer","style":{"code":true}},{"type":"text","text":" is a Tables.jl table (of timing data), and I want to vcat them into a big dataframe but also know which rows came from which timer. My current verbose way is via DataFrames, using "},{"type":"text","text":"select","style":{"code":true}},{"type":"text","text":" to add the extra column at the start."}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770"},{"client_msg_id":"315bbe9d-82ba-433f-bf1b-3451f43697c1","type":"message","text":"Ah, that makes more sense. How about this? Using some new functionality <@U674T0Y9Z> just merged in to Tables.jl v1.4:\n```julia&gt; df = DataFrame(\n           TableOperations.joinpartitions(\n               Tables.partitioner(\n                   map(x -&gt; TableOperations.map(row -&gt; Tables.rowmerge(row; simid=x[1]), x[2]),\n                       enumerate(dfvec)\n                   )\n               )\n           )\n       )\n6×3 DataFrame\n Row │ id     x          simid\n     │ Int64  Float64    Int64\n─────┼─────────────────────────\n   1 │     1   2.36491       1\n   2 │     2  -0.216807      1\n   3 │     3  -0.765207      1\n   4 │     1  -1.78451       2\n   5 │     2  -1.55212       2\n   6 │     3  -0.238659      2```\n","user":"U681ELA87","ts":"1615326966.315500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5SaHA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, that makes more sense. How about this? Using some new functionality "},{"type":"user","user_id":"U674T0Y9Z"},{"type":"text","text":" just merged in to Tables.jl v1.4:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> df = DataFrame(\n           TableOperations.joinpartitions(\n               Tables.partitioner(\n                   map(x -> TableOperations.map(row -> Tables.rowmerge(row; simid=x[1]), x[2]),\n                       enumerate(dfvec)\n                   )\n               )\n           )\n       )\n6×3 DataFrame\n Row │ id     x          simid\n     │ Int64  Float64    Int64\n─────┼─────────────────────────\n   1 │     1   2.36491       1\n   2 │     2  -0.216807      1\n   3 │     3  -0.765207      1\n   4 │     1  -1.78451       2\n   5 │     2  -1.55212       2\n   6 │     3  -0.238659      2"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770","reactions":[{"name":"tada","users":["UCZ7VBGUD","U674T0Y9Z"],"count":2}]},{"client_msg_id":"048bc81d-83b6-4c64-aa3b-fa59df3dfadf","type":"message","text":"A quick walk-through of what’s going on here, since we’re using a few different tools:\n• `Tables.rowmerge`, what Jarrett just added to Tables.jl; allows “patching” a row w/ an additional value, in this case, adding the `simid` column with the index of the DataFrame of current iteration of `map`\n• `TableOperations.map`, maps a function over rows of input table, function must produce a row. basically a convenient and lazy version of `map(row -&gt; …, Tables.rows(input))`\n•  `Tables.partitioner` allows treating any table iterator as as a “partitioned table”, i.e. `Tables.partitions` will iterate it, treating each iterated element as a table partition\n• `TableOperations.joinpartitions` takes table partitions and vcats the columns utilizing `SentinelArrays.ChainedVector`, returning a single table, kind of like a lazy vcat\n• Then a single `DataFrame` just takes the lazily vcatted columns and uses them as its columns internally","user":"U681ELA87","ts":"1615327527.315800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CED","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A quick walk-through of what’s going on here, since we’re using a few different tools:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tables.rowmerge","style":{"code":true}},{"type":"text","text":", what Jarrett just added to Tables.jl; allows “patching” a row w/ an additional value, in this case, adding the "},{"type":"text","text":"simid","style":{"code":true}},{"type":"text","text":" column with the index of the DataFrame of current iteration of "},{"type":"text","text":"map","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"TableOperations.map","style":{"code":true}},{"type":"text","text":", maps a function over rows of input table, function must produce a row. basically a convenient and lazy version of "},{"type":"text","text":"map(row -> …, Tables.rows(input))","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":" "},{"type":"text","text":"Tables.partitioner","style":{"code":true}},{"type":"text","text":" allows treating any table iterator as as a “partitioned table”, i.e. "},{"type":"text","text":"Tables.partitions","style":{"code":true}},{"type":"text","text":" will iterate it, treating each iterated element as a table partition"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"TableOperations.joinpartitions","style":{"code":true}},{"type":"text","text":" takes table partitions and vcats the columns utilizing "},{"type":"text","text":"SentinelArrays.ChainedVector","style":{"code":true}},{"type":"text","text":", returning a single table, kind of like a lazy vcat"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Then a single "},{"type":"text","text":"DataFrame","style":{"code":true}},{"type":"text","text":" just takes the lazily vcatted columns and uses them as its columns internally"}]}],"style":"bullet","indent":0}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770","reactions":[{"name":"+1","users":["UCZ7VBGUD"],"count":1},{"name":"party_wizard","users":["U674T0Y9Z"],"count":1}]},{"client_msg_id":"cb370845-5bb2-40b3-bcb1-e518dec7602f","type":"message","text":"It seems you will be able to use <https://github.com/JuliaData/DataFrames.jl/pull/2649> soon (if I understand your use case correctly)","user":"U8JAMQGQY","ts":"1615330473.316400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ltDg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems you will be able to use "},{"type":"link","url":"https://github.com/JuliaData/DataFrames.jl/pull/2649"},{"type":"text","text":" soon (if I understand your use case correctly)"}]}]}],"thread_ts":"1615152587.280500","parent_user_id":"U680T6770","reactions":[{"name":"+1","users":["UCZ7VBGUD","UBF9YRB6H"],"count":2}]}]