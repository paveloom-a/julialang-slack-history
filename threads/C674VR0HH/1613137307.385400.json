[{"client_msg_id":"c1dbbe67-5ad1-4892-b5ba-17423224e504","type":"message","text":"Is there some overview or benchmark between DataFrames and IndexedTables (used in JuliaDB), with both compile-time and run-time estimations?","user":"UB2QSHWPN","ts":"1613137307.385400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ktex","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there some overview or benchmark between DataFrames and IndexedTables (used in JuliaDB), with both compile-time and run-time estimations?"}]}]}],"thread_ts":"1613137307.385400","reply_count":6,"reply_users_count":2,"latest_reply":"1613152620.387900","reply_users":["U8JAMQGQY","UB2QSHWPN"],"subscribed":false},{"client_msg_id":"0361b8a8-a14c-4807-80f7-a4c27a599be4","type":"message","text":"I do not think so. In general these packages have very different API so it will be hard to do. What do you want to benchmark exactly?","user":"U8JAMQGQY","ts":"1613139020.385600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"10MK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do not think so. In general these packages have very different API so it will be hard to do. What do you want to benchmark exactly?"}]}]}],"thread_ts":"1613137307.385400","parent_user_id":"UB2QSHWPN"},{"client_msg_id":"204c38fe-60a8-4fd0-8c49-43bda154e91c","type":"message","text":"How about generic Tables.jl or TableOperations.jl methods? I just want to understand, what is the difference between these two use-cases? And what operations are slower or faster when you have:\n(a) sorted primary key, and\n(b) static schema.","user":"UB2QSHWPN","ts":"1613141905.386100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EsW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"How about generic Tables.jl or TableOperations.jl methods? I just want to understand, what is the difference between these two use-cases? And what operations are slower or faster when you have:\n(a) sorted primary key, and\n(b) static schema."}]}]}],"thread_ts":"1613137307.385400","parent_user_id":"UB2QSHWPN"},{"client_msg_id":"af5719dc-416d-4740-94c1-c12114c68322","type":"message","text":"Static schema is not required for performance in general as you can always use barrier function. Sorted PK will make a difference. However, at the cost of not being able to freely mutate columns. In DataFrames.jl you can: 1) do `groupby` to create PK, 2) joins soon will take full advantage of sorted PK, 3) you can use vector type that is sorted-aware if you want. Of course having guarantee of sorted PK is a preferable option if you accept the costs.","user":"U8JAMQGQY","ts":"1613142912.386300","team":"T68168MUP","edited":{"user":"U8JAMQGQY","ts":"1613142926.000000"},"blocks":[{"type":"rich_text","block_id":"dVb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Static schema is not required for performance in general as you can always use barrier function. Sorted PK will make a difference. However, at the cost of not being able to freely mutate columns. In DataFrames.jl you can: 1) do "},{"type":"text","text":"groupby","style":{"code":true}},{"type":"text","text":" to create PK, 2) joins soon will take full advantage of sorted PK, 3) you can use vector type that is sorted-aware if you want. Of course having guarantee of sorted PK is a preferable option if you accept the costs."}]}]}],"thread_ts":"1613137307.385400","parent_user_id":"UB2QSHWPN"},{"client_msg_id":"83471dee-0c9b-4ae6-93d2-3632f59454b6","type":"message","text":"I think a major issue in general lies in different place: DataFrames.jl was designed for in-memory processing and if you need out of core capabilities then it will not be a good choice currently.","user":"U8JAMQGQY","ts":"1613143012.386600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gGKC=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think a major issue in general lies in different place: DataFrames.jl was designed for in-memory processing and if you need out of core capabilities then it will not be a good choice currently."}]}]}],"thread_ts":"1613137307.385400","parent_user_id":"UB2QSHWPN"},{"client_msg_id":"1499687e-15db-4211-b4af-f716cafa6d34","type":"message","text":"Thank you for explanation!\nFor out-of-core processing, can we just  construct DataFrames from <https://github.com/meggart/DiskArrays.jl|AbstractDiskArrays> columns? Or data loading from disk in chunks on getindex is not enough?","user":"UB2QSHWPN","ts":"1613145266.387000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lbub","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you for explanation!\nFor out-of-core processing, can we just  construct DataFrames from "},{"type":"link","url":"https://github.com/meggart/DiskArrays.jl","text":"AbstractDiskArrays"},{"type":"text","text":" columns? Or data loading from disk in chunks on getindex is not enough?"}]}]}],"thread_ts":"1613137307.385400","parent_user_id":"UB2QSHWPN"},{"client_msg_id":"47dd9f7e-0365-4153-8f07-2e3ec6333286","type":"message","text":"You can store distributed columns in a data frame,but I would not rely on the fact that transformations (like `combine`) would also properly create such columns.","user":"U8JAMQGQY","ts":"1613152620.387900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ocg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can store distributed columns in a data frame,but I would not rely on the fact that transformations (like "},{"type":"text","text":"combine","style":{"code":true}},{"type":"text","text":") would also properly create such columns."}]}]}],"thread_ts":"1613137307.385400","parent_user_id":"UB2QSHWPN"}]