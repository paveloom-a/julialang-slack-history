[{"client_msg_id":"964d3841-c6d5-44e7-99fe-5925b196e25e","type":"message","text":"Hello all, I'm trying to optimize the following code. Essentially, I'm want to find the minimum value from `value` for each unique combination of 2 vectors (for the purposes of this code, v1 = 1 and v2 = 2 is the same as v1 = 2 and v2 = 1, which is why I do that hacky part with `min` and `max`). I need to scale this up pretty massively, so I'm hoping to find ways to speed it up. Any suggestions? Thanks very much!!\n```using Base.Threads\n# Vector 1\nv1 = rand(collect(1:1000), 100000)\n# Vector 2\nv2 = rand(collect(1:1000), 100000)\n# Values\nvalue = rand(100000)\n\n# Get unique combos of v1 and v2\nminv = min.(v1, v2)\nmaxv = max.(v1, v2)\nunique_combos = unique(tuple.(minv, maxv))\nn_unique = length(unique_combos)\n\n# init a vector to house minimum of `value` per unique v1 and v2 combination\nvalue_mins = Vector{Float64}(undef, n_unique)\n\n# loop through to find minimum per unique group\n@threads for i in 1:n_unique\n    unique_combo = unique_combos[i]\n    min_value_for_combo_i = minimum(value[(minv .== unique_combo[1]) .&amp; (maxv .== unique_combo[2])])\n    value_mins[i] = min_value_for_combo_i\nend```","user":"U011NV8FNF7","ts":"1609287683.257400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JQpt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hello all, I'm trying to optimize the following code. Essentially, I'm want to find the minimum value from "},{"type":"text","text":"value","style":{"code":true}},{"type":"text","text":" for each unique combination of 2 vectors (for the purposes of this code, v1 = 1 and v2 = 2 is the same as v1 = 2 and v2 = 1, which is why I do that hacky part with "},{"type":"text","text":"min","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"max","style":{"code":true}},{"type":"text","text":"). I need to scale this up pretty massively, so I'm hoping to find ways to speed it up. Any suggestions? Thanks very much!!\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Base.Threads\n# Vector 1\nv1 = rand(collect(1:1000), 100000)\n# Vector 2\nv2 = rand(collect(1:1000), 100000)\n# Values\nvalue = rand(100000)\n\n# Get unique combos of v1 and v2\nminv = min.(v1, v2)\nmaxv = max.(v1, v2)\nunique_combos = unique(tuple.(minv, maxv))\nn_unique = length(unique_combos)\n\n# init a vector to house minimum of `value` per unique v1 and v2 combination\nvalue_mins = Vector{Float64}(undef, n_unique)\n\n# loop through to find minimum per unique group\n@threads for i in 1:n_unique\n    unique_combo = unique_combos[i]\n    min_value_for_combo_i = minimum(value[(minv .== unique_combo[1]) .& (maxv .== unique_combo[2])])\n    value_mins[i] = min_value_for_combo_i\nend"}]}]}],"thread_ts":"1609287683.257400","reply_count":5,"reply_users_count":3,"latest_reply":"1609345681.262000","reply_users":["UDD5Z7FLZ","U01GMP3HF9C","U011NV8FNF7"],"subscribed":false},{"client_msg_id":"dcd5b4a7-b65a-4dee-8153-041a0d6dc7a9","type":"message","text":"Try\n```using Base.Threads\nv1 = rand(collect(1:1000), 100000)\nv2 = rand(collect(1:1000), 100000)\nvalue = rand(100000)# Get unique combos of v1 and v2\n\n\n\nfunction F(v1, v2, value)\n    minv = min.(v1, v2)\n    maxv = max.(v1, v2)\n    unique_combos = unique(tuple.(minv, maxv))\n    n_unique = length(unique_combos)# init a vector to house minimum of `value` per unique v1 and v2 combination\n    value_mins = Vector{Float64}(undef, n_unique)# loop through to find minimum per unique group\n    @threads for i in 1:n_unique\n        unique_combo = unique_combos[i]\n        min_value_for_combo_i = minimum(value[(minv .== unique_combo[1]) .&amp; (maxv .== unique_combo[2])])\n        value_mins[i] = min_value_for_combo_i\n    end\n    value_mins\nend\n\nfunction G(v1, v2, value)\n    n = length(v1)\n    minv = min.(v1, v2)\n    maxv = max.(v1, v2)\n\n    idx = Dict{Tuple{Int,Int}, Int}((minv[1], maxv[1]) =&gt; 1)\n    value_mins = [value[1]]\n    Ct = 2\n    @inbounds for i in 2:n\n        curr = (minv[i],maxv[i])\n        if haskey(idx, curr)\n            value_mins[idx[curr]] = min(value_mins[idx[curr]], value[i])\n        else\n            idx[curr] = Ct\n            push!(value_mins, value[i])\n            Ct += 1\n        end\n    end\n    value_mins\nend```","user":"UDD5Z7FLZ","ts":"1609305571.257800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"nUF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Try\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Base.Threads\nv1 = rand(collect(1:1000), 100000)\nv2 = rand(collect(1:1000), 100000)\nvalue = rand(100000)# Get unique combos of v1 and v2\n\n\n\nfunction F(v1, v2, value)\n    minv = min.(v1, v2)\n    maxv = max.(v1, v2)\n    unique_combos = unique(tuple.(minv, maxv))\n    n_unique = length(unique_combos)# init a vector to house minimum of `value` per unique v1 and v2 combination\n    value_mins = Vector{Float64}(undef, n_unique)# loop through to find minimum per unique group\n    @threads for i in 1:n_unique\n        unique_combo = unique_combos[i]\n        min_value_for_combo_i = minimum(value[(minv .== unique_combo[1]) .& (maxv .== unique_combo[2])])\n        value_mins[i] = min_value_for_combo_i\n    end\n    value_mins\nend\n\nfunction G(v1, v2, value)\n    n = length(v1)\n    minv = min.(v1, v2)\n    maxv = max.(v1, v2)\n\n    idx = Dict{Tuple{Int,Int}, Int}((minv[1], maxv[1]) => 1)\n    value_mins = [value[1]]\n    Ct = 2\n    @inbounds for i in 2:n\n        curr = (minv[i],maxv[i])\n        if haskey(idx, curr)\n            value_mins[idx[curr]] = min(value_mins[idx[curr]], value[i])\n        else\n            idx[curr] = Ct\n            push!(value_mins, value[i])\n            Ct += 1\n        end\n    end\n    value_mins\nend"}]}]}],"thread_ts":"1609287683.257400","parent_user_id":"U011NV8FNF7"},{"client_msg_id":"87151581-e816-4d5c-8779-668c2657c45d","type":"message","text":"This gives a small speedup\n```julia&gt; @btime F($v1, $v2, $value);\n  3.959 s (362644 allocations: 1.45 GiB)\njulia&gt; @btime G($v1, $v2, $value);\n  9.339 ms (57 allocations: 11.86 MiB)```","user":"UDD5Z7FLZ","ts":"1609305591.258000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UJ/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This gives a small speedup\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime F($v1, $v2, $value);\n  3.959 s (362644 allocations: 1.45 GiB)\njulia> @btime G($v1, $v2, $value);\n  9.339 ms (57 allocations: 11.86 MiB)"}]}]}],"thread_ts":"1609287683.257400","parent_user_id":"U011NV8FNF7"},{"client_msg_id":"2a3af331-843f-45c8-a1a3-337e41d0f54d","type":"message","text":"Hi! <@UDD5Z7FLZ> as a newbie can I ask where the $ signs come from in front of the variables? My impression is that you may waste a lot of time on the `push!`  (I haven’t profiled it yet), maybe a first pass to compute the final length of `value_mins` and pre-allocate the memory would help?","user":"U01GMP3HF9C","ts":"1609322667.258200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vYcA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi! "},{"type":"user","user_id":"UDD5Z7FLZ"},{"type":"text","text":" as a newbie can I ask where the $ signs come from in front of the variables? My impression is that you may waste a lot of time on the "},{"type":"text","text":"push!","style":{"code":true}},{"type":"text","text":"  (I haven’t profiled it yet), maybe a first pass to compute the final length of "},{"type":"text","text":"value_mins","style":{"code":true}},{"type":"text","text":" and pre-allocate the memory would help?"}]}]}],"thread_ts":"1609287683.257400","parent_user_id":"U011NV8FNF7"},{"client_msg_id":"35a1cd9b-dcc5-41c1-98ce-835b96569a36","type":"message","text":"Regarding the $, this is due to the problem of global variables are less performant in Julia, so by using $ interpolation, this avoids this issue when benchmarking. The suggestion to write performant Julia code is to avoid using globals where possible.\n\nRealistically, `push!` takes amortized O(1) time, and preallocating it by computing it with another loop is not always faster. I am not very sure of the details, but just brief experimentation on my device don't seem to suggest that such a precomputation is worthwhile.","user":"UDD5Z7FLZ","ts":"1609326180.258400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hSEyi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Regarding the $, this is due to the problem of global variables are less performant in Julia, so by using $ interpolation, this avoids this issue when benchmarking. The suggestion to write performant Julia code is to avoid using globals where possible.\n\nRealistically, "},{"type":"text","text":"push!","style":{"code":true}},{"type":"text","text":" takes amortized O(1) time, and preallocating it by computing it with another loop is not always faster. I am not very sure of the details, but just brief experimentation on my device don't seem to suggest that such a precomputation is worthwhile."}]}]}],"thread_ts":"1609287683.257400","parent_user_id":"U011NV8FNF7","reactions":[{"name":"+1","users":["U01GMP3HF9C","U011NV8FNF7"],"count":2}]},{"client_msg_id":"aa68b5c4-0ac7-4965-a376-d43afd695822","type":"message","text":"Thanks very much <@UDD5Z7FLZ>! That is incredibly helpful!","user":"U011NV8FNF7","ts":"1609345681.262000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AtS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks very much "},{"type":"user","user_id":"UDD5Z7FLZ"},{"type":"text","text":"! That is incredibly helpful!"}]}]}],"thread_ts":"1609287683.257400","parent_user_id":"U011NV8FNF7"}]