[{"client_msg_id":"e54b6091-4f3d-4635-af2a-2d0f41b6350c","type":"message","text":"Could anyone familiar with ComponentArrays explain why this line seems to be type-unstable with `@code_warntype` despite all of the present variables (i.e. `values` ,`start` ,`stop`) being fully known? It's really perplexing me.\n```newvalues = ComponentArray(values,(Axis{(edges=start:2:stop,cells=start+1:2:stop-1)}(),))```","user":"U01H36BUDJB","ts":"1613749045.266000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OpeP3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Could anyone familiar with ComponentArrays explain why this line seems to be type-unstable with "},{"type":"text","text":"@code_warntype","style":{"code":true}},{"type":"text","text":" despite all of the present variables (i.e. "},{"type":"text","text":"values","style":{"code":true}},{"type":"text","text":" ,"},{"type":"text","text":"start","style":{"code":true}},{"type":"text","text":" ,"},{"type":"text","text":"stop","style":{"code":true}},{"type":"text","text":") being fully known? It's really perplexing me.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"newvalues = ComponentArray(values,(Axis{(edges=start:2:stop,cells=start+1:2:stop-1)}(),))"}]}]}],"thread_ts":"1613749045.266000","reply_count":7,"reply_users_count":3,"latest_reply":"1613757699.282000","reply_users":["U01H36BUDJB","U69BL50BF","US4A6G6B0"],"subscribed":false},{"client_msg_id":"3c8eb001-b96e-4638-92e4-7e0a0182a5d6","type":"message","text":"`values` is a fully-specified `SVector` and the type is known according to `@code_warntype`","user":"U01H36BUDJB","ts":"1613749075.266100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oaea","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"values","style":{"code":true}},{"type":"text","text":" is a fully-specified "},{"type":"text","text":"SVector","style":{"code":true}},{"type":"text","text":" and the type is known according to "},{"type":"text","text":"@code_warntype","style":{"code":true}}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"cb138eba-e0b7-4cfe-9e29-bb50955e43ef","type":"message","text":"<@US4A6G6B0>","user":"U69BL50BF","ts":"1613754986.266300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l85HM","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"US4A6G6B0"}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"C62FD607-0DE4-4F03-A823-FAC925BB8D79","type":"message","text":"I think this all comes down to how  `start` and `stop` are defined. If the compiler has access to their values (e.g. they were defined at the outset as a `Val` and passed in to the containing function and destructured from there), this will be type stable. But in general the compiler doesn’t have access to the values of these variables, only their types. And constant folding only goes so far. Kinda like how you can’t do `SVector{length(x)}(x)` in a type-stable way.","user":"US4A6G6B0","ts":"1613756457.276800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DZr4w","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this all comes down to how  "},{"type":"text","text":"start","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"stop","style":{"code":true}},{"type":"text","text":" are defined. If the compiler has access to their values (e.g. they were defined at the outset as a "},{"type":"text","text":"Val","style":{"code":true}},{"type":"text","text":" and passed in to the containing function and destructured from there), this will be type stable. But in general the compiler doesn’t have access to the values of these variables, only their types. And constant folding only goes so far. Kinda like how you can’t do "},{"type":"text","text":"SVector{length(x)}(x)","style":{"code":true}},{"type":"text","text":" in a type-stable way."}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"DC4ED60B-52E2-4B01-B01A-BB2587A4C4AB","type":"message","text":"But it sounds like they were defined based on the length of the `SVector` right? In that case I’m not sure how long the compiler holds on to that information. I guess a `@generated` function would work here? I’m not sure. But I don’t think there’s anything I can do about it on the ComponentArrays side.","user":"US4A6G6B0","ts":"1613756724.280700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iyka2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it sounds like they were defined based on the length of the "},{"type":"text","text":"SVector","style":{"code":true}},{"type":"text","text":" right? In that case I’m not sure how long the compiler holds on to that information. I guess a "},{"type":"text","text":"@generated","style":{"code":true}},{"type":"text","text":" function would work here? I’m not sure. But I don’t think there’s anything I can do about it on the ComponentArrays side."}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"0209EE8A-819D-495A-90F7-E8174A53038E","type":"message","text":"But if it turns out I’m wrong and there is some way to fix it, I’d be happy to do so. ","user":"US4A6G6B0","ts":"1613756966.281600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JUR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But if it turns out I’m wrong and there is some way to fix it, I’d be happy to do so. "}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"6b48667d-9d9d-4dc0-b0ac-06452f53d47e","type":"message","text":"<@US4A6G6B0> Yes, that's what I figured after experimenting with it for a while. In this particular function, the new start and stop values are not necessarily determined by the `SVector` , so they aren't knowable at compile time. I think I tried using `Val` as well, but it didn't work, presumably because the `Val` still has to be created using a value only known at runtime.","user":"U01H36BUDJB","ts":"1613757370.281800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Idus","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"US4A6G6B0"},{"type":"text","text":" Yes, that's what I figured after experimenting with it for a while. In this particular function, the new start and stop values are not necessarily determined by the "},{"type":"text","text":"SVector","style":{"code":true}},{"type":"text","text":" , so they aren't knowable at compile time. I think I tried using "},{"type":"text","text":"Val","style":{"code":true}},{"type":"text","text":" as well, but it didn't work, presumably because the "},{"type":"text","text":"Val","style":{"code":true}},{"type":"text","text":" still has to be created using a value only known at runtime."}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"0470259f-8419-4876-96bd-9801ae63c337","type":"message","text":"I guess I'm a bit confused though about how `ComponentArrays` works. I didn't realize that the indices were always determined at compile time. You don't provide any size type information directly, like with `SVector` , so I didn't really think about this issue until now.","user":"U01H36BUDJB","ts":"1613757699.282000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NEMYi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess I'm a bit confused though about how "},{"type":"text","text":"ComponentArrays","style":{"code":true}},{"type":"text","text":" works. I didn't realize that the indices were always determined at compile time. You don't provide any size type information directly, like with "},{"type":"text","text":"SVector","style":{"code":true}},{"type":"text","text":" , so I didn't really think about this issue until now."}]}]}],"thread_ts":"1613749045.266000","parent_user_id":"U01H36BUDJB"}]