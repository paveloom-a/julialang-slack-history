[{"client_msg_id":"9bfa960e-0709-4118-8ec6-69d8d268fe8f","type":"message","text":"Trying to optimize the `fastmod` function here. Any thoughts?\n```struct Mod\n    modulo::UInt32\n    modulo_inv::UInt64\n    function Mod(d::UInt32)\n        cmod::UInt64 = div(typemax(UInt64), d) + 1\n        return new(d,cmod)\n    end\n    function Mod(d::Int)\n        ud = convert(UInt32, d)\n        return Mod(ud)\n    end\nend\n\n@inline function fastmod(n::UInt32,T::Mod)::UInt32\n    lowbits::UInt64 = T.modulo_inv * n\n    return (convert(UInt128,lowbits) * T.modulo) &gt;&gt; 64\nend```\ntranslation from this code from Lemire et al (2019)\n```uint32_t d = ...;// your divisor &gt; 0\n\nuint64_t c = UINT64_C(0xFFFFFFFFFFFFFFFF) / d + 1;\n\n// fastmod computes (n mod d) given precomputed c\nuint32_t fastmod(uint32_t n ) {\n  uint64_t lowbits = c * n;\n  return ((__uint128_t)lowbits * d) &gt;&gt; 64; \n}```\nI also made a <https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586|discourse post> last night with more info and copypastable benchmarking code but it hasn't gotten any traffic.","user":"U011V2YN59N","ts":"1617651204.127300","team":"T68168MUP","edited":{"user":"U011V2YN59N","ts":"1617651220.000000"},"blocks":[{"type":"rich_text","block_id":"Dx7=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Trying to optimize the "},{"type":"text","text":"fastmod","style":{"code":true}},{"type":"text","text":" function here. Any thoughts?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Mod\n    modulo::UInt32\n    modulo_inv::UInt64\n    function Mod(d::UInt32)\n        cmod::UInt64 = div(typemax(UInt64), d) + 1\n        return new(d,cmod)\n    end\n    function Mod(d::Int)\n        ud = convert(UInt32, d)\n        return Mod(ud)\n    end\nend\n\n@inline function fastmod(n::UInt32,T::Mod)::UInt32\n    lowbits::UInt64 = T.modulo_inv * n\n    return (convert(UInt128,lowbits) * T.modulo) >> 64\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"translation from this code from Lemire et al (2019)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"uint32_t d = ...;// your divisor > 0\n\nuint64_t c = UINT64_C(0xFFFFFFFFFFFFFFFF) / d + 1;\n\n// fastmod computes (n mod d) given precomputed c\nuint32_t fastmod(uint32_t n ) {\n  uint64_t lowbits = c * n;\n  return ((__uint128_t)lowbits * d) >> 64; \n}"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I also made a "},{"type":"link","url":"https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586","text":"discourse post"},{"type":"text","text":" last night with more info and copypastable benchmarking code but it hasn't gotten any traffic."}]}]}],"thread_ts":"1617651204.127300","reply_count":1,"reply_users_count":1,"latest_reply":"1617693169.128000","reply_users":["U68QW0PUZ"],"is_locked":false,"subscribed":false},{"client_msg_id":"05363c6a-7c90-4dd1-b79a-c2edca83e8cb","type":"message","text":"see <https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586/2>","user":"U68QW0PUZ","ts":"1617693169.128000","team":"T68168MUP","edited":{"user":"U68QW0PUZ","ts":"1617693182.000000"},"attachments":[{"service_name":"JuliaLang","title":"Optimizing remainder with constant modulus implementation","title_link":"https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586/2","text":"(a) change convert(UInt128, lowbits) to (lowbits % UInt128) for quicker, safe widening conversion. (b) your function fastmod has a declared return type of UInt32, however the return statement , without coercion, generates a UInt128 value. Best to be explicit. If you want to truncate, consider return ((lowbits % UInt128) * T.modulo) &gt;&gt; 64)) % UInt32","fallback":"JuliaLang: Optimizing remainder with constant modulus implementation","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","ts":1617693038,"from_url":"https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586/2","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586/2"}],"blocks":[{"type":"rich_text","block_id":"Ht=J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"see "},{"type":"link","url":"https://discourse.julialang.org/t/optimizing-remainder-with-constant-modulus-implementation/58586/2"}]}]}],"thread_ts":"1617651204.127300","parent_user_id":"U011V2YN59N"}]