[{"client_msg_id":"be34b342-27bf-423f-9c7f-06c335bf262b","type":"message","text":"Which types of operations is julia still lacking behind compared with C in terms of preformamce?\nAre these performance issues related to inherent issues with Julia or simply due to julias relative immaturity?","user":"U01FAHWCMFF","ts":"1609345469.261100","team":"T68168MUP","edited":{"user":"U01FAHWCMFF","ts":"1609345524.000000"},"blocks":[{"type":"rich_text","block_id":"8WzB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Which types of operations is julia still lacking behind compared with C in terms of preformamce?\nAre these performance issues related to inherent issues with Julia or simply due to julias relative immaturity?"}]}]}],"thread_ts":"1609345469.261100","reply_count":22,"reply_users_count":8,"latest_reply":"1609419400.281700","reply_users":["U0179G7FG4F","U01FAHWCMFF","UH24GRBLL","UGU761DU2","U01GRS159T8","U7HAYKY9X","UDD5Z7FLZ","UB7JS9CHF"],"subscribed":false},{"client_msg_id":"625f15a7-a2ce-42c2-80f6-1a0296c76854","type":"message","text":"There really aren't many","user":"U0179G7FG4F","ts":"1609346348.262300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lo1Bh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There really aren't many"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"01d19493-97df-4f19-920f-63f767d13af0","type":"message","text":"Good to know that Julias limitations dont affect performance. Thanks","user":"U01FAHWCMFF","ts":"1609347001.262500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q8xLL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Good to know that Julias limitations dont affect performance. Thanks"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"8266cb9f-38b8-4103-b76a-8d1cb9822ac4","type":"message","text":"shooting yourself in the foot with pointers?","user":"UH24GRBLL","ts":"1609347025.262700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=tPJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"shooting yourself in the foot with pointers?"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"891d768e-9584-4aa6-8861-2096408980cd","type":"message","text":"I think the biggest footgun for me personally has been type instability; if you avoid it then you really do get C-like performance, but if you miss any then it’s another story. `@code_warntype` FTW","user":"UGU761DU2","ts":"1609352583.263000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l8xB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the biggest footgun for me personally has been type instability; if you avoid it then you really do get C-like performance, but if you miss any then it’s another story. "},{"type":"text","text":"@code_warntype","style":{"code":true}},{"type":"text","text":" FTW"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"raised_hands","users":["U01FAHWCMFF"],"count":1},{"name":"point_up","users":["UB7JS9CHF","U67G3QRJM"],"count":2}]},{"client_msg_id":"2486b011-7fd2-4f31-967a-2c44e372558d","type":"message","text":"the problems I always run into are related to compiler optimizations that may or may not occur, and its hard to tell when they'll actually happen and its sometimes hard to force them to happen","user":"U01GRS159T8","ts":"1609352756.263200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FjmF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the problems I always run into are related to compiler optimizations that may or may not occur, and its hard to tell when they'll actually happen and its sometimes hard to force them to happen"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"heavy_check_mark","users":["UGU761DU2"],"count":1}]},{"client_msg_id":"9a1f6824-3760-4129-9eef-4e3f318fc4b4","type":"message","text":"things like eliding certain small heap allocations or union splitting","user":"U01GRS159T8","ts":"1609352788.263400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"id4l1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"things like eliding certain small heap allocations or union splitting"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"82e2a80c-d6cb-4d8f-ad69-2d782a90d34b","type":"message","text":"No tail call elimination. Relatively slow IO (though I'm not sure where the fault is). Sometimes you hit the internals of Julia which is written in C, and therefore can't inline and be optimized. Poor support for stack-allocated arrays and static arrays.","user":"U7HAYKY9X","ts":"1609354104.263800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X4hB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No tail call elimination. Relatively slow IO (though I'm not sure where the fault is). Sometimes you hit the internals of Julia which is written in C, and therefore can't inline and be optimized. Poor support for stack-allocated arrays and static arrays."}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"dc97ac9a-7698-4e50-8f55-d239a9ddf1a4","type":"message","text":"I'm not sure no tail call is bad. tail call elimination destroys debugging and is usually better written as a loop.","user":"U0179G7FG4F","ts":"1609354167.264000","team":"T68168MUP","edited":{"user":"U0179G7FG4F","ts":"1609354173.000000"},"blocks":[{"type":"rich_text","block_id":"eVe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure no tail call is bad. tail call elimination destroys debugging and is usually better written as a loop."}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"point_up","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"466b7b9f-0ddc-4d77-b7a2-6afbea9a9015","type":"message","text":"jakob this is related to the sometimes poor IO performance\n<https://github.com/JuliaLang/julia/issues/39041>","user":"U01GRS159T8","ts":"1609354250.264300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d6dp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"jakob this is related to the sometimes poor IO performance\n"},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/39041"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"3e1431eb-df85-4c0b-8304-8084b1c50021","type":"message","text":"Better optimized Union types (not sure that's in C, though)","user":"U7HAYKY9X","ts":"1609354271.264500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2IEv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Better optimized Union types (not sure that's in C, though)"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"2c7a2d05-e049-460d-a5d3-97e30315752e","type":"message","text":"Also, garbage collection is slower than manual or deterministic destruction","user":"U7HAYKY9X","ts":"1609354306.264700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"371","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, garbage collection is slower than manual or deterministic destruction"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"this-is-true","users":["UGU761DU2"],"count":1}]},{"client_msg_id":"19b4c04f-932e-4b3e-a682-0da0fafc038a","type":"message","text":"gc is definitely a weakpoint for us. We have the problem that experienced Julia programmers don't often get bit by it since Julia gives you pretty good tools to avoid allocation. Languages like Java have excellent GC since otherwise they would be completely unusable for performance sensitive things. We really should get someone from that world to take a look and see what we could do better","user":"U0179G7FG4F","ts":"1609354842.265100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XOA8b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"gc is definitely a weakpoint for us. We have the problem that experienced Julia programmers don't often get bit by it since Julia gives you pretty good tools to avoid allocation. Languages like Java have excellent GC since otherwise they would be completely unusable for performance sensitive things. We really should get someone from that world to take a look and see what we could do better"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF","reactions":[{"name":"raised_hands","users":["U01FAHWCMFF","UB7JS9CHF","UGU761DU2"],"count":3}]},{"client_msg_id":"ec9be196-32cd-4d73-9b77-4b6969ba70dc","type":"message","text":"Why does TCE destroys debugging? Is it just that the stack is too big to reasonably read?","user":"UDD5Z7FLZ","ts":"1609407168.266700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FQW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why does TCE destroys debugging? Is it just that the stack is too big to reasonably read?"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"0c0cb3ed-0da2-4e29-aa1a-e5958245a65f","type":"message","text":"tail call elimination eliminates any sense of \"how far along are we?\"","user":"UH24GRBLL","ts":"1609407355.266900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9v+3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"tail call elimination eliminates any sense of \"how far along are we?\""}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"60250d1b-b187-48b1-891d-273492863603","type":"message","text":"since the tail call is collapsed into a jump, intermediary state of other calls is gone","user":"UH24GRBLL","ts":"1609407387.267100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rOX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"since the tail call is collapsed into a jump, intermediary state of other calls is gone"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5b8ecd29-27c1-455c-a09a-7617b493cf16","type":"message","text":"But you don't think while loops destroy debugging?","user":"UDD5Z7FLZ","ts":"1609407733.267300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rL+Gn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But you don't think while loops destroy debugging?"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"5f9fb3fd-d68b-49ed-ae47-bc559e572172","type":"message","text":"well, for those the loop already exists in the source code, so the position the debugger shows makes sense","user":"UH24GRBLL","ts":"1609407996.267500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KBVyU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"well, for those the loop already exists in the source code, so the position the debugger shows makes sense"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"867b23cf-11ed-4b23-b4dd-962ac80c22ad","type":"message","text":"for TCE, since the recursion is transformed, there's no easy way to map the position in the actual execution to the source code with the calls","user":"UH24GRBLL","ts":"1609408023.267700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eWWH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for TCE, since the recursion is transformed, there's no easy way to map the position in the actual execution to the source code with the calls"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"a7659172-8fb9-491c-b0b6-66514af5039a","type":"message","text":"hence why it's harder :man-shrugging:","user":"UH24GRBLL","ts":"1609408047.267900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M+2bt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hence why it's harder "},{"type":"emoji","name":"man-shrugging"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"a08f7da5-5593-4fdf-9d55-4e821e98978a","type":"message","text":"I just feel that this is more of a debugger issue rather than a valid argument of the avoidance of TCE. I think the proposed reason of why not TCE of \"its hard to implement and doesnt achieve much\" would resonate more.","user":"UDD5Z7FLZ","ts":"1609408086.268100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/qz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just feel that this is more of a debugger issue rather than a valid argument of the avoidance of TCE. I think the proposed reason of why not TCE of \"its hard to implement and doesnt achieve much\" would resonate more."}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"a1bf66c5-89f7-4675-9881-4f41ceff638b","type":"message","text":"I agree, and IIRC the consensus was that TCE would be useful, it just hasn't been a focus yet","user":"UH24GRBLL","ts":"1609408115.268300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J0N","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree, and IIRC the consensus was that TCE would be useful, it just hasn't been a focus yet"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"},{"client_msg_id":"f59e483e-12fa-4e45-8fe8-d64568920cfb","type":"message","text":"There are a lot of things, where some more work can help improve the performance, some at the very low level.   One thing is the overhead of try/catch, unlike in CLU or C++, try is not zero cost.\nI’m not *too* concerned for the moment, because all of the issues I know about, that I’d like to see change, only affect the internals (or add new low level functionality that is backwards compatible, no need to wait for Julia 2.0)","user":"UB7JS9CHF","ts":"1609419400.281700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l4A","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are a lot of things, where some more work can help improve the performance, some at the very low level.   One thing is the overhead of try/catch, unlike in CLU or C++, try is not zero cost.\nI’m not "},{"type":"text","text":"too","style":{"bold":true}},{"type":"text","text":" concerned for the moment, because all of the issues I know about, that I’d like to see change, only affect the internals (or add new low level functionality that is backwards compatible, no need to wait for Julia 2.0)"}]}]}],"thread_ts":"1609345469.261100","parent_user_id":"U01FAHWCMFF"}]