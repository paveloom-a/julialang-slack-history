[{"client_msg_id":"c5dbdcbb-84e1-46f3-b1c1-ce09e7246032","type":"message","text":"Does anyone have a good way of making a struct use a memory arena? <https://github.com/tonyrubak/MemoryArena.jl> Looks unmaintained, and it would be nice to have a go-to idiom for this","user":"U0179G7FG4F","ts":"1614393044.032100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LpmUQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone have a good way of making a struct use a memory arena? "},{"type":"link","url":"https://github.com/tonyrubak/MemoryArena.jl"},{"type":"text","text":" Looks unmaintained, and it would be nice to have a go-to idiom for this"}]}]}],"thread_ts":"1614393044.032100","reply_count":2,"reply_users_count":1,"latest_reply":"1614449589.032600","reply_users":["UAUPJLBQX"],"subscribed":false},{"client_msg_id":"453a5fbd-cdd4-4944-81a0-4eaa815b6420","type":"message","text":"It'd be nice to put some sugar on that sort of memory management.\nSomething I've done in the past is define 2 struct types: 1 real one, and 1 sham that's just a pointer.\nThen, define convenience getter function for accessing the fields based on offsets (e.g., using `fieldoffset` with reference to the non-sham type).\nThen I can manage memory manually, e.g. operating on a `malloc` blocked of memory that acts like a stack. Here is an example:\n<https://github.com/chriselrod/QuasiNewtonMethods.jl/blob/06a3ee71fc2b20a1cd064dccc26e61acfc8111ac/src/QuasiNewtonMethods.jl#L114>\nWould be great to make sugar for automatically defining the pointer type with convenience functions (maybe even using `getproperty` overloading?) and of course adding a total-size function for how much memory it consumes from whatever our own custom memory type is.","user":"UAUPJLBQX","ts":"1614449516.032400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4hfD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It'd be nice to put some sugar on that sort of memory management.\nSomething I've done in the past is define 2 struct types: 1 real one, and 1 sham that's just a pointer.\nThen, define convenience getter function for accessing the fields based on offsets (e.g., using "},{"type":"text","text":"fieldoffset","style":{"code":true}},{"type":"text","text":" with reference to the non-sham type).\nThen I can manage memory manually, e.g. operating on a "},{"type":"text","text":"malloc","style":{"code":true}},{"type":"text","text":" blocked of memory that acts like a stack. Here is an example:\n"},{"type":"link","url":"https://github.com/chriselrod/QuasiNewtonMethods.jl/blob/06a3ee71fc2b20a1cd064dccc26e61acfc8111ac/src/QuasiNewtonMethods.jl#L114"},{"type":"text","text":"\nWould be great to make sugar for automatically defining the pointer type with convenience functions (maybe even using "},{"type":"text","text":"getproperty","style":{"code":true}},{"type":"text","text":" overloading?) and of course adding a total-size function for how much memory it consumes from whatever our own custom memory type is."}]}]}],"thread_ts":"1614393044.032100","parent_user_id":"U0179G7FG4F","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F","U9YTNSWCA"],"count":2}]},{"client_msg_id":"3959fa24-cf55-4888-b9e7-822c6e2251d9","type":"message","text":"(The `PtrArray` type from `StrideArrays.jl`/`StrideArraysCore.jl` provides a strided array type you can use with arbitrary memory.)","user":"UAUPJLBQX","ts":"1614449589.032600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FaDsX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(The "},{"type":"text","text":"PtrArray","style":{"code":true}},{"type":"text","text":" type from "},{"type":"text","text":"StrideArrays.jl","style":{"code":true}},{"type":"text","text":"/"},{"type":"text","text":"StrideArraysCore.jl","style":{"code":true}},{"type":"text","text":" provides a strided array type you can use with arbitrary memory.)"}]}]}],"thread_ts":"1614393044.032100","parent_user_id":"U0179G7FG4F"}]