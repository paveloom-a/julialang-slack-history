[{"client_msg_id":"468584d3-ae05-40dc-bbc9-26b2ff406991","type":"message","text":"I found a quick comparison code on github that was comparing C vs Java and decided to add Julia and python to the mix. The code is not pretty, but I was wondering if people could give me some feedback. Will post the code inside the thread.","user":"U013V2CFZAN","ts":"1611227612.005500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1DZK4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I found a quick comparison code on github that was comparing C vs Java and decided to add Julia and python to the mix. The code is not pretty, but I was wondering if people could give me some feedback. Will post the code inside the thread."}]}]}],"thread_ts":"1611227612.005500","reply_count":2,"reply_users_count":1,"latest_reply":"1611227688.005800","reply_users":["U013V2CFZAN"],"subscribed":false},{"client_msg_id":"1b8e59ea-d3d0-4f56-8cb2-915c85290925","type":"message","text":"```using LoopVectorization\n\nconst NSIZE = 1000\nconst MINOR_LOOPS = 1000\nconst LOOPS = 10\n\n\n# I would rather use BenchmarkTools, but since the other languages are not using something\n# similar I will stick to simple timing for now \n\nfunction main(loopfunction::Function)\n    println(\"Starting\")\n\n    a = Array{Float64,2}(undef, NSIZE, NSIZE)\n    \n    for n in 1:LOOPS\n        \n        a .= zeros(Float64, NSIZE, NSIZE)     \n\t\tdiff = @elapsed loopfunction(a)\n\n\t\tprintln(\"Time taken $diff seconds\")    \n    end\n\nend\n\n# Takes ~3.3s roughly on my computer ... similar code style using python takes ~255s (I tried with lists and numpy arrays)\nfunction regular_loop(a)\n    @inbounds @fastmath for k in 1:MINOR_LOOPS\n        a[1,1] = 1.0\n        @inbounds for i in 2:NSIZE-1, j in 2:NSIZE-1\n            a[i, j] = (a[i, j]  + a[i-1, j] + a[i+1, j]  + a[i, j+1] + a[i, j-1]) / 5.0\n        end\n    end\nend\n\n# Takes ~15s on my computer ... similar code style using numpy in python takes ~3s \nfunction array_style(a)\n    @inbounds for k in 1:MINOR_LOOPS\n        a[1,1] = 1.0\n        off0 = 2:NSIZE-1\n        offm1 = 1:NSIZE-2\n        offp1 = 3:NSIZE\n        a[off0, off0] .= (a[off0, off0]  + a[offm1, off0] + a[offp1, off0]  + a[off0, offp1] + a[off0, offm1]) / 5.0\n    end\nend\n\n# Takes ~0.67s on my computer\nfunction avx_loop(a)\n    @inbounds for k in 1:MINOR_LOOPS\n        a[1,1] = 1.0\n        @avx for i in 2:NSIZE-1, j in 2:NSIZE-1\n            a[i, j] = (a[i, j]  + a[i-1, j] + a[i+1, j]  + a[i, j+1] + a[i, j-1]) / 5.0\n        end\n    end\nend\n\nmain(regular_loop)\nmain(array_style)\nmain(avx_loop)```","user":"U013V2CFZAN","ts":"1611227631.005600","team":"T68168MUP","edited":{"user":"U013V2CFZAN","ts":"1611228773.000000"},"blocks":[{"type":"rich_text","block_id":"erNK","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using LoopVectorization\n\nconst NSIZE = 1000\nconst MINOR_LOOPS = 1000\nconst LOOPS = 10\n\n\n# I would rather use BenchmarkTools, but since the other languages are not using something\n# similar I will stick to simple timing for now \n\nfunction main(loopfunction::Function)\n    println(\"Starting\")\n\n    a = Array{Float64,2}(undef, NSIZE, NSIZE)\n    \n    for n in 1:LOOPS\n        \n        a .= zeros(Float64, NSIZE, NSIZE)     \n\t\tdiff = @elapsed loopfunction(a)\n\n\t\tprintln(\"Time taken $diff seconds\")    \n    end\n\nend\n\n# Takes ~3.3s roughly on my computer ... similar code style using python takes ~255s (I tried with lists and numpy arrays)\nfunction regular_loop(a)\n    @inbounds @fastmath for k in 1:MINOR_LOOPS\n        a[1,1] = 1.0\n        @inbounds for i in 2:NSIZE-1, j in 2:NSIZE-1\n            a[i, j] = (a[i, j]  + a[i-1, j] + a[i+1, j]  + a[i, j+1] + a[i, j-1]) / 5.0\n        end\n    end\nend\n\n# Takes ~15s on my computer ... similar code style using numpy in python takes ~3s \nfunction array_style(a)\n    @inbounds for k in 1:MINOR_LOOPS\n        a[1,1] = 1.0\n        off0 = 2:NSIZE-1\n        offm1 = 1:NSIZE-2\n        offp1 = 3:NSIZE\n        a[off0, off0] .= (a[off0, off0]  + a[offm1, off0] + a[offp1, off0]  + a[off0, offp1] + a[off0, offm1]) / 5.0\n    end\nend\n\n# Takes ~0.67s on my computer\nfunction avx_loop(a)\n    @inbounds for k in 1:MINOR_LOOPS\n        a[1,1] = 1.0\n        @avx for i in 2:NSIZE-1, j in 2:NSIZE-1\n            a[i, j] = (a[i, j]  + a[i-1, j] + a[i+1, j]  + a[i, j+1] + a[i, j-1]) / 5.0\n        end\n    end\nend\n\nmain(regular_loop)\nmain(array_style)\nmain(avx_loop)"}]}]}],"thread_ts":"1611227612.005500","parent_user_id":"U013V2CFZAN"},{"client_msg_id":"c5a64a27-e49d-4631-913c-101228669534","type":"message","text":"FYI, it's based on this <https://github.com/davidmoten/c-vs-java>","user":"U013V2CFZAN","ts":"1611227688.005800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZSkGm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"FYI, it's based on this "},{"type":"link","url":"https://github.com/davidmoten/c-vs-java"}]}]}],"thread_ts":"1611227612.005500","parent_user_id":"U013V2CFZAN"}]