[{"client_msg_id":"d70e31e6-442f-470b-b3a7-85dddf700ed7","type":"message","text":"what is this (pretty huge) difference in performance between anonymous function and normal function due to? Do anonymous functions have some extra overhead when called?\n\n```julia&gt; f = x -&gt; x+1\n#95 (generic function with 1 method)\n\njulia&gt; g(x) = x+1\ng (generic function with 1 method)\n\njulia&gt; @btime f(1)\n  20.543 ns (0 allocations: 0 bytes)\n2\n\njulia&gt; @btime g(1)\n  0.001 ns (0 allocations: 0 bytes)```","user":"U012RPHRSP3","ts":"1612037752.082300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yAs+z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what is this (pretty huge) difference in performance between anonymous function and normal function due to? Do anonymous functions have some extra overhead when called?\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> f = x -> x+1\n#95 (generic function with 1 method)\n\njulia> g(x) = x+1\ng (generic function with 1 method)\n\njulia> @btime f(1)\n  20.543 ns (0 allocations: 0 bytes)\n2\n\njulia> @btime g(1)\n  0.001 ns (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1612037752.082300","reply_count":10,"reply_users_count":4,"latest_reply":"1612085760.085100","reply_users":["U7HAYKY9X","U011V2YN59N","U012RPHRSP3","U01H36BUDJB"],"subscribed":false},{"client_msg_id":"f66ca20a-8f27-4935-a63b-c85653bebb02","type":"message","text":"It's the same. It must be a benchmarking artifact. Also note that it reports it can do addition in a picosecond, which is not possible","user":"U7HAYKY9X","ts":"1612037843.082400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZIc2X","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's the same. It must be a benchmarking artifact. Also note that it reports it can do addition in a picosecond, which is not possible"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3"},{"client_msg_id":"a07dfd30-88bf-482d-83ec-7db7ee55ece8","type":"message","text":"yes the compiler is doing the addition for you, ahead of time","user":"U011V2YN59N","ts":"1612037866.082600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dgalr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes the compiler is doing the addition for you, ahead of time"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3"},{"client_msg_id":"3af516fc-7cf0-4822-9d8c-5e0a8099a2c8","type":"message","text":"for `g`","user":"U011V2YN59N","ts":"1612037882.082800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M7cIl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for "},{"type":"text","text":"g","style":{"code":true}}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3"},{"client_msg_id":"505074af-d13d-4e1a-b41d-caaca1625857","type":"message","text":"I think the main difference is that function are declared constant","user":"U7HAYKY9X","ts":"1612037922.083000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PZXb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think the main difference is that function are declared constant"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3","reactions":[{"name":"+1","users":["U012RPHRSP3"],"count":1}]},{"client_msg_id":"eee418f9-977f-4c0a-b439-7d27bc8fae4e","type":"message","text":"so they should take the same amount of time, but `g` seems faster because it's precomputed ahead of time, which the benchmarking tool does not take into acount?","user":"U012RPHRSP3","ts":"1612038183.083200","team":"T68168MUP","edited":{"user":"U012RPHRSP3","ts":"1612038215.000000"},"blocks":[{"type":"rich_text","block_id":"W/IMo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so they should take the same amount of time, but "},{"type":"text","text":"g","style":{"code":true}},{"type":"text","text":" seems faster because it's precomputed ahead of time, which the benchmarking tool does not take into acount?"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"f0f6c529-2a81-488b-a018-0bc1995a9a08","type":"message","text":"yes, specifically as <@U7HAYKY9X> suggested, `g`  is actually a constant whereas `f` is a variable holding a function","user":"U011V2YN59N","ts":"1612038391.083600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J32Q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, specifically as "},{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" suggested, "},{"type":"text","text":"g","style":{"code":true}},{"type":"text","text":"  is actually a constant whereas "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" is a variable holding a function"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3","reactions":[{"name":"+1","users":["U012RPHRSP3"],"count":1}]},{"client_msg_id":"b66be842-56ac-4d1e-873e-7505c3f73131","type":"message","text":"consider\n```julia&gt; const h = x -&gt; x+1\n#10 (generic function with 1 method)\n\njulia&gt; @btime g(rand())\n^[[A  3.298 ns (0 allocations: 0 bytes)\n1.6780005922260453\n\njulia&gt; @btime f(rand())\n  13.469 ns (2 allocations: 32 bytes)\n1.7856980843134607\n\njulia&gt; @btime h(rand())\n  3.309 ns (0 allocations: 0 bytes)\n1.1392644968677543```","user":"U011V2YN59N","ts":"1612038483.084000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B7/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"consider\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> const h = x -> x+1\n#10 (generic function with 1 method)\n\njulia> @btime g(rand())\n^[[A  3.298 ns (0 allocations: 0 bytes)\n1.6780005922260453\n\njulia> @btime f(rand())\n  13.469 ns (2 allocations: 32 bytes)\n1.7856980843134607\n\njulia> @btime h(rand())\n  3.309 ns (0 allocations: 0 bytes)\n1.1392644968677543"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3","reactions":[{"name":"heart_eyes","users":["U012RPHRSP3"],"count":1}]},{"client_msg_id":"a8fe110f-29df-4a9c-9615-822da1df6f22","type":"message","text":"the `rand()` prevents the compiler from being able to precompute anything","user":"U011V2YN59N","ts":"1612038502.084200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xz4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the "},{"type":"text","text":"rand()","style":{"code":true}},{"type":"text","text":" prevents the compiler from being able to precompute anything"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3","reactions":[{"name":"+1","users":["U67G3QRJM"],"count":1}]},{"client_msg_id":"2b002eb3-3348-4344-864d-0faa26b0db5e","type":"message","text":"That example really helped understanding, thank you!","user":"U012RPHRSP3","ts":"1612038778.084500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pk9V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That example really helped understanding, thank you!"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3","reactions":[{"name":"+1","users":["U011V2YN59N"],"count":1}]},{"client_msg_id":"84bcd06b-d15a-4558-843a-8ebe759c386c","type":"message","text":"Might be worth mentioning that in older versions of Julia (pre 0.6, I think?) there actually was a performance disparity between normal and anonymous functions due to the compiler being unable to properly infer types. And there still is a major performance impact of using function closures due to type inference failure: <https://github.com/JuliaLang/julia/issues/23618>","user":"U01H36BUDJB","ts":"1612085760.085100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Olvhb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Might be worth mentioning that in older versions of Julia (pre 0.6, I think?) there actually was a performance disparity between normal and anonymous functions due to the compiler being unable to properly infer types. And there still is a major performance impact of using function closures due to type inference failure: "},{"type":"link","url":"https://github.com/JuliaLang/julia/issues/23618"}]}]}],"thread_ts":"1612037752.082300","parent_user_id":"U012RPHRSP3"}]