[{"client_msg_id":"7fdfaccf-f3c5-467f-8fe2-c0250dbd995f","type":"message","text":"When I run joining benchmarks in DataFrames.jl I get the following timing for `llen=10^6` and `rlen=2*20^7`:\n```[ Info: sorted int duplicates many\n 34.686326 seconds (171 allocations: 2.454 GiB, 91.70% gc time)\n 34.366576 seconds (171 allocations: 2.454 GiB, 91.61% gc time)```\nwhen called from within a function. But if I call the same code (copy-pasted) in top level scope I get:\n```julia&gt; df1 = DataFrame(id = sort!(rand(1:llen ÷ 100, llen)), copycols=false);\n\njulia&gt; df2 = DataFrame(id = sort!(rand(1:rlen ÷ 100, rlen)), copycols=false);\n\njulia&gt; GC.gc()\n\njulia&gt; @time innerjoin(df1, df2, on=:id);\n  3.472643 seconds (172 allocations: 2.453 GiB, 9.72% gc time)\n\njulia&gt; GC.gc()\n\njulia&gt; @time innerjoin(df2, df1, on=:id);\n  3.269198 seconds (172 allocations: 2.453 GiB, 6.79% gc time)```\nCould someone please help me understand what is going on here? Why `GC.gc()` does not garbage collect things if it is called within a loop that is in a function but does it when called in top-level scope? (within a function only `df1` and `df2` variables get binding except for some variables controlling looping - these variables are bound to other values earlier in the function but then are rebound as in the code above) CC <@U67431ELR>","user":"U8JAMQGQY","ts":"1612968087.157100","team":"T68168MUP","edited":{"user":"U8JAMQGQY","ts":"1612968229.000000"},"blocks":[{"type":"rich_text","block_id":"yc6u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When I run joining benchmarks in DataFrames.jl I get the following timing for "},{"type":"text","text":"llen=10^6","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"rlen=2*20^7","style":{"code":true}},{"type":"text","text":":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"[ Info: sorted int duplicates many\n 34.686326 seconds (171 allocations: 2.454 GiB, 91.70% gc time)\n 34.366576 seconds (171 allocations: 2.454 GiB, 91.61% gc time)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"when called from within a function. But if I call the same code (copy-pasted) in top level scope I get:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> df1 = DataFrame(id = sort!(rand(1:llen ÷ 100, llen)), copycols=false);\n\njulia> df2 = DataFrame(id = sort!(rand(1:rlen ÷ 100, rlen)), copycols=false);\n\njulia> GC.gc()\n\njulia> @time innerjoin(df1, df2, on=:id);\n  3.472643 seconds (172 allocations: 2.453 GiB, 9.72% gc time)\n\njulia> GC.gc()\n\njulia> @time innerjoin(df2, df1, on=:id);\n  3.269198 seconds (172 allocations: 2.453 GiB, 6.79% gc time)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Could someone please help me understand what is going on here? Why "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" does not garbage collect things if it is called within a loop that is in a function but does it when called in top-level scope? (within a function only "},{"type":"text","text":"df1","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"df2","style":{"code":true}},{"type":"text","text":" variables get binding except for some variables controlling looping - these variables are bound to other values earlier in the function but then are rebound as in the code above) CC "},{"type":"user","user_id":"U67431ELR"}]}]}],"thread_ts":"1612968087.157100","reply_count":16,"reply_users_count":4,"latest_reply":"1612971441.160700","reply_users":["U01H36BUDJB","UCZ7VBGUD","U8JAMQGQY","U67431ELR"],"subscribed":false},{"client_msg_id":"41c235c4-0fa3-423d-ac84-9d515f7ce504","type":"message","text":"Relevant: <https://discourse.julialang.org/t/when-does-the-garbage-collector-runs/15142>","user":"U01H36BUDJB","ts":"1612968498.157300","team":"T68168MUP","attachments":[{"service_name":"JuliaLang","title":"When does the garbage collector runs?","title_link":"https://discourse.julialang.org/t/when-does-the-garbage-collector-runs/15142","text":"Hello everyone, I was hoping that GC would free some memory, and I noticed that it does not works when I’m using @btime. Here, a basic example using BenchmarkTools function a(N) x = rand(N) @time y = sin.(x) x = 1; y = 1; GC.gc() end function b(N) x = rand(N) @btime y = sin.($x) x = 1; y = 1; GC.gc() end a(10^8) GC.gc() # actually clears the memory b(10^8) GC.gc() # does not clears the memory There are two points that I would like to understand. I can see in my System Monitor t...","fallback":"JuliaLang: When does the garbage collector runs?","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","fields":[{"title":"Reading time","value":"1 mins :clock2:","short":true},{"title":"Likes","value":"1 :heart:","short":true}],"ts":1537298940,"from_url":"https://discourse.julialang.org/t/when-does-the-garbage-collector-runs/15142","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/when-does-the-garbage-collector-runs/15142"}],"blocks":[{"type":"rich_text","block_id":"bI1eW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Relevant: "},{"type":"link","url":"https://discourse.julialang.org/t/when-does-the-garbage-collector-runs/15142"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"8e47b415-c39c-44e3-bcf2-4c5396fa1f32","type":"message","text":"Also, I don't think it's a good idea to call GC explicitly in a loop. You're triggering a sweep regardless of whether or not it is necessary, which is probably why you're getting 90% GC time. Have you tried removing your `GC` calls and just letting the runtime handle it?","user":"U01H36BUDJB","ts":"1612968620.157600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GSiWA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, I don't think it's a good idea to call GC explicitly in a loop. You're triggering a sweep regardless of whether or not it is necessary, which is probably why you're getting 90% GC time. Have you tried removing your "},{"type":"text","text":"GC","style":{"code":true}},{"type":"text","text":" calls and just letting the runtime handle it?"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"a4b24c26-e09b-4e96-853d-78511f68e028","type":"message","text":"BenchmarkTools runs gc four times in a row btw: <https://github.com/JuliaCI/BenchmarkTools.jl/blob/65620228af076a67506a618d7e61fa61b3c60cc5/src/execution.jl#L1-L4>","user":"UCZ7VBGUD","ts":"1612968735.157800","team":"T68168MUP","edited":{"user":"UCZ7VBGUD","ts":"1612968829.000000"},"blocks":[{"type":"rich_text","block_id":"72nen","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"BenchmarkTools runs gc four times in a row btw: "},{"type":"link","url":"https://github.com/JuliaCI/BenchmarkTools.jl/blob/65620228af076a67506a618d7e61fa61b3c60cc5/src/execution.jl#L1-L4"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY","reactions":[{"name":"scream","users":["U8JAMQGQY"],"count":1}]},{"client_msg_id":"5da439ec-2863-406b-ab89-18c90f4b0430","type":"message","text":"I will check, but then the problem is that I do not have a control over when GC gets run. I could use `@benchmark` but most of the tests I run take significant time, so running them once is enough for me.","user":"U8JAMQGQY","ts":"1612968741.158000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jdC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I will check, but then the problem is that I do not have a control over when GC gets run. I could use "},{"type":"text","text":"@benchmark","style":{"code":true}},{"type":"text","text":" but most of the tests I run take significant time, so running them once is enough for me."}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"82191b02-2a82-4cd6-b654-14e2fe9aba02","type":"message","text":"Interesting. So the function would have a variable which prevents an object from being GCed and that would slow down everything?","user":"U67431ELR","ts":"1612969687.158400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EBK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Interesting. So the function would have a variable which prevents an object from being GCed and that would slow down everything?"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"011a62a1-0373-4934-a312-223104c1f3e0","type":"message","text":"But I made sure not to leave such dangling references - unless the compiler decides to delay performing of binding operation till it is really needed. Maybe adding `@info nrow(df1)` or similar will resolve the problem as this must force the compiler to rebind the variable before `GC.gc()` is run.","user":"U8JAMQGQY","ts":"1612969852.158600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zaNS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But I made sure not to leave such dangling references - unless the compiler decides to delay performing of binding operation till it is really needed. Maybe adding "},{"type":"text","text":"@info nrow(df1)","style":{"code":true}},{"type":"text","text":" or similar will resolve the problem as this must force the compiler to rebind the variable before "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" is run."}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"58869a93-759f-4a98-9975-3c0b4c7f0d64","type":"message","text":"<@U67431ELR> Yes that is possible. <@U8JAMQGQY> What do you mean you don't have control? It's not your code? Or just in general? Julia is fast, but it's not C. `GC.gc()` isn't a replacement for manual memory management, of course.","user":"U01H36BUDJB","ts":"1612969915.158800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dtGOl","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67431ELR"},{"type":"text","text":" Yes that is possible. "},{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" What do you mean you don't have control? It's not your code? Or just in general? Julia is fast, but it's not C. "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" isn't a replacement for manual memory management, of course."}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"03e83cce-eb50-4ba8-8b5c-7276d57068f9","type":"message","text":"Have you tried removing other code from the function to see whether it makes a difference?","user":"U67431ELR","ts":"1612969922.159000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dDxRK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Have you tried removing other code from the function to see whether it makes a difference?"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"b79533d0-9171-40f1-ac1f-88da7616c620","type":"message","text":"Also worth noting that you *never* have control over when GC gets run. `GC.gc()` just forces a GC sweep at that point. It doesn't force the runtime to actually garbage collect anything, and it doesn't necessarily prevent GC from running at some other point.","user":"U01H36BUDJB","ts":"1612970024.159200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tj3t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also worth noting that you "},{"type":"text","text":"never","style":{"bold":true}},{"type":"text","text":" have control over when GC gets run. "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" just forces a GC sweep at that point. It doesn't force the runtime to actually garbage collect anything, and it doesn't necessarily prevent GC from running at some other point."}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"a78b2f90-9936-4079-8088-75b2c5ee3516","type":"message","text":"You may also want to consider that DataFrame is type unstable by default. This can slow things down considerably and possibly also force additional allocations. You can force it to be type stable by using `Table.columntable` . I'm not sure if the implementation of `innerjoin` does this internally or not, but it might be worth looking into. See also: <https://www.juliabloggers.com/why-dataframe-is-not-type-stable-and-when-it-matters/>","user":"U01H36BUDJB","ts":"1612970388.159400","team":"T68168MUP","attachments":[{"service_name":"juliabloggers.com","title":"Why DataFrame is not type stable and when it matters | juliabloggers.com","title_link":"https://www.juliabloggers.com/why-dataframe-is-not-type-stable-and-when-it-matters/","text":"Introduction","fallback":"juliabloggers.com: Why DataFrame is not type stable and when it matters | juliabloggers.com","from_url":"https://www.juliabloggers.com/why-dataframe-is-not-type-stable-and-when-it-matters/","service_icon":"https://www.juliabloggers.com/favicon.ico","id":1,"original_url":"https://www.juliabloggers.com/why-dataframe-is-not-type-stable-and-when-it-matters/"}],"blocks":[{"type":"rich_text","block_id":"E2P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You may also want to consider that DataFrame is type unstable by default. This can slow things down considerably and possibly also force additional allocations. You can force it to be type stable by using "},{"type":"text","text":"Table.columntable","style":{"code":true}},{"type":"text","text":" . I'm not sure if the implementation of "},{"type":"text","text":"innerjoin","style":{"code":true}},{"type":"text","text":" does this internally or not, but it might be worth looking into. See also: "},{"type":"link","url":"https://www.juliabloggers.com/why-dataframe-is-not-type-stable-and-when-it-matters/"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"98c46d38-26b2-4323-8a43-8e5a86dab4b3","type":"message","text":"<@U01H36BUDJB> I think you should check who's the author of that blog post. :wink:","user":"U67431ELR","ts":"1612970439.159700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O2y","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01H36BUDJB"},{"type":"text","text":" I think you should check who's the author of that blog post. "},{"type":"emoji","name":"wink"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"b14dfab2-f9f4-4524-94ba-f4611a7a61fb","type":"message","text":"I see, nice :slightly_smiling_face:","user":"U01H36BUDJB","ts":"1612970473.159900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eXJNs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see, nice "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"264288da-2608-4a20-a376-702398fc6e82","type":"message","text":"Wait <@U8JAMQGQY> are you disabling GC via `GC.enable(false)`  and relying on manual calls? Or just calling `GC.gc()` ?","user":"U01H36BUDJB","ts":"1612970962.160100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9GSR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Wait "},{"type":"user","user_id":"U8JAMQGQY"},{"type":"text","text":" are you disabling GC via "},{"type":"text","text":"GC.enable(false)","style":{"code":true}},{"type":"text","text":"  and relying on manual calls? Or just calling "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"bde8e9d6-f7c2-46d7-9c5c-d3994b600766","type":"message","text":"No - just calling `GC.gc()`. The `innerjoin` code we discuss is type stable. Look at the `@time` report above. I have only 171 allocations there - and this is expected (I create some `Dict`s and `Vector`s). For sure no boxing or anything like this happens there (the loops inside the function run tens millions of times for the parameters I pass them). With 171 allocations it is impossible that GC spends 30 seconds doing GC. It must be sweeping some objects that were allocated earlier and not cleaned by `GC.gc()`","user":"U8JAMQGQY","ts":"1612971140.160300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lev","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No - just calling "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":". The "},{"type":"text","text":"innerjoin","style":{"code":true}},{"type":"text","text":" code we discuss is type stable. Look at the "},{"type":"text","text":"@time","style":{"code":true}},{"type":"text","text":" report above. I have only 171 allocations there - and this is expected (I create some "},{"type":"text","text":"Dict","style":{"code":true}},{"type":"text","text":"s and "},{"type":"text","text":"Vector","style":{"code":true}},{"type":"text","text":"s). For sure no boxing or anything like this happens there (the loops inside the function run tens millions of times for the parameters I pass them). With 171 allocations it is impossible that GC spends 30 seconds doing GC. It must be sweeping some objects that were allocated earlier and not cleaned by "},{"type":"text","text":"GC.gc()","style":{"code":true}}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"d2997512-8f13-421f-ba0f-98267ea0f762","type":"message","text":"Maybe `GC.gc(full=false)` would help?","user":"U01H36BUDJB","ts":"1612971274.160500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ri=Fy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe "},{"type":"text","text":"GC.gc(full=false)","style":{"code":true}},{"type":"text","text":" would help?"}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"},{"client_msg_id":"34c920c2-7094-41d5-a391-c692ce81822c","type":"message","text":"From the documentation, for reference:\n&gt; The argument `full` determines the kind of collection: A full collection (default) sweeps all objects, which makes the next GC scan much slower, while an incremental collection may only sweep so-called young objects.","user":"U01H36BUDJB","ts":"1612971441.160700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4N/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"From the documentation, for reference:\n"}]},{"type":"rich_text_quote","elements":[{"type":"text","text":"The argument "},{"type":"text","text":"full","style":{"code":true}},{"type":"text","text":" determines the kind of collection: A full collection (default) sweeps all objects, which makes the next GC scan much slower, while an incremental collection may only sweep so-called young objects."}]}]}],"thread_ts":"1612968087.157100","parent_user_id":"U8JAMQGQY"}]