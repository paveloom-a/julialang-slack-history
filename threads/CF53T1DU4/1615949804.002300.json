[{"client_msg_id":"16cd862c-b805-4ab0-8a35-d21ca6e6c1d2","type":"message","text":"If I have a function that needs _some_ arguments from a struct but not all, is it quicker to pass arguments individually or is there no performance penalty for passing the whole struct (assuming it is fully typed, doesn't generate type instability etc.)?\n\nFrom tests some small tests it appears that there is a performance penalty. Is this something that can be improved by inlining?\n\nIdeally I'd like to pass the full struct to keep the code neat (lots of arguments required). Cheers!","user":"U017FUJDBT7","ts":"1615949804.002300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QOZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I have a function that needs "},{"type":"text","text":"some","style":{"italic":true}},{"type":"text","text":" arguments from a struct but not all, is it quicker to pass arguments individually or is there no performance penalty for passing the whole struct (assuming it is fully typed, doesn't generate type instability etc.)?\n\nFrom tests some small tests it appears that there is a performance penalty. Is this something that can be improved by inlining?\n\nIdeally I'd like to pass the full struct to keep the code neat (lots of arguments required). Cheers!"}]}]}],"thread_ts":"1615949804.002300","reply_count":4,"reply_users_count":3,"latest_reply":"1615951001.004000","reply_users":["U017FUJDBT7","U0179G7FG4F","UDD5Z7FLZ"],"subscribed":false},{"client_msg_id":"c7059079-b939-44e6-94a5-396d1d787ca9","type":"message","text":"```mutable struct TestStruct\n  a1::Vector{Float64}\n  a2::Vector{Float64}\n  a3::Vector{Float64}\n  a4::Vector{Float64}\n  a5::Vector{Float64}\n  a6::Vector{Float64}\n  a7::Vector{Float64}\n  a8::Vector{Float64}\n  a9::Vector{Float64}\n  a10::Vector{Float64}\nend\n\nts = TestStruct(\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  )\n\nfunction individual(vec1, vec2)\n  for i in eachindex(vec1)\n    vec2[i] = vec1[i] + 2.0\n  end\nend\n\nfunction together(ts::TestStruct)\n  for i in eachindex(ts.a1)\n    ts.a2[i] = ts.a1[i] + 2.0\n  end\nend\n\njulia&gt; @btime together($ts)\n  5.835 μs (0 allocations: 0 bytes)\n\njulia&gt; @btime individual($(ts.a1), $(ts.a2))\n  4.907 μs (0 allocations: 0 bytes)```","user":"U017FUJDBT7","ts":"1615949996.002400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8G0","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct TestStruct\n  a1::Vector{Float64}\n  a2::Vector{Float64}\n  a3::Vector{Float64}\n  a4::Vector{Float64}\n  a5::Vector{Float64}\n  a6::Vector{Float64}\n  a7::Vector{Float64}\n  a8::Vector{Float64}\n  a9::Vector{Float64}\n  a10::Vector{Float64}\nend\n\nts = TestStruct(\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  zeros(10000),\n  )\n\nfunction individual(vec1, vec2)\n  for i in eachindex(vec1)\n    vec2[i] = vec1[i] + 2.0\n  end\nend\n\nfunction together(ts::TestStruct)\n  for i in eachindex(ts.a1)\n    ts.a2[i] = ts.a1[i] + 2.0\n  end\nend\n\njulia> @btime together($ts)\n  5.835 μs (0 allocations: 0 bytes)\n\njulia> @btime individual($(ts.a1), $(ts.a2))\n  4.907 μs (0 allocations: 0 bytes)"}]}]}],"thread_ts":"1615949804.002300","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"44f38357-bb27-4313-a3fe-cf067c33a7fa","type":"message","text":"structs are passed as pointers, so it should be fast to pass the whole thing","user":"U0179G7FG4F","ts":"1615950046.002600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2uh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"structs are passed as pointers, so it should be fast to pass the whole thing"}]}]}],"thread_ts":"1615949804.002300","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"45CDE517-58BE-420D-A84D-52AB73AC85F0","type":"message","text":"Yeah Ok, makes sense. Do you know why it seems to make a difference in my examples above?","user":"U017FUJDBT7","ts":"1615950470.003800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rkM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah Ok, makes sense. Do you know why it seems to make a difference in my examples above?"}]}]}],"thread_ts":"1615949804.002300","parent_user_id":"U017FUJDBT7"},{"client_msg_id":"aa2594b7-a2e6-460c-a822-5a1094154d40","type":"message","text":"Well, the code generated is nearly identical, so it looks like the struct is causing an additional lookup, so its slightly slower. But I tried `@inbounds` and the difference seem to vanish, so I'm not sure....","user":"UDD5Z7FLZ","ts":"1615951001.004000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vMjB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well, the code generated is nearly identical, so it looks like the struct is causing an additional lookup, so its slightly slower. But I tried "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" and the difference seem to vanish, so I'm not sure...."}]}]}],"thread_ts":"1615949804.002300","parent_user_id":"U017FUJDBT7","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F"],"count":1}]}]