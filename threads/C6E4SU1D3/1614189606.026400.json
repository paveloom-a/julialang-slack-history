[{"client_msg_id":"e584aae1-fc1a-479b-96e3-3e955bb249d1","type":"message","text":"how to plot heatmap given xs,ys,zs? currently the `heatmap(x,y,z)` requires `z` to be a matrix of size `x*y`. I have x,y,z with same length","user":"UH8A351DJ","ts":"1614189606.026400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+xd2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"how to plot heatmap given xs,ys,zs? currently the "},{"type":"text","text":"heatmap(x,y,z)","style":{"code":true}},{"type":"text","text":" requires "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" to be a matrix of size "},{"type":"text","text":"x*y","style":{"code":true}},{"type":"text","text":". I have x,y,z with same length"}]}]}],"thread_ts":"1614189606.026400","reply_count":2,"reply_users_count":2,"latest_reply":"1614190338.027100","reply_users":["UEGRU91B2","UH8A351DJ"],"subscribed":false},{"client_msg_id":"907bdbd2-bafe-4ff8-bad0-dbdfc541fa3b","type":"message","text":"I think that doesn’t work because heatmap is thought for rectilinear grids. I saw a post just today that the `plotly`backends allows that. In other backends, maybe using `surface` and selecting a good camera position?","user":"UEGRU91B2","ts":"1614190289.026900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T92yx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think that doesn’t work because heatmap is thought for rectilinear grids. I saw a post just today that the `plotly`backends allows that. In other backends, maybe using "},{"type":"text","text":"surface","style":{"code":true}},{"type":"text","text":" and selecting a good camera position?"}]}]}],"thread_ts":"1614189606.026400","parent_user_id":"UH8A351DJ"},{"client_msg_id":"aa2af8ab-f6ce-4cbe-b698-643ef8b036ff","type":"message","text":"```\"\"\"\n\n\tGiven three raw arrays, construct a partially filled matrix, returns both\n\taxises and the resultent matrix. Can be fed into Plots.heatmap directly\n\"\"\"\nfunction mesh_hm(xs, ys, zs::Array{T}) where T&lt;: Number\n\tx_axis = xs|&gt;sort|&gt;unique\n\ty_axis = ys|&gt;sort|&gt;unique\n\tres = Matrix{Union{Missing, eltype(zs)}}(undef, length(y_axis), length(x_axis))\n\tfill!(res, missing)\n\tfor (idx,z) in enumerate(zs)\n\t\tx_idx = findfirst(isequal(xs[idx]), x_axis)\n\t\ty_idx = findfirst(isequal(ys[idx]), y_axis)\n\t\tres[y_idx, x_idx] = z\n\tend\n\tx_axis, y_axis, res\nend```\nhad to roll my own","user":"UH8A351DJ","ts":"1614190338.027100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9mX+","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\"\"\"\n\n\tGiven three raw arrays, construct a partially filled matrix, returns both\n\taxises and the resultent matrix. Can be fed into Plots.heatmap directly\n\"\"\"\nfunction mesh_hm(xs, ys, zs::Array{T}) where T<: Number\n\tx_axis = xs|>sort|>unique\n\ty_axis = ys|>sort|>unique\n\tres = Matrix{Union{Missing, eltype(zs)}}(undef, length(y_axis), length(x_axis))\n\tfill!(res, missing)\n\tfor (idx,z) in enumerate(zs)\n\t\tx_idx = findfirst(isequal(xs[idx]), x_axis)\n\t\ty_idx = findfirst(isequal(ys[idx]), y_axis)\n\t\tres[y_idx, x_idx] = z\n\tend\n\tx_axis, y_axis, res\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"had to roll my own"}]}]}],"thread_ts":"1614189606.026400","parent_user_id":"UH8A351DJ"}]