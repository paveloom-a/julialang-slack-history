[{"client_msg_id":"deed5f21-5d8d-4750-8ae8-39efa385955b","type":"message","text":"Hi guys, first Merry Christmas for everyone who celebrate this date. Second, I have quite an intricate problem here. I'm trying to use a C library in my Julia code. I have a structure (say S) in the Julia side where I have an array of pointers (say S.array). In the Julia side I initalize S.array[i] to be C_NULL for every i. The C code allocates memory for the entries in the S.array, so after calling the C code, S.array[0], for example, is populated. The problem is that I'm getting an error when trying to do unsafe_load(S.array[1]) (changed from 0 to 1 because of Julia's index system). Debugging the code I discovered the following:\n• The address of S.array is the same, both on Julia and C side.\n• The address of S.array[0] in C is different than S.array[1] in Julia.\nI already tried doing unsafe_wrap on S.array, but same error happens. I'm not sure how to proceed here. Any help is greatly appreciated. Thanks!","user":"U01HLMKGH43","ts":"1608852643.002100","team":"T68168MUP","edited":{"user":"U01HLMKGH43","ts":"1608852674.000000"},"blocks":[{"type":"rich_text","block_id":"yj2W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi guys, first Merry Christmas for everyone who celebrate this date. Second, I have quite an intricate problem here. I'm trying to use a C library in my Julia code. I have a structure (say S) in the Julia side where I have an array of pointers (say S.array). In the Julia side I initalize S.array[i] to be C_NULL for every i. The C code allocates memory for the entries in the S.array, so after calling the C code, S.array[0], for example, is populated. The problem is that I'm getting an error when trying to do unsafe_load(S.array[1]) (changed from 0 to 1 because of Julia's index system). Debugging the code I discovered the following:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The address of S.array is the same, both on Julia and C side."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The address of S.array[0] in C is different than S.array[1] in Julia."}]}],"style":"bullet","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI already tried doing unsafe_wrap on S.array, but same error happens. I'm not sure how to proceed here. Any help is greatly appreciated. Thanks!"}]}]}],"thread_ts":"1608852643.002100","reply_count":19,"reply_users_count":3,"latest_reply":"1609056370.104400","reply_users":["USU9FRPEU","U01HLMKGH43","UKVBDU6HF"],"subscribed":false,"reactions":[{"name":"eyes","users":["U01HLMKGH43"],"count":1}]},{"client_msg_id":"b72cf71d-bf51-4911-9c91-3922f688b672","type":"message","text":"`S.array[0]` is a pointer though... do the pointers on the C and Julia side point to the same thing?","user":"USU9FRPEU","ts":"1608852795.002600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hG9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"S.array[0]","style":{"code":true}},{"type":"text","text":" is a pointer though... do the pointers on the C and Julia side point to the same thing?"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"8991302e-e06f-4cbe-a5b3-1d5979d6436a","type":"message","text":"I believe `unsafe_load` makes a copy.","user":"USU9FRPEU","ts":"1608852827.002800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l6F0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I believe "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":" makes a copy."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"dfe185b2-278a-42af-b4d1-2597f2d4552e","type":"message","text":"No, the pointer do not point to the same thing. (Sorry I had written that the address of S.array[0] in C is different than the address of S.array[1], but actually, it is the *content* that are differents. I don't know about the addresses (I will check now though).","user":"U01HLMKGH43","ts":"1608859501.003500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rRgC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, the pointer do not point to the same thing. (Sorry I had written that the address of S.array[0] in C is different than the address of S.array[1], but actually, it is the "},{"type":"text","text":"content ","style":{"bold":true}},{"type":"text","text":"that are differents. I don't know about the addresses (I will check now though)."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"ef73913c-0f7d-4c0c-8414-c5a1b89b5e82","type":"message","text":"My context do not require me to use unsafe_load, specifically. I just want to get (*S.array[0]) and treat it as the correspondent data structure.","user":"U01HLMKGH43","ts":"1608859567.003700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"V5W","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My context do not require me to use unsafe_load, specifically. I just want to get (*S.array[0]) and treat it as the correspondent data structure."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"6e84cfdd-dcf4-403f-a3fc-88de27cc02e9","type":"message","text":"You might want to check out <https://github.com/analytech-solutions/CBinding.jl|CBinding.jl> to more elegantly work with complex C constructs, and <https://github.com/analytech-solutions/CBindingGen.jl|CBindingGen.jl> if you want to create bindings for a C library/headers.","user":"UKVBDU6HF","ts":"1608860350.003900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zPQZy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might want to check out "},{"type":"link","url":"https://github.com/analytech-solutions/CBinding.jl","text":"CBinding.jl"},{"type":"text","text":" to more elegantly work with complex C constructs, and "},{"type":"link","url":"https://github.com/analytech-solutions/CBindingGen.jl","text":"CBindingGen.jl"},{"type":"text","text":" if you want to create bindings for a C library/headers."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43","reactions":[{"name":"+1","users":["U01HLMKGH43"],"count":1}]},{"client_msg_id":"7505c59b-7119-4781-92f7-c94d7ed80fb5","type":"message","text":"Thanks for the recommendation, but first I would like to understand what is the problem here. In my view it is quite strange. I added some print statements to debug, this is the output.\n\n```C side ----------------\nS address: 0x7feb15d37950\nS.array value: 0x7feb157b8e10\nS.array[0] value: 0xaf1e3b0\nJulia side ----------------\nS address: 0x00007feb15d37950\nS.array value: 0x000000000af1e3b0\nS.array[0] value: 0x0000000000000067```\nI'm creating the data structure S on Julia side. It seems that it is getting sent fine to C (the addresses are the same). However, on C side, the value of the S.array field is the same as the address of S, while on Julia side, they are different. The S.array is of type \"Array{Ptr{T}}\" and it is initalized with [C_NULL for i in 1:Size].\n\nIt seems that, on C side, the S.array field is pointing back to S, so changing S.array actually changes the values on S. I don't know why this happens, since S.array should point to a new list that was allocated on Julia side.","user":"U01HLMKGH43","ts":"1608874337.004200","team":"T68168MUP","edited":{"user":"U01HLMKGH43","ts":"1608875475.000000"},"blocks":[{"type":"rich_text","block_id":"2bt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the recommendation, but first I would like to understand what is the problem here. In my view it is quite strange. I added some print statements to debug, this is the output.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"C side ----------------\nS address: 0x7feb15d37950\nS.array value: 0x7feb157b8e10\nS.array[0] value: 0xaf1e3b0\nJulia side ----------------\nS address: 0x00007feb15d37950\nS.array value: 0x000000000af1e3b0\nS.array[0] value: 0x0000000000000067"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI'm creating the data structure S on Julia side. It seems that it is getting sent fine to C (the addresses are the same). However, on C side, the value of the S.array field is the same as the address of S, while on Julia side, they are different. The S.array is of type \"Array{Ptr{T}}\" and it is initalized with [C_NULL for i in 1:Size].\n\nIt seems that, on C side, the S.array field is pointing back to S, so changing S.array actually changes the values on S. I don't know why this happens, since S.array should point to a new list that was allocated on Julia side."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"d9bf644b-ee4b-4355-874a-d13ed5c334ec","type":"message","text":"Well maybe you do want to use `unsafe_wrap` then assuming what you want are the actual addresses.\n\nIt would be helpful if you could get more specific. I'm assuming you cannot just show us the code itself. Could you at least tells us what a similar struct in C looks like and and be more specific about how you declared the data structure in Julia (what is T)? How are you communicating between the two? Are you using `ccall` ?","user":"USU9FRPEU","ts":"1608877424.004900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5aUSk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well maybe you do want to use "},{"type":"text","text":"unsafe_wrap","style":{"code":true}},{"type":"text","text":" then assuming what you want are the actual addresses.\n\nIt would be helpful if you could get more specific. I'm assuming you cannot just show us the code itself. Could you at least tells us what a similar struct in C looks like and and be more specific about how you declared the data structure in Julia (what is T)? How are you communicating between the two? Are you using "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"02f5d778-3353-4dad-a073-7419e2f21cf7","type":"message","text":"What is the declaration of `array` on the C side?","user":"USU9FRPEU","ts":"1608877473.005100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jYJk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What is the declaration of "},{"type":"text","text":"array","style":{"code":true}},{"type":"text","text":" on the C side?"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"dc954bf4-ede7-49cf-bdd5-e5ccfda1b189","type":"message","text":"If it's helpful, here is some code that I work with that uses a lot of `unsafe_load`: <https://github.com/JuliaInterop/JavaCall.jl/blob/master/src/JNI.jl>","user":"USU9FRPEU","ts":"1608877513.005300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wuS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If it's helpful, here is some code that I work with that uses a lot of "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":": "},{"type":"link","url":"https://github.com/JuliaInterop/JavaCall.jl/blob/master/src/JNI.jl"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"61c00ce5-a0ad-49d5-a2bb-f86e0af87d30","type":"message","text":"Actually I have no problem with showing the code, I just tried to hide irrelevant details. But I guess this made it harder to understand the problem. So I will describe it better now.\n\nThe S structure on C/Julia side is actually this.\n```------------ C ---------------\ntypedef struct\n{\n  int Dim;\n  int Size;\n  CnstrRecord **CPL;\n} CnstrMgrRecord;\n----------- Julia ------------\nmutable struct CnstrMgrRecord\n  Dim::Cint\n  Size::Cint\n  CPL::Array{Ptr{CnstrRecord}}\nend```\nSo the `array` on C side is actually a double pointer. But the first indirection is used as an array (so `*CPL` points to the first element in the array). I used an Array type on Julia side in order to initialize `CPL` with `[C_NULL for i in 1:Dim]`.\n\nI have a function on C side that accepts a bunch of parameters, including a `CnstrRecord` . This function then dynamically allocates memory for the entries on `CPL`. I'm calling this function using `ccall`. Finally, below is the output of the debug messages with the real names of the structures.\n\n```C side ----------------\nCnstrMgrRecord address: 0x7feb15d37950\nCnstrMgrRecord.CPL value: 0x7feb157b8e10\nCnstrMgrRecord.CPL[0] value: 0xaf1e3b0\nJulia side ----------------\nCnstrMgrRecord address: 0x00007feb15d37950\nCnstrMgrRecord.CPL value: 0x000000000af1e3b0\nCnstrMgrRecord.CPL[0] value: 0x0000000000000067```\nThanks for your example, I'll check it and try to progress here.","user":"U01HLMKGH43","ts":"1608909864.006900","team":"T68168MUP","edited":{"user":"U01HLMKGH43","ts":"1608910231.000000"},"blocks":[{"type":"rich_text","block_id":"5aVeU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Actually I have no problem with showing the code, I just tried to hide irrelevant details. But I guess this made it harder to understand the problem. So I will describe it better now.\n\nThe S structure on C/Julia side is actually this.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"------------ C ---------------\ntypedef struct\n{\n  int Dim;\n  int Size;\n  CnstrRecord **CPL;\n} CnstrMgrRecord;\n----------- Julia ------------\nmutable struct CnstrMgrRecord\n  Dim::Cint\n  Size::Cint\n  CPL::Array{Ptr{CnstrRecord}}\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So the "},{"type":"text","text":"array","style":{"code":true}},{"type":"text","text":" on C side is actually a double pointer. But the first indirection is used as an array (so "},{"type":"text","text":"*CPL","style":{"code":true}},{"type":"text","text":" points to the first element in the array). I used an Array type on Julia side in order to initialize "},{"type":"text","text":"CPL ","style":{"code":true}},{"type":"text","text":"with "},{"type":"text","text":"[C_NULL for i in 1:Dim]","style":{"code":true}},{"type":"text","text":".\n\nI have a function on C side that accepts a bunch of parameters, including a "},{"type":"text","text":"CnstrRecord","style":{"code":true}},{"type":"text","text":" . This function then dynamically allocates memory for the entries on "},{"type":"text","text":"CPL","style":{"code":true}},{"type":"text","text":". I'm calling this function using "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":". Finally, below is the output of the debug messages with the real names of the structures.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"C side ----------------\nCnstrMgrRecord address: 0x7feb15d37950\nCnstrMgrRecord.CPL value: 0x7feb157b8e10\nCnstrMgrRecord.CPL[0] value: 0xaf1e3b0\nJulia side ----------------\nCnstrMgrRecord address: 0x00007feb15d37950\nCnstrMgrRecord.CPL value: 0x000000000af1e3b0\nCnstrMgrRecord.CPL[0] value: 0x0000000000000067"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThanks for your example, I'll check it and try to progress here."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"cd8fa6f6-6b0a-42b4-98d6-8cb51a30a7d3","type":"message","text":"Mmm... Array is not right","user":"USU9FRPEU","ts":"1608920441.009800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KCHM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Mmm... Array is not right"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"8c31f282-89cc-406b-8545-d3aa828c546c","type":"message","text":"You want `Ptr{Ptr{CnstrRecord}}` I think","user":"USU9FRPEU","ts":"1608920462.010000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ylSn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You want "},{"type":"text","text":"Ptr{Ptr{CnstrRecord}}","style":{"code":true}},{"type":"text","text":" I think"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"a9a33d23-5de4-4adf-bdc8-5cfdead0a91e","type":"message","text":"yea, so first load in\n```struct CnstrMgrRecord\n   Dim::Cint\n   Size::Cint\n   CPL::Ptr{Ptr{CnstrRecord}}\nend```\nYou probably do not want this to be mutable.","user":"USU9FRPEU","ts":"1608921176.010200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ORRj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yea, so first load in\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct CnstrMgrRecord\n   Dim::Cint\n   Size::Cint\n   CPL::Ptr{Ptr{CnstrRecord}}\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"You probably do not want this to be mutable."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"a70776b1-8ba2-4d2a-81ee-ed45bb929231","type":"message","text":"Now if you want an `Array{Ptr{CnstrRecord}}`  then you can use `unsafe_wrap`:\n```record = unsafe_load(some_pointer::Ptr{CnstrMgrRecord})\ncpl_ptr_array = unsafe_wrap(Array{Ptr{CnstrRecord}}, record.CPL, record.Dim)\ncpl_array = [unsafe_load(ptr) for ptr in cpl_ptr_array]```\nOr maybe\n```record = unsafe_load(some_pointer::Ptr{CnstrMgrRecord})\ncpl_array = [unsafe_load(record.CPL, i) for i in 1:record.Dim]```","user":"USU9FRPEU","ts":"1608921831.010400","team":"T68168MUP","edited":{"user":"USU9FRPEU","ts":"1608921871.000000"},"blocks":[{"type":"rich_text","block_id":"bcqQU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Now if you want an "},{"type":"text","text":"Array{Ptr{CnstrRecord}}","style":{"code":true}},{"type":"text","text":"  then you can use "},{"type":"text","text":"unsafe_wrap","style":{"code":true}},{"type":"text","text":":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"record = unsafe_load(some_pointer::Ptr{CnstrMgrRecord})\ncpl_ptr_array = unsafe_wrap(Array{Ptr{CnstrRecord}}, record.CPL, record.Dim)\ncpl_array = [unsafe_load(ptr) for ptr in cpl_ptr_array]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Or maybe\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"record = unsafe_load(some_pointer::Ptr{CnstrMgrRecord})\ncpl_array = [unsafe_load(record.CPL, i) for i in 1:record.Dim]"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"53023810-754e-40ef-93e0-629ab5bb8e42","type":"message","text":"A Julia array is not simply a pointer. It stores a few attributes: <https://github.com/JuliaLang/julia/blob/391f2dd2b5ac67da4a136673b1923d966b606439/src/julia.h#L166-L185>","user":"USU9FRPEU","ts":"1608922346.010700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"h/D0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A Julia array is not simply a pointer. It stores a few attributes: "},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/391f2dd2b5ac67da4a136673b1923d966b606439/src/julia.h#L166-L185"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"96138276-0c42-4d4f-9e7e-17a18d58d019","type":"message","text":"So you can't just map a Julia array to a C pointer and expect that work.","user":"USU9FRPEU","ts":"1608922369.010900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"q3yW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So you can't just map a Julia array to a C pointer and expect that work."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"37e95c9c-f5cb-4146-a68b-0ed10d3f414c","type":"message","text":"Also you don't want mutable because you probably want a simple bittype that is aligned with the C struct.","user":"USU9FRPEU","ts":"1608922414.011100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HXo7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also you don't want mutable because you probably want a simple bittype that is aligned with the C struct."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"c9c4d2a2-5953-421c-8a35-2066a39e82ef","type":"message","text":"Thanks! Changing from Array to Ptr did the trick. I think I did this mistake because there is an example on the internet where the C function has a parameter `int *array` and this function is called on Julia side (using `ccall` ) by passing an Array. Maybe this only works for Arrays without nested pointers?","user":"U01HLMKGH43","ts":"1609027678.100300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CC4yG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks! Changing from Array to Ptr did the trick. I think I did this mistake because there is an example on the internet where the C function has a parameter "},{"type":"text","text":"int *array","style":{"code":true}},{"type":"text","text":" and this function is called on Julia side (using "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" ) by passing an Array. Maybe this only works for Arrays without nested pointers?"}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"},{"client_msg_id":"b0164261-5189-49a4-bdc7-5c7d0429e471","type":"message","text":"Passing an `Array` is another thing entirely. Julia can unwrap it's own structures.","user":"USU9FRPEU","ts":"1609056370.104400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IM6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Passing an "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":" is another thing entirely. Julia can unwrap it's own structures."}]}]}],"thread_ts":"1608852643.002100","parent_user_id":"U01HLMKGH43"}]