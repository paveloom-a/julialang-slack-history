[{"client_msg_id":"1fc63207-c8f0-4a16-b4d5-1b9cdb99599f","type":"message","text":"I'm looking at some nice AVX2 instructions, and I'm wondering if there is a path to use this in Julia:\n<https://stackoverflow.com/questions/66347928/simd-unpack-12-bit-fields-to-16-bit>","user":"USU9FRPEU","ts":"1615047101.476400","team":"T68168MUP","attachments":[{"service_name":"Stack Overflow","title":"SIMD unpack 12-bit fields to 16-bit","title_link":"https://stackoverflow.com/questions/66347928/simd-unpack-12-bit-fields-to-16-bit","text":"I need to unpack two 16-bit values from each 24 bits of input. (3 bytes -&gt; 4 bytes). I already did it the naïve way but I'm not happy with the performance. For example, InBuffer is __m128i: valu...","fallback":"Stack Overflow: SIMD unpack 12-bit fields to 16-bit","thumb_url":"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded","from_url":"https://stackoverflow.com/questions/66347928/simd-unpack-12-bit-fields-to-16-bit","thumb_width":316,"thumb_height":316,"service_icon":"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a","id":1,"original_url":"https://stackoverflow.com/questions/66347928/simd-unpack-12-bit-fields-to-16-bit"}],"blocks":[{"type":"rich_text","block_id":"d+U","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm looking at some nice AVX2 instructions, and I'm wondering if there is a path to use this in Julia:\n"},{"type":"link","url":"https://stackoverflow.com/questions/66347928/simd-unpack-12-bit-fields-to-16-bit"}]}]}],"thread_ts":"1615047101.476400","reply_count":8,"reply_users_count":3,"latest_reply":"1615064885.484900","reply_users":["B01J9QZ4SP8","USU9FRPEU","U7HAYKY9X"],"subscribed":false,"reactions":[{"name":"bridge","users":["USU9FRPEU"],"count":1}]},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1615047103.476500","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"},{"client_msg_id":"eebcdcfe-21a1-43d0-b236-97d06aaa1a29","type":"message","text":"I'm considering SIMD.jl, <@U67D54KS8>’s <http://kristofferc.github.io/post/intrinsics/|Intrinsic Blog post>, and `Core.Intrinsics.llvmcall`","user":"USU9FRPEU","ts":"1615047181.476900","team":"T68168MUP","attachments":[{"title":"SIMD and SIMD-intrinsics in Julia | Kristoffer Carlsson","title_link":"http://kristofferc.github.io/post/intrinsics/","text":"Software engineer","fallback":"SIMD and SIMD-intrinsics in Julia | Kristoffer Carlsson","from_url":"http://kristofferc.github.io/post/intrinsics/","service_icon":"http://kristofferc.github.io/img/apple-touch-icon.png","service_name":"kristofferc.github.io","id":1,"original_url":"http://kristofferc.github.io/post/intrinsics/"}],"blocks":[{"type":"rich_text","block_id":"awCK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm considering SIMD.jl, "},{"type":"user","user_id":"U67D54KS8"},{"type":"text","text":"’s "},{"type":"link","url":"http://kristofferc.github.io/post/intrinsics/","text":"Intrinsic Blog post"},{"type":"text","text":", and "},{"type":"text","text":"Core.Intrinsics.llvmcall","style":{"code":true}}]}]}],"thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"},{"client_msg_id":"3d22b6d3-f123-4dde-b174-93fb0bc1e47d","type":"message","text":"Check my package ScanByte - it uses the byte shuffling instruction extensively, and it also has a section for how to check if the users computer has AVX2","user":"U7HAYKY9X","ts":"1615050530.477800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z043","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Check my package ScanByte - it uses the byte shuffling instruction extensively, and it also has a section for how to check if the users computer has AVX2"}]}]}],"thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU","reactions":[{"name":"+1","users":["USU9FRPEU"],"count":1}]},{"client_msg_id":"1bc6b46e-8a42-4d4b-885f-a714e4e2ce24","type":"message","text":"But it's not great - SIMD.jl is way more stable and IIRC, it only uses instructions that are directly supported by LLVM. My package parses some LLVM output to check which instructions are available, which seems brittle.","user":"U7HAYKY9X","ts":"1615050610.478100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i5V5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But it's not great - SIMD.jl is way more stable and IIRC, it only uses instructions that are directly supported by LLVM. My package parses some LLVM output to check which instructions are available, which seems brittle."}]}]}],"thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"},{"client_msg_id":"11e4fbbd-14b0-4ac0-9635-7ccb5176b97e","type":"message","text":"I just about have the solution with SIMD.jl. i just needed to recognize that the blend Intel instrinsic is also a `shufflevector` operation","user":"USU9FRPEU","ts":"1615050757.478300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XZe3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I just about have the solution with SIMD.jl. i just needed to recognize that the blend Intel instrinsic is also a "},{"type":"text","text":"shufflevector","style":{"code":true}},{"type":"text","text":" operation"}]}]}],"thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"},{"client_msg_id":"fde1d078-83c1-4a14-958d-4a943749119a","type":"message","text":"Current solution is:\n```julia&gt; function unpack_uint12_to_uint16(A::Vector{UInt8}, out::Vector{UInt16})\n           idx = 1:24:length(A)\n           for i = idx\n               unpack_uint12_to_uint16(A, out, i)\n           end\n           out\n       end\nunpack_uint12_to_uint16 (generic function with 2 methods)\n\njulia&gt; @inline function unpack_uint12_to_uint16(A::Vector{UInt8}, out::Vector{UInt16}, i)\n           a = @inbounds vload(Vec{32,UInt8}, A, i)\n\n           # Move bytes into 16-bit chunks\n           # v = Val( ntuple(i-&gt;m[mod1(i,4)] +  3( (i-1)÷4 ),32) )\n           v = Val{(0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23)}()\n           a16 = reinterpret(Vec{16,UInt16},shufflevector(a,v))\n\n           # Modify hi and low chunks and reshuffle\n           # fm = Val(ntuple(i-&gt;mod(i,2) == 1 ? i-1 : i+15, 16))\n           fm = Val{(0, 17, 2, 19, 4, 21, 6, 23, 8, 25, 10, 27, 12, 29, 14, 31)}()\n           a16 = shufflevector(a16 &amp; 0xfff, a16 &gt;&gt; 4, fm)\n\n           @inbounds vstore(a16, out, 1 + 2( ( i-1 ) ÷ 3) )\n       end```","user":"USU9FRPEU","ts":"1615053921.478900","team":"T68168MUP","edited":{"user":"USU9FRPEU","ts":"1615054067.000000"},"blocks":[{"type":"rich_text","block_id":"n36s","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Current solution is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function unpack_uint12_to_uint16(A::Vector{UInt8}, out::Vector{UInt16})\n           idx = 1:24:length(A)\n           for i = idx\n               unpack_uint12_to_uint16(A, out, i)\n           end\n           out\n       end\nunpack_uint12_to_uint16 (generic function with 2 methods)\n\njulia> @inline function unpack_uint12_to_uint16(A::Vector{UInt8}, out::Vector{UInt16}, i)\n           a = @inbounds vload(Vec{32,UInt8}, A, i)\n\n           # Move bytes into 16-bit chunks\n           # v = Val( ntuple(i->m[mod1(i,4)] +  3( (i-1)÷4 ),32) )\n           v = Val{(0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 22, 23)}()\n           a16 = reinterpret(Vec{16,UInt16},shufflevector(a,v))\n\n           # Modify hi and low chunks and reshuffle\n           # fm = Val(ntuple(i->mod(i,2) == 1 ? i-1 : i+15, 16))\n           fm = Val{(0, 17, 2, 19, 4, 21, 6, 23, 8, 25, 10, 27, 12, 29, 14, 31)}()\n           a16 = shufflevector(a16 & 0xfff, a16 >> 4, fm)\n\n           @inbounds vstore(a16, out, 1 + 2( ( i-1 ) ÷ 3) )\n       end"}]}]}],"thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"},{"type":"message","subtype":"bot_message","text":"Success, it has been cross posted <https://discourse.julialang.org/t/56624| to Discourse>. Keep and eye out on Discourse for responses and please add an answer there once you are satisfied with the solution so others can benefit as well. Happy debugging!","ts":"1615054081.479300","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"},{"type":"message","subtype":"bot_message","text":"Hey <@USU9FRPEU>, if you were able to find an answer here on Slack, please cross post it to Discourse via the link above. Thank you! ","ts":"1615064885.484900","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615047101.476400","parent_user_id":"USU9FRPEU"}]