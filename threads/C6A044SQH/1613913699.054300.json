[{"client_msg_id":"6804e620-e865-42a2-a07e-d7c69234f0cf","type":"message","text":"I'm having some problems understanding how to work with shared libraries using `ccall`. I made a small toy example (<https://gist.github.com/ahojukka5/ab3a198ca25ce55e4f6947c217e0293f>) to try out different things as starting wrapping bigger libraries right away seems to be a bit too hard without any practicing first.\n\nIn line 26, I try to access data allocated in C without success. I guess it should work like this but I don't get expected results. `unsafe_wrap` is working as expected.\n\nIn test2, I'm trying to allocate data in Julia and create a pointer to point data, so that it would be accessible in C, but again this is somehow wrong.\n\nAny tips on how to proceed?\n\nThe third question might be, that do I strictly speaking need to define my own mutable struct in Julia if I only use functions defined in a shared library? That is, can I just get a pointer address from C and pass that around without exactly knowing how to structure is actually created in C?","user":"UAGBT2X1A","ts":"1613913699.054300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f8GM1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having some problems understanding how to work with shared libraries using "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":". I made a small toy example ("},{"type":"link","url":"https://gist.github.com/ahojukka5/ab3a198ca25ce55e4f6947c217e0293f"},{"type":"text","text":") to try out different things as starting wrapping bigger libraries right away seems to be a bit too hard without any practicing first.\n\nIn line 26, I try to access data allocated in C without success. I guess it should work like this but I don't get expected results. "},{"type":"text","text":"unsafe_wrap","style":{"code":true}},{"type":"text","text":" is working as expected.\n\nIn test2, I'm trying to allocate data in Julia and create a pointer to point data, so that it would be accessible in C, but again this is somehow wrong.\n\nAny tips on how to proceed?\n\nThe third question might be, that do I strictly speaking need to define my own mutable struct in Julia if I only use functions defined in a shared library? That is, can I just get a pointer address from C and pass that around without exactly knowing how to structure is actually created in C?"}]}]}],"thread_ts":"1613913699.054300","reply_count":12,"reply_users_count":3,"latest_reply":"1613923595.070200","reply_users":["B01J9QZ4SP8","UBEF50B7C","UAGBT2X1A"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1613913702.054400","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"b0ea6ad1-443a-4e42-b58a-ffc439cda7cf","type":"message","text":"Not an expert here, but I think `unsafe_load` is 1-indexed.","user":"UBEF50B7C","ts":"1613915996.055800","team":"T68168MUP","edited":{"user":"UBEF50B7C","ts":"1613916158.000000"},"blocks":[{"type":"rich_text","block_id":"H=5a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not an expert here, but I think "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":" is 1-indexed."}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"f77e9b91-9718-4db6-9f54-c6d7a50b9eae","type":"message","text":"Hmm that's correct. For indexes 1, 2, 3 I get meaningful results. Good!","user":"UAGBT2X1A","ts":"1613920938.065900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bkQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm that's correct. For indexes 1, 2, 3 I get meaningful results. Good!"}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"1a40b42d-fc8b-4bbd-9bd1-3381ed9046f8","type":"message","text":"So the only question left is I guess that how to reserve/allocate memory in Julia and use that in C. But I might be thinking this somehow \"wrong\". Anyway, I guess it should be possible to do like this.","user":"UAGBT2X1A","ts":"1613921323.068600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6pWW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So the only question left is I guess that how to reserve/allocate memory in Julia and use that in C. But I might be thinking this somehow \"wrong\". Anyway, I guess it should be possible to do like this."}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"1da89ca8-9b28-4cf2-a625-c2e11e9c514f","type":"message","text":"what you have to be careful when allocating memory in Julia and then passing that memory to C, is that Julias garbage collector does not decide to free that memory while you are in the C function. That can be done with the `GC.@preserve` macro for example","user":"UBEF50B7C","ts":"1613921452.068800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"asU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what you have to be careful when allocating memory in Julia and then passing that memory to C, is that Julias garbage collector does not decide to free that memory while you are in the C function. That can be done with the "},{"type":"text","text":"GC.@preserve","style":{"code":true}},{"type":"text","text":" macro for example"}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"0828987e-a3d9-41d0-8d16-782e2a28b336","type":"message","text":"although I think using `Ref` might achieve the same","user":"UBEF50B7C","ts":"1613921483.069000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ugsp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"although I think using "},{"type":"text","text":"Ref","style":{"code":true}},{"type":"text","text":" might achieve the same"}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"017a8a05-eb26-4f3e-9e2a-a3b042cd3fd2","type":"message","text":"That came to my mind also. However, if I try `v = Vec(3, Ref(data))` I get somewhat expected `Cannot convert an object of type Base.RefValue{Array{Float64,1}} to an object of type Ptr{Float64}`. So I could change that struct definition to have `Base.RefValue{Vector{Float64}}` , but then I have to go back to basics. Why the data is having type `Ptr{Cdouble}` in the first place. I think it's right as it seems to match well with the C struct `double* data` .","user":"UAGBT2X1A","ts":"1613922047.069200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ei71","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That came to my mind also. However, if I try "},{"type":"text","text":"v = Vec(3, Ref(data))","style":{"code":true}},{"type":"text","text":" I get somewhat expected "},{"type":"text","text":"Cannot convert an object of type Base.RefValue{Array{Float64,1}} to an object of type Ptr{Float64}","style":{"code":true}},{"type":"text","text":". So I could change that struct definition to have "},{"type":"text","text":"Base.RefValue{Vector{Float64}}","style":{"code":true}},{"type":"text","text":" , but then I have to go back to basics. Why the data is having type "},{"type":"text","text":"Ptr{Cdouble}","style":{"code":true}},{"type":"text","text":" in the first place. I think it's right as it seems to match well with the C struct "},{"type":"text","text":"double* data","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"aa41d5ea-f92b-4669-bb8e-258174618d3e","type":"message","text":"I replaced that `pointer_from_objref` with `pointer` and now it's working like expected. Hmm.","user":"UAGBT2X1A","ts":"1613922671.069400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eA3F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I replaced that "},{"type":"text","text":"pointer_from_objref","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"pointer","style":{"code":true}},{"type":"text","text":" and now it's working like expected. Hmm."}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"87c88e7d-156f-4ca5-9407-f8d4f3bcdfb5","type":"message","text":"Well, there's still that third thing I'm wondering. Do I really need to create a struct matching with the C struct layout or could I just handle the pointer coming from C as a \"general something\" that I just pass around in wrapped functions without thinking too much about its contents.","user":"UAGBT2X1A","ts":"1613923255.069600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qU7c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well, there's still that third thing I'm wondering. Do I really need to create a struct matching with the C struct layout or could I just handle the pointer coming from C as a \"general something\" that I just pass around in wrapped functions without thinking too much about its contents."}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"3476ddd6-1dfe-4bfc-a594-2d8cb6f11d92","type":"message","text":"I mean, if I create a new vector with `new_vector`, use `set_vector_data` to set vector data and `get_vector_data` to get data from it, and they are all defined in a shared library, then I guess I don't need to know anything about the internal structure?","user":"UAGBT2X1A","ts":"1613923380.069800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s8k7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, if I create a new vector with "},{"type":"text","text":"new_vector","style":{"code":true}},{"type":"text","text":", use "},{"type":"text","text":"set_vector_data","style":{"code":true}},{"type":"text","text":" to set vector data and "},{"type":"text","text":"get_vector_data","style":{"code":true}},{"type":"text","text":" to get data from it, and they are all defined in a shared library, then I guess I don't need to know anything about the internal structure?"}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"824f79d7-6268-412a-91bf-cf1c0c93e60f","type":"message","text":"I only need to know about internal structure in the case I'm planning to read the data in Julia","user":"UAGBT2X1A","ts":"1613923434.070000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1Yl=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I only need to know about internal structure in the case I'm planning to read the data in Julia"}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"},{"client_msg_id":"ec91b252-0afd-4af9-b45a-d27f421e9558","type":"message","text":"Hmm but yeah, if C code is returning a struct and not a pointer to that ...","user":"UAGBT2X1A","ts":"1613923595.070200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/8y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hmm but yeah, if C code is returning a struct and not a pointer to that ..."}]}]}],"thread_ts":"1613913699.054300","parent_user_id":"UAGBT2X1A"}]