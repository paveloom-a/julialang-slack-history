[{"client_msg_id":"6b08ee53-920f-4b7b-b8bf-310a912a5169","type":"message","text":"Is there a way to use `map`  w/  `enumerate`  such that the original collection type is returned? E.g.\n```A = (a = 1, b = 2.0, c = 4.0)\n\nB = map(A) do _a\n    _a\nend # NamedTuple{(:a, :b, :c),Tuple{Int64,Float64,Float64}}\n\nB2 = map(enumerate(A)) do (idx,_a)\n        _a\nend #Array{Real,1}```","user":"UP95S4864","ts":"1616429935.397100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Aci","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a way to use "},{"type":"text","text":"map","style":{"code":true}},{"type":"text","text":"  w/  "},{"type":"text","text":"enumerate","style":{"code":true}},{"type":"text","text":"  such that the original collection type is returned? E.g.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"A = (a = 1, b = 2.0, c = 4.0)\n\nB = map(A) do _a\n    _a\nend # NamedTuple{(:a, :b, :c),Tuple{Int64,Float64,Float64}}\n\nB2 = map(enumerate(A)) do (idx,_a)\n        _a\nend #Array{Real,1}"}]}]}],"thread_ts":"1616429935.397100","reply_count":4,"reply_users_count":2,"latest_reply":"1616431163.400300","reply_users":["U7HAYKY9X","UP95S4864"],"subscribed":false},{"client_msg_id":"5f16a57e-4618-4a8e-818d-6498c8f82723","type":"message","text":"Not that I'm aware of. Tuple is special cased for map, I think, to make it type stable. You can always use `Iterators.map` (on Julia 1.6) or a generator expression, and build a Tuple from that. But I don't think the compiler will be clever enough to realize it's type stable","user":"U7HAYKY9X","ts":"1616430369.397700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C7w","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not that I'm aware of. Tuple is special cased for map, I think, to make it type stable. You can always use "},{"type":"text","text":"Iterators.map","style":{"code":true}},{"type":"text","text":" (on Julia 1.6) or a generator expression, and build a Tuple from that. But I don't think the compiler will be clever enough to realize it's type stable"}]}]}],"thread_ts":"1616429935.397100","parent_user_id":"UP95S4864"},{"client_msg_id":"9eceb23b-52f3-4798-b14f-62e015a4db21","type":"message","text":"`A` isn't necessarily always a tuple. Maybe it will help if I make the problem a little more concrete. I essentially want to do something like A[[1,3,5]] .= [1,2,2] w/o mutation, so it plays nice with Zygote.","user":"UP95S4864","ts":"1616431011.399700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"x9YC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" isn't necessarily always a tuple. Maybe it will help if I make the problem a little more concrete. I essentially want to do something like A[[1,3,5]] .= [1,2,2] w/o mutation, so it plays nice with Zygote."}]}]}],"thread_ts":"1616429935.397100","parent_user_id":"UP95S4864"},{"client_msg_id":"4c6911c9-37c3-4a98-b03a-fd6a9ff35999","type":"message","text":"My thought is something like the following, BUT I want the return type to match that of `A`\n```function f(A, replace_mask, replace_vals)\n    map(enumerate(A)) do (idx, _a)\n       replace_mask[idx] ? replace_vals[idx] : _a\n    end\nend```","user":"UP95S4864","ts":"1616431061.399900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uTjP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My thought is something like the following, BUT I want the return type to match that of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":"\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f(A, replace_mask, replace_vals)\n    map(enumerate(A)) do (idx, _a)\n       replace_mask[idx] ? replace_vals[idx] : _a\n    end\nend"}]}]}],"thread_ts":"1616429935.397100","parent_user_id":"UP95S4864"},{"client_msg_id":"e0c06ce8-9916-4d53-8b83-286b8b1f2e72","type":"message","text":"I think your best bet is something like\n```my_map(f, x) = Iterators.map(f, x) |&gt; typeof(x)```","user":"U7HAYKY9X","ts":"1616431163.400300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Kw=DN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think your best bet is something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"my_map(f, x) = Iterators.map(f, x) |> typeof(x)"}]}]}],"thread_ts":"1616429935.397100","parent_user_id":"UP95S4864"}]