[{"client_msg_id":"369dc91d-0673-4d5e-8c7f-54a1b97cbdae","type":"message","text":"Hey everyone ! I am pretty new to Julia and I looked in the docs but could not find the answer (probably because I didn't look long enough :wink: ).\n\nLet's say I have a dummy structure:\n```struct MyType\n    attr::Int\nend\n\nBase.broadcastable(m::MyType) = Ref(m)```\nI want to be able to broadcast the following function `f` over every argument, which works well with:\n```arr = [MyType(1),MyType(2)]\n\nf(m::MyType,x,y) = x * m.attr + y\n\n&gt; f.(arr,1,1)\n2-element Array{Int64,1}:\n 2\n 3\n\nm1 = MyType(3)\n\n&gt; f.(m1,1,1:1:3)\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\n&gt; f.(m1,1:1:3,1:1:3)\n3-element Array{Int64,1}:\n  4\n  8\n 12```\nIs there a way to use this nice broadcast style and avoid loops and do something like:\n\n```f.(arr, 1:1:3,1:1:3)```\ninstead of explicitly  looping over the array ? (When trying I get the expected error: ERROR: DimensionMismatch(\"arrays could not be broadcast to a common size; got a dimension with lengths 2 and 3\")","user":"U0130KT0C22","ts":"1611218902.037500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AGtJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey everyone ! I am pretty new to Julia and I looked in the docs but could not find the answer (probably because I didn't look long enough "},{"type":"emoji","name":"wink"},{"type":"text","text":" ).\n\nLet's say I have a dummy structure:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct MyType\n    attr::Int\nend\n\nBase.broadcastable(m::MyType) = Ref(m)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I want to be able to broadcast the following function "},{"type":"text","text":"f","style":{"code":true}},{"type":"text","text":" over every argument, which works well with:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"arr = [MyType(1),MyType(2)]\n\nf(m::MyType,x,y) = x * m.attr + y\n\n> f.(arr,1,1)\n2-element Array{Int64,1}:\n 2\n 3\n\nm1 = MyType(3)\n\n> f.(m1,1,1:1:3)\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\n> f.(m1,1:1:3,1:1:3)\n3-element Array{Int64,1}:\n  4\n  8\n 12"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a way to use this nice broadcast style and avoid loops and do something like:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"f.(arr, 1:1:3,1:1:3)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\ninstead of explicitly  looping over the array ? (When trying I get the expected error: ERROR: DimensionMismatch(\"arrays could not be broadcast to a common size; got a dimension with lengths 2 and 3\")"}]}]}],"thread_ts":"1611218902.037500","reply_count":8,"reply_users_count":2,"latest_reply":"1611220318.043600","reply_users":["UD0NS8PDF","U0130KT0C22"],"subscribed":false},{"client_msg_id":"d91ed540-c31b-4cf2-abd5-5f71e52dabe6","type":"message","text":"What answer would you like here? I think the issue is the same as say `atan.(1:2, 1:3)`, compare\n```julia&gt; atan.(1:2, (1:3)')\n2×3 Matrix{Float64}:\n 0.785398  0.463648  0.321751\n 1.10715   0.785398  0.588003\n\njulia&gt; map(atan, 1:2, 1:3)\n2-element Vector{Float64}:\n 0.7853981633974483\n 0.7853981633974483```","user":"UD0NS8PDF","ts":"1611219403.039400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XEPf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What answer would you like here? I think the issue is the same as say "},{"type":"text","text":"atan.(1:2, 1:3)","style":{"code":true}},{"type":"text","text":", compare\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> atan.(1:2, (1:3)')\n2×3 Matrix{Float64}:\n 0.785398  0.463648  0.321751\n 1.10715   0.785398  0.588003\n\njulia> map(atan, 1:2, 1:3)\n2-element Vector{Float64}:\n 0.7853981633974483\n 0.7853981633974483"}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"923ffa80-2fc4-49e6-b83f-f0235999695b","type":"message","text":"I would like the behaviour to be like the one of:\n\n```res = zeros(2,3)\nfor (index,elt) in enumerate(arr)\n@. res[index,:] = f(elt,1:3,1:3)\nend ```\n","user":"U0130KT0C22","ts":"1611219707.040300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M=k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would like the behaviour to be like the one of:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"res = zeros(2,3)\nfor (index,elt) in enumerate(arr)\n@. res[index,:] = f(elt,1:3,1:3)\nend "}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"14dcd67b-9d85-4077-bcab-17491582bc6c","type":"message","text":"Like `f.(arr, (1:3)', (1:3)')` then?","user":"UD0NS8PDF","ts":"1611219818.040700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UDN0L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like "},{"type":"text","text":"f.(arr, (1:3)', (1:3)')","style":{"code":true}},{"type":"text","text":" then?"}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"3914e6fd-7116-473f-878b-433ec5138b3a","type":"message","text":"Yes ! Thanks :slightly_smiling_face: Could you maybe explain quickly why it works like this ?","user":"U0130KT0C22","ts":"1611219880.041800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bHY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes ! Thanks "},{"type":"emoji","name":"slightly_smiling_face"},{"type":"text","text":" Could you maybe explain quickly why it works like this ?"}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"91d70ca8-58ff-43dc-8487-8ecc83eb4cf2","type":"message","text":"Also, if I wanted to make the function f part of a pulic API and would like to make it simple for the users so that they can actually write `f.(arr,1:3,1:3)` , is there a way to do this ?","user":"U0130KT0C22","ts":"1611219994.042800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OIE0h","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, if I wanted to make the function f part of a pulic API and would like to make it simple for the users so that they can actually write "},{"type":"text","text":"f.(arr,1:3,1:3)","style":{"code":true}},{"type":"text","text":" , is there a way to do this ?"}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"49b55a5f-6ff2-4c5c-a1d7-281065075a70","type":"message","text":"Broadcasting sort-of extends out any size-1 dimensions, to produce something which matches the largest in every dimension. In this case that’s `(2,3)`, 2 from the first argument, 3 from the second &amp; third:\n```julia&gt; size(arr)\n(2,)\n\njulia&gt; size(arr,1), size(arr,2), size(arr,3) # implicit trailing dimensions\n(2, 1, 1)\n\njulia&gt; size((1:3)')\n(1, 3)\n\njulia&gt; size(res)\n(2, 3)```","user":"UD0NS8PDF","ts":"1611220068.043000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XN3vT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Broadcasting sort-of extends out any size-1 dimensions, to produce something which matches the largest in every dimension. In this case that’s "},{"type":"text","text":"(2,3)","style":{"code":true}},{"type":"text","text":", 2 from the first argument, 3 from the second & third:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> size(arr)\n(2,)\n\njulia> size(arr,1), size(arr,2), size(arr,3) # implicit trailing dimensions\n(2, 1, 1)\n\njulia> size((1:3)')\n(1, 3)\n\njulia> size(res)\n(2, 3)"}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"1f0fe2be-0b7b-4128-8b15-cc8a7d57ed8a","type":"message","text":"You can overload things to do almost anything, but IMO altering this broadcast behaviour would be extremely surprising. You could have a function `applyperp(f, x, y, z)` which transposes y,z and then broadcasts. You could also have another method of f:\n```f(x::MyType, y::Number, z::Number) = \"as before\"\nf(x::AbstractVector, y::AbstractVector, z::AbstractVector) = \"broadcast as desired\"```","user":"UD0NS8PDF","ts":"1611220256.043400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XlC4X","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can overload things to do almost anything, but IMO altering this broadcast behaviour would be extremely surprising. You could have a function "},{"type":"text","text":"applyperp(f, x, y, z)","style":{"code":true}},{"type":"text","text":" which transposes y,z and then broadcasts. You could also have another method of f:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"f(x::MyType, y::Number, z::Number) = \"as before\"\nf(x::AbstractVector, y::AbstractVector, z::AbstractVector) = \"broadcast as desired\""}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22"},{"client_msg_id":"7c95142f-584d-463c-8dca-c629c37cab84","type":"message","text":"Ok thank you very much for your explanations, helped a lot !","user":"U0130KT0C22","ts":"1611220318.043600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KY+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok thank you very much for your explanations, helped a lot !"}]}]}],"thread_ts":"1611218902.037500","parent_user_id":"U0130KT0C22","reactions":[{"name":"+1","users":["UD0NS8PDF"],"count":1}]}]