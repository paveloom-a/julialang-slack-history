[{"client_msg_id":"9d2a0bb4-9cdd-4730-a424-afaca90456bd","type":"message","text":"Hey all,\nI’m trying to create a macro to broadcast in parallel. I have a large dataframe and I frequently create new columns based on values from old columns.\nLet’s take string concatenation for example.\n The non parallel broadcasting version looks like this:\n```df.input .* df.target```\nand the parallel broadcasted version looks like this\n```function divide_range_into_max_n_chunks(r::UnitRange{Int64}, n::Int64)\n    range_length = r.stop - r.start\n    chunk_size = Int64(ceil(range_length / n))\n    return [i:min(i + chunk_size - 1, r.stop) for i in r.start:chunk_size:r.stop]\nend\n\ndf_length = nrow(df)\nconcatenated_col = Vector(undef, df_length)\n\n@threads for subrange in divide_range_into_max_n_chunks(1:df_length, nthreads())\n    concatenated_col[subrange] = view(df.input, subrange) .* view(df.target, subrange)\nend```\nI would like to turn the code up there into a macro like this\n```@parallel_broadcast df.input .* df.target```\nbut I’m very new to this and I’m not sure what I’m doing wrong. I piped the code above into Meta.show_sexpr and came up with this, but it doesn’t quite do the job. Here is what I have so far:\n```macro parallel_broadcast(col_a, broadcasted_operator, col_b)\n    return (:macrocall, Symbol(\"@threads\"), :(#= none:1 =#), (:for, (:(=), :subrange, (:call, :divide_range_into_max_n_chunks, (:call, :(:), 1, :df_length), (:call, :nthreads))), (:block,\n      :(#= none:2 =#),\n      (:(=), (:ref, :result_col, :subrange), (:call, broadcasted_operator, (:call, :view, col_a, :subrange), (:call, :view, col_b, :subrange)))\n    )))\nend```\n(This has also been posted on <https://discourse.julialang.org/t/creating-a-macro-to-broadcast-in-parallel/53508|discourse> for posterity)","user":"U01GXNFKY6R","ts":"1610928045.203300","team":"T68168MUP","edited":{"user":"U01GXNFKY6R","ts":"1610928056.000000"},"blocks":[{"type":"rich_text","block_id":"nIzM=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey all,\nI’m trying to create a macro to broadcast in parallel. I have a large dataframe and I frequently create new columns based on values from old columns.\nLet’s take string concatenation for example.\n The non parallel broadcasting version looks like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df.input .* df.target"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and the parallel broadcasted version looks like this\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function divide_range_into_max_n_chunks(r::UnitRange{Int64}, n::Int64)\n    range_length = r.stop - r.start\n    chunk_size = Int64(ceil(range_length / n))\n    return [i:min(i + chunk_size - 1, r.stop) for i in r.start:chunk_size:r.stop]\nend\n\ndf_length = nrow(df)\nconcatenated_col = Vector(undef, df_length)\n\n@threads for subrange in divide_range_into_max_n_chunks(1:df_length, nthreads())\n    concatenated_col[subrange] = view(df.input, subrange) .* view(df.target, subrange)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I would like to turn the code up there into a macro like this\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@parallel_broadcast df.input .* df.target"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but I’m very new to this and I’m not sure what I’m doing wrong. I piped the code above into Meta.show_sexpr and came up with this, but it doesn’t quite do the job. Here is what I have so far:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"macro parallel_broadcast(col_a, broadcasted_operator, col_b)\n    return (:macrocall, Symbol(\"@threads\"), :(#= none:1 =#), (:for, (:(=), :subrange, (:call, :divide_range_into_max_n_chunks, (:call, :(:), 1, :df_length), (:call, :nthreads))), (:block,\n      :(#= none:2 =#),\n      (:(=), (:ref, :result_col, :subrange), (:call, broadcasted_operator, (:call, :view, col_a, :subrange), (:call, :view, col_b, :subrange)))\n    )))\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"(This has also been posted on "},{"type":"link","url":"https://discourse.julialang.org/t/creating-a-macro-to-broadcast-in-parallel/53508","text":"discourse"},{"type":"text","text":" for posterity)"}]}]}],"thread_ts":"1610928045.203300","reply_count":1,"reply_users_count":1,"latest_reply":"1610986429.249100","reply_users":["UTJT285RN"],"subscribed":false},{"client_msg_id":"4049ceac-76b9-4f50-8023-e368eb37e8ed","type":"message","text":"Ok, maybe this is a stupid question. I don't fully get what you are trying to do. But why does this need a macro? Why can't you make function to do it?","user":"UTJT285RN","ts":"1610986429.249100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"u1e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, maybe this is a stupid question. I don't fully get what you are trying to do. But why does this need a macro? Why can't you make function to do it?"}]}]}],"thread_ts":"1610928045.203300","parent_user_id":"U01GXNFKY6R","reactions":[{"name":"white_check_mark","users":["U01GXNFKY6R"],"count":1}]}]