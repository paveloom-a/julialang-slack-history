[{"client_msg_id":"96d86584-db2e-4d20-a77a-bec32f6e9107","type":"message","text":"Say I work with sets of integers: The integers I work with are all between 0 and some N, and all sets I work with have at most 20 elements. I mostly want to do inclusion/intersection/… stuff with them. If N is say less than 32, I'm pretty sure working with bitsets of fixed size 32 is going to be more efficient. What about 1000 elements? How do fixed bitsets, vs dynamic bitsets vs vectors compare? Obviously the best way to know is just to compare actual code, but is there any reasonable estimate to be made?","user":"U01MG0TN079","ts":"1615459681.334300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Wezlw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Say I work with sets of integers: The integers I work with are all between 0 and some N, and all sets I work with have at most 20 elements. I mostly want to do inclusion/intersection/… stuff with them. If N is say less than 32, I'm pretty sure working with bitsets of fixed size 32 is going to be more efficient. What about 1000 elements? How do fixed bitsets, vs dynamic bitsets vs vectors compare? Obviously the best way to know is just to compare actual code, but is there any reasonable estimate to be made?"}]}]}],"thread_ts":"1615459681.334300","reply_count":15,"reply_users_count":4,"latest_reply":"1615460420.340900","reply_users":["B01J9QZ4SP8","U7HAYKY9X","U01MG0TN079","U01L0RJC6FM"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1615459683.334400","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"fc542978-8654-422d-bef5-5256538a642f","type":"message","text":"Fixed bitsets will almost always beat dynamic bitsets, if the fixed bitsets are implemented by fixed-width integers. (e.g. StackCollections). If they're implemented with Tuples, then they become hard on the compiler when they get too large - say, 50-ish elements of the tuple.","user":"U7HAYKY9X","ts":"1615459848.334600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+b0+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fixed bitsets will almost always beat dynamic bitsets, if the fixed bitsets are implemented by fixed-width integers. (e.g. StackCollections). If they're implemented with Tuples, then they become hard on the compiler when they get too large - say, 50-ish elements of the tuple."}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"fec04eb0-5829-401c-8fef-8fe734c8ffd8","type":"message","text":"For bit sets vs vectors, bit sets are more efficient when the integers are dense. E.g. they are terrible if you have `[5, 10000, 523562]` , but good if you have `[123, 126, 130, 131, 133, 140]` . I would estimate they will beat vectors if they have a density of about 0.05 (one in twenty numbers in the range exist in the set), but that's just a guess.","user":"U7HAYKY9X","ts":"1615459947.335500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WZ2dY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For bit sets vs vectors, bit sets are more efficient when the integers are dense. E.g. they are terrible if you have "},{"type":"text","text":"[5, 10000, 523562]","style":{"code":true}},{"type":"text","text":" , but good if you have "},{"type":"text","text":"[123, 126, 130, 131, 133, 140]","style":{"code":true}},{"type":"text","text":" . I would estimate they will beat vectors if they have a density of about 0.05 (one in twenty numbers in the range exist in the set), but that's just a guess."}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"c96438a7-6e94-4c0d-9fab-b33c3025cfd6","type":"message","text":"The reason I say one in 20 is because bit sets are stored wiht 64-bit integers, so a density of 1/64 means a vector is just as good - but the bitsets also have some overhead, so the actual breakeven point will be lower than 64 - maybe 20.","user":"U7HAYKY9X","ts":"1615460000.336900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5TIqT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The reason I say one in 20 is because bit sets are stored wiht 64-bit integers, so a density of 1/64 means a vector is just as good - but the bitsets also have some overhead, so the actual breakeven point will be lower than 64 - maybe 20."}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"adccb88c-f9d0-458a-ab3e-9e1f2fdd9817","type":"message","text":"wait, what's the overhead of bitsets?","user":"U01MG0TN079","ts":"1615460030.337500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aVNFd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"wait, what's the overhead of bitsets?"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"c33c4de5-ebc5-4fe0-89ee-05e31c8ae2c7","type":"message","text":"and here you're only talking about space efficiency here, right?","user":"U01MG0TN079","ts":"1615460066.338000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"weZFO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and here you're only talking about space efficiency here, right?"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"233c0207-14fb-4983-ae58-892baa4b2d19","type":"message","text":"depends on what you do but from a theoretical perspective should be very small","user":"U01L0RJC6FM","ts":"1615460071.338200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qSk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"depends on what you do but from a theoretical perspective should be very small"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"7e33444f-c102-4687-a067-7b38d600d242","type":"message","text":"they outperform conventional vectors up to very large sets... i remember there was a paper on this","user":"U01L0RJC6FM","ts":"1615460097.338600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wtNbG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"they outperform conventional vectors up to very large sets... i remember there was a paper on this"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"339b8000-2318-46c7-b325-022d3d58a26f","type":"message","text":"ah, I'd gladly take a look if you find it","user":"U01MG0TN079","ts":"1615460129.338800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pXqHi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah, I'd gladly take a look if you find it"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"f63be375-b23d-4ccf-ad5e-14ac07c0b0be","type":"message","text":"Offset calculation is not a no-op, although it's cheap. E.g. if you intersect or union bitsets, the offset change and have to be calculated.\nAlso, space efficiency and time efficiency are coupled.","user":"U7HAYKY9X","ts":"1615460130.339000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1UxLz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Offset calculation is not a no-op, although it's cheap. E.g. if you intersect or union bitsets, the offset change and have to be calculated.\nAlso, space efficiency and time efficiency are coupled."}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"0b58db13-bc14-4225-9130-6c110f54bbaa","type":"message","text":"what do you mean, offset calculation? like if my set has elements 1000,1001,1002, you store it as (1000,0b111) ?","user":"U01MG0TN079","ts":"1615460197.339200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0HyHD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what do you mean, offset calculation? like if my set has elements 1000,1001,1002, you store it as (1000,0b111) ?"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"9a91ba20-c0d4-41c7-b237-3ed967330e3c","type":"message","text":"Since the set of numbers I'm using is {0,…,N} for a fixed N &lt; 1000, say,  and the numbers will probably be evenly distributed, I think playing offset tricks would not be useful","user":"U01MG0TN079","ts":"1615460297.339900","team":"T68168MUP","edited":{"user":"U01MG0TN079","ts":"1615460311.000000"},"blocks":[{"type":"rich_text","block_id":"dYCn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Since the set of numbers I'm using is {0,…,N} for a fixed N < 1000, say,  and the numbers will probably be evenly distributed, I think playing offset tricks would not be useful"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"22ee67e9-13f0-461b-9706-1d94ebecc5bb","type":"message","text":"A bitset of 1000, 1001,1002 is stored as \"0,1,2\" + 1000 internally.","user":"U7HAYKY9X","ts":"1615460340.340200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dXKI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A bitset of 1000, 1001,1002 is stored as \"0,1,2\" + 1000 internally."}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"},{"client_msg_id":"dd384313-2f11-4c5d-9a58-6e2615d24452","type":"message","text":"mmh, OK: that's the stdlib implementation?","user":"U01MG0TN079","ts":"1615460369.340600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fsTa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"mmh, OK: that's the stdlib implementation?"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"97e0521f-6b6a-4677-9734-47201c8459c8","type":"message","text":"for now I'm using that <https://github.com/bottine/vinberg/blob/main/src/sbitset.jl>","user":"U01MG0TN079","ts":"1615460420.340900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kt8bM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"for now I'm using that "},{"type":"link","url":"https://github.com/bottine/vinberg/blob/main/src/sbitset.jl"}]}]}],"thread_ts":"1615459681.334300","parent_user_id":"U01MG0TN079"}]