[{"client_msg_id":"d6df7bbc-b7ff-4c94-b6e3-1097afc274bb","type":"message","text":"I'm attempting to debug some knotty `ccall` calls and in doing so I realise that I don't know how the layout of structs works. I find the following unexpected but perhaps I'm being naive.\n\n```julia&gt; struct Bar\n       a::Int8\n       b::Int16\n       c::Int32\n       d::Int64\n       e::Int128\n       f::Ptr{Nothing}\n       g::Ptr{Nothing}\n       end\n\njulia&gt; structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\n\njulia&gt; structinfo(Bar)\n7-element Vector{Tuple{UInt64, Symbol, DataType}}:\n (0x0000000000000000, :a, Int8)\n (0x0000000000000002, :b, Int16)\n (0x0000000000000004, :c, Int32)\n (0x0000000000000008, :d, Int64)\n (0x0000000000000010, :e, Int128)\n (0x0000000000000020, :f, Ptr{Nothing})\n (0x0000000000000028, :g, Ptr{Nothing})```\nI naively expected offsets to be calculated by accumulating  `0,1,2,4,8,16,8`  to give `0,1,3,7,15,31,39`, but this evidently isn't the case. I've tried searching the docs to work out whats going on and have found <https://docs.julialang.org/en/v1/devdocs/reflection/#DataType-layout> and <https://docs.julialang.org/en/v1/devdocs/object/>. Are there any other docs pages could help, does anyone know?","user":"UDSG73JTH","ts":"1613479853.440600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"teTb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm attempting to debug some knotty "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" calls and in doing so I realise that I don't know how the layout of structs works. I find the following unexpected but perhaps I'm being naive.\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct Bar\n       a::Int8\n       b::Int16\n       c::Int32\n       d::Int64\n       e::Int128\n       f::Ptr{Nothing}\n       g::Ptr{Nothing}\n       end\n\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\n\njulia> structinfo(Bar)\n7-element Vector{Tuple{UInt64, Symbol, DataType}}:\n (0x0000000000000000, :a, Int8)\n (0x0000000000000002, :b, Int16)\n (0x0000000000000004, :c, Int32)\n (0x0000000000000008, :d, Int64)\n (0x0000000000000010, :e, Int128)\n (0x0000000000000020, :f, Ptr{Nothing})\n (0x0000000000000028, :g, Ptr{Nothing})"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I naively expected offsets to be calculated by accumulating  "},{"type":"text","text":"0,1,2,4,8,16,8","style":{"code":true}},{"type":"text","text":"  to give "},{"type":"text","text":"0,1,3,7,15,31,39","style":{"code":true}},{"type":"text","text":", but this evidently isn't the case. I've tried searching the docs to work out whats going on and have found "},{"type":"link","url":"https://docs.julialang.org/en/v1/devdocs/reflection/#DataType-layout"},{"type":"text","text":" and "},{"type":"link","url":"https://docs.julialang.org/en/v1/devdocs/object/"},{"type":"text","text":". Are there any other docs pages could help, does anyone know?"}]}]}],"thread_ts":"1613479853.440600","reply_count":18,"reply_users_count":4,"latest_reply":"1613482815.446100","reply_users":["B01J9QZ4SP8","UDB26738Q","U7HAYKY9X","UDSG73JTH"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1613479855.440700","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"7a969b33-4092-4fc0-b00f-8130080a215b","type":"message","text":"is your C library doing struct packing?","user":"UDB26738Q","ts":"1613480161.441300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tua9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is your C library doing struct packing?"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH","reactions":[{"name":"man-shrugging","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"d81bbcf9-36b6-44f0-902c-74ebfc30cf2b","type":"message","text":"<https://github.com/analytech-solutions/CBinding.jl> may help with that","user":"UDB26738Q","ts":"1613480183.441500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z04B2","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/analytech-solutions/CBinding.jl"},{"type":"text","text":" may help with that"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"a874c2b4-c398-4f40-bf1e-b0ada9241035","type":"message","text":"This is a low-level optimization. CPUs have a hard time fetching an object from the CPU cache if it straddles a \"cache line\", that is, if one part of the object has a memory address in one 64-byte chunk, and another part in the next chunk","user":"U7HAYKY9X","ts":"1613480187.441700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FpK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is a low-level optimization. CPUs have a hard time fetching an object from the CPU cache if it straddles a \"cache line\", that is, if one part of the object has a memory address in one 64-byte chunk, and another part in the next chunk"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"0d6bd5c8-1616-42e1-a051-8892000105b6","type":"message","text":"<https://en.wikipedia.org/wiki/Data_structure_alignment>","user":"U7HAYKY9X","ts":"1613480241.442100","team":"T68168MUP","attachments":[{"title":"Data structure alignment","title_link":"https://en.wikipedia.org/wiki/Data_structure_alignment","from_url":"https://en.wikipedia.org/wiki/Data_structure_alignment","author_name":"Wikipedia","author_link":"https://en.wikipedia.org/","text":"Data structure alignment is the way data is arranged and accessed in computer memory. It consists of three separate but related issues: data alignment, data structure padding, and packing.\nThe CPU in modern computer hardware performs reads and writes to memory most efficiently when the data is naturally aligned, which generally means that the data's memory address is a multiple of the data size. For instance, in a 32-bit architecture, the data may be aligned if the data is stored in four consecutive bytes and the first byte lies on a 4-byte boundary.\nData alignment is the aligning of elements according to their natural alignment. To ensure natural alignment, it may be necessary to insert some padding between structure elements or after the last element of a structure. For example, on a 32-bit machine, a data structure containing a 16-bit value followed by a 32-bit value could have 16 bits of padding between the 16-bit value and the 32-bit value to align the 32-bit value on a 32-bit boundary. Alternatively, one can pack the structure, omitting the padding, which may lead to slower access, but uses three quarters as much memory.\nAlthough data structure alignment is a fundamental issue for all modern computers, many computer languages and computer language implementations handle data alignment automatically. Fortran, Ada, PL/I, Pascal, certain C and C++ implementations, D, Rust, C#, and assembly language allow at least partial control of data structure padding, which may be useful in certain special circumstances.","fallback":"wikipedia: Data structure alignment","service_icon":"https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png","id":1,"original_url":"https://en.wikipedia.org/wiki/Data_structure_alignment"}],"blocks":[{"type":"rich_text","block_id":"36Ou3","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://en.wikipedia.org/wiki/Data_structure_alignment"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"ebb66f96-5722-44ff-9f66-f45166d0bb7a","type":"message","text":"Julia's structs are guaranteed to have the same memory layout as C's, both use padding by default","user":"U7HAYKY9X","ts":"1613480281.442400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=coW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Julia's structs are guaranteed to have the same memory layout as C's, both use padding by default"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH","reactions":[{"name":"heart","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"8a285d8a-a798-4052-bad7-691bd13dcb10","type":"message","text":"So I would probably find some documentation of how C does it","user":"U7HAYKY9X","ts":"1613480374.442600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jBT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I would probably find some documentation of how C does it"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"6ffa1554-aff0-4d6f-b8e9-63eda637cf55","type":"message","text":"Cool. I've no doubt it's user error, it's just nice to see it written down.","user":"UDSG73JTH","ts":"1613480562.443100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eRZw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Cool. I've no doubt it's user error, it's just nice to see it written down."}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"4af89a07-d094-46f8-83a4-ae655a57e84a","type":"message","text":"Is there anywhere in the docs that says the struct memory alignment is guaranteed to be same as in c?","user":"UDSG73JTH","ts":"1613480595.443300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tt=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there anywhere in the docs that says the struct memory alignment is guaranteed to be same as in c?"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"d59390b3-e4ea-495b-b724-9b3eefefebb4","type":"message","text":"Hm... this seems to imply it, but it's not clear:\n<https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences>","user":"U7HAYKY9X","ts":"1613480754.443800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Rk9L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hm... this seems to imply it, but it's not clear:\n"},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"040cce83-7529-481b-8f2e-14e3822e2a86","type":"message","text":"Thanks both. Very helpful.","user":"UDSG73JTH","ts":"1613481045.444200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/yXD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks both. Very helpful."}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"1d7ca7ba-ce9d-44c2-bc2b-34e5470af3e9","type":"message","text":"What does \"Unnamed structs are not possible in the translation to Julia.\" mean at the end of the 2nd para of <https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences>?","user":"UDSG73JTH","ts":"1613481774.444400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jha","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What does \"Unnamed structs are not possible in the translation to Julia.\" mean at the end of the 2nd para of "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Struct-Type-Correspondences"},{"type":"text","text":"?"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"f3b106d0-cffc-4853-8404-98c2fba68043","type":"message","text":"Does it mean that anonymous structs don't exist in julia or that entities written c with anonymous structs can't be used in Julia? Probably the former?","user":"UDSG73JTH","ts":"1613481892.444600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lc54","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does it mean that anonymous structs don't exist in julia or that entities written c with anonymous structs can't be used in Julia? Probably the former?"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH","reactions":[{"name":"shrug","users":["U7HAYKY9X"],"count":1}]},{"client_msg_id":"975eb2a2-8c57-4689-9867-a8a2f81b2467","type":"message","text":"maybe you can with <https://github.com/analytech-solutions/CBinding.jl>","user":"UDB26738Q","ts":"1613482132.445100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Bvia","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"maybe you can with "},{"type":"link","url":"https://github.com/analytech-solutions/CBinding.jl"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH","reactions":[{"name":"+1","users":["UDSG73JTH"],"count":1}]},{"client_msg_id":"3156aec8-c9a4-4938-aba3-b7d61ca8d9a7","type":"message","text":"Perhaps the docs could be improved a little there, but I have never really interfaced with C, so I'm not the one to know","user":"U7HAYKY9X","ts":"1613482197.445300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B2c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Perhaps the docs could be improved a little there, but I have never really interfaced with C, so I'm not the one to know"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"e8d34e69-dd26-429c-a933-7d399ec16ac9","type":"message","text":"It looks like `MySecondType` in the README of the `CBindings.jl`  package makes an anonymous struct.","user":"UDSG73JTH","ts":"1613482462.445700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SjO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It looks like "},{"type":"text","text":"MySecondType","style":{"code":true}},{"type":"text","text":" in the README of the "},{"type":"text","text":"CBindings.jl","style":{"code":true}},{"type":"text","text":"  package makes an anonymous struct."}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"49176325-9c20-4582-a876-cbe3a64f3c70","type":"message","text":"julia's builtin C interface works very well but it's very standard, for anything else more advanced `CBindings.jl` does a good job","user":"UDB26738Q","ts":"1613482787.445900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cOCpq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"julia's builtin C interface works very well but it's very standard, for anything else more advanced "},{"type":"text","text":"CBindings.jl","style":{"code":true}},{"type":"text","text":" does a good job"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"},{"client_msg_id":"322e58ed-9a98-4e8e-af55-6b07c198453e","type":"message","text":"(and it's also impressive you can do this in a third-party package)","user":"UDB26738Q","ts":"1613482815.446100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WSFG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(and it's also impressive you can do this in a third-party package)"}]}]}],"thread_ts":"1613479853.440600","parent_user_id":"UDSG73JTH"}]