[{"client_msg_id":"7ec36fd3-15e5-422b-98c1-9a130b1e659d","type":"message","text":"I want to embed a Julia module inside a C program. The documentation is not very clear. Does someone know how to import a module? The example uses `jl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");` and I would like to do something like\n`jl_function_t *myfunc = jl_get_function(jl_mymodule_module, \"myfunc\");`","user":"U013V2CFZAN","ts":"1612571094.142500","team":"T68168MUP","edited":{"user":"U013V2CFZAN","ts":"1612571159.000000"},"blocks":[{"type":"rich_text","block_id":"071PE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want to embed a Julia module inside a C program. The documentation is not very clear. Does someone know how to import a module? The example uses "},{"type":"text","text":"jl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");","style":{"code":true}},{"type":"text","text":" and I would like to do something like\n"},{"type":"text","text":"jl_function_t *myfunc = jl_get_function(jl_mymodule_module, \"myfunc\");","style":{"code":true}}]}]}],"thread_ts":"1612571094.142500","reply_count":8,"reply_users_count":4,"latest_reply":"1612879497.359900","reply_users":["B01J9QZ4SP8","U6740K1SP","U01M24BJPTP","U013V2CFZAN"],"subscribed":false,"reactions":[{"name":"bridge","users":["U013V2CFZAN"],"count":1}]},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1612571096.142600","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"},{"client_msg_id":"d93fc92a-c3c4-447a-aa0c-aaef6d3e43a9","type":"message","text":"small breadcrumb: <https://stackoverflow.com/questions/65322339/how-to-use-julia-special-functions-inside-c#comment115494570_65322339>","user":"U6740K1SP","ts":"1612581304.143200","team":"T68168MUP","attachments":[{"service_name":"Stack Overflow","title":"How to use Julia special functions inside c++","title_link":"https://stackoverflow.com/questions/65322339/how-to-use-julia-special-functions-inside-c#comment115494570_65322339","text":"Hi I want to use the special functions of Julia implementation (<https://juliamath.github.io/SpecialFunctions.jl/dev/functions_list/>) inside c++. Following the manual (<https://docs.julialang.org/en/v1/>","fallback":"Stack Overflow: How to use Julia special functions inside c++","thumb_url":"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded","from_url":"https://stackoverflow.com/questions/65322339/how-to-use-julia-special-functions-inside-c#comment115494570_65322339","thumb_width":316,"thumb_height":316,"service_icon":"https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a","id":1,"original_url":"https://stackoverflow.com/questions/65322339/how-to-use-julia-special-functions-inside-c#comment115494570_65322339"}],"blocks":[{"type":"rich_text","block_id":"a3L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"small breadcrumb: "},{"type":"link","url":"https://stackoverflow.com/questions/65322339/how-to-use-julia-special-functions-inside-c#comment115494570_65322339"}]}]}],"thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN","reactions":[{"name":"+1","users":["U013V2CFZAN"],"count":1}]},{"client_msg_id":"a52db214-c1c1-436d-9655-a22362aa5188","type":"message","text":"<@U013V2CFZAN>\nPerhaps you need to call jl_load <https://github.com/JuliaLang/julia/blob/985158ff5b138954c87db273ebfed2ca4321a67c/src/toplevel.c#L1051>, also see <https://docs.julialang.org/en/v1/devdocs/eval/>\nAlthough my recommendation is to write your C program as a library and call it from Julia. You can pass Julia function pointers to C functions. <https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Creating-C-Compatible-Julia-Function-Pointers>","user":"U01M24BJPTP","ts":"1612582485.143900","team":"T68168MUP","edited":{"user":"U01M24BJPTP","ts":"1612590682.000000"},"blocks":[{"type":"rich_text","block_id":"v9X","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U013V2CFZAN"},{"type":"text","text":"\nPerhaps you need to call jl_load "},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/985158ff5b138954c87db273ebfed2ca4321a67c/src/toplevel.c#L1051"},{"type":"text","text":", also see "},{"type":"link","url":"https://docs.julialang.org/en/v1/devdocs/eval/"},{"type":"text","text":"\nAlthough my recommendation is to write your C program as a library and call it from Julia. You can pass Julia function pointers to C functions. "},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Creating-C-Compatible-Julia-Function-Pointers"}]}]}],"thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"},{"client_msg_id":"f655bb03-4093-4ca2-bc56-2dcbbfdaf762","type":"message","text":"<@U01M24BJPTP> I don't have too much choice on the matter. He want to embed Julia for numerical calculations on a larger system that is written in C++ ... perhaps you can call it a robotics system due too all the drivers and servos involved.","user":"U013V2CFZAN","ts":"1612608130.153500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m8Zh","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01M24BJPTP"},{"type":"text","text":" I don't have too much choice on the matter. He want to embed Julia for numerical calculations on a larger system that is written in C++ ... perhaps you can call it a robotics system due too all the drivers and servos involved."}]}]}],"thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"},{"client_msg_id":"ebf85758-6f28-454b-814b-c9b88515e5b7","type":"message","text":"<@U6740K1SP> Thanks! this is exactly what I was looking for!","user":"U013V2CFZAN","ts":"1612608437.153700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4k+/X","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U6740K1SP"},{"type":"text","text":" Thanks! this is exactly what I was looking for!"}]}]}],"thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"},{"client_msg_id":"9e9a68a3-7d51-4482-91f9-3d27804dd9a2","type":"message","text":"<@U01M24BJPTP> oh great! your answer expands on the SO thread, thanks! that makes my life much easier. Thank you both!","user":"U013V2CFZAN","ts":"1612609030.154000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rfji","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U01M24BJPTP"},{"type":"text","text":" oh great! your answer expands on the SO thread, thanks! that makes my life much easier. Thank you both!"}]}]}],"thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"},{"client_msg_id":"d2774d12-7060-455a-b4e8-8c6affd7baf8","type":"message","text":"Hi guys, I modified the example from the post that <@U6740K1SP> referred me to from SGJ. I want to modify it in order to send back and forth arrays with zero copy. However, I don't know what is missing. I'm sure that it is something silly.\n```#include &lt;julia.h&gt;\nJULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.\n\n#include &lt;vector&gt;\n\ntypedef jl_array_t* (*erf_ptr)(jl_array_t * z);\n// erf_ptr erf = NULL;\n\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[])\n{\n    jl_init();\n    jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\n\n    double v[] = { .1, .2, .3, .4 };\n\n    // Expected output\n    // julia&gt; [.1, .2, .3, .4] .|&gt; SpecialFunctions.erf\n    // 4-element Vector{Float64}:\n    // 0.1124629160182849\n    // 0.22270258921047847\n    // 0.3286267594591274\n    // 0.42839235504666845\n    \n\n    jl_array_t *x = jl_ptr_to_array_1d(array_type, v, 4, 0);\n\n    // get a C function pointer to the Julia erf function compiled for\n    jl_eval_string(\"import SpecialFunctions\");\n    jl_value_t *ret = jl_eval_string(\"@cfunction(x-&gt;SpecialFunctions.erf.(x), Vector{Float64}, (Vector{Float64},))\");\n    erf_ptr erf = (erf_ptr) jl_unbox_voidpointer(ret);\n\n    jl_array_t*  out = erf(x); // Probably doing something wrong here\n    double *outData = (double*)jl_array_data(out);\n\n        // Print out the vector\n    for(size_t i=0; i&lt;4; i++)\n        std::cout &lt;&lt; outData[i] &lt;&lt; ' ';\n\n    std::cout &lt;&lt; \"\\n\";\n\n    // Returns garbage\n    // 4.94066e-324 0 0 6.91799e-310 \n\n    jl_atexit_hook(0);\n    return 0;\n}```","user":"U013V2CFZAN","ts":"1612879071.359600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8r+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi guys, I modified the example from the post that "},{"type":"user","user_id":"U6740K1SP"},{"type":"text","text":" referred me to from SGJ. I want to modify it in order to send back and forth arrays with zero copy. However, I don't know what is missing. I'm sure that it is something silly.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"#include <julia.h>\nJULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.\n\n#include <vector>\n\ntypedef jl_array_t* (*erf_ptr)(jl_array_t * z);\n// erf_ptr erf = NULL;\n\n#include <iostream>\n\nint main(int argc, char *argv[])\n{\n    jl_init();\n    jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\n\n    double v[] = { .1, .2, .3, .4 };\n\n    // Expected output\n    // julia> [.1, .2, .3, .4] .|> SpecialFunctions.erf\n    // 4-element Vector{Float64}:\n    // 0.1124629160182849\n    // 0.22270258921047847\n    // 0.3286267594591274\n    // 0.42839235504666845\n    \n\n    jl_array_t *x = jl_ptr_to_array_1d(array_type, v, 4, 0);\n\n    // get a C function pointer to the Julia erf function compiled for\n    jl_eval_string(\"import SpecialFunctions\");\n    jl_value_t *ret = jl_eval_string(\"@cfunction(x->SpecialFunctions.erf.(x), Vector{Float64}, (Vector{Float64},))\");\n    erf_ptr erf = (erf_ptr) jl_unbox_voidpointer(ret);\n\n    jl_array_t*  out = erf(x); // Probably doing something wrong here\n    double *outData = (double*)jl_array_data(out);\n\n        // Print out the vector\n    for(size_t i=0; i<4; i++)\n        std::cout << outData[i] << ' ';\n\n    std::cout << \"\\n\";\n\n    // Returns garbage\n    // 4.94066e-324 0 0 6.91799e-310 \n\n    jl_atexit_hook(0);\n    return 0;\n}"}]}]}],"thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"},{"type":"message","subtype":"bot_message","text":"Success, it has been cross posted <https://discourse.julialang.org/t/54928| to Discourse>. Keep and eye out on Discourse for responses and please add an answer there once you are satisfied with the solution so others can benefit as well. Happy debugging!","ts":"1612879497.359900","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1612571094.142500","parent_user_id":"U013V2CFZAN"}]