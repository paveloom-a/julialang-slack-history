[{"client_msg_id":"89e5e07f-bff4-42e1-ac28-02a9deb78bee","type":"message","text":"A question about string parsing: I have a bunch of files that look like `data/1-57656.txt`, `data/2-65725.txt`, `data/3-6557.txt`, basically I know they start with `N-`, but not what will come after that. I have a function `function read(N)` that I would like to based on N, read in the data file, then do some slicing. I know there must be a better way than writing a massive if/else for each suffix (I don't know if the suffix will change in future, and don't want to have updated this). I would do this with tab completion in the REPL, as I know there's only 1 for each `N`. My question is: is there a smart/julian way of handling this kind of wildcard parsing? I guess I can do some regular expression things, but wanted to check I wasn't missing a trick first","user":"U01EU0XGD1D","ts":"1610973754.232100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PUu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A question about string parsing: I have a bunch of files that look like "},{"type":"text","text":"data/1-57656.txt","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"data/2-65725.txt","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"data/3-6557.txt","style":{"code":true}},{"type":"text","text":", basically I know they start with "},{"type":"text","text":"N-","style":{"code":true}},{"type":"text","text":", but not what will come after that. I have a function "},{"type":"text","text":"function read(N)","style":{"code":true}},{"type":"text","text":" that I would like to based on N, read in the data file, then do some slicing. I know there must be a better way than writing a massive if/else for each suffix (I don't know if the suffix will change in future, and don't want to have updated this). I would do this with tab completion in the REPL, as I know there's only 1 for each "},{"type":"text","text":"N","style":{"code":true}},{"type":"text","text":". My question is: is there a smart/julian way of handling this kind of wildcard parsing? I guess I can do some regular expression things, but wanted to check I wasn't missing a trick first"}]}]}],"thread_ts":"1610973754.232100","reply_count":3,"reply_users_count":3,"latest_reply":"1610977230.234200","reply_users":["U67SCG4HG","U017JTQFNEQ","U01EU0XGD1D"],"subscribed":false},{"client_msg_id":"c8ef599b-fc8b-47d5-9c62-2257f1708282","type":"message","text":"You can use <https://github.com/vtjnash/Glob.jl> for pattern matching. Or you can just regex match yourself, something like\n```r\"^\\d+-\\d+\\.txt$\"```\nmaybe","user":"U67SCG4HG","ts":"1610974756.232300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UEGCB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can use "},{"type":"link","url":"https://github.com/vtjnash/Glob.jl"},{"type":"text","text":" for pattern matching. Or you can just regex match yourself, something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"r\"^\\d+-\\d+\\.txt$\""}]},{"type":"rich_text_section","elements":[{"type":"text","text":"maybe"}]}]}],"thread_ts":"1610973754.232100","parent_user_id":"U01EU0XGD1D","reactions":[{"name":"raised_hands","users":["U01EU0XGD1D"],"count":1}]},{"client_msg_id":"e73de3ad-fa36-4afa-aa68-340e5da3a220","type":"message","text":"there is also `startswith`","user":"U017JTQFNEQ","ts":"1610975071.232500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+dW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there is also "},{"type":"text","text":"startswith","style":{"code":true}}]}]}],"thread_ts":"1610973754.232100","parent_user_id":"U01EU0XGD1D"},{"client_msg_id":"52a24b04-658b-45b6-808d-e1f2fd07f986","type":"message","text":"`Glob.jl` worked perfectly. `startswith` seems mainly for checking if it matches a predicate, rather than finding the files which do directly (I guess I could scan the directory for a match, but thats a little roundabout)","user":"U01EU0XGD1D","ts":"1610977230.234200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ASC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Glob.jl","style":{"code":true}},{"type":"text","text":" worked perfectly. "},{"type":"text","text":"startswith","style":{"code":true}},{"type":"text","text":" seems mainly for checking if it matches a predicate, rather than finding the files which do directly (I guess I could scan the directory for a match, but thats a little roundabout)"}]}]}],"thread_ts":"1610973754.232100","parent_user_id":"U01EU0XGD1D","reactions":[{"name":"100","users":["U017JTQFNEQ"],"count":1}]}]