[{"client_msg_id":"05a9f84d-529a-4ed7-a537-d8c35a84f39f","type":"message","text":"I feel like I should be taking advantage of multiple dispatch here but I can't wrap my head around how this should be done in properly in julia:\n```function foo(x; a::Symbol=:bar, b::Symbol=:baz)\n  if a == :bar\n    if b == :baz\n      return _foo1(x)\n    end\n  else\n    return _foo2(x)\n  end\nend```\nI have lots of functions for calculating some quantity (_foo1, _foo2) and I want to expose just one function to the public (foo) which takes in some optional parameters (a,b) which will specify which internal functions get used. Is this the right way to do this in julia? Feels very much how i would do this in R","user":"U6CFMFM2R","ts":"1610045122.481700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zNpL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I feel like I should be taking advantage of multiple dispatch here but I can't wrap my head around how this should be done in properly in julia:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function foo(x; a::Symbol=:bar, b::Symbol=:baz)\n  if a == :bar\n    if b == :baz\n      return _foo1(x)\n    end\n  else\n    return _foo2(x)\n  end\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I have lots of functions for calculating some quantity (_foo1, _foo2) and I want to expose just one function to the public (foo) which takes in some optional parameters (a,b) which will specify which internal functions get used. Is this the right way to do this in julia? Feels very much how i would do this in R"}]}]}],"thread_ts":"1610045122.481700","reply_count":1,"reply_users_count":1,"latest_reply":"1610045489.483100","reply_users":["U011QC7QLPL"],"subscribed":false},{"client_msg_id":"c7ea8fa3-b6a5-41eb-bd07-3670a40efe3d","type":"message","text":"IMO this is okay, as Mason noted they are compile time constants but with multiple dispatch it could look something like\n```\nabstract type AbstractThingA end\nstruct Bar &lt;: AbstractThingA end\nstruct Barf &lt;: AbstractThingA end\n\nabstract type AbstractThingB end\nstruct Baz &lt;: AbstractThingB end\nstruct Bazf &lt;: AbstractThingB end\n\nfoo(x, ::Bar, ::Baz) = _foo1(x)\nfoo(x, ::Barf, ::Baz) = _foo2(x)\n# etc\nfoo(x) = # default arg case```","user":"U011QC7QLPL","ts":"1610045489.483100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Afq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"IMO this is okay, as Mason noted they are compile time constants but with multiple dispatch it could look something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\nabstract type AbstractThingA end\nstruct Bar <: AbstractThingA end\nstruct Barf <: AbstractThingA end\n\nabstract type AbstractThingB end\nstruct Baz <: AbstractThingB end\nstruct Bazf <: AbstractThingB end\n\nfoo(x, ::Bar, ::Baz) = _foo1(x)\nfoo(x, ::Barf, ::Baz) = _foo2(x)\n# etc\nfoo(x) = # default arg case"}]}]}],"thread_ts":"1610045122.481700","parent_user_id":"U6CFMFM2R"}]