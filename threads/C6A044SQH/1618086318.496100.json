[{"client_msg_id":"7a51734c-e692-437b-926b-27f9cd47b73a","type":"message","text":"Is there a way to make this work, i.e. have a type parameter that applies both the input and output?\n```f(::T)::T where {T} = T(1)```","user":"U67431ELR","ts":"1618086318.496100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HoXn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a way to make this work, i.e. have a type parameter that applies both the input and output?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"f(::T)::T where {T} = T(1)"}]}]}],"thread_ts":"1618086318.496100","reply_count":3,"reply_users_count":2,"latest_reply":"1618086672.498100","reply_users":["UM30MT6RF","U67431ELR"],"is_locked":false,"subscribed":false},{"client_msg_id":"45e653cc-b45f-471e-b435-4d0bf999de74","type":"message","text":"Move the `::T` inside the function body, i.e. `T(1)::T`","user":"UM30MT6RF","ts":"1618086483.497500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QJ+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Move the "},{"type":"text","text":"::T","style":{"code":true}},{"type":"text","text":" inside the function body, i.e. "},{"type":"text","text":"T(1)::T","style":{"code":true}}]}]}],"thread_ts":"1618086318.496100","parent_user_id":"U67431ELR"},{"client_msg_id":"bc3e95cc-69e7-40dc-afbf-a6726324f675","type":"message","text":"Indeed I guess that should do the trick. Does that make any difference?","user":"U67431ELR","ts":"1618086552.497700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6VOF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Indeed I guess that should do the trick. Does that make any difference?"}]}]}],"thread_ts":"1618086318.496100","parent_user_id":"U67431ELR"},{"client_msg_id":"11d04468-a076-42e7-aa96-60eafdaaf074","type":"message","text":"W.r.t type inference, there shouldn't be any difference, but I believe the return type annotation will convert the output if it doesn't match the type, while type asserts in the body will just throw an error in that case.","user":"UM30MT6RF","ts":"1618086672.498100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ac06","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"W.r.t type inference, there shouldn't be any difference, but I believe the return type annotation will convert the output if it doesn't match the type, while type asserts in the body will just throw an error in that case."}]}]}],"thread_ts":"1618086318.496100","parent_user_id":"U67431ELR","reactions":[{"name":"heavy_check_mark","users":["U67431ELR"],"count":1}]}]