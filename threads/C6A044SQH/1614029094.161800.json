[{"client_msg_id":"43afdb6d-ca21-48bb-acdc-5152d625b0f8","type":"message","text":"Is there any problem with using eval in a function to find a constant? I have a bunch of constants `Foo_&lt;Type&gt;` in my module that can be input to a function. I'd &lt;Type&gt; corresponds to the type of another argument to that function, like `bar(a, Foo_&lt;typeof(a)&gt;`. I'd like to just do `bar(a, Foo)` and have the function figure out which constant to use. Can I just `eval(Foo_$typeof(a))`? I think it should work","user":"U017D4RFTFC","ts":"1614029094.161800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4kEu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there any problem with using eval in a function to find a constant? I have a bunch of constants "},{"type":"text","text":"Foo_<Type>","style":{"code":true}},{"type":"text","text":" in my module that can be input to a function. I'd <Type> corresponds to the type of another argument to that function, like "},{"type":"text","text":"bar(a, Foo_<typeof(a)>","style":{"code":true}},{"type":"text","text":". I'd like to just do "},{"type":"text","text":"bar(a, Foo) ","style":{"code":true}},{"type":"text","text":"and have the function figure out which constant to use. Can I just "},{"type":"text","text":"eval(Foo_$typeof(a))","style":{"code":true}},{"type":"text","text":"? I think it should work"}]}]}],"thread_ts":"1614029094.161800","reply_count":7,"reply_users_count":3,"latest_reply":"1614034447.166600","reply_users":["UM30MT6RF","U017D4RFTFC","U017LQ3A59U"],"subscribed":false},{"client_msg_id":"2202781b-2956-4ac0-8a91-16e6bda1ce4e","type":"message","text":"`eval` is always dynamic, so this will be pretty slow. Why not just make `Foo` a function that returns constants based on the type? What you describe doesn't really sound idiomatic","user":"UM30MT6RF","ts":"1614029319.161900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NlD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"eval","style":{"code":true}},{"type":"text","text":" is always dynamic, so this will be pretty slow. Why not just make "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" a function that returns constants based on the type? What you describe doesn't really sound idiomatic"}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC","reactions":[{"name":"thumbsup_all","users":["U0179G7FG4F","U017D4RFTFC"],"count":2}]},{"client_msg_id":"d8dcf1b3-1dde-4db1-ae36-db6bbf4aab77","type":"message","text":"Ok, is there any problem with using dlsym multiple times if the user called the function repeatedly? These constants wrap cglobals. I don't think it should since they're just pointers to what should be the same immutable object","user":"U017D4RFTFC","ts":"1614029464.163400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Su5LO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, is there any problem with using dlsym multiple times if the user called the function repeatedly? These constants wrap cglobals. I don't think it should since they're just pointers to what should be the same immutable object"}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"b948a79d-b190-4bfb-90eb-395762c91110","type":"message","text":"I guess I should contextualize, there are a lot of `Foo`s but only about 8-12 types a could take","user":"U017D4RFTFC","ts":"1614029982.165100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GTxpE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess I should contextualize, there are a lot of "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":"s but only about 8-12 types a could take"}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"7bbac1e2-c3c0-4e38-92c4-e28ac6b2ffb6","type":"message","text":"There are several ways of doing it so that the constants are only computed once. Among others\n1. Define your constants in dictionnaries using your types as keys\n2. Define all yours constants and then use `Foo{::Type}` to retrieve the one you need based on type\n3. Access your constants through `Foo` function and memoize/cache the result\nIn any case there should really be no need for `eval` in your use case.","user":"U017LQ3A59U","ts":"1614030956.165500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"urm1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are several ways of doing it so that the constants are only computed once. Among others\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Define your constants in dictionnaries using your types as keys"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Define all yours constants and then use "},{"type":"text","text":"Foo{::Type}","style":{"code":true}},{"type":"text","text":" to retrieve the one you need based on type"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Access your constants through "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" function and memoize/cache the result"}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"In any case there should really be no need for "},{"type":"text","text":"eval","style":{"code":true}},{"type":"text","text":" in your use case."}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"cfd0ac8d-e2b6-4521-973b-fcaf7da32503","type":"message","text":"Dictionaries is probably the way I'll go, it's just so verbose. Could you elaborate on 2? I have `const Foo_INT8 = _Foo{Int8}()` right now","user":"U017D4RFTFC","ts":"1614031427.165900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0z/F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Dictionaries is probably the way I'll go, it's just so verbose. Could you elaborate on 2? I have "},{"type":"text","text":"const Foo_INT8 = _Foo{Int8}()","style":{"code":true}},{"type":"text","text":" right now"}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC"},{"client_msg_id":"66dee8ed-1364-4907-ae7f-b4b8edb214f2","type":"message","text":"You can define\n```foo(::Type{Int8}) = Foo_INT8\nfoo(::Type{Int16}) = Foo_INT16\n# etc```\nIf `Foo_INT8` has been declared as a constant the compiler should even be kind enough to inline the function everywhere.","user":"U017LQ3A59U","ts":"1614034405.166400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I+u=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can define\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"foo(::Type{Int8}) = Foo_INT8\nfoo(::Type{Int16}) = Foo_INT16\n# etc"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"If "},{"type":"text","text":"Foo_INT8","style":{"code":true}},{"type":"text","text":" has been declared as a constant the compiler should even be kind enough to inline the function everywhere."}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC","reactions":[{"name":"+1","users":["U017D4RFTFC"],"count":1}]},{"client_msg_id":"ac15a7a4-df0d-4d41-8a26-f0438c621b23","type":"message","text":"(and if the types can be inferred at compile time)","user":"U017LQ3A59U","ts":"1614034447.166600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=MMG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(and if the types can be inferred at compile time)"}]}]}],"thread_ts":"1614029094.161800","parent_user_id":"U017D4RFTFC"}]