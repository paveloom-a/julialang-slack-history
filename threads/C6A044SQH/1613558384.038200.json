[{"client_msg_id":"1445f93f-3059-4277-b3bd-8e532024add9","type":"message","text":"Does anyone know how to take a parametric type, e.g. `Array{Float64,1}` and get its `UnionAll`, i.e. drop the type parameters? So basically define a function `f(::Type{A}) where {A} = ...` which produces the `UnionAll` of `A`? (in the case of `Array{Float64,1}` this would be `Array` )","user":"U01H36BUDJB","ts":"1613558384.038200","team":"T68168MUP","edited":{"user":"U01H36BUDJB","ts":"1613558878.000000"},"blocks":[{"type":"rich_text","block_id":"+sHN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does anyone know how to take a parametric type, e.g. "},{"type":"text","text":"Array{Float64,1}","style":{"code":true}},{"type":"text","text":" and get its "},{"type":"text","text":"UnionAll","style":{"code":true}},{"type":"text","text":", i.e. drop the type parameters? So basically define a function "},{"type":"text","text":"f(::Type{A}) where {A} = ...","style":{"code":true}},{"type":"text","text":" which produces the "},{"type":"text","text":"UnionAll","style":{"code":true}},{"type":"text","text":" of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":"? (in the case of "},{"type":"text","text":"Array{Float64,1}","style":{"code":true}},{"type":"text","text":" this would be "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":" )"}]}]}],"thread_ts":"1613558384.038200","reply_count":8,"reply_users_count":4,"latest_reply":"1613566590.054100","reply_users":["B01J9QZ4SP8","U7HAYKY9X","U01H36BUDJB","U017LQ3A59U"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1613558385.038300","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"c62c9542-31b7-4393-9632-61d9e030e569","type":"message","text":"Yes, `Base.typename(x).wrapper` , but the \"wrapper\" part is not API, so may change.","user":"U7HAYKY9X","ts":"1613559541.038900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X+l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, "},{"type":"text","text":"Base.typename(x).wrapper","style":{"code":true}},{"type":"text","text":" , but the \"wrapper\" part is not API, so may change."}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"b85e77fa-c07c-40dc-9697-870165907d98","type":"message","text":"I'm curious, this quesiton have been asked a lot here on Slack, but I can't imagine a situation where I'd want to do this. There must be a common use case since so many people want it. What are you using it for?","user":"U7HAYKY9X","ts":"1613559601.039100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2qU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm curious, this quesiton have been asked a lot here on Slack, but I can't imagine a situation where I'd want to do this. There must be a common use case since so many people want it. What are you using it for?"}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"b5c10a61-09a4-411d-a78d-39a5a491557c","type":"message","text":"It's useful if you have two concrete types `A` and `B` and you want to do `promote_type` and see if they are both in the same \"family\" or union of types.","user":"U01H36BUDJB","ts":"1613563653.045500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Zds","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's useful if you have two concrete types "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" and you want to do "},{"type":"text","text":"promote_type","style":{"code":true}},{"type":"text","text":" and see if they are both in the same \"family\" or union of types."}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"ecbeba10-1fea-4692-bad2-357df31977f8","type":"message","text":"The real solution to this would be type constructors... but I kind of doubt that will make it into Julia any time soon, if ever.","user":"U01H36BUDJB","ts":"1613563686.045700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"G3Z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The real solution to this would be type constructors... but I kind of doubt that will make it into Julia any time soon, if ever."}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"802c8fb6-5e00-4848-b6aa-018094b84e35","type":"message","text":"There is another workaround that I figured out. If you have abstract type `A` and then a struct `S{T}&lt;:A` you can also just do `promote_type(x,y)` where `x` and `y` might be conrete types of `S{T}` or might be some other subtype of `A` , and then you can check whether or not the promoted type is `== A` . This works but is a bit clunky and requires assumptions about the type hierarchy.","user":"U01H36BUDJB","ts":"1613563933.046100","team":"T68168MUP","edited":{"user":"U01H36BUDJB","ts":"1613563984.000000"},"blocks":[{"type":"rich_text","block_id":"AtV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There is another workaround that I figured out. If you have abstract type "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" and then a struct "},{"type":"text","text":"S{T}<:A","style":{"code":true}},{"type":"text","text":" you can also just do "},{"type":"text","text":"promote_type(x,y)","style":{"code":true}},{"type":"text","text":" where "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" might be conrete types of "},{"type":"text","text":"S{T}","style":{"code":true}},{"type":"text","text":" or might be some other subtype of "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" , and then you can check whether or not the promoted type is "},{"type":"text","text":"== A","style":{"code":true}},{"type":"text","text":" . This works but is a bit clunky and requires assumptions about the type hierarchy."}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"9893c4e9-e099-4c0b-b901-ad953437bcb8","type":"message","text":"Another case I had is `B{T} &lt;: A{T}` and `C{T} &lt;: A{T}` and I want to have a generic way to convert the parameter for any type `&lt;: A` . Ideally I would write something like\n```convert_param(S, a::T) where {P, T &lt;: A{P}} = wrapper(T)(convert(S, fields(a)...))```\nThis issue came up a lot when I tried to set up infrastructure for various interval types in IntervalArithmetic","user":"U017LQ3A59U","ts":"1613564993.046800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2zCuI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Another case I had is "},{"type":"text","text":"B{T} <: A{T}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"C{T} <: A{T}","style":{"code":true}},{"type":"text","text":" and I want to have a generic way to convert the parameter for any type "},{"type":"text","text":"<: A","style":{"code":true}},{"type":"text","text":" . Ideally I would write something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"convert_param(S, a::T) where {P, T <: A{P}} = wrapper(T)(convert(S, fields(a)...))"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"This issue came up a lot when I tried to set up infrastructure for various interval types in IntervalArithmetic"}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB","reactions":[{"name":"+1","users":["U01H36BUDJB"],"count":1}]},{"client_msg_id":"7991803a-eed4-4dbe-9258-8aaa81de35c6","type":"message","text":"I couldn't find a previous discussion about this so I created a new one on Discourse:\n<https://discourse.julialang.org/t/feature-higher-order-type-constructors/55456>","user":"U01H36BUDJB","ts":"1613566590.054100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5mq73","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I couldn't find a previous discussion about this so I created a new one on Discourse:\n"},{"type":"link","url":"https://discourse.julialang.org/t/feature-higher-order-type-constructors/55456"}]}]}],"thread_ts":"1613558384.038200","parent_user_id":"U01H36BUDJB"}]