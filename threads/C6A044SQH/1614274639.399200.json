[{"client_msg_id":"e7507899-cfb7-4319-9afc-96989b28790c","type":"message","text":"I want to discretize a normal distribution. It feels to me like at least one package (e.g., Distributions or Expectations) should already have  this functionality built in, i.e. that I just write `discretize(\"normal\",mu=0,sigma=1,grdpnts=5)` and it spits out two vectors (with five elements), one with a PMF and one with the values? The actual values would probably depend on how you discretize, but I don't really care too much. Am I missing something obvious in some other package?","user":"UBTGC7HPA","ts":"1614274639.399200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+rP5c","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want to discretize a normal distribution. It feels to me like at least one package (e.g., Distributions or Expectations) should already have  this functionality built in, i.e. that I just write "},{"type":"text","text":"discretize(\"normal\",mu=0,sigma=1,grdpnts=5)","style":{"code":true}},{"type":"text","text":" and it spits out two vectors (with five elements), one with a PMF and one with the values? The actual values would probably depend on how you discretize, but I don't really care too much. Am I missing something obvious in some other package?"}]}]}],"thread_ts":"1614274639.399200","reply_count":8,"reply_users_count":3,"latest_reply":"1614276163.401000","reply_users":["B01J9QZ4SP8","UH8A351DJ","UBTGC7HPA"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1614274642.399300","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"91902325-da8d-4a1a-90de-fc5b000d4e64","type":"message","text":"If I'm not mistaken:\n```julia&gt; d = Normal(0, 1)\nNormal{Float64}(μ=0.0, σ=1.0)\n\njulia&gt; edges = [-Inf, -1, 0, 1, Inf]\n5-element Vector{Float64}:\n -Inf\n  -1.0\n   0.0\n   1.0\n  Inf\n\njulia&gt; diff(cdf.(d, edges))\n4-element Vector{Float64}:\n 0.15865525393145702\n 0.341344746068543\n 0.34134474606854304\n 0.15865525393145696```","user":"UH8A351DJ","ts":"1614275147.399600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zhQF/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I'm not mistaken:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> d = Normal(0, 1)\nNormal{Float64}(μ=0.0, σ=1.0)\n\njulia> edges = [-Inf, -1, 0, 1, Inf]\n5-element Vector{Float64}:\n -Inf\n  -1.0\n   0.0\n   1.0\n  Inf\n\njulia> diff(cdf.(d, edges))\n4-element Vector{Float64}:\n 0.15865525393145702\n 0.341344746068543\n 0.34134474606854304\n 0.15865525393145696"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"f074c98a-19e9-4b1f-a279-44bf0fb0d25f","type":"message","text":"this is what you want?","user":"UH8A351DJ","ts":"1614275150.399800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5ir","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"this is what you want?"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"a44df62a-aa50-441c-97f9-e4cda875b443","type":"message","text":"Pretty close, and I can use this for now. I guess I would want an algorithm that some smart people figured out such that E[X]=\\mu, Var[X]=\\sigma^2, etc, which I don't think your method satisfies?\n```using Distributions\nd = Normal(0, 1)\nx = [-2, -1, 0, 1, 2]\np = pdf.(d,x)\nmean = sum(x.*p) # = 0 , great\nvar = sum((x).^2.0.*p) # = 0.916.. not great```\nI guess I should use some quadrature method, but I'd rather not write the function myself","user":"UBTGC7HPA","ts":"1614275659.400000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wR8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Pretty close, and I can use this for now. I guess I would want an algorithm that some smart people figured out such that E[X]=\\mu, Var[X]=\\sigma^2, etc, which I don't think your method satisfies?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Distributions\nd = Normal(0, 1)\nx = [-2, -1, 0, 1, 2]\np = pdf.(d,x)\nmean = sum(x.*p) # = 0 , great\nvar = sum((x).^2.0.*p) # = 0.916.. not great"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I guess I should use some quadrature method, but I'd rather not write the function myself"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"23a64ed0-a5e9-4095-8425-444ac810719f","type":"message","text":"bin center is not -2 right?","user":"UH8A351DJ","ts":"1614275818.400200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q0Cu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"bin center is not -2 right?"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"90c39263-e7cb-4961-83d5-b1198695626c","type":"message","text":"I mean in general you can't do this for ANY distribution precisely anyways. Can you point me to a library that does this perfectly/properly? maybe we can learn from them","user":"UH8A351DJ","ts":"1614275842.400400","team":"T68168MUP","edited":{"user":"UH8A351DJ","ts":"1614275856.000000"},"blocks":[{"type":"rich_text","block_id":"XhV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean in general you can't do this for ANY distribution precisely anyways. Can you point me to a library that does this perfectly/properly? maybe we can learn from them"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"01e66ade-1a1f-40cd-a48a-2c60db52bf3a","type":"message","text":"(Of course though the method generally gets better the more nodes you allow for, i.e. if `x=-10:1:10` it's very accurate, at least for the first four moments)","user":"UBTGC7HPA","ts":"1614275865.400800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"E2d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(Of course though the method generally gets better the more nodes you allow for, i.e. if "},{"type":"text","text":"x=-10:1:10","style":{"code":true}},{"type":"text","text":" it's very accurate, at least for the first four moments)"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"},{"client_msg_id":"caad50e6-b03a-477d-b68b-9a8c8301e843","type":"message","text":"So the closest that springs to mind are all the papers in economics that discretize an AR(1) process (y[t] = rho y[t-1] + whitenoise), typically using Tauchen or the Rowenhourst algorithm, for example in QuantEcon (<http://quantecon.github.io/QuantEcon.jl/latest/api/QuantEcon.html#QuantEcon.rouwenhorst>). Well, I guess I could always rho=0, and see what happens..!","user":"UBTGC7HPA","ts":"1614276163.401000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"F3R+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So the closest that springs to mind are all the papers in economics that discretize an AR(1) process (y[t] = rho y[t-1] + whitenoise), typically using Tauchen or the Rowenhourst algorithm, for example in QuantEcon ("},{"type":"link","url":"http://quantecon.github.io/QuantEcon.jl/latest/api/QuantEcon.html#QuantEcon.rouwenhorst"},{"type":"text","text":"). Well, I guess I could always rho=0, and see what happens..!"}]}]}],"thread_ts":"1614274639.399200","parent_user_id":"UBTGC7HPA"}]