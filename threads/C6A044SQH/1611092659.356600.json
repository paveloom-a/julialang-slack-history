[{"client_msg_id":"f4b5b91c-aca4-4f16-a8f2-e54ef6bfcdc3","type":"message","text":"Should `eachcol` propagate `@inbounds`? It's defined <https://github.com/JuliaLang/julia/blob/master/base/abstractarraymath.jl#L452|here> in terms of `view`, but a loop over columns cannot be annotated with `@inbounds` to remove the bounds checking done inside `view`:\n```eachcol(A::AbstractVecOrMat) = (view(A, :, i) for i in axes(A, 2))```\n","user":"U68M6ERG8","ts":"1611092659.356600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SkFT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Should "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":" propagate "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":"? It's defined "},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/master/base/abstractarraymath.jl#L452","text":"here"},{"type":"text","text":" in terms of "},{"type":"text","text":"view","style":{"code":true}},{"type":"text","text":", but a loop over columns cannot be annotated with "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" to remove the bounds checking done inside "},{"type":"text","text":"view","style":{"code":true}},{"type":"text","text":":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"eachcol(A::AbstractVecOrMat) = (view(A, :, i) for i in axes(A, 2))"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1611092659.356600","reply_count":50,"reply_users_count":3,"latest_reply":"1611181088.480700","reply_users":["U0179G7FG4F","U68M6ERG8","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"dcb659e3-e166-4317-9457-84a5c65eda91","type":"message","text":"presumably the correct definition should be `eachcol(A::AbstractVecOrMat) = (@inbounds view(A, :, i) for i in axes(A, 2))` right?","user":"U0179G7FG4F","ts":"1611093109.357200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PGCa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"presumably the correct definition should be "},{"type":"text","text":"eachcol(A::AbstractVecOrMat) = (@inbounds view(A, :, i) for i in axes(A, 2))","style":{"code":true}},{"type":"text","text":" right?"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"b5f3c744-7988-4b0f-92c2-4a2808bb4f0f","type":"message","text":"I'm not sure. Is it correct to use `@inbounds` on arbitrary user-defined array types?","user":"U68M6ERG8","ts":"1611093176.357600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CSE=U","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not sure. Is it correct to use "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" on arbitrary user-defined array types?"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"c13fecea-fbbd-43bd-ad42-4e25eaf63f40","type":"message","text":"There could be a bug in their definition of `axes` which the `@inbounds` would turn into silent wrong behavior instead of an error","user":"U68M6ERG8","ts":"1611093219.358000","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611093229.000000"},"blocks":[{"type":"rich_text","block_id":"oyYTg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There could be a bug in their definition of "},{"type":"text","text":"axes","style":{"code":true}},{"type":"text","text":" which the "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" would turn into silent wrong behavior instead of an error"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"b72c7621-3c5c-4e27-9b53-b537296c5706","type":"message","text":"I think this is probably OK. I'm pretty sure we can assume `axes` and `getindex` are correct (that is basically the definition of an AbstractArray)","user":"U0179G7FG4F","ts":"1611093280.358300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I5d","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this is probably OK. I'm pretty sure we can assume "},{"type":"text","text":"axes","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" are correct (that is basically the definition of an AbstractArray)"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"6e2e8db6-96ab-47a9-b272-02af0ba2aa5e","type":"message","text":"The Julia manual says \"Only use `@inbounds` when it is certain from the information locally available that all accesses are in bounds.\": <https://docs.julialang.org/en/v1/base/base/#Base.@inbounds>","user":"U68M6ERG8","ts":"1611093330.358500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5vRP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The Julia manual says \"Only use "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" when it is certain from the information locally available that all accesses are in bounds.\": "},{"type":"link","url":"https://docs.julialang.org/en/v1/base/base/#Base.@inbounds"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"9add275e-9b4d-420b-9c94-36481e16b098","type":"message","text":"I don't think that's the case for a generic function that accepts any user-defined array since those arrays will call user-defined `axes` and `getindex` functions","user":"U68M6ERG8","ts":"1611093353.358700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L2k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think that's the case for a generic function that accepts any user-defined array since those arrays will call user-defined "},{"type":"text","text":"axes","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" functions"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"2766dd8d-1632-403f-be9f-6d6bae46e780","type":"message","text":"I've personally written buggy `getindex` functions for my own custom types before","user":"U68M6ERG8","ts":"1611093367.358900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"90fL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've personally written buggy "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" functions for my own custom types before"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"bdd87808-5a5d-4d13-8886-df0a163e2957","type":"message","text":"And was glad to get an error instead of silent corruption","user":"U68M6ERG8","ts":"1611093377.359100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t0yhe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And was glad to get an error instead of silent corruption"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"33de5d82-8ab0-4bde-bfac-6b21c228c4d6","type":"message","text":"If `eachcol` uses `@propagate_inbounds` then the user can opt into the elision of bounds checks at the call site if they're confident in their own code, so I don't think we lose anything by making this correct by default","user":"U68M6ERG8","ts":"1611093437.359300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MZ=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":" uses "},{"type":"text","text":"@propagate_inbounds","style":{"code":true}},{"type":"text","text":" then the user can opt into the elision of bounds checks at the call site if they're confident in their own code, so I don't think we lose anything by making this correct by default"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"636cce2e-4f37-41e4-b90b-30f05f3d7fff","type":"message","text":"I see what you're saying and mostly agree with you. I mostly just wish I didn't.","user":"U0179G7FG4F","ts":"1611093438.359500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RnkI3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see what you're saying and mostly agree with you. I mostly just wish I didn't."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"a0bb4279-c069-4580-ba23-f3f4249b30df","type":"message","text":"It would be really nice if we could assume correct definitions here. It's often probably a 2x speedup","user":"U0179G7FG4F","ts":"1611093483.359700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IlyIY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It would be really nice if we could assume correct definitions here. It's often probably a 2x speedup"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"1af081a3-a392-4366-8029-088482c9d219","type":"message","text":"What is the performance advantage of `@inbounds` over `@propagate_inbounds`?","user":"U68M6ERG8","ts":"1611093609.359900","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611093618.000000"},"blocks":[{"type":"rich_text","block_id":"/H0y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What is the performance advantage of "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" over "},{"type":"text","text":"@propagate_inbounds","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"84e6faff-6e67-484b-b10c-d92abc473367","type":"message","text":"the only difference is it wouldn't require someone at top level specifying `@inbounds` for something that will be correct as long as the `Array` isn't bugged","user":"U0179G7FG4F","ts":"1611093707.360400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FXASe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the only difference is it wouldn't require someone at top level specifying "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" for something that will be correct as long as the "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":" isn't bugged"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"f67e2e2d-90c9-42b5-bc8f-cf62d52e35de","type":"message","text":"I think there could be a specialization for `Array` that uses `@inbounds`","user":"U68M6ERG8","ts":"1611093753.360800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wsCzL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think there could be a specialization for "},{"type":"text","text":"Array","style":{"code":true}},{"type":"text","text":" that uses "},{"type":"text","text":"@inbounds","style":{"code":true}}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"2fbc82ae-5802-4a3a-a61d-adca315d0bec","type":"message","text":"Doesn’t boundscheck compare with axes anyway?","user":"UD0NS8PDF","ts":"1611093874.361100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eM3x","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Doesn’t boundscheck compare with axes anyway?"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"24f0a093-31f8-40d9-be28-253f3bb8ed07","type":"message","text":"It ends up somewhere like `Base.checkbounds_indices(Bool, axes(rand(3,3)), (3,3))`, so if you’ve defined axes wrong, then I think the check performed in each view won’t help you.","user":"UD0NS8PDF","ts":"1611094092.361300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"irUH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It ends up somewhere like "},{"type":"text","text":"Base.checkbounds_indices(Bool, axes(rand(3,3)), (3,3))","style":{"code":true}},{"type":"text","text":", so if you’ve defined axes wrong, then I think the check performed in each view won’t help you."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8","reactions":[{"name":"+1","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"7967c678-87dd-4f84-a724-40d85df4879a","type":"message","text":"Interesting! So axes need to be correct. That still leaves a potentially buggy `getindex` if the `@inbounds` annotation was applied to arbitrary types, right?","user":"U68M6ERG8","ts":"1611095017.361900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=V2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Interesting! So axes need to be correct. That still leaves a potentially buggy "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" if the "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" annotation was applied to arbitrary types, right?"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"ae16aa15-a458-46b5-a430-5aad1fa54368","type":"message","text":"Yes, your getindex could always be written to read the wrong thing. But you won’t get a warning about that now, here or anywhere","user":"UD0NS8PDF","ts":"1611096166.362300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ITKa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, your getindex could always be written to read the wrong thing. But you won’t get a warning about that now, here or anywhere"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"b9c2416d-a0e5-4d11-8086-31dca7c81163","type":"message","text":"You do get an error:\n```julia&gt; struct WrongArray\n               arr\n       end\n\njulia&gt; Base.getindex(x::WrongArray, i) = getindex(x.arr, i + 1)\n\njulia&gt; Base.axes(x::WrongArray) = axes(x.arr)\n\njulia&gt; wa = WrongArray([1, 2, 3])\nWrongArray([1, 2, 3])\n\njulia&gt; wa[1]\n2\n\njulia&gt; wa[3]\nERROR: BoundsError: attempt to access 3-element Array{Int64,1} at index [4]\nStacktrace:\n [1] getindex(::Array{Int64,1}, ::Int64) at ./array.jl:809\n [2] getindex(::WrongArray, ::Int64) at ./REPL[2]:1\n [3] top-level scope at REPL[6]:1```","user":"U68M6ERG8","ts":"1611096513.363700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ppd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You do get an error:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> struct WrongArray\n               arr\n       end\n\njulia> Base.getindex(x::WrongArray, i) = getindex(x.arr, i + 1)\n\njulia> Base.axes(x::WrongArray) = axes(x.arr)\n\njulia> wa = WrongArray([1, 2, 3])\nWrongArray([1, 2, 3])\n\njulia> wa[1]\n2\n\njulia> wa[3]\nERROR: BoundsError: attempt to access 3-element Array{Int64,1} at index [4]\nStacktrace:\n [1] getindex(::Array{Int64,1}, ::Int64) at ./array.jl:809\n [2] getindex(::WrongArray, ::Int64) at ./REPL[2]:1\n [3] top-level scope at REPL[6]:1"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"faead767-012a-4846-aff8-d1178d142443","type":"message","text":"In this case the error also occurs with `@inbounds` on the indexing line since `getindex(::WrongArray, i)` does not propagate inbounds, but in general you should get errors for wrong definitions wherever possible, I think. The worst possible problems are those that occur silently, and an `@inbounds` that is applied incorrectly causes those sorts of errors","user":"U68M6ERG8","ts":"1611096702.363900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7g7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In this case the error also occurs with "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" on the indexing line since "},{"type":"text","text":"getindex(::WrongArray, i)","style":{"code":true}},{"type":"text","text":" does not propagate inbounds, but in general you should get errors for wrong definitions wherever possible, I think. The worst possible problems are those that occur silently, and an "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" that is applied incorrectly causes those sorts of errors"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"d6d10b88-e893-4fc6-94a6-810d988eb23e","type":"message","text":"These issues do occur in practice. Here is one example I ran up against two weeks ago where an incorrect answer is silently returned due to incorrect use of `@inbounds`: <https://github.com/JuliaStats/Distributions.jl/issues/1253>","user":"U68M6ERG8","ts":"1611096745.364400","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611096825.000000"},"blocks":[{"type":"rich_text","block_id":"s7+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"These issues do occur in practice. Here is one example I ran up against two weeks ago where an incorrect answer is silently returned due to incorrect use of "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":": "},{"type":"link","url":"https://github.com/JuliaStats/Distributions.jl/issues/1253"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"966e4ed7-a2ad-4a9b-ba9d-d8558dd54f5c","type":"message","text":"The warning in the manual to \"only use `@inbounds` when it is certain from the information locally available that all accesses are in bounds.\" seems reasonable to me. As far as I understand, the case of `eachcol` does not fit that criterion since the user might pass in an array where `getindex` is not correctly defined, causing `eachcol`  to successfully return with a wrong result or crash the process instead of throwing an error.","user":"U68M6ERG8","ts":"1611097024.366300","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611097152.000000"},"blocks":[{"type":"rich_text","block_id":"nEr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The warning in the manual to \"only use "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" when it is certain from the information locally available that all accesses are in bounds.\" seems reasonable to me. As far as I understand, the case of "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":" does not fit that criterion since the user might pass in an array where "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" is not correctly defined, causing "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":"  to successfully return with a wrong result or crash the process instead of throwing an error."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"37f58965-2fb9-4952-999f-f1021f6f129a","type":"message","text":"No, I don’t follow. As far as I can see, the bounds check doesn’t check anything. It checks that `i in axes(A,2)` which is precisely what is already guaranteed by `eachcol`. That’s what the manual means by “it is certain from the information locally available that all accesses are in bounds”.","user":"UD0NS8PDF","ts":"1611135837.403400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X9W3b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, I don’t follow. As far as I can see, the bounds check doesn’t check anything. It checks that "},{"type":"text","text":"i in axes(A,2)","style":{"code":true}},{"type":"text","text":" which is precisely what is already guaranteed by "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":". That’s what the manual means by “it is certain from the information locally available that all accesses are in bounds”."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"237b1202-c565-452c-8afa-6ba49c5f49b7","type":"message","text":"This would be like the issue linked if we had `eachcol1(A::AbstractVecOrMat) = @inbounds (view(A, :, i) for i in 1:size(A, 2))`. There, the bounds check in `view` checks something different to the definition of `i`, and would catch offsets. Although checking once, up front, like `LinearAlgebra.require_one_based_indexing(A)`, would be better than checking within the loop.","user":"UD0NS8PDF","ts":"1611136224.403600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kXLTi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This would be like the issue linked if we had "},{"type":"text","text":"eachcol1(A::AbstractVecOrMat) = @inbounds (view(A, :, i) for i in 1:size(A, 2))","style":{"code":true}},{"type":"text","text":". There, the bounds check in "},{"type":"text","text":"view","style":{"code":true}},{"type":"text","text":" checks something different to the definition of "},{"type":"text","text":"i","style":{"code":true}},{"type":"text","text":", and would catch offsets. Although checking once, up front, like "},{"type":"text","text":"LinearAlgebra.require_one_based_indexing(A)","style":{"code":true}},{"type":"text","text":", would be better than checking within the loop."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"77a988df-3047-4803-8236-dc99df3746aa","type":"message","text":"The case I was imagining was an incorrectly implemented wrapper array with an error in its `getindex` method, like the `WrongArray` earlier in this thread. Indexing such an array with an index from its axes would throw an error as the index would not be a valid index for its underlying storage since it would be out of bounds. If the `WrongArray` had `@propagate_inbounds` then the bounds check would be removed by the presence of an `@inbounds` annotation inside `eachcol`.","user":"U68M6ERG8","ts":"1611156420.420700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aa4m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The case I was imagining was an incorrectly implemented wrapper array with an error in its "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" method, like the "},{"type":"text","text":"WrongArray","style":{"code":true}},{"type":"text","text":" earlier in this thread. Indexing such an array with an index from its axes would throw an error as the index would not be a valid index for its underlying storage since it would be out of bounds. If the "},{"type":"text","text":"WrongArray","style":{"code":true}},{"type":"text","text":" had "},{"type":"text","text":"@propagate_inbounds","style":{"code":true}},{"type":"text","text":" then the bounds check would be removed by the presence of an "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" annotation inside "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"debca827-7ec1-4bc5-a16d-1e50c6158337","type":"message","text":"After doing some more research I found some comments on Julia issues indicating that there was some consensus around an implicit assumption that for any `getindex` implementation that uses `@boundscheck` or `@propagate_inbounds`, `axes` and `getindex` simply have to be implemented correctly, and otherwise you might get undefined behavior and this is fine.\n\nI'm not so sure about that being fine, but I think this is essentially the argument you and Oscar are making.\n\nMy current perspective is that Julia code should be safe by default, and that a user should never silently get undefined behavior or crashes without explicitly opting into it themselves. A user implementing an array type might make an error in doing so, and that error should be caught, rather than potentially result in silently incorrect behavior or a crash, unless they themselves specifically opt into the unsafe behavior by using `@inbounds`.\n\nIn the case of `eachcol`, there is not enough local information to identify the specific array type for which `getindex` will be invoked; any code might be run. So you are now applying `@inbounds` to arbitrary user-defined code.","user":"U68M6ERG8","ts":"1611156781.420900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ULXc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"After doing some more research I found some comments on Julia issues indicating that there was some consensus around an implicit assumption that for any "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" implementation that uses "},{"type":"text","text":"@boundscheck","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"@propagate_inbounds","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"axes","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" simply have to be implemented correctly, and otherwise you might get undefined behavior and this is fine.\n\nI'm not so sure about that being fine, but I think this is essentially the argument you and Oscar are making.\n\nMy current perspective is that Julia code should be safe by default, and that a user should never silently get undefined behavior or crashes without explicitly opting into it themselves. A user implementing an array type might make an error in doing so, and that error should be caught, rather than potentially result in silently incorrect behavior or a crash, unless they themselves specifically opt into the unsafe behavior by using "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":".\n\nIn the case of "},{"type":"text","text":"eachcol","style":{"code":true}},{"type":"text","text":", there is not enough local information to identify the specific array type for which "},{"type":"text","text":"getindex","style":{"code":true}},{"type":"text","text":" will be invoked; any code might be run. So you are now applying "},{"type":"text","text":"@inbounds","style":{"code":true}},{"type":"text","text":" to arbitrary user-defined code."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"95c7ab32-21bc-4288-b1b8-5baf85c77b40","type":"message","text":"In the strictest sense, even knowing type info isn't enough because there could always be type pirated method definitions for `getindex`","user":"U0179G7FG4F","ts":"1611157012.421100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oaxrm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In the strictest sense, even knowing type info isn't enough because there could always be type pirated method definitions for "},{"type":"text","text":"getindex","style":{"code":true}}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"ad9b1c4d-7b12-44a5-a7d1-c8df62be5b87","type":"message","text":"Yes, that's true. Julia is sufficiently flexible that you can do almost anything regardless of whether it's a good idea or not. Type piracy can be useful during development or as a short-term workaround for an immediate problem but is dangerous when used at scale for this and other reasons","user":"U68M6ERG8","ts":"1611157329.421300","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611158048.000000"},"blocks":[{"type":"rich_text","block_id":"X6OCD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, that's true. Julia is sufficiently flexible that you can do almost anything regardless of whether it's a good idea or not. Type piracy can be useful during development or as a short-term workaround for an immediate problem but is dangerous when used at scale for this and other reasons"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"ea4e67e2-33df-4d00-bc7b-73bd7376e476","type":"message","text":"Do you have any examples where removing this bounds check matters for speed? Here’s a 0.1% speedup…\n```julia&gt; myeachcol(A::AbstractVecOrMat) = @inbounds (view(A, :, i) for i in axes(A, 2));\n\njulia&gt; @btime sum(sum(x) for x in eachcol(y))  setup=(y=rand(2,10^4));\n  28.340 μs (5 allocations: 112 bytes)\n\njulia&gt; @btime sum(sum(x) for x in myeachcol(y))  setup=(y=rand(2,10^4));\n  28.294 μs (5 allocations: 112 bytes)\n\njulia&gt; 28.340 / 28.294\n1.0016257863858062```","user":"UD0NS8PDF","ts":"1611169500.446400","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1611169749.000000"},"blocks":[{"type":"rich_text","block_id":"TCB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Do you have any examples where removing this bounds check matters for speed? Here’s a 0.1% speedup…\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> myeachcol(A::AbstractVecOrMat) = @inbounds (view(A, :, i) for i in axes(A, 2));\n\njulia> @btime sum(sum(x) for x in eachcol(y))  setup=(y=rand(2,10^4));\n  28.340 μs (5 allocations: 112 bytes)\n\njulia> @btime sum(sum(x) for x in myeachcol(y))  setup=(y=rand(2,10^4));\n  28.294 μs (5 allocations: 112 bytes)\n\njulia> 28.340 / 28.294\n1.0016257863858062"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"d0da01bd-6c3b-40d1-b425-fd3001144ae1","type":"message","text":"The case I came across this was writing code to compute a 2d histogram","user":"U68M6ERG8","ts":"1611169827.446900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hV5s=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The case I came across this was writing code to compute a 2d histogram"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"34658b6c-5b31-401e-9f2d-db20a219c58c","type":"message","text":"The eachcol version:\n```function density_v11(data, sz, ranges)\n\tbins = zeros(Float32, sz)\n\try, rx = ranges\n\tybin = bin_index_v11(ry, sz[1])\n\txbin = bin_index_v11(rx, sz[2])\n\tfor (y, x) in eachcol(data)\n\t\tif ry[1] ≤ y ≤ ry[2] &amp;&amp; rx[1] ≤ x ≤ rx[2]\n\t\t\t# we know that x and y are in bounds and that bins\n\t\t\t# is an array with standard linear indexing, so it\n\t\t\t# is safe to eliminate the bounds check.\n\t\t\t@inbounds bins[ybin(y), xbin(x)] += 1\n\t\tend\n\tend\n\tbins\nend\n\nfunction bin_index_v11((a, b), nbins)\n\tif a == b\n\t\t# handle equal endpoints\n\t\tb += one(b)\n\tend\n\t\n\t# rescale data from (0, b - a) to (0, nbins - eps)\n\tscale = prevfloat(float(nbins)) / (b - a)\n\t\n\t# rescale, add 1, and truncate to an integer bin index.\n\t# we only call bin_index on values in the range, so it\n\t# is safe to use unsafe_trunc.\n\td -&gt; unsafe_trunc(Int, muladd(d - a, scale, 1))\nend```\n","user":"U68M6ERG8","ts":"1611169841.447100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1Rc8g","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The eachcol version:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function density_v11(data, sz, ranges)\n\tbins = zeros(Float32, sz)\n\try, rx = ranges\n\tybin = bin_index_v11(ry, sz[1])\n\txbin = bin_index_v11(rx, sz[2])\n\tfor (y, x) in eachcol(data)\n\t\tif ry[1] ≤ y ≤ ry[2] && rx[1] ≤ x ≤ rx[2]\n\t\t\t# we know that x and y are in bounds and that bins\n\t\t\t# is an array with standard linear indexing, so it\n\t\t\t# is safe to eliminate the bounds check.\n\t\t\t@inbounds bins[ybin(y), xbin(x)] += 1\n\t\tend\n\tend\n\tbins\nend\n\nfunction bin_index_v11((a, b), nbins)\n\tif a == b\n\t\t# handle equal endpoints\n\t\tb += one(b)\n\tend\n\t\n\t# rescale data from (0, b - a) to (0, nbins - eps)\n\tscale = prevfloat(float(nbins)) / (b - a)\n\t\n\t# rescale, add 1, and truncate to an integer bin index.\n\t# we only call bin_index on values in the range, so it\n\t# is safe to use unsafe_trunc.\n\td -> unsafe_trunc(Int, muladd(d - a, scale, 1))\nend"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"440be9be-5f45-4459-a122-1d4e5f76db6d","type":"message","text":"The faster version without eachcol:\n```function density(data::Matrix, sz, ranges)\n\tbins = zeros(Float32, sz)\n\try, rx = ranges\n\tybin = bin_index(ry, sz[1])\n\txbin = bin_index(rx, sz[2])\n\tiy, ix = axes(data, 1)\n\tfor i in axes(data, 2)\n\t\t@inbounds y, x = data[iy, i], data[ix, i]\n\t\tif ry[1] ≤ y ≤ ry[2] &amp;&amp; rx[1] ≤ x ≤ rx[2]\n\t\t\t@inbounds bins[ybin(y), xbin(x)] += 1\n\t\tend\n\tend\n\tbins\nend\n\nfunction bin_index((a, b), nbins)\n\tif a == b\n\t\t# handle equal endpoints\n\t\tb += one(b)\n\tend\n\t\n\t# rescale data from (0, b - a) to (0, nbins - eps)\n\tscale = prevfloat(float(nbins)) / (b - a)\n\t\n\t# rescale, add 1, and truncate to an integer bin index.\n\t# we only call bin_index on values in the range, so it\n\t# is safe to use unsafe_trunc.\n\td -&gt; unsafe_trunc(Int, muladd(d - a, scale, 1))\nend```","user":"U68M6ERG8","ts":"1611169858.447300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"suvx2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The faster version without eachcol:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function density(data::Matrix, sz, ranges)\n\tbins = zeros(Float32, sz)\n\try, rx = ranges\n\tybin = bin_index(ry, sz[1])\n\txbin = bin_index(rx, sz[2])\n\tiy, ix = axes(data, 1)\n\tfor i in axes(data, 2)\n\t\t@inbounds y, x = data[iy, i], data[ix, i]\n\t\tif ry[1] ≤ y ≤ ry[2] && rx[1] ≤ x ≤ rx[2]\n\t\t\t@inbounds bins[ybin(y), xbin(x)] += 1\n\t\tend\n\tend\n\tbins\nend\n\nfunction bin_index((a, b), nbins)\n\tif a == b\n\t\t# handle equal endpoints\n\t\tb += one(b)\n\tend\n\t\n\t# rescale data from (0, b - a) to (0, nbins - eps)\n\tscale = prevfloat(float(nbins)) / (b - a)\n\t\n\t# rescale, add 1, and truncate to an integer bin index.\n\t# we only call bin_index on values in the range, so it\n\t# is safe to use unsafe_trunc.\n\td -> unsafe_trunc(Int, muladd(d - a, scale, 1))\nend"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"5f701233-54a9-481d-8c7f-8bbf54b820e6","type":"message","text":"Called with e.g. `data = randn(2, 10_000_000);`","user":"U68M6ERG8","ts":"1611169867.447500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZWwY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Called with e.g. "},{"type":"text","text":"data = randn(2, 10_000_000);","style":{"code":true}}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"61dae4f6-fe97-44d9-8de8-fff3cfdb7378","type":"message","text":"`@time density(data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)))`","user":"U68M6ERG8","ts":"1611169872.447700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vJUeA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"@time density(data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)))","style":{"code":true}}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"7be8157e-63f5-4927-883a-d06d1504745e","type":"message","text":"meaning, compute the density histogram of data into an array with 400 x and y bins, for values in the range (-2.5, 2.5) in each axis","user":"U68M6ERG8","ts":"1611169896.448100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XlD0J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"meaning, compute the density histogram of data into an array with 400 x and y bins, for values in the range (-2.5, 2.5) in each axis"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"c5f6cbee-544c-459a-87d2-6b891d67a06f","type":"message","text":"I see, but here `density` doesn’t make views at all? Times for me:\n```julia&gt; @btime density($data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)));\n  41.267 ms (2 allocations: 625.08 KiB)\n\njulia&gt; @btime density_v11($data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)));\n  44.165 ms (2 allocations: 625.08 KiB)\n\njulia&gt; @btime mydensity_v11($data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)));  # variant with myeachcol\n  44.373 ms (2 allocations: 625.08 KiB)```","user":"UD0NS8PDF","ts":"1611170211.448300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2GB7S","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see, but here "},{"type":"text","text":"density","style":{"code":true}},{"type":"text","text":" doesn’t make views at all? Times for me:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime density($data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)));\n  41.267 ms (2 allocations: 625.08 KiB)\n\njulia> @btime density_v11($data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)));\n  44.165 ms (2 allocations: 625.08 KiB)\n\njulia> @btime mydensity_v11($data, (400, 400), ((-2.5, 2.5), (-2.5, 2.5)));  # variant with myeachcol\n  44.373 ms (2 allocations: 625.08 KiB)"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"56de8b9f-5e80-405f-b5e2-ba69acbf28bd","type":"message","text":"I believe that your `myeachcol` definition is not correct. I see a speedup when it is defined like this:\n```myeachcol(A::AbstractVecOrMat) = ((@inbounds view(A, :, i)) for i in axes(A, 2));```","user":"U68M6ERG8","ts":"1611178971.476500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yoDrH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I believe that your "},{"type":"text","text":"myeachcol","style":{"code":true}},{"type":"text","text":" definition is not correct. I see a speedup when it is defined like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"myeachcol(A::AbstractVecOrMat) = ((@inbounds view(A, :, i)) for i in axes(A, 2));"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"87baf2f2-bef9-42a8-89c9-746eed7ad1ac","type":"message","text":"That’s weird, with your defn. I get a slowdown:\n```julia&gt; @btime sum(sum(x) for x in eachcol(y))  setup=(y=rand(2,10^4));\n  28.231 μs (5 allocations: 112 bytes)\n\njulia&gt; @btime sum(sum(x) for x in myeachcol(y))  setup=(y=rand(2,10^4));\n  39.245 μs (5 allocations: 112 bytes)```","user":"UD0NS8PDF","ts":"1611179443.476700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"88Vdn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That’s weird, with your defn. I get a slowdown:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @btime sum(sum(x) for x in eachcol(y))  setup=(y=rand(2,10^4));\n  28.231 μs (5 allocations: 112 bytes)\n\njulia> @btime sum(sum(x) for x in myeachcol(y))  setup=(y=rand(2,10^4));\n  39.245 μs (5 allocations: 112 bytes)"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"c183ebb9-23eb-4ee3-b032-08d272711133","type":"message","text":"That does seem odd. Me too (on your example).","user":"U68M6ERG8","ts":"1611179852.476900","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611179898.000000"},"blocks":[{"type":"rich_text","block_id":"uSj/t","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That does seem odd. Me too (on your example)."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"d3508f5f-2034-4fae-a0e5-301461a2e457","type":"message","text":"The generated assembly from\n```g() = let y = rand(2, 10^4)\n       sum(sum(x) for x in eachcol(y))\n       end```\nand the same definition but with my `myeachcol` appears to be the same.","user":"U68M6ERG8","ts":"1611179868.477100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uxp3j","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The generated assembly from\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"g() = let y = rand(2, 10^4)\n       sum(sum(x) for x in eachcol(y))\n       end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"and the same definition but with my "},{"type":"text","text":"myeachcol","style":{"code":true}},{"type":"text","text":" appears to be the same."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"38497326-eaa6-4ea3-91b0-b5fa908f7ac3","type":"message","text":"So I wonder whether something is going wrong in the benchmark library? Or perhaps I'm missing something...","user":"U68M6ERG8","ts":"1611179881.477300","team":"T68168MUP","edited":{"user":"U68M6ERG8","ts":"1611179970.000000"},"blocks":[{"type":"rich_text","block_id":"/E/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So I wonder whether something is going wrong in the benchmark library? Or perhaps I'm missing something..."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"823acadb-29b4-45dc-9e78-d28e6eda302f","type":"message","text":"This is weird. I'll file an issue","user":"U68M6ERG8","ts":"1611180273.477700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O2IUF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This is weird. I'll file an issue"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"550acd04-9e9d-4a13-a4a2-06f7e2b4ff14","type":"message","text":"Benchmarking\n```test(eachcol) = let y = rand(2, 10^5)\n           sum(sum(x) for x in eachcol(y))\n       end```\nin both cases still shows the performance difference with identical generated code","user":"U68M6ERG8","ts":"1611180310.478400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QoH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Benchmarking\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"test(eachcol) = let y = rand(2, 10^5)\n           sum(sum(x) for x in eachcol(y))\n       end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"in both cases still shows the performance difference with identical generated code"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"880be953-8a59-4b35-be3c-49602689ca06","type":"message","text":"and I'm not sure how best to debug it further","user":"U68M6ERG8","ts":"1611180323.478800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i0J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and I'm not sure how best to debug it further"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"48ac8b41-3e1d-4d12-bfd1-fb29ce951fed","type":"message","text":"Oh that’s super-weird.","user":"UD0NS8PDF","ts":"1611180327.479100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sj1qp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh that’s super-weird."}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"bdbc862b-dd78-4138-bdd6-981c5845a7dd","type":"message","text":"Let me see what happens if I remove the allocation from the function","user":"U68M6ERG8","ts":"1611180338.479500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WEy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Let me see what happens if I remove the allocation from the function"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"8ae2e69a-a805-4888-a9b0-34228afca185","type":"message","text":"The performance difference is still there","user":"U68M6ERG8","ts":"1611180389.479700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gq8+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The performance difference is still there"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"eb0b69f0-d9e1-4cc3-83f4-ee5d5a5d6245","type":"message","text":"I did think there were some loops simple enough that the compiler could remove bounds checks for you. But I don’t know how that works. It could explain why `myeachcol` fails to produce a speedup, but not this difference you see, I think?","user":"UD0NS8PDF","ts":"1611180413.479900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rj+SL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I did think there were some loops simple enough that the compiler could remove bounds checks for you. But I don’t know how that works. It could explain why "},{"type":"text","text":"myeachcol","style":{"code":true}},{"type":"text","text":" fails to produce a speedup, but not this difference you see, I think?"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"type":"message","text":"","files":[{"id":"F01KHV53AJY","created":1611180554,"timestamp":1611180554,"name":"image.png","title":"image.png","mimetype":"image/png","filetype":"png","pretty_type":"PNG","user":"U68M6ERG8","editable":false,"size":408317,"mode":"hosted","is_external":false,"external_type":"","is_public":true,"public_url_shared":false,"display_as_bot":false,"username":"","url_private":"https://files.slack.com/files-pri/T68168MUP-F01KHV53AJY/image.png","url_private_download":"https://files.slack.com/files-pri/T68168MUP-F01KHV53AJY/download/image.png","thumb_64":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_64.png","thumb_80":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_80.png","thumb_360":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_360.png","thumb_360_w":360,"thumb_360_h":307,"thumb_480":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_480.png","thumb_480_w":480,"thumb_480_h":409,"thumb_160":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_160.png","thumb_720":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_720.png","thumb_720_w":720,"thumb_720_h":614,"thumb_800":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_800.png","thumb_800_w":800,"thumb_800_h":682,"thumb_960":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_960.png","thumb_960_w":960,"thumb_960_h":818,"thumb_1024":"https://files.slack.com/files-tmb/T68168MUP-F01KHV53AJY-7aa0503b31/image_1024.png","thumb_1024_w":1024,"thumb_1024_h":873,"original_w":2086,"original_h":1778,"thumb_tiny":"AwAoADDRYe9Awe5/OlPb60i0AKFA7n86aeD1/Wn01v6UAAAPc/nS4wO/50i9KcelADGAJ5GaABn7v6UpzSAntigB2B6U0gZ5FOGcc005zQAAD+7TsADpTQT2xTu1ACHt9aFwKU9aSgYuRSHn8qKKBMUYFGaKB1oEf//Z","permalink":"https://julialang.slack.com/files/U68M6ERG8/F01KHV53AJY/image.png","permalink_public":"https://slack-files.com/T68168MUP-F01KHV53AJY-fbcda16524","is_starred":false,"has_rich_preview":false}],"upload":false,"user":"U68M6ERG8","display_as_bot":false,"ts":"1611180557.480100","thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8"},{"client_msg_id":"6ef66d25-759c-4848-a8b9-1960bad69881","type":"message","text":"<https://github.com/JuliaLang/julia/issues/39340>","user":"U68M6ERG8","ts":"1611181088.480700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cfb","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/JuliaLang/julia/issues/39340"}]}]}],"thread_ts":"1611092659.356600","parent_user_id":"U68M6ERG8","reactions":[{"name":"+1","users":["UD0NS8PDF"],"count":1}]}]