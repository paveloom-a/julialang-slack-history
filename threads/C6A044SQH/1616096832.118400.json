[{"client_msg_id":"a5d95f20-c4e5-4817-84fe-18f6acc44f19","type":"message","text":"Hey guys, I'm trying to plot the rastrigin function(given below) through plots.jl. It takes in a vector input (a x coordinate and y coordinate) . According to a <https://discourse.julialang.org/t/plotting-a-3d-surface/17143|Discourse post>, all I could come up with is this :\n\n```using Plots; pyplot()\nx=range(-5.12,stop=5.12,length=100)\ny=range(-5.12,stop=5.12,length=100)\nf(x,y) = 20 + x^2 + y^2 -10*cos(2*π*x) - 10*cos(2*π*y)\nplot(x,y,f,st=:surface,camera=(-30,30)) ```\nAlthough this gives me the right plot, I'm having to hardcode it, which is a pain. Could anyone please help me by suggesting a way that doesn't involve hardcoding the function? (ie, a method where the rastrigin function takes in a vector and spits out a number to plot, instead of taking 2 separate variables as a input)\n```function rastrigin(x::Vector{T}) where {T &lt;: Real}\n    return 10 * size(x)[1] + sum(@. x^2 - 10 * cos(2*π*x))\nend```","user":"U017D621ELC","ts":"1616096832.118400","team":"T68168MUP","edited":{"user":"U017D621ELC","ts":"1616097085.000000"},"attachments":[{"service_name":"JuliaLang","title":"Plotting a 3D Surface","title_link":"https://discourse.julialang.org/t/plotting-a-3d-surface/17143","text":"How would I plot the surface f(x,y)=xy-y-x+1 between \\sqrt2\\leq y\\leq2 using PyPlot; x = collect(Float16, range(-2,length=100,stop=2)); y = collect(Float16, range(sqrt(2),length=100, stop=2)); z = (x.*y).-y.-x.+1; surf(x,y,z);","fallback":"JuliaLang: Plotting a 3D Surface","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/9/95b3da98ba6277dbc8cceb2385e6805aa6bd503c.png","fields":[{"title":"Reading time","value":"4 mins :clock2:","short":true},{"title":"Likes","value":"24 :heart:","short":true}],"ts":1541359416,"from_url":"https://discourse.julialang.org/t/plotting-a-3d-surface/17143","thumb_width":640,"thumb_height":480,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/plotting-a-3d-surface/17143"}],"blocks":[{"type":"rich_text","block_id":"kIv4k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hey guys, I'm trying to plot the rastrigin function(given below) through plots.jl. It takes in a vector input (a x coordinate and y coordinate) . According to a "},{"type":"link","url":"https://discourse.julialang.org/t/plotting-a-3d-surface/17143","text":"Discourse post"},{"type":"text","text":", all I could come up with is this :\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using Plots; pyplot()\nx=range(-5.12,stop=5.12,length=100)\ny=range(-5.12,stop=5.12,length=100)\nf(x,y) = 20 + x^2 + y^2 -10*cos(2*π*x) - 10*cos(2*π*y)\nplot(x,y,f,st=:surface,camera=(-30,30)) "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Although this gives me the right plot, I'm having to hardcode it, which is a pain. Could anyone please help me by suggesting a way that doesn't involve hardcoding the function? (ie, a method where the rastrigin function takes in a vector and spits out a number to plot, instead of taking 2 separate variables as a input)\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function rastrigin(x::Vector{T}) where {T <: Real}\n    return 10 * size(x)[1] + sum(@. x^2 - 10 * cos(2*π*x))\nend"}]}]}],"thread_ts":"1616096832.118400","reply_count":22,"reply_users_count":3,"latest_reply":"1616270992.283400","reply_users":["B01J9QZ4SP8","U67G3QRJM","U017D621ELC"],"is_locked":false,"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1616096834.118500","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"754af0d4-f9b5-4dc2-9cf2-e5a83371de9c","type":"message","text":"Once you have defined your `rastrigin` function taking a vector, define another method as","user":"U67G3QRJM","ts":"1616137108.147900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IB+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Once you have defined your "},{"type":"text","text":"rastrigin","style":{"code":true}},{"type":"text","text":" function taking a vector, define another method as"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"cc0bea95-0a85-4979-bf16-3f75cfde1b63","type":"message","text":"```rastrigin(x, y) = rastrigin([x, y])```","user":"U67G3QRJM","ts":"1616137125.148300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9Kc","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"rastrigin(x, y) = rastrigin([x, y])"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"+1","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"c9f7965a-f7e8-4beb-a0fb-e9453ffda1a3","type":"message","text":"<@U017D621ELC> ^","user":"U67G3QRJM","ts":"1616137132.148500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1Hb7","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U017D621ELC"},{"type":"text","text":" ^"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"4777d301-69e5-4f42-8b25-7a0b965f870c","type":"message","text":"Also you might like the `plotly()` backend, since it will allow you to rotate the 3D plot","user":"U67G3QRJM","ts":"1616137164.148900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mAPU+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also you might like the "},{"type":"text","text":"plotly()","style":{"code":true}},{"type":"text","text":" backend, since it will allow you to rotate the 3D plot"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"heart","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"cb1458a5-0383-4859-9420-9d9a6e1a854b","type":"message","text":"And you can just do `surface(x, y, f)`","user":"U67G3QRJM","ts":"1616137187.149200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6auC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"And you can just do "},{"type":"text","text":"surface(x, y, f)","style":{"code":true}}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"+1","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"6562152f-9dc9-47da-8dca-e6d12756029e","type":"message","text":"Thanks for the help <@U67G3QRJM>!","user":"U017D621ELC","ts":"1616146250.161800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"945","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the help "},{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":"!"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"d6a3e63b-39da-49c2-8d2a-88b2002ed69f","type":"message","text":"I tried it to code it up your way, and it works perfectly! I had one more question though, using a function call like `rastrigin(x, y) = rastrigin([x, y])`  leads to the compiler allocating `[x, y]` on the heap. Is there anyway according to you that bypasses this?\nIn the worst case, I could add StaticArrays to mitigate this, but I don't want to add a dependency just for this :sweat_smile:\nThanks again for the solution <@U67G3QRJM>","user":"U017D621ELC","ts":"1616152626.169200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Syw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I tried it to code it up your way, and it works perfectly! I had one more question though, using a function call like "},{"type":"text","text":"rastrigin(x, y) = rastrigin([x, y])","style":{"code":true}},{"type":"text","text":"  leads to the compiler allocating "},{"type":"text","text":"[x, y]","style":{"code":true}},{"type":"text","text":" on the heap. Is there anyway according to you that bypasses this?\nIn the worst case, I could add StaticArrays to mitigate this, but I don't want to add a dependency just for this "},{"type":"emoji","name":"sweat_smile"},{"type":"text","text":"\nThanks again for the solution "},{"type":"user","user_id":"U67G3QRJM"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"b9b56379-0707-44a3-bba1-6ab9cf357bda","type":"message","text":"As an example, please have a look at the code block below:\n```julia&gt; rastrigin(x, y) = rastrigin([x, y])\nrastrigin (generic function with 2 methods)\n\njulia&gt; using Plots, BenchmarkTools\n\njulia&gt; plotly();\n\njulia&gt; x = y =  range(-5.12, stop=5.12, length=100);\n\njulia&gt; f(x,y) = 20 + x^2 + y^2 -10*cos(2*π*x) - 10*cos(2*π*y) \nf (generic function with 1 method)\n\njulia&gt; @btime surface(x, y, f)\n  761.244 μs (2869 allocations: 355.27 KiB)\n\njulia&gt; @btime surface(x, y, rastrigin)\n  1.347 ms (22869 allocations: 2.18 MiB)```\nThere's almost a 2x difference while plotting, and a ton of memory use difference. Any help is very much appreciated","user":"U017D621ELC","ts":"1616154673.171600","team":"T68168MUP","edited":{"user":"U017D621ELC","ts":"1616154890.000000"},"blocks":[{"type":"rich_text","block_id":"8WA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As an example, please have a look at the code block below:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> rastrigin(x, y) = rastrigin([x, y])\nrastrigin (generic function with 2 methods)\n\njulia> using Plots, BenchmarkTools\n\njulia> plotly();\n\njulia> x = y =  range(-5.12, stop=5.12, length=100);\n\njulia> f(x,y) = 20 + x^2 + y^2 -10*cos(2*π*x) - 10*cos(2*π*y) \nf (generic function with 1 method)\n\njulia> @btime surface(x, y, f)\n  761.244 μs (2869 allocations: 355.27 KiB)\n\njulia> @btime surface(x, y, rastrigin)\n  1.347 ms (22869 allocations: 2.18 MiB)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"There's almost a 2x difference while plotting, and a ton of memory use difference. Any help is very much appreciated"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"af30e56a-7e04-4694-9374-649f06277b63","type":"message","text":"That's because you made your version of Rastrigin take a Vector. Try removing that type annotation and using a tuple instead","user":"U67G3QRJM","ts":"1616160674.189000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/Pur","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's because you made your version of Rastrigin take a Vector. Try removing that type annotation and using a tuple instead"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"a6f71ae3-7219-4d2e-bd7c-100fc14f309c","type":"message","text":"You can even write it as `rastrigin( (x, y)) =... `","user":"U67G3QRJM","ts":"1616160704.189200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MGs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can even write it as `rastrigin( (x, y)) =... `"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"ac83c67d-9427-4b27-9bf8-d408d7e85f05","type":"message","text":"<@U67G3QRJM> I'm actually writing the rastrigin function to test out an optimizer that I had implemented myself (The gradients are calculated through Zygote). If I were to implement the function as taking in a tuple, I would not be able to update my input variable through gradients :sweat_smile:. I also tried `rastrigin(x::Float64 y::Float64) = rastrigin(Float64[x, y])`, hoping that the compiler would be able to infer types, but to no avail. Do you have any other suggestions on where I could proceed from here?","user":"U017D621ELC","ts":"1616228257.264300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"mOC","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U67G3QRJM"},{"type":"text","text":" I'm actually writing the rastrigin function to test out an optimizer that I had implemented myself (The gradients are calculated through Zygote). If I were to implement the function as taking in a tuple, I would not be able to update my input variable through gradients "},{"type":"emoji","name":"sweat_smile"},{"type":"text","text":". I also tried "},{"type":"text","text":"rastrigin(x::Float64 y::Float64) = rastrigin(Float64[x, y])","style":{"code":true}},{"type":"text","text":", hoping that the compiler would be able to infer types, but to no avail. Do you have any other suggestions on where I could proceed from here?"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"180e1eed-665d-4e30-9d55-24f5e8390319","type":"message","text":"I don't think I understand what you mean by updating the input variable. I think what's happening is that creating arrays leads to allocations","user":"U67G3QRJM","ts":"1616251503.271200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uD+M","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't think I understand what you mean by updating the input variable. I think what's happening is that creating arrays leads to allocations"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"f9233255-f272-4bbf-b792-6185b792727c","type":"message","text":"You may want to look at SVectors from the StaticArrays package","user":"U67G3QRJM","ts":"1616251523.271400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/k8Vt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You may want to look at SVectors from the StaticArrays package"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"+1","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"046f6481-8e65-4ddf-88ea-5d893c43fdd9","type":"message","text":"By updating I meant doing something like\n```z  = rastrigin(x) #x is a vector here\ngrad_x = gradient(x -&gt; rastrigin(x), x)[1] #grab gradients using zygote\nx .-= learning_rate .* grad_x #this is for SGD, but can be implemented for any optimizer in general```\nWhat I meant to say was that if I were to implement the rastrigin with input as a tuple, I wouldn't be able to update my input variables like in the last step, even if it reduces allocations.\nSure, I'll take a look at SVectors !","user":"U017D621ELC","ts":"1616252087.272100","team":"T68168MUP","edited":{"user":"U017D621ELC","ts":"1616252242.000000"},"blocks":[{"type":"rich_text","block_id":"zIv4V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"By updating I meant doing something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"z  = rastrigin(x) #x is a vector here\ngrad_x = gradient(x -> rastrigin(x), x)[1] #grab gradients using zygote\nx .-= learning_rate .* grad_x #this is for SGD, but can be implemented for any optimizer in general"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"What I meant to say was that if I were to implement the rastrigin with input as a tuple, I wouldn't be able to update my input variables like in the last step, even if it reduces allocations.\nSure, I'll take a look at SVectors !"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"dfec00e2-6144-4bda-b153-c8dff7daa6f7","type":"message","text":"If you use SVectors you won’t update in place","user":"U67G3QRJM","ts":"1616259204.276000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8fLTg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If you use SVectors you won’t update in place"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"disappointed","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"8bf8044c-835d-4e7a-872a-ded64b44ee48","type":"message","text":"I guess I'd have to go with the first example that you illustrated. Thanks for the help!","user":"U017D621ELC","ts":"1616267937.281100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+kt=T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I guess I'd have to go with the first example that you illustrated. Thanks for the help!"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"da952df4-3b25-4e94-a835-8f932da15293","type":"message","text":"Why do you need to update in place? With SVectors it will be fast to do non-inplace updatign","user":"U67G3QRJM","ts":"1616268204.281600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=Ms","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why do you need to update in place? With SVectors it will be fast to do non-inplace updatign"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"5168424a-7eb8-4222-a6ce-c9ad5089e2db","type":"message","text":"with `x -= eta * gradient`","user":"U67G3QRJM","ts":"1616268226.281800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"x4m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"with "},{"type":"text","text":"x -= eta * gradient","style":{"code":true}}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"+1","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"df4f7356-d45d-445a-bbe1-032062341de8","type":"message","text":"(without the dot)","user":"U67G3QRJM","ts":"1616268228.282000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yt80/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(without the dot)"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"},{"client_msg_id":"5421255f-5a99-4e33-9e28-c0b69be4b8eb","type":"message","text":"if `x` is an `SVector` that will be fast","user":"U67G3QRJM","ts":"1616268239.282200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cOx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is an "},{"type":"text","text":"SVector","style":{"code":true}},{"type":"text","text":" that will be fast"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC","reactions":[{"name":"hushed","users":["U017D621ELC"],"count":1}]},{"client_msg_id":"761a971a-e933-4bef-81fb-26bc10d24248","type":"message","text":"I don't have any need to update in place, which I think makes `SVector` a good candidate. I'll be sure to try it out. Thanks!","user":"U017D621ELC","ts":"1616270992.283400","team":"T68168MUP","edited":{"user":"U017D621ELC","ts":"1616271009.000000"},"blocks":[{"type":"rich_text","block_id":"d25p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't have any need to update in place, which I think makes `SVector` a good candidate. I'll be sure to try it out. Thanks!"}]}]}],"thread_ts":"1616096832.118400","parent_user_id":"U017D621ELC"}]