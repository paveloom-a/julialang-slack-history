[{"client_msg_id":"54244d19-61f5-4380-a3a4-2106fc92daf2","type":"message","text":"I know I can attach a finalizer to a mutable object. But how would the mutable object behave like an array in Julia, yet not allow to copy a member array in a way that would copy my `existingArray` pointer in an immutable object?","user":"U01ST17EY9L","ts":"1617981498.394200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VKXe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I know I can attach a finalizer to a mutable object. But how would the mutable object behave like an array in Julia, yet not allow to copy a member array in a way that would copy my "},{"type":"text","text":"existingArray","style":{"code":true}},{"type":"text","text":" pointer in an immutable object?"}]}]}],"thread_ts":"1617981498.394200","reply_count":27,"reply_users_count":2,"latest_reply":"1618074113.479200","reply_users":["UM30MT6RF","U01ST17EY9L"],"is_locked":false,"subscribed":false},{"client_msg_id":"a73cc3f3-265d-4bf2-8bdc-330774ccc6d6","type":"message","text":"Not sure what you mean by this. Why shouldn't `finalizer` work here?","user":"UM30MT6RF","ts":"1617981703.394300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uPs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not sure what you mean by this. Why shouldn't "},{"type":"text","text":"finalizer","style":{"code":true}},{"type":"text","text":" work here?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"f6f713a5-1791-4316-97d4-ad9b37a31071","type":"message","text":"If I want to put my pointer inside a mutable, doesn't that mean that my pointer (wrapped in a Julia array) is going to be a field and that a routine could copy that field to some other variable, creating a reference to that memory that I will not be aware of?","user":"U01ST17EY9L","ts":"1618001812.427400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rcI+F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I want to put my pointer inside a mutable, doesn't that mean that my pointer (wrapped in a Julia array) is going to be a field and that a routine could copy that field to some other variable, creating a reference to that memory that I will not be aware of?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"f204bbc5-29d6-4a69-aa56-312180064e88","type":"message","text":"Thus the finalizer could be called while that copy still exist. No?","user":"U01ST17EY9L","ts":"1618001912.427600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zS=4n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thus the finalizer could be called while that copy still exist. No?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"029502e4-afbc-4582-b011-666539c3e26b","type":"message","text":"Yeah, Julia won't know anything about pointers. If you add a finalizer to the array, that finalizer will be called once there are no references to the tracked Julia array anymore. The raw pointer won't be tracked at all though. If you put just the raw pointer into a mutable struct, you probably want to add a finalizer to that mutable struct instead.","user":"UM30MT6RF","ts":"1618005924.431600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ghs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, Julia won't know anything about pointers. If you add a finalizer to the array, that finalizer will be called once there are no references to the tracked Julia array anymore. The raw pointer won't be tracked at all though. If you put just the raw pointer into a mutable struct, you probably want to add a finalizer to that mutable struct instead."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"4e792fae-685d-4d99-9dc9-3f42f8bb964f","type":"message","text":"That's what it seems to be like. I wish there was a way to attach a finalizer to a Julia Array{Float64} where the array refers to memory allocated on the C side.","user":"U01ST17EY9L","ts":"1618068957.457100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2iNSn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's what it seems to be like. I wish there was a way to attach a finalizer to a Julia Array{Float64} where the array refers to memory allocated on the C side."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"7ea2a4b0-77bf-40d4-a5db-ff22ac95cf12","type":"message","text":"I don't really follow you. If you want Julia's GC to manage the arrays, you can pass the option to let Julia take ownership of the memory and free it once the GC can prove there are no references to the Julia array anymore. You can't use that pointer from C afterwards of course, since Julia is free to free that memory. OTOH, you can wrap the pointer as a Julia array without taking ownership, then you have to manage the memory yourself, but you also have full control over when exactly the memory is freed. You can still add a finalizer from Julia's side, which will be called once the Julia array is not referenced anymore, but the memory won't be freed automatically. Since Julia already supports both these usecases, I don't understand what you are missing currently.","user":"UM30MT6RF","ts":"1618069987.457900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BwC/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't really follow you. If you want Julia's GC to manage the arrays, you can pass the option to let Julia take ownership of the memory and free it once the GC can prove there are no references to the Julia array anymore. You can't use that pointer from C afterwards of course, since Julia is free to free that memory. OTOH, you can wrap the pointer as a Julia array without taking ownership, then you have to manage the memory yourself, but you also have full control over when exactly the memory is freed. You can still add a finalizer from Julia's side, which will be called once the Julia array is not referenced anymore, but the memory won't be freed automatically. Since Julia already supports both these usecases, I don't understand what you are missing currently."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"3bb8113f-cbef-4cd1-9d91-97a0837a1622","type":"message","text":"I do want to do what you describe as wrapping a C++ pointer for Julia. But to put a finalizer, you have to make an object mutable, right? That mutable will be a `mutable struct` with a Array{Float64} right?\nSomething like:\n```mutable Wrapped\n    v::Array{Float64,1}\nend;```\nSo far so good. But now assume I have this routine:\n```function g(w::Wrapped)\n    global z = w.v;\nend```","user":"U01ST17EY9L","ts":"1618072082.463800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z1e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do want to do what you describe as wrapping a C++ pointer for Julia. But to put a finalizer, you have to make an object mutable, right? That mutable will be a "},{"type":"text","text":"mutable struct","style":{"code":true}},{"type":"text","text":" with a Array{Float64} right?\nSomething like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable Wrapped\n    v::Array{Float64,1}\nend;"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So far so good. But now assume I have this routine:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function g(w::Wrapped)\n    global z = w.v;\nend"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"dcb0ffe3-79a8-4252-bc66-9e2920e3ecd2","type":"message","text":"Now z has a reference to my wrapped array but I have no way of knowing when that reference will disappear.","user":"U01ST17EY9L","ts":"1618072114.464500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OLx4F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Now z has a reference to my wrapped array but I have no way of knowing when that reference will disappear."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"81fc2e9a-b977-469b-b2ca-825f7f071263","type":"message","text":"My pointer inside my wrapped array is a pointer from owned in a C++ object. On the C++ side, shared_ptr with reference count handles the memory management. If I attach a finalizer to `Wrapped`, it will simply clear a _hidden_ shared_ptr in the `Wrapped` structure. Thus the pointer will not be freed until both the original C++ object AND the Wrapped are unreachable.\nBut if I called `g(w)`, then there is still going to be a rogue reference `z` of which I have no knowledge...","user":"U01ST17EY9L","ts":"1618072398.469200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Hk=wN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My pointer inside my wrapped array is a pointer from owned in a C++ object. On the C++ side, shared_ptr with reference count handles the memory management. If I attach a finalizer to "},{"type":"text","text":"Wrapped","style":{"code":true}},{"type":"text","text":", it will simply clear a "},{"type":"text","text":"hidden","style":{"italic":true}},{"type":"text","text":" shared_ptr in the "},{"type":"text","text":"Wrapped","style":{"code":true}},{"type":"text","text":" structure. Thus the pointer will not be freed until both the original C++ object AND the Wrapped are unreachable.\nBut if I called "},{"type":"text","text":"g(w)","style":{"code":true}},{"type":"text","text":", then there is still going to be a rogue reference "},{"type":"text","text":"z","style":{"code":true}},{"type":"text","text":" of which I have no knowledge..."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"f02dac21-dc17-4465-848c-a7f427209c73","type":"message","text":"Why not just add a finalizer to `v` directly here?","user":"UM30MT6RF","ts":"1618072475.469800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Y4iF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Why not just add a finalizer to "},{"type":"text","text":"v","style":{"code":true}},{"type":"text","text":" directly here?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"e9808d50-160b-43d3-a894-2883ceb5227a","type":"message","text":"`v` is a system type. Isn't that immutable?","user":"U01ST17EY9L","ts":"1618072496.470000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r1xsC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"v","style":{"code":true}},{"type":"text","text":" is a system type. Isn't that immutable?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"2e48173f-74db-44e2-b530-59d1a6811048","type":"message","text":"No, you can add finalizers to arrays","user":"UM30MT6RF","ts":"1618072553.470200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dGs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, you can add finalizers to arrays"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"8175bcd9-5273-4324-8d8f-aed59f38bdba","type":"message","text":"That is kind of my fundamental question. My understanding is that I cannot add a finalizer directly to `v`. If you know how to do that, then you have the answer to my question","user":"U01ST17EY9L","ts":"1618072557.470400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sRWfH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That is kind of my fundamental question. My understanding is that I cannot add a finalizer directly to "},{"type":"text","text":"v","style":{"code":true}},{"type":"text","text":". If you know how to do that, then you have the answer to my question"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"b4f72d96-e11e-44f6-a82d-415b8536a84b","type":"message","text":"You can?","user":"U01ST17EY9L","ts":"1618072564.470600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=N2u","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"b71cd0c7-89f6-4087-a9b8-9e78af30d036","type":"message","text":"```julia&gt; v = Array{Float64,1}\nVector{Float64} (alias for Array{Float64, 1})\n\njulia&gt; finalizer(v, x-&gt;println(\"Destroying $x\"))\nERROR: objects of type var\"#3#4\" cannot be finalized\nStacktrace:\n [1] error(::String, ::Type, ::String)\n   @ Base ./error.jl:42\n [2] finalizer(f::Any, o::Any)\n   @ Base ./gcutils.jl:46\n [3] top-level scope\n   @ REPL[8]:1\n\njulia&gt; ```","user":"U01ST17EY9L","ts":"1618072681.471000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"i3wl","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> v = Array{Float64,1}\nVector{Float64} (alias for Array{Float64, 1})\n\njulia> finalizer(v, x->println(\"Destroying $x\"))\nERROR: objects of type var\"#3#4\" cannot be finalized\nStacktrace:\n [1] error(::String, ::Type, ::String)\n   @ Base ./error.jl:42\n [2] finalizer(f::Any, o::Any)\n   @ Base ./gcutils.jl:46\n [3] top-level scope\n   @ REPL[8]:1\n\njulia> "}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"80c20674-54d3-4ae8-a963-310bb72f237e","type":"message","text":"Here is a complete example, where I allocate some memory manually, wrap it as an array and add a finalizer to manually free that memory again:\n```julia&gt; function f()\n           p = ccall(:malloc, Ptr{UInt8}, (Cint,), 10)\n           a = Base.unsafe_wrap(Vector{UInt8}, p, 10)\n           finalizer(a) do a\n               ccall(:jl_safe_printf, Cvoid, (Cstring,), \"gone\\n\")\n               ccall(:free, Cvoid, (Ptr{UInt8},), p)\n           end\n           nothing\n       end\nf (generic function with 1 method)\n\njulia&gt; f()\n\njulia&gt; GC.gc()\ngone```","user":"UM30MT6RF","ts":"1618072681.471200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"U67E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here is a complete example, where I allocate some memory manually, wrap it as an array and add a finalizer to manually free that memory again:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function f()\n           p = ccall(:malloc, Ptr{UInt8}, (Cint,), 10)\n           a = Base.unsafe_wrap(Vector{UInt8}, p, 10)\n           finalizer(a) do a\n               ccall(:jl_safe_printf, Cvoid, (Cstring,), \"gone\\n\")\n               ccall(:free, Cvoid, (Ptr{UInt8},), p)\n           end\n           nothing\n       end\nf (generic function with 1 method)\n\njulia> f()\n\njulia> GC.gc()\ngone"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"4ad4c750-4d11-478d-a896-81f5ef146b88","type":"message","text":"Note that `GC.gc()` here is only to demonstrate that the finalizer is actually called, but in practice, Julia will automatically clean that up, once it makes sense to do so.","user":"UM30MT6RF","ts":"1618072843.471900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fIz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Note that "},{"type":"text","text":"GC.gc()","style":{"code":true}},{"type":"text","text":" here is only to demonstrate that the finalizer is actually called, but in practice, Julia will automatically clean that up, once it makes sense to do so."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"dcfde0ac-cf6f-4a74-a96f-467f13fb8f28","type":"message","text":"In your example, the order of the two arguments is just the wrong way around.","user":"UM30MT6RF","ts":"1618072887.472300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K+G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In your example, the order of the two arguments is just the wrong way around."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"b4382eef-d5ac-47a8-bf04-7bf829668d29","type":"message","text":"You are right.","user":"U01ST17EY9L","ts":"1618072938.472500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"xk+ja","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You are right."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"a0bd346c-6674-4f13-8980-19ada481370c","type":"message","text":"That does look like it is the solution I was looking for. Thank you.","user":"U01ST17EY9L","ts":"1618072970.472700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"menHA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That does look like it is the solution I was looking for. Thank you."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"45cf6888-a1df-494b-8a9c-dd7a2dc3ec73","type":"message","text":"My finalizer is not being called. But I'm going to look more in depth at your example and see if I can get something similar to work.","user":"U01ST17EY9L","ts":"1618073524.475400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Yoh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My finalizer is not being called. But I'm going to look more in depth at your example and see if I can get something similar to work."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"c572465a-5ac0-4e44-93ae-efddfb21abbe","type":"message","text":"My test is creating a Julia object per se for the array. So maybe that's why. Let me try in my actual code something based on your example.","user":"U01ST17EY9L","ts":"1618073678.476200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"amR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My test is creating a Julia object per se for the array. So maybe that's why. Let me try in my actual code something based on your example."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"69b61644-3475-49f9-afb1-b8d150491d0d","type":"message","text":"Even if you close the Julia session? Note that I/O is generally not supported inside finalizers, that's why I used `jl_safe_printf`","user":"UM30MT6RF","ts":"1618073753.476400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vdg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Even if you close the Julia session? Note that I/O is generally not supported inside finalizers, that's why I used "},{"type":"text","text":"jl_safe_printf","style":{"code":true}}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"af43bc33-162c-4648-be7e-c034d0ea09a3","type":"message","text":"When quitting it does call it.","user":"U01ST17EY9L","ts":"1618073939.477700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Slfnn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"When quitting it does call it."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"f7f357c7-f109-4521-baf3-d43a0bb4330d","type":"message","text":"```julia&gt; function f()\n          w = Array{Float64,1}\n          finalizer(x-&gt;println(\"Destroying $x\"),w)\n          return nothing;\n       end\nf (generic function with 1 method)\n\njulia&gt; f()\n\njulia&gt; GC.gc()\n\njulia&gt; exit()\nDestroying Vector{Float64}```","user":"U01ST17EY9L","ts":"1618073971.477900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KOs","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> function f()\n          w = Array{Float64,1}\n          finalizer(x->println(\"Destroying $x\"),w)\n          return nothing;\n       end\nf (generic function with 1 method)\n\njulia> f()\n\njulia> GC.gc()\n\njulia> exit()\nDestroying Vector{Float64}"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"e86980f9-d072-4053-8c71-69a3036189a6","type":"message","text":"Thanks for the additional info on `jl_safe_printf`","user":"U01ST17EY9L","ts":"1618074015.478100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JN5L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the additional info on "},{"type":"text","text":"jl_safe_printf","style":{"code":true}}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"52c33fe0-37dd-4665-b42d-086853f25d19","type":"message","text":"You can try `GC.gc(true)` to force a full sweep, but generally the GC doesn't make any guarantees about when objects are finalized.","user":"UM30MT6RF","ts":"1618074113.479200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vgc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can try "},{"type":"text","text":"GC.gc(true)","style":{"code":true}},{"type":"text","text":" to force a full sweep, but generally the GC doesn't make any guarantees about when objects are finalized."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"}]