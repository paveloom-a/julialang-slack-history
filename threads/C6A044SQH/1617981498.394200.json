[{"client_msg_id":"54244d19-61f5-4380-a3a4-2106fc92daf2","type":"message","text":"I know I can attach a finalizer to a mutable object. But how would the mutable object behave like an array in Julia, yet not allow to copy a member array in a way that would copy my `existingArray` pointer in an immutable object?","user":"U01ST17EY9L","ts":"1617981498.394200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VKXe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I know I can attach a finalizer to a mutable object. But how would the mutable object behave like an array in Julia, yet not allow to copy a member array in a way that would copy my "},{"type":"text","text":"existingArray","style":{"code":true}},{"type":"text","text":" pointer in an immutable object?"}]}]}],"thread_ts":"1617981498.394200","reply_count":8,"reply_users_count":2,"latest_reply":"1618072114.464500","reply_users":["UM30MT6RF","U01ST17EY9L"],"is_locked":false,"subscribed":false},{"client_msg_id":"a73cc3f3-265d-4bf2-8bdc-330774ccc6d6","type":"message","text":"Not sure what you mean by this. Why shouldn't `finalizer` work here?","user":"UM30MT6RF","ts":"1617981703.394300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uPs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not sure what you mean by this. Why shouldn't "},{"type":"text","text":"finalizer","style":{"code":true}},{"type":"text","text":" work here?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"f6f713a5-1791-4316-97d4-ad9b37a31071","type":"message","text":"If I want to put my pointer inside a mutable, doesn't that mean that my pointer (wrapped in a Julia array) is going to be a field and that a routine could copy that field to some other variable, creating a reference to that memory that I will not be aware of?","user":"U01ST17EY9L","ts":"1618001812.427400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rcI+F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If I want to put my pointer inside a mutable, doesn't that mean that my pointer (wrapped in a Julia array) is going to be a field and that a routine could copy that field to some other variable, creating a reference to that memory that I will not be aware of?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"f204bbc5-29d6-4a69-aa56-312180064e88","type":"message","text":"Thus the finalizer could be called while that copy still exist. No?","user":"U01ST17EY9L","ts":"1618001912.427600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zS=4n","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thus the finalizer could be called while that copy still exist. No?"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"029502e4-afbc-4582-b011-666539c3e26b","type":"message","text":"Yeah, Julia won't know anything about pointers. If you add a finalizer to the array, that finalizer will be called once there are no references to the tracked Julia array anymore. The raw pointer won't be tracked at all though. If you put just the raw pointer into a mutable struct, you probably want to add a finalizer to that mutable struct instead.","user":"UM30MT6RF","ts":"1618005924.431600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ghs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, Julia won't know anything about pointers. If you add a finalizer to the array, that finalizer will be called once there are no references to the tracked Julia array anymore. The raw pointer won't be tracked at all though. If you put just the raw pointer into a mutable struct, you probably want to add a finalizer to that mutable struct instead."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"4e792fae-685d-4d99-9dc9-3f42f8bb964f","type":"message","text":"That's what it seems to be like. I wish there was a way to attach a finalizer to a Julia Array{Float64} where the array refers to memory allocated on the C side.","user":"U01ST17EY9L","ts":"1618068957.457100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2iNSn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That's what it seems to be like. I wish there was a way to attach a finalizer to a Julia Array{Float64} where the array refers to memory allocated on the C side."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"7ea2a4b0-77bf-40d4-a5db-ff22ac95cf12","type":"message","text":"I don't really follow you. If you want Julia's GC to manage the arrays, you can pass the option to let Julia take ownership of the memory and free it once the GC can prove there are no references to the Julia array anymore. You can't use that pointer from C afterwards of course, since Julia is free to free that memory. OTOH, you can wrap the pointer as a Julia array without taking ownership, then you have to manage the memory yourself, but you also have full control over when exactly the memory is freed. You can still add a finalizer from Julia's side, which will be called once the Julia array is not referenced anymore, but the memory won't be freed automatically. Since Julia already supports both these usecases, I don't understand what you are missing currently.","user":"UM30MT6RF","ts":"1618069987.457900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BwC/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I don't really follow you. If you want Julia's GC to manage the arrays, you can pass the option to let Julia take ownership of the memory and free it once the GC can prove there are no references to the Julia array anymore. You can't use that pointer from C afterwards of course, since Julia is free to free that memory. OTOH, you can wrap the pointer as a Julia array without taking ownership, then you have to manage the memory yourself, but you also have full control over when exactly the memory is freed. You can still add a finalizer from Julia's side, which will be called once the Julia array is not referenced anymore, but the memory won't be freed automatically. Since Julia already supports both these usecases, I don't understand what you are missing currently."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"3bb8113f-cbef-4cd1-9d91-97a0837a1622","type":"message","text":"I do want to do what you describe as wrapping a C++ pointer for Julia. But to put a finalizer, you have to make an object mutable, right? That mutable will be a `mutable struct` with a Array{Float64} right?\nSomething like:\n```mutable Wrapped\n    v::Array{Float64,1}\nend;```\nSo far so good. But now assume I have this routine:\n```function g(w::Wrapped)\n    global z = w.v;\nend```","user":"U01ST17EY9L","ts":"1618072082.463800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z1e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do want to do what you describe as wrapping a C++ pointer for Julia. But to put a finalizer, you have to make an object mutable, right? That mutable will be a "},{"type":"text","text":"mutable struct","style":{"code":true}},{"type":"text","text":" with a Array{Float64} right?\nSomething like:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable Wrapped\n    v::Array{Float64,1}\nend;"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"So far so good. But now assume I have this routine:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function g(w::Wrapped)\n    global z = w.v;\nend"}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"},{"client_msg_id":"dcb0ffe3-79a8-4252-bc66-9e2920e3ecd2","type":"message","text":"Now z has a reference to my wrapped array but I have no way of knowing when that reference will disappear.","user":"U01ST17EY9L","ts":"1618072114.464500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OLx4F","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Now z has a reference to my wrapped array but I have no way of knowing when that reference will disappear."}]}]}],"thread_ts":"1617981498.394200","parent_user_id":"U01ST17EY9L"}]