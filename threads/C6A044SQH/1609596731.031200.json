[{"client_msg_id":"adf88642-0787-4426-815b-010f57de268f","type":"message","text":"is there something in base to take the first `k` elements of a tuple (or less when the tuple has length &lt; k)? basically I want to cap `I::Vararg{Any,L}` to length `k` and then splat it into a function call; it ends up allocating for reasons I don't understand (writing it with a generated function with getindex, or functional style with recursion), I guess it has to do with some type instability when indexing into a tuple.","user":"U6N6VQE30","ts":"1609596731.031200","team":"T68168MUP","edited":{"user":"U6N6VQE30","ts":"1609597034.000000"},"blocks":[{"type":"rich_text","block_id":"SH0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is there something in base to take the first "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" elements of a tuple (or less when the tuple has length < k)? basically I want to cap "},{"type":"text","text":"I::Vararg{Any,L}","style":{"code":true}},{"type":"text","text":" to length "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" and then splat it into a function call; it ends up allocating for reasons I don't understand (writing it with a generated function with getindex, or functional style with recursion), I guess it has to do with some type instability when indexing into a tuple."}]}]}],"thread_ts":"1609596731.031200","reply_count":13,"reply_users_count":5,"latest_reply":"1609602964.035300","reply_users":["U7HAYKY9X","U6N6VQE30","UH24GRBLL","UM30MT6RF","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"b438b8d4-8649-4280-ab41-c5c5ebb20d40","type":"message","text":"Tuple(Iterators.take((1,2,3), 2))","user":"U7HAYKY9X","ts":"1609598835.031700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KkU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Tuple(Iterators.take((1,2,3), 2))"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"074a2b1f-609a-448c-b585-cf465855f5cc","type":"message","text":"it looks pretty, but it's not type stable it seems :disappointed:","user":"U6N6VQE30","ts":"1609599109.031900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Red","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it looks pretty, but it's not type stable it seems "},{"type":"emoji","name":"disappointed"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"f6cf331a-b889-43e9-a7de-81992f3f59c1","type":"message","text":"indexing into a tuple shouldn't ever be type unstable, but capping `Vararg{Any,L}` will always incur dynamic dispatch","user":"UH24GRBLL","ts":"1609599520.032100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"wjduv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"indexing into a tuple shouldn't ever be type unstable, but capping "},{"type":"text","text":"Vararg{Any,L}","style":{"code":true}},{"type":"text","text":" will always incur dynamic dispatch"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"06c377d4-5c86-4ac4-a8d2-145af6992144","type":"message","text":"there's an `Any` there after all","user":"UH24GRBLL","ts":"1609599529.032300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WV4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"there's an "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" there after all"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"f87e4aec-ae47-4925-899e-ff106c74e43b","type":"message","text":"the `Any` is in the function argument type signature, it's just to force specialization because otherwise the compiler gives up. Should be fine to use Any there?","user":"U6N6VQE30","ts":"1609601962.033500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tadd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" is in the function argument type signature, it's just to force specialization because otherwise the compiler gives up. Should be fine to use Any there?"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"e5b9d619-5413-4a78-abeb-a8a162635219","type":"message","text":"I think `I[1:k]` should be type stable for inferrable small `k`","user":"UM30MT6RF","ts":"1609602059.033700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"B6GE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think "},{"type":"text","text":"I[1:k]","style":{"code":true}},{"type":"text","text":" should be type stable for inferrable small "},{"type":"text","text":"k","style":{"code":true}}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"8f110ade-d8a9-44a5-8a4a-b02135916fc3","type":"message","text":"oh, you're probably right. I tried `I[OneTo(k)]` which collects a temp array and then splats that into a tuple, but UnitRange has a different implementation","user":"U6N6VQE30","ts":"1609602265.033900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KKH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh, you're probably right. I tried "},{"type":"text","text":"I[OneTo(k)]","style":{"code":true}},{"type":"text","text":" which collects a temp array and then splats that into a tuple, but UnitRange has a different implementation"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"72470a78-5fd1-4acc-871e-5c91cc4c01c0","type":"message","text":"It's apparently only type stable if `k &gt;= length(I) - 2`: <https://github.com/JuliaLang/julia/blob/5ee2d601edcf2dcdd467041ba9f08c43bf23e1a3/base/range.jl#L300|https://github.com/JuliaLang/julia/blob/5ee2d601edcf2dcdd467041ba9f08c43bf23e1a3/base/range.jl#L300>. I am not really a big fan of thay implementation","user":"UM30MT6RF","ts":"1609602383.034100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R653","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's apparently only type stable if "},{"type":"text","text":"k >= length(I) - 2","style":{"code":true}},{"type":"text","text":": "},{"type":"link","url":"https://github.com/JuliaLang/julia/blob/5ee2d601edcf2dcdd467041ba9f08c43bf23e1a3/base/range.jl#L300","text":"https://github.com/JuliaLang/julia/blob/5ee2d601edcf2dcdd467041ba9f08c43bf23e1a3/base/range.jl#L300"},{"type":"text","text":". I am not really a big fan of thay implementation"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30","reactions":[{"name":"heavy_check_mark","users":["U6N6VQE30"],"count":1}]},{"client_msg_id":"ba8b7ede-33f3-4766-a160-22122c71949b","type":"message","text":"is it possible to make it type stable for all `k`, without sacrificing too much compile time?","user":"UH24GRBLL","ts":"1609602659.034400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3RzhJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is it possible to make it type stable for all "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":", without sacrificing too much compile time?"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"e953013b-ea9b-4497-a86c-1fa77dafcd42","type":"message","text":"hm kay :stuck_out_tongue: i basically created an array wrapper for an N dimensional array, but the underlying memory model is an N+1 dimensional array (an extra dim in the back; struct-of-array-like). my problem was with wrapping `view(x::MyArray{T,N}, I::Varag{Any,K})` to return `MyArray(view(x, I..., :))`, where I'd have to cap the length of `I`, since it is allow to index an array with trailing ones: x = rand(3); x[1,1,1,1,1] is legal. Somehow I didn't manage to drop the trailing vararg values for inhomogeneous varags like `(1:3, :, 1)`","user":"U6N6VQE30","ts":"1609602681.034600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gO6Mn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hm kay "},{"type":"emoji","name":"stuck_out_tongue"},{"type":"text","text":" i basically created an array wrapper for an N dimensional array, but the underlying memory model is an N+1 dimensional array (an extra dim in the back; struct-of-array-like). my problem was with wrapping "},{"type":"text","text":"view(x::MyArray{T,N}, I::Varag{Any,K})","style":{"code":true}},{"type":"text","text":" to return "},{"type":"text","text":"MyArray(view(x, I..., :))","style":{"code":true}},{"type":"text","text":", where I'd have to cap the length of "},{"type":"text","text":"I","style":{"code":true}},{"type":"text","text":", since it is allow to index an array with trailing ones: x = rand(3); x[1,1,1,1,1] is legal. Somehow I didn't manage to drop the trailing vararg values for inhomogeneous varags like "},{"type":"text","text":"(1:3, :, 1)","style":{"code":true}}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"a38716d9-c29f-4481-b4c0-d5f7af9bbe65","type":"message","text":"&gt; is it possible to make it type stable for all `k`, without sacrificing too much compile time?\n\nYou can just wrap `k` in `Val` and write a generated function, but you still want an opt-out for large tuples to avoid huge latencies","user":"UM30MT6RF","ts":"1609602887.034800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PYr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"> is it possible to make it type stable for all "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":", without sacrificing too much compile time?\n\nYou can just wrap "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":" in "},{"type":"text","text":"Val","style":{"code":true}},{"type":"text","text":" and write a generated function, but you still want an opt-out for large tuples to avoid huge latencies"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"},{"client_msg_id":"543c0bbb-1690-45c3-97d4-21dd0e2adeb5","type":"message","text":"Maybe safest just to do it explcitly? `ttake(t::Tuple, ::Val{n}) where n = ntuple(i -&gt; t[i], min(n, length(t)))` should always be type-stable.","user":"UD0NS8PDF","ts":"1609602890.035000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SCe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe safest just to do it explcitly? "},{"type":"text","text":"ttake(t::Tuple, ::Val{n}) where n = ntuple(i -> t[i], min(n, length(t)))","style":{"code":true}},{"type":"text","text":" should always be type-stable."}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30","reactions":[{"name":"+1","users":["UM30MT6RF","U6N6VQE30"],"count":2}]},{"client_msg_id":"251077f7-23ca-4e69-b74c-592cad3899e5","type":"message","text":"(I think it's type stable uo to n = 10, which is probably fine for most cases)","user":"UM30MT6RF","ts":"1609602964.035300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r5J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(I think it's type stable uo to n = 10, which is probably fine for most cases)"}]}]}],"thread_ts":"1609596731.031200","parent_user_id":"U6N6VQE30"}]