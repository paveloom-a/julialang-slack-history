[{"client_msg_id":"7d3f36d8-a224-48ec-999b-3541c3940a3b","type":"message","text":"Anyone have any thoughts on inversion of control and dependency injection in Julia? For example: if module A depends on method `foo(::Bar)` but is agnostic to the implementation of `foo` for any subtype of `Bar`  that might exist in the calling module or some other module, what is the general pattern to make these methods available to A without introducing direct dependencies via `using`? It's not obvious to me how to do this since modules do not inherit scope from their callers (presumably for the purpose of namespace separation).","user":"U01H36BUDJB","ts":"1610997234.270500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"O8X3Q","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyone have any thoughts on inversion of control and dependency injection in Julia? For example: if module A depends on method "},{"type":"text","text":"foo(::Bar)","style":{"code":true}},{"type":"text","text":" but is agnostic to the implementation of "},{"type":"text","text":"foo","style":{"code":true}},{"type":"text","text":" for any subtype of "},{"type":"text","text":"Bar","style":{"code":true}},{"type":"text","text":"  that might exist in the calling module or some other module, what is the general pattern to make these methods available to A without introducing direct dependencies via "},{"type":"text","text":"using","style":{"code":true}},{"type":"text","text":"? It's not obvious to me how to do this since modules do not inherit scope from their callers (presumably for the purpose of namespace separation)."}]}]}],"thread_ts":"1610997234.270500","reply_count":2,"reply_users_count":2,"latest_reply":"1611002892.271600","reply_users":["U86LUCPRP","U01H36BUDJB"],"subscribed":false},{"client_msg_id":"0780cb49-2193-42ac-92fd-d30f162fc7b5","type":"message","text":"You’d have to depend on `Bar` which would be an “interface”. In case there are multiple implementations I usually have something like\n• Interface module - `module Bars, abstract type Bar, foo(::Bar)`\n• Implementation - `module FileBars, struct FileBar &lt;: Bar, foo(::FileBar)`\n• Client - `module Client; using Bar; struct Client{B &lt;: Bar} bar :: B;`","user":"U86LUCPRP","ts":"1611000345.271300","team":"T68168MUP","edited":{"user":"U86LUCPRP","ts":"1611000369.000000"},"blocks":[{"type":"rich_text","block_id":"rnJCn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You’d have to depend on "},{"type":"text","text":"Bar","style":{"code":true}},{"type":"text","text":" which would be an “interface”. In case there are multiple implementations I usually have something like\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Interface module - "},{"type":"text","text":"module Bars, abstract type Bar, foo(::Bar)","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Implementation - "},{"type":"text","text":"module FileBars, struct FileBar <: Bar, foo(::FileBar)","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Client - "},{"type":"text","text":"module Client; using Bar; struct Client{B <: Bar} bar :: B;","style":{"code":true}}]}],"style":"bullet","indent":0}]}],"thread_ts":"1610997234.270500","parent_user_id":"U01H36BUDJB"},{"client_msg_id":"30d3fb22-b4d9-4781-ab2e-9de014799d50","type":"message","text":"Ok, so then FileBars and Client both depend on Bars, Client also would depend on FileBars, I suppose. How would you structure this within a single package, where Client is external code? Bars and FileBars would both be submodules (\"siblings\" in the file structure) of the package top level module, maybe?","user":"U01H36BUDJB","ts":"1611002892.271600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xngz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok, so then FileBars and Client both depend on Bars, Client also would depend on FileBars, I suppose. How would you structure this within a single package, where Client is external code? Bars and FileBars would both be submodules (\"siblings\" in the file structure) of the package top level module, maybe?"}]}]}],"thread_ts":"1610997234.270500","parent_user_id":"U01H36BUDJB"}]