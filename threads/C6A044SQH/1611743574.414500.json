[{"client_msg_id":"8afedce9-98fc-4ba1-95d2-4fda7678bd2c","type":"message","text":"A question regarding structs - I have this hierarchical data structure which is somewhat like a binary tree. In my current implementation (see below) I use indicators rootnode and leafnode to indicate where the tree ends. In this case A11, A22 usually remain uninitialized and are #undef objects. I want to have the option of not having to specify certain fields of my data structures as they only make sense in a certain context (if it is a leafnode for instance). What is the best way to do that?\n```mutable struct HssMatrix{T&lt;:Number} &lt;: AbstractMatrix{T}\n  # 2x2 recursive block structure for branchnodes\n  A11       ::HssMatrix{T}\n  A22       ::HssMatrix{T}\n  B12       ::Matrix{T}\n  B21       ::Matrix{T}\n\n  # indicators whether we are at the root- or leafnode\n  rootnode  ::Bool\n  leafnode  ::Bool\n\n  # dimensions of its children\n  m1        ::Integer\n  n1        ::Integer\n  m2        ::Integer\n  n2        ::Integer\n\n  # translation operators if we are at a branchnode\n  R1        ::Matrix{T}\n  R2        ::Matrix{T}\n  W1        ::Matrix{T}\n  W2        ::Matrix{T}\n\n  # at the leaf level we store the diagonal block and generators directly\n  U         ::Matrix{T}\n  V         ::Matrix{T}\n  D         ::Matrix{T}\n\n  # inner constructor\n  HssMatrix{T}() where T = new{T}()\n  HssMatrix() = HssMatrix{Float64}()\nend```","user":"U01L0RJC6FM","ts":"1611743574.414500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WIq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A question regarding structs - I have this hierarchical data structure which is somewhat like a binary tree. In my current implementation (see below) I use indicators rootnode and leafnode to indicate where the tree ends. In this case A11, A22 usually remain uninitialized and are #undef objects. I want to have the option of not having to specify certain fields of my data structures as they only make sense in a certain context (if it is a leafnode for instance). What is the best way to do that?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct HssMatrix{T<:Number} <: AbstractMatrix{T}\n  # 2x2 recursive block structure for branchnodes\n  A11       ::HssMatrix{T}\n  A22       ::HssMatrix{T}\n  B12       ::Matrix{T}\n  B21       ::Matrix{T}\n\n  # indicators whether we are at the root- or leafnode\n  rootnode  ::Bool\n  leafnode  ::Bool\n\n  # dimensions of its children\n  m1        ::Integer\n  n1        ::Integer\n  m2        ::Integer\n  n2        ::Integer\n\n  # translation operators if we are at a branchnode\n  R1        ::Matrix{T}\n  R2        ::Matrix{T}\n  W1        ::Matrix{T}\n  W2        ::Matrix{T}\n\n  # at the leaf level we store the diagonal block and generators directly\n  U         ::Matrix{T}\n  V         ::Matrix{T}\n  D         ::Matrix{T}\n\n  # inner constructor\n  HssMatrix{T}() where T = new{T}()\n  HssMatrix() = HssMatrix{Float64}()\nend"}]}]}],"thread_ts":"1611743574.414500","reply_count":42,"reply_users_count":2,"latest_reply":"1611838564.488200","reply_users":["U7HAYKY9X","U01L0RJC6FM"],"subscribed":false},{"client_msg_id":"56d4a05d-81d4-454c-bf53-d793934ea200","type":"message","text":"It's much better to have them as `Union{T, Nothing}` , and then have constructors that decide if they should be nothing orT","user":"U7HAYKY9X","ts":"1611748710.421900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XIl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's much better to have them as "},{"type":"text","text":"Union{T, Nothing}","style":{"code":true}},{"type":"text","text":" , and then have constructors that decide if they should be nothing orT"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"14dcdef4-8e60-4e91-8cd3-357c0db2279f","type":"message","text":"thank you! Is there a difference between `Matrix{Union{T, Nothing}}` and `Union{Matrix{T},Nothing}` ?","user":"U01L0RJC6FM","ts":"1611753303.427200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QVuQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thank you! Is there a difference between "},{"type":"text","text":"Matrix{Union{T, Nothing}}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Union{Matrix{T},Nothing}","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"f960df17-c5cc-4e63-97e0-422562ef2a77","type":"message","text":"Yes, you want the latter. The former is a matrix where each element can be nothing, but you want a field which is either nothing or a matrix","user":"U7HAYKY9X","ts":"1611754629.429700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K5GK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, you want the latter. The former is a matrix where each element can be nothing, but you want a field which is either nothing or a matrix"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"963d5436-336b-4497-beb4-3a13b854e460","type":"message","text":"Also, each of those fields that are duplicated (like R1 and R2), could instead just be called `R` and contains an `NTuple{2, Matrix{T}}` , right?","user":"U7HAYKY9X","ts":"1611754667.430300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"m0l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Also, each of those fields that are duplicated (like R1 and R2), could instead just be called "},{"type":"text","text":"R","style":{"code":true}},{"type":"text","text":" and contains an "},{"type":"text","text":"NTuple{2, Matrix{T}}","style":{"code":true}},{"type":"text","text":" , right?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"a263d11e-9ff3-4df2-8932-963c4c68abcd","type":"message","text":"yes, you're right! I keep it like this for readability. Changing it to Tuples would be a matter of style preference right?","user":"U01L0RJC6FM","ts":"1611755081.430700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"szR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, you're right! I keep it like this for readability. Changing it to Tuples would be a matter of style preference right?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"27749593-06cc-44e6-8a37-1d5bd850cab1","type":"message","text":"btw.. changing the data structure to be able to contain Nothing has drastically increased the number of allocations for some operations. Isn't that an issue?","user":"U01L0RJC6FM","ts":"1611756272.431200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IwJz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"btw.. changing the data structure to be able to contain Nothing has drastically increased the number of allocations for some operations. Isn't that an issue?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"b29d29c8-a7d6-4f0d-8ac4-281fb8c4440a","type":"message","text":"Yeah, that's an issue. You'll have to mitigate that by providing some hints to the compiler. One way would be to have a method similar to:\n`getmatrix(x::HssMatrix)::Matrix = x.A` , and then only access the matrix through that method. Then the compiler knows for certain the result is a matrix, and not `nothing`","user":"U7HAYKY9X","ts":"1611769027.435900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IZa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, that's an issue. You'll have to mitigate that by providing some hints to the compiler. One way would be to have a method similar to:\n"},{"type":"text","text":"getmatrix(x::HssMatrix)::Matrix = x.A","style":{"code":true}},{"type":"text","text":" , and then only access the matrix through that method. Then the compiler knows for certain the result is a matrix, and not "},{"type":"text","text":"nothing","style":{"code":true}}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ac524a07-b8db-4e51-ac30-a796c02a120d","type":"message","text":"ohh that's a really useful hint. Thanks a lot. I actually split the type into two types, one for the leaves and one for the branch nodes. This avoids having so many nothing  allocations. Then they only become necessary at the root node.","user":"U01L0RJC6FM","ts":"1611827585.478500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0tTq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ohh that's a really useful hint. Thanks a lot. I actually split the type into two types, one for the leaves and one for the branch nodes. This avoids having so many nothing  allocations. Then they only become necessary at the root node."}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"7b8810ca-35f0-4fd5-8a6f-cbc48fef90a3","type":"message","text":"Thank you again for all the helpful answers Jakob - If you ever pass by EPFL let me offer you a beer :)","user":"U01L0RJC6FM","ts":"1611827621.478700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jbh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you again for all the helpful answers Jakob - If you ever pass by EPFL let me offer you a beer :)"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"547c08a1-26e8-450f-9d86-beebb54530b9","type":"message","text":"The problem with your solution is that you might end up just pushing the problem one step higher: Now, some of your code may end up inferring to `Union{Leaf, Branch}` (depending on what you do exactly, of course), and you'll need to provide hints to the compiler when you know for certain you are only working with branches or leaves","user":"U7HAYKY9X","ts":"1611827813.480800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4MV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The problem with your solution is that you might end up just pushing the problem one step higher: Now, some of your code may end up inferring to "},{"type":"text","text":"Union{Leaf, Branch}","style":{"code":true}},{"type":"text","text":" (depending on what you do exactly, of course), and you'll need to provide hints to the compiler when you know for certain you are only working with branches or leaves"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ec652652-186a-4dc9-84ec-eda505cfb04f","type":"message","text":"hmm wouldn't that be a non-issue if I define separate functions for `Leaf` and `Branch` ?","user":"U01L0RJC6FM","ts":"1611827875.481000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+A0k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm wouldn't that be a non-issue if I define separate functions for "},{"type":"text","text":"Leaf ","style":{"code":true}},{"type":"text","text":"and "},{"type":"text","text":"Branch","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"39392735-b66b-475d-81f9-14db5ceab3ce","type":"message","text":"most routines do different operations if they are at the leaf level","user":"U01L0RJC6FM","ts":"1611827907.481200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rpFF6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"most routines do different operations if they are at the leaf level"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"a5dcbafd-b0e2-4028-93e9-5899e8a7e460","type":"message","text":"Yep, that would be a non-issue, unless you then also have some operations in the same functions that traverse the tree, and move from branches to leaves, such that a variable may be a branch or a leaf.","user":"U7HAYKY9X","ts":"1611828017.481500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IKr9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yep, that would be a non-issue, unless you then also have some operations in the same functions that traverse the tree, and move from branches to leaves, such that a variable may be a branch or a leaf."}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"5eae957c-6f4b-41b2-b245-7742f4b0bf1f","type":"message","text":"(my first Julia package was module for phylogenetic tree analysis, where I made a `Root` and `Child` type, so I know this by unfortunate experience ;) )","user":"U7HAYKY9X","ts":"1611828056.481700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vUv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"(my first Julia package was module for phylogenetic tree analysis, where I made a "},{"type":"text","text":"Root","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Child","style":{"code":true}},{"type":"text","text":" type, so I know this by unfortunate experience ;) )"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"0bc1c1d6-5a45-48ff-8194-8f349f578a98","type":"message","text":"you mean a function that operates simultaneously on leaves and branches?","user":"U01L0RJC6FM","ts":"1611828079.481900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4VAhO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you mean a function that operates simultaneously on leaves and branches?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"485a733d-f2b6-4a27-89a3-8519c9a6989e","type":"message","text":"ahha ok, so I will be more than happy to learn from your mistakes :smile:","user":"U01L0RJC6FM","ts":"1611828103.482100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pO8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ahha ok, so I will be more than happy to learn from your mistakes "},{"type":"emoji","name":"smile"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"6af02772-11f4-47a3-9e12-9c4132456fe7","type":"message","text":"I mean, if you do something like\n```get_first_leaf(x::Branch)\n    while x isa Branch\n        x = child(x)\n    end\n    x\nend```","user":"U7HAYKY9X","ts":"1611828154.482300","team":"T68168MUP","edited":{"user":"U7HAYKY9X","ts":"1611828191.000000"},"blocks":[{"type":"rich_text","block_id":"W5yN3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, if you do something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"get_first_leaf(x::Branch)\n    while x isa Branch\n        x = child(x)\n    end\n    x\nend"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"5f59052b-438e-4c63-89b7-3999ed113b59","type":"message","text":"Then `x` can, at any point, be either a `Branch` or a `Leaf` . So any code where a variable may be either a branch or a leaf have the same instability","user":"U7HAYKY9X","ts":"1611828232.482600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hoZat","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Then "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" can, at any point, be either a "},{"type":"text","text":"Branch","style":{"code":true}},{"type":"text","text":" or a "},{"type":"text","text":"Leaf","style":{"code":true}},{"type":"text","text":" . So any code where a variable may be either a branch or a leaf have the same instability"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"be56a063-755e-41ce-a0b2-a16dbf49ddd0","type":"message","text":"aha I see, so the problem is due to the type allowing children to be of a different type it cannot infer the type of x?","user":"U01L0RJC6FM","ts":"1611828345.482800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2810k","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"aha I see, so the problem is due to the type allowing children to be of a different type it cannot infer the type of x?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"327f9b1b-ef0d-4062-88ef-a90a8b27b9a9","type":"message","text":"so the return type is ambiguous?","user":"U01L0RJC6FM","ts":"1611828361.483000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"irTLe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so the return type is ambiguous?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"170e4399-a563-4f53-93f4-c6d304834b0e","type":"message","text":"most of my routines and basically all performance related routines should look like this:","user":"U01L0RJC6FM","ts":"1611828414.483200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q9tG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"most of my routines and basically all performance related routines should look like this:"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"7768b68a-c3a8-48ef-ba49-7bc0b8078645","type":"message","text":"```factor(x::Leaf) = #do something\nfunction factor(x::Branch)\n  factor(x.left)\n  factor(x.right)\n  # do something slightly different on x\nend```\n","user":"U01L0RJC6FM","ts":"1611828420.483400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YRN","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"factor(x::Leaf) = #do something\nfunction factor(x::Branch)\n  factor(x.left)\n  factor(x.right)\n  # do something slightly different on x\nend"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"15143297-d90d-4d32-b423-2f136a851c26","type":"message","text":"Yes, exactly! And this ambiguity propagates until suddenly Julia have to put things on the heap in boxed containers because it doesn't know the type. That was what you saw earlier with the `Union{Matrix, Nothing}` example","user":"U7HAYKY9X","ts":"1611828447.483600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=D/L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, exactly! And this ambiguity propagates until suddenly Julia have to put things on the heap in boxed containers because it doesn't know the type. That was what you saw earlier with the "},{"type":"text","text":"Union{Matrix, Nothing}","style":{"code":true}},{"type":"text","text":" example"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"37c59267-706d-414b-9f30-b340ddd708e0","type":"message","text":"Yeah, and I suppose `x.left` can return either a `Leaf` or a `Branch` , right?","user":"U7HAYKY9X","ts":"1611828489.483800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1BX+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, and I suppose "},{"type":"text","text":"x.left","style":{"code":true}},{"type":"text","text":" can return either a "},{"type":"text","text":"Leaf","style":{"code":true}},{"type":"text","text":" or a "},{"type":"text","text":"Branch","style":{"code":true}},{"type":"text","text":" , right?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ba7bcd76-54ac-4402-b74e-c4939011c58c","type":"message","text":"hmm... in most cases it will just operate on x, so the return type should be stable","user":"U01L0RJC6FM","ts":"1611828570.484000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DsvMe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm... in most cases it will just operate on x, so the return type should be stable"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"0149c201-21c1-4e82-82ac-ef2ee6d1a13d","type":"message","text":"in fact I should have maybe included !","user":"U01L0RJC6FM","ts":"1611828580.484200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OAP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"in fact I should have maybe included !"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"4e9ce310-a9db-43d4-8742-7275794001ab","type":"message","text":"You can't get around the fundamental uncertainty in SOME respect: At some point you're going to \"move\" from a branch to a leaf, and that cannot be known until runtime. The trick is to make the compiler do this switch via a branch in the code instead of via dynamic dispatch. Sometimes, if the compiler can infer a return type to a small union, it will do the conversion to a branch itself (this is called \"union-splitting\"), but I've found it to be somewhat unreliable. One clunky approach, when union splitting fails is:\n```if x isa Leaf\n    # do stuff in this branch the compiler KNOWS x is a leaf.\nelseif x isa Branch\n    # do other stuff\nelse\n    error()\nend```","user":"U7HAYKY9X","ts":"1611828599.484400","team":"T68168MUP","edited":{"user":"U7HAYKY9X","ts":"1611828700.000000"},"blocks":[{"type":"rich_text","block_id":"1wQT","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can't get around the fundamental uncertainty in SOME respect: At some point you're going to \"move\" from a branch to a leaf, and that cannot be known until runtime. The trick is to make the compiler do this switch via a branch in the code instead of via dynamic dispatch. Sometimes, if the compiler can infer a return type to a small union, it will do the conversion to a branch itself (this is called \"union-splitting\"), but I've found it to be somewhat unreliable. One clunky approach, when union splitting fails is:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"if x isa Leaf\n    # do stuff in this branch the compiler KNOWS x is a leaf.\nelseif x isa Branch\n    # do other stuff\nelse\n    error()\nend"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"3f4ea21d-0f09-41cb-8e4c-16fc10e83aec","type":"message","text":"Most of the time, union-splitting will work, though.","user":"U7HAYKY9X","ts":"1611828756.484700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rs0ye","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Most of the time, union-splitting will work, though."}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"7fcd1f8c-867b-49a8-85a1-28b9745bab66","type":"message","text":"yes so `x.left` will inevitably be `Union{Leaf,Branch}` . What I don't get is, shouldn't it be fine if Julia knows different functions for both types `Leaf` and `Branch` ?","user":"U01L0RJC6FM","ts":"1611828854.484900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fB34e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes so "},{"type":"text","text":"x.left","style":{"code":true}},{"type":"text","text":" will inevitably be "},{"type":"text","text":"Union{Leaf,Branch}","style":{"code":true}},{"type":"text","text":" . What I don't get is, shouldn't it be fine if Julia knows different functions for both types "},{"type":"text","text":"Leaf","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Branch","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"2f775ce3-8750-4a9e-971b-6ba54788c5d1","type":"message","text":"in that case it knows x is a leaf or branch in their respective functions","user":"U01L0RJC6FM","ts":"1611828867.485100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"fYR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"in that case it knows x is a leaf or branch in their respective functions"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"315bf45d-f725-4b9b-83c8-f245d1611c5f","type":"message","text":"and as long as return types are stable across these two functions we're good?","user":"U01L0RJC6FM","ts":"1611828886.485300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KV9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and as long as return types are stable across these two functions we're good?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"9f5de094-dcfc-4fcb-b9f3-53dc8ae8a28d","type":"message","text":"I agree with you that at some point which we can only know during runtime we'll be switching from one function to the other","user":"U01L0RJC6FM","ts":"1611828917.485500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Tn3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree with you that at some point which we can only know during runtime we'll be switching from one function to the other"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"fea3bcf1-f197-4cc1-9e2d-0537cbf20e49","type":"message","text":"if I understood you correctly this corresponds to a branch in the code?","user":"U01L0RJC6FM","ts":"1611829075.485900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SAm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if I understood you correctly this corresponds to a branch in the code?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"b16a0f2d-16a2-45f1-949c-752f7cc55a3f","type":"message","text":"and not to dynamic dispatch","user":"U01L0RJC6FM","ts":"1611829082.486100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8IWI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and not to dynamic dispatch"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"eb4392e7-970f-47e3-b38c-f270d0d3196e","type":"message","text":"So, if `x.leaf` is a `Union{Branch, Leaf}` , and you next have a `factor(x.leaf)` , then the Julia compiler can do one of two things:\n1. Either, it can say \"well, I don't know what type `x.leaf` is, so since there are multiple methods of `factor` that can get called, *who knows* what the return type of *those* methods are, so I'm just going to give up on inference and reserve space on the heap for whatever comes back from `factor(x.leaf)`\n2. Or it can say: It's either a Leaf or a Branch, so there are only two possible methods of `factor` to call. So I'll just insert a branch that calls either one method specifically, or the other\nYou want number 2 to happen.","user":"U7HAYKY9X","ts":"1611829090.486300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2XWG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So, if "},{"type":"text","text":"x.leaf","style":{"code":true}},{"type":"text","text":" is a "},{"type":"text","text":"Union{Branch, Leaf}","style":{"code":true}},{"type":"text","text":" , and you next have a "},{"type":"text","text":"factor(x.leaf)","style":{"code":true}},{"type":"text","text":" , then the Julia compiler can do one of two things:\n"}]},{"type":"rich_text_list","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Either, it can say \"well, I don't know what type "},{"type":"text","text":"x.leaf","style":{"code":true}},{"type":"text","text":" is, so since there are multiple methods of "},{"type":"text","text":"factor","style":{"code":true}},{"type":"text","text":" that can get called, "},{"type":"text","text":"who knows","style":{"bold":true}},{"type":"text","text":" what the return type of "},{"type":"text","text":"those","style":{"bold":true}},{"type":"text","text":" methods are, so I'm just going to give up on inference and reserve space on the heap for whatever comes back from "},{"type":"text","text":"factor(x.leaf)","style":{"code":true}}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Or it can say: It's either a Leaf or a Branch, so there are only two possible methods of "},{"type":"text","text":"factor","style":{"code":true}},{"type":"text","text":" to call. So I'll just insert a branch that calls either one method specifically, or the other"}]}],"style":"ordered","indent":0},{"type":"rich_text_section","elements":[{"type":"text","text":"You want number 2 to happen."}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"67ae8690-aaa0-4bef-b57b-1fddb501a99b","type":"message","text":"Yeah. And from 0.7 Julia is able to automatically do #2 if there are just a few options to choose from. But it doesn't always work out, as you saw in your `Union{Nothing, Matrix}` example.","user":"U7HAYKY9X","ts":"1611829160.486500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FOKs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah. And from 0.7 Julia is able to automatically do #2 if there are just a few options to choose from. But it doesn't always work out, as you saw in your "},{"type":"text","text":"Union{Nothing, Matrix}","style":{"code":true}},{"type":"text","text":" example."}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"e532afbf-877c-41e4-aa68-218aa7eba747","type":"message","text":"aha ok, thanks for the clarification. So the question is really under which circumstances does #2 happen? Is there a way to make sure it does?","user":"U01L0RJC6FM","ts":"1611829222.486700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S4QOH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"aha ok, thanks for the clarification. So the question is really under which circumstances does #2 happen? Is there a way to make sure it does?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"c124f5e8-4753-4bba-b4fb-a45ce4f7a04e","type":"message","text":"I believe before we started discussing the two-types solution you gave me an example involving a specified output type. Is that the way?","user":"U01L0RJC6FM","ts":"1611829254.486900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"s0ca2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I believe before we started discussing the two-types solution you gave me an example involving a specified output type. Is that the way?"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"6a337ead-6a56-4388-a476-d70747d91543","type":"message","text":"I'm not 100% when it fails to do this \"union-splitting\". It seems to be when the possible types begin to multiply. So anything you can do to tell the compiler that `x` is CERTAINLY of some specific type will stop this multiplication of possible types and result in faster code","user":"U7HAYKY9X","ts":"1611837654.487500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"tne","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not 100% when it fails to do this \"union-splitting\". It seems to be when the possible types begin to multiply. So anything you can do to tell the compiler that "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" is CERTAINLY of some specific type will stop this multiplication of possible types and result in faster code"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"cee3a87b-144f-4ddd-b04a-65c71b6225d7","type":"message","text":"thanks, you have pointed me in the right direction I feel. I learned a lot!","user":"U01L0RJC6FM","ts":"1611838544.487800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"WgRz=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thanks, you have pointed me in the right direction I feel. I learned a lot!"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"fbc8b6c3-9213-487f-8a48-11d743fea95e","type":"message","text":"I found this article discussing Union types and type stability:","user":"U01L0RJC6FM","ts":"1611838560.488000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/INH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I found this article discussing Union types and type stability:"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ab1ae31f-b391-459d-8aa5-6d252f93c09c","type":"message","text":"<https://julialang.org/blog/2018/08/union-splitting/>","user":"U01L0RJC6FM","ts":"1611838564.488200","team":"T68168MUP","attachments":[{"title":"Union-splitting: what it is, and why you should care","title_link":"https://julialang.org/blog/2018/08/union-splitting/","text":"Union-splitting: what it is, and why you should care | Among those who follow Julia's development closely, one of the (many) new features causing great excitement is something called","fallback":"Union-splitting: what it is, and why you should care","image_url":"https://julialang.org/assets/images/julia-open-graph.png","from_url":"https://julialang.org/blog/2018/08/union-splitting/","image_width":500,"image_height":250,"image_bytes":742374,"service_name":"julialang.org","id":1,"original_url":"https://julialang.org/blog/2018/08/union-splitting/"}],"blocks":[{"type":"rich_text","block_id":"NEd","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://julialang.org/blog/2018/08/union-splitting/"}]}]}],"thread_ts":"1611743574.414500","parent_user_id":"U01L0RJC6FM","reactions":[{"name":"point_up","users":["U7HAYKY9X"],"count":1}]}]