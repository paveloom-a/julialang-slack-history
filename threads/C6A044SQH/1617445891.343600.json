[{"client_msg_id":"136971f9-5975-456a-ae51-50fc3d90cb52","type":"message","text":"A question on functional programming and efficiency... I am suspecting that I am slowing down my code significanly with the following few lines:\n```  Lmul = (y, _, x) -&gt;  y = Abi*blockldiv!(D, x) # this is just some matrix arithmetic\n  Lmulc = (y, _, x) -&gt;  y = blockrdiv!((x'*Abi), D)'\n  Lop = LinearOperator{T}(size(Abi)..., Lmul, Lmulc, nothing)\n  F = pqrfact(Lop, sketch=:randn, atol, rtol=rtol)```\nA few remarks: I am using the `LowRankApprox`  package found here: <https://github.com/JuliaMatrices/LowRankApprox.jl>. The idea is to define `Lmul`  and `Lmulc`  as functions and compute a low-rank approximation on the fly without ever forming the matrix. I suspect however, that my code is highly inefficient for the compiler as `julia --track-allocation=user`  reports high memory usage on the function definition and LinearOperator. Any pointers as to what I am doing wrong here??","user":"U01L0RJC6FM","ts":"1617445891.343600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pRPQH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"A question on functional programming and efficiency... I am suspecting that I am slowing down my code significanly with the following few lines:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"  Lmul = (y, _, x) ->  y = Abi*blockldiv!(D, x) # this is just some matrix arithmetic\n  Lmulc = (y, _, x) ->  y = blockrdiv!((x'*Abi), D)'\n  Lop = LinearOperator{T}(size(Abi)..., Lmul, Lmulc, nothing)\n  F = pqrfact(Lop, sketch=:randn, atol, rtol=rtol)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"A few remarks: I am using the "},{"type":"text","text":"LowRankApprox","style":{"code":true}},{"type":"text","text":"  package found here: "},{"type":"link","url":"https://github.com/JuliaMatrices/LowRankApprox.jl"},{"type":"text","text":". The idea is to define "},{"type":"text","text":"Lmul","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"Lmulc","style":{"code":true}},{"type":"text","text":"  as functions and compute a low-rank approximation on the fly without ever forming the matrix. I suspect however, that my code is highly inefficient for the compiler as"},{"type":"text","text":" julia --track-allocation=user","style":{"code":true}},{"type":"text","text":"  reports high memory usage on the function definition and LinearOperator. Any pointers as to what I am doing wrong here??"}]}]}],"thread_ts":"1617445891.343600","reply_count":54,"reply_users_count":4,"latest_reply":"1617475393.376700","reply_users":["UH24GRBLL","U01L0RJC6FM","U012XER8K4M","U01PLQWQXPV"],"is_locked":false,"subscribed":false},{"client_msg_id":"c3bc6b7f-9e01-471c-ae7b-ef9f616c1a84","type":"message","text":"`Abi` is not passed into that function, so that means it's capture from the outside","user":"UH24GRBLL","ts":"1617446412.343700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uvAGd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Abi","style":{"code":true}},{"type":"text","text":" is not passed into that function, so that means it's capture from the outside"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"b009a1de-77b1-4c47-a829-8e7647815716","type":"message","text":"I suspect your allocation tracking is measuring the effect of compiling those anonymous functions as well as the accesses to the outer scope","user":"UH24GRBLL","ts":"1617446459.343900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1ANK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I suspect your allocation tracking is measuring the effect of compiling those anonymous functions as well as the accesses to the outer scope"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"d98a37e2-298a-4dd4-8124-bde9734e160e","type":"message","text":"is this code placed in global or local scope?","user":"UH24GRBLL","ts":"1617446468.344100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3r/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"is this code placed in global or local scope?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"c4eb8919-99f6-439a-82e1-0be85f39452a","type":"message","text":"it's in local scipe","user":"U01L0RJC6FM","ts":"1617446481.344300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S7TWz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it's in local scipe"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"91553b6f-23ed-43c6-9276-05598252bcf3","type":"message","text":"and no Abi and D are not passed to the function as `LinearOperator`  wants something that takes `x` , modifies it and writes it into `y`","user":"U01L0RJC6FM","ts":"1617446533.344500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Uh7B9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and no Abi and D are not passed to the function as "},{"type":"text","text":"LinearOperator","style":{"code":true}},{"type":"text","text":"  wants something that takes "},{"type":"text","text":"x","style":{"code":true}},{"type":"text","text":" , modifies it and writes it into "},{"type":"text","text":"y","style":{"code":true}}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"cab8bc83-5009-45cb-ae3c-4f9d7b28567f","type":"message","text":"well you're not actually modifying `y` at all though","user":"UH24GRBLL","ts":"1617446550.344700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HpT2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"well you're not actually modifying "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" at all though"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ee3ad476-8a39-4315-9f7c-4a9563800105","type":"message","text":"I was suspecting the issue to be the generation of many different function types?","user":"U01L0RJC6FM","ts":"1617446554.344900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HPu","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was suspecting the issue to be the generation of many different function types?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"2bd58f2e-8c2a-4312-b84d-4f6187abb8ba","type":"message","text":"you'd need `y .= ..` for that","user":"UH24GRBLL","ts":"1617446560.345100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LwDL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you'd need "},{"type":"text","text":"y .= ..","style":{"code":true}},{"type":"text","text":" for that"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"0cf3c549-5b1c-42ab-b5ab-01a927039d6e","type":"message","text":"am I not overwriting y?","user":"U01L0RJC6FM","ts":"1617446571.345300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VlczH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"am I not overwriting y?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"89aed363-48d8-43cd-90df-40f76eeb1e75","type":"message","text":"as it stands, you're rebinding the variable name `y` in the anonymous function","user":"UH24GRBLL","ts":"1617446586.345500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W=Xt","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"as it stands, you're rebinding the variable name "},{"type":"text","text":"y","style":{"code":true}},{"type":"text","text":" in the anonymous function"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"f999dbf5-b732-4386-b761-8d33555f385c","type":"message","text":"right, of course","user":"U01L0RJC6FM","ts":"1617446597.345700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dPw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"right, of course"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"accc839f-e0e6-4072-bc11-0e9f6191c0b6","type":"message","text":"`Abi * blockldiv!` probably also manifests an array","user":"UH24GRBLL","ts":"1617446608.345900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KZxR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Abi * blockldiv!","style":{"code":true}},{"type":"text","text":" probably also manifests an array"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"3a462184-3f0f-47dc-bad7-326764146c43","type":"message","text":"hmm, that is fine as Abi itself is efficient and D\\x has only a few columns","user":"U01L0RJC6FM","ts":"1617446665.346100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IGv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm, that is fine as Abi itself is efficient and D\\x has only a few columns"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"148b5724-face-4d5f-8daf-959ffc2b3041","type":"message","text":"so it executes `blockldiv!`  on x, then multiplies with `Abi` .","user":"U01L0RJC6FM","ts":"1617446726.346300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cGK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so it executes"},{"type":"text","text":" blockldiv!","style":{"code":true}},{"type":"text","text":"  on x, then multiplies with "},{"type":"text","text":"Abi","style":{"code":true}},{"type":"text","text":" ."}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"920a0491-8f95-465e-a245-a9e6ab306127","type":"message","text":"On the compiler end and the generation of generic functions like this, there are no issues?","user":"U01L0RJC6FM","ts":"1617446748.346500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vF2U","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"On the compiler end and the generation of generic functions like this, there are no issues?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"bc664182-1bac-4e1e-849c-076bb8ccbc37","type":"message","text":"should be fine, but I have to admit that I don't know what `LinearOperator` expects as an API","user":"UH24GRBLL","ts":"1617446808.346700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q3xd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"should be fine, but I have to admit that I don't know what "},{"type":"text","text":"LinearOperator","style":{"code":true}},{"type":"text","text":" expects as an API"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"9879dbff-1e78-4eb2-adbb-3acd1cb6cbdc","type":"message","text":"one sec, lemme find the code","user":"U01L0RJC6FM","ts":"1617446837.346900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MZ2wg","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"one sec, lemme find the code"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"456ec820-dd9b-4c02-9ae8-e11dd6403b52","type":"message","text":"<https://github.com/JuliaMatrices/LowRankApprox.jl/blob/master/src/linop.jl>","user":"U01L0RJC6FM","ts":"1617446853.347100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KPbc","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/JuliaMatrices/LowRankApprox.jl/blob/master/src/linop.jl"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"cd307575-d293-412a-809b-299d185ff4b8","type":"message","text":"```mutable struct LinearOperator{T} &lt;: AbstractLinOp{T}\n  m::Int\n  n::Int\n  mul!::Function\n  mulc!::Function\n  _tmp::Nullable{Array{T}}\nend```","user":"U01L0RJC6FM","ts":"1617446868.347300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5gd","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct LinearOperator{T} <: AbstractLinOp{T}\n  m::Int\n  n::Int\n  mul!::Function\n  mulc!::Function\n  _tmp::Nullable{Array{T}}\nend"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"6b87d775-137f-4b1b-8564-17ab72a3c8d8","type":"message","text":"I should note that this function is called many many times recursively so what I am afraid of is that I have many generic functions and that this is slowing down the whole thing","user":"U01L0RJC6FM","ts":"1617446959.347500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"CjfiL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I should note that this function is called many many times recursively so what I am afraid of is that I have many generic functions and that this is slowing down the whole thing"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"07d2ac3f-07af-4ed9-9ad5-d0d667d33f24","type":"message","text":"as long as `Abi` is type stable, it shouldn't matter and should only generate a single anonymous function","user":"UH24GRBLL","ts":"1617447359.347700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"e66jE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"as long as "},{"type":"text","text":"Abi","style":{"code":true}},{"type":"text","text":" is type stable, it shouldn't matter and should only generate a single anonymous function"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"f091ac1b-8bba-4e87-8fe1-1c8a2575c088","type":"message","text":"hmm... not sure about that","user":"U01L0RJC6FM","ts":"1617447390.347900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"q+Rk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm... not sure about that"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"371914aa-6c24-401d-89aa-c1588749cabf","type":"message","text":"about it being type stable or about it only generating a single anonymous function?","user":"UH24GRBLL","ts":"1617447478.348100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cc2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"about it being type stable or about it only generating a single anonymous function?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"db69dbfd-e6c6-44d5-b539-4b2109f9870a","type":"message","text":"`Abi`  is a `BlockMatrix{T, T11, T12, T21, T22}` object, where all of the `T11`  etc. are `&lt;: AbstractMatrix` . So I have a line before that where `Abi`  is computed at runtime but it has the potential to be of other types","user":"U01L0RJC6FM","ts":"1617447484.348300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HtPy2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Abi","style":{"code":true}},{"type":"text","text":"  is a "},{"type":"text","text":"BlockMatrix{T, T11, T12, T21, T22}","style":{"code":true}},{"type":"text","text":" object, where all of the "},{"type":"text","text":"T11","style":{"code":true}},{"type":"text","text":"  etc. are "},{"type":"text","text":"<: AbstractMatrix","style":{"code":true}},{"type":"text","text":" . So I have a line before that where "},{"type":"text","text":"Abi","style":{"code":true}},{"type":"text","text":"  is computed at runtime but it has the potential to be of other types"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"2819389f-dd77-488c-94d9-03f45222ab7d","type":"message","text":"what does `@code_warntype` say?","user":"UH24GRBLL","ts":"1617447501.348500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1Fh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what does "},{"type":"text","text":"@code_warntype","style":{"code":true}},{"type":"text","text":" say?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"13677ebe-caa4-4134-b5cd-3a5bde97d500","type":"message","text":"if `Abi` is unstable, the anonymous function has to dispatch dynamically, which will probably lead to compilation and overhead etc etc","user":"UH24GRBLL","ts":"1617447550.348700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HPE7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if "},{"type":"text","text":"Abi","style":{"code":true}},{"type":"text","text":" is unstable, the anonymous function has to dispatch dynamically, which will probably lead to compilation and overhead etc etc"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"5197adac-f615-4bfe-878f-5004c7434309","type":"message","text":"thats my isee// I cant debug the code with code_warntype.. at least if I call it from the top i get\n```Variables\n  #s9::Core.Const(Main.HierarchicalSolvers.var\"#factor##kw\"())\n  @_2::NamedTuple{(:swlevel, :atol, :rtol, :kest, :stepsize, :leafsize, :verbose), Tuple{Int64, Float64, Float64, Int64, Int64, Int64, Bool}}\n  @_3::Core.Const(Main.HierarchicalSolvers.factor)\n  A::SparseMatrixCSC{Float64, Int64}\n  nd::BinaryNode{Tuple{Vector{Int64}, Vector{Int64}}}\n\nBody::Any\n1 ─ %1 = Main.HierarchicalSolvers.SolverOptions()::SolverOptions\n│   %2 = (#s9)(@_2, @_3, A, nd, %1)::Any\n└──      return %2```","user":"U01L0RJC6FM","ts":"1617447690.348900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+Q7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thats my isee// I cant debug the code with code_warntype.. at least if I call it from the top i get\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Variables\n  #s9::Core.Const(Main.HierarchicalSolvers.var\"#factor##kw\"())\n  @_2::NamedTuple{(:swlevel, :atol, :rtol, :kest, :stepsize, :leafsize, :verbose), Tuple{Int64, Float64, Float64, Int64, Int64, Int64, Bool}}\n  @_3::Core.Const(Main.HierarchicalSolvers.factor)\n  A::SparseMatrixCSC{Float64, Int64}\n  nd::BinaryNode{Tuple{Vector{Int64}, Vector{Int64}}}\n\nBody::Any\n1 ─ %1 = Main.HierarchicalSolvers.SolverOptions()::SolverOptions\n│   %2 = (#s9)(@_2, @_3, A, nd, %1)::Any\n└──      return %2"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"d07ae1fd-6cda-443c-a599-0e9e8f280d18","type":"message","text":"i think there is some isse with the options that I pass to the functions which is completely unrelated","user":"U01L0RJC6FM","ts":"1617447715.349100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"rlW9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"i think there is some isse with the options that I pass to the functions which is completely unrelated"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"5cd7b560-6604-45a7-b907-c4a97d9dd62a","type":"message","text":"You might want to take a look at Cthulhu.jl then","user":"UH24GRBLL","ts":"1617448074.349300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0=ui","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You might want to take a look at Cthulhu.jl then"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"4961ca84-9c39-4aae-8fce-af533e5d5318","type":"message","text":"I will! I didn't come around to try it out yet","user":"U01L0RJC6FM","ts":"1617448434.349500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S+phL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I will! I didn't come around to try it out yet"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"2950f0eb-ab91-4ef1-83c3-2b87c03fc056","type":"message","text":"thanks a lot for your help :slightly_smiling_face:","user":"U01L0RJC6FM","ts":"1617448447.349700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"chHEh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"thanks a lot for your help "},{"type":"emoji","name":"slightly_smiling_face"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"7f2a5058-77bc-4ae4-a899-50be67fdbaad","type":"message","text":"follow-up question on a question i posted earlier:\n\nI believe that I have a type stability issue with the following function:\n```function _assemble_blocks(A::AbstractMatrix{T}, S1::AbstractMatrix{T}, S2::AbstractMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}; args...) where T\n  ni1 = length(int1); nb1 = length(bnd1)\n  ni2 = length(int2); nb2 = length(bnd2)\n  Aii = BlockMatrix(S1[1:ni1, 1:ni1], A[int1, int2], A[int2, int1], S2[1:ni2, 1:ni2])\n  Aib = BlockMatrix(S1[1:ni1, ni1+1:ni1+nb1], A[int1, bnd2], A[int2, bnd1], S2[1:ni2, ni2+1:ni2+nb2])\n  Abi = BlockMatrix(S1[ni1+1:ni1+nb1, 1:ni1], A[bnd1, int2], A[bnd2, int1], S2[ni2+1:ni2+nb2, 1:ni2])\n  Abb = BlockMatrix(S1[ni1+1:ni1+nb1, ni1+1:ni1+nb1], A[bnd1, bnd2], A[bnd2, bnd1], S2[ni2+1:ni2+nb2, ni2+1:ni2+nb2])\n  return Aii, Aib, Abi, Abb\nend```\n`@code_warntype`  complains that the return type is `Ntuple{4,Any}`  and I believe that this is where all my trouble originates. The members of the tuple are all `BlockMatrix{T,T11,T12,T21,T22}`  types with same `T`  but different `T11`  etc. however they're all `AbstractArray` . Am I understanding it right that at the end when this ufnction gets called\n```Aii, Aib, Abi, Abb = _assemble_blocks(...)```\ntype-inference stops working as `Aii`  is of type `Any` ? If so, what would be a better way of writing `_assemble_blocks` ? Should I define the return-type?","user":"U01L0RJC6FM","ts":"1617456027.350000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ksX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"follow-up question on a question i posted earlier:\n\nI believe that I have a type stability issue with the following function:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function _assemble_blocks(A::AbstractMatrix{T}, S1::AbstractMatrix{T}, S2::AbstractMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}; args...) where T\n  ni1 = length(int1); nb1 = length(bnd1)\n  ni2 = length(int2); nb2 = length(bnd2)\n  Aii = BlockMatrix(S1[1:ni1, 1:ni1], A[int1, int2], A[int2, int1], S2[1:ni2, 1:ni2])\n  Aib = BlockMatrix(S1[1:ni1, ni1+1:ni1+nb1], A[int1, bnd2], A[int2, bnd1], S2[1:ni2, ni2+1:ni2+nb2])\n  Abi = BlockMatrix(S1[ni1+1:ni1+nb1, 1:ni1], A[bnd1, int2], A[bnd2, int1], S2[ni2+1:ni2+nb2, 1:ni2])\n  Abb = BlockMatrix(S1[ni1+1:ni1+nb1, ni1+1:ni1+nb1], A[bnd1, bnd2], A[bnd2, bnd1], S2[ni2+1:ni2+nb2, ni2+1:ni2+nb2])\n  return Aii, Aib, Abi, Abb\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"@code_warntype","style":{"code":true}},{"type":"text","text":"  complains that the return type is "},{"type":"text","text":"Ntuple{4,Any}","style":{"code":true}},{"type":"text","text":"  and I believe that this is where all my trouble originates. The members of the tuple are all "},{"type":"text","text":"BlockMatrix{T,T11,T12,T21,T22}","style":{"code":true}},{"type":"text","text":"  types with same "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":"  but different "},{"type":"text","text":"T11","style":{"code":true}},{"type":"text","text":"  etc. however they're all "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" . Am I understanding it right that at the end when this ufnction gets called\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"Aii, Aib, Abi, Abb = _assemble_blocks(...)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"type-inference stops working as "},{"type":"text","text":"Aii","style":{"code":true}},{"type":"text","text":"  is of type "},{"type":"text","text":"Any","style":{"code":true}},{"type":"text","text":" ? If so, what would be a better way of writing "},{"type":"text","text":"_assemble_blocks","style":{"code":true}},{"type":"text","text":" ? Should I define the return-type?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"f3006172-7499-4c4c-9783-d8d6a98085b9","type":"message","text":"I see no type instability here. I tried feeding it some input but it seems a bit complicated. Do you have a minimal example to reproduce the input?","user":"U012XER8K4M","ts":"1617457205.350300","team":"T68168MUP","edited":{"user":"U012XER8K4M","ts":"1617457217.000000"},"blocks":[{"type":"rich_text","block_id":"eNZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see no type instability here. I tried feeding it some input but it seems a bit complicated. Do you have a minimal example to reproduce the input?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"0de2d802-c077-4115-87b1-61dc6c55841f","type":"message","text":"yes, lemme try and put it all in a file","user":"U01L0RJC6FM","ts":"1617457798.350800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"r5MR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes, lemme try and put it all in a file"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"603df6dc-7c08-4a66-af2e-48c8dbd9cdbd","type":"message","text":"```using SparseArrays\n\nA = sprandn(100,100,0.1);\nint1 = Vector(1:10); int2 = Vector(11:20)\nbnd1 = Vector(21:30); bnd2 = Vector(31:40)\nS1 = randn(10,10); S2 = randn(10,10)\n\nfunction _assemble_blocks(A::AbstractMatrix{T}, S1::AbstractMatrix{T}, S2::AbstractMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}; args...) where T\n  ni1 = length(int1); nb1 = length(bnd1)\n  ni2 = length(int2); nb2 = length(bnd2)\n  Aii = BlockMatrix(S1[1:ni1, 1:ni1], A[int1, int2], A[int2, int1], S2[1:ni2, 1:ni2])\n  Aib = BlockMatrix(S1[1:ni1, ni1+1:ni1+nb1], A[int1, bnd2], A[int2, bnd1], S2[1:ni2, ni2+1:ni2+nb2])\n  Abi = BlockMatrix(S1[ni1+1:ni1+nb1, 1:ni1], A[bnd1, int2], A[bnd2, int1], S2[ni2+1:ni2+nb2, 1:ni2])\n  Abb = BlockMatrix(S1[ni1+1:ni1+nb1, ni1+1:ni1+nb1], A[bnd1, bnd2], A[bnd2, bnd1], S2[ni2+1:ni2+nb2, ni2+1:ni2+nb2])\n  return Aii, Aib, Abi, Abb\nend```","user":"U01L0RJC6FM","ts":"1617457974.351000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+iDH","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using SparseArrays\n\nA = sprandn(100,100,0.1);\nint1 = Vector(1:10); int2 = Vector(11:20)\nbnd1 = Vector(21:30); bnd2 = Vector(31:40)\nS1 = randn(10,10); S2 = randn(10,10)\n\nfunction _assemble_blocks(A::AbstractMatrix{T}, S1::AbstractMatrix{T}, S2::AbstractMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}; args...) where T\n  ni1 = length(int1); nb1 = length(bnd1)\n  ni2 = length(int2); nb2 = length(bnd2)\n  Aii = BlockMatrix(S1[1:ni1, 1:ni1], A[int1, int2], A[int2, int1], S2[1:ni2, 1:ni2])\n  Aib = BlockMatrix(S1[1:ni1, ni1+1:ni1+nb1], A[int1, bnd2], A[int2, bnd1], S2[1:ni2, ni2+1:ni2+nb2])\n  Abi = BlockMatrix(S1[ni1+1:ni1+nb1, 1:ni1], A[bnd1, int2], A[bnd2, int1], S2[ni2+1:ni2+nb2, 1:ni2])\n  Abb = BlockMatrix(S1[ni1+1:ni1+nb1, ni1+1:ni1+nb1], A[bnd1, bnd2], A[bnd2, bnd1], S2[ni2+1:ni2+nb2, ni2+1:ni2+nb2])\n  return Aii, Aib, Abi, Abb\nend"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"6c95024c-6768-49e7-bf82-e8e8cc5be783","type":"message","text":"`@code_warntype _assemble_blocks(A, S1, S2, int1, int2, bnd1, bnd2)`  gives me said problem","user":"U01L0RJC6FM","ts":"1617457991.351200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ORnXm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"@code_warntype _assemble_blocks(A, S1, S2, int1, int2, bnd1, bnd2)","style":{"code":true}},{"type":"text","text":"  gives me said problem"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"32b7328c-e65f-45b7-8481-85825b4f9be2","type":"message","text":"I can't run run this code using `SparseArrays` . Are you also using `BlockArrays` ?","user":"U01PLQWQXPV","ts":"1617458639.351500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qQw8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I can't run run this code using "},{"type":"text","text":"SparseArrays","style":{"code":true}},{"type":"text","text":" . Are you also using "},{"type":"text","text":"BlockArrays","style":{"code":true}},{"type":"text","text":" ?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"246d7e35-615a-4729-a167-6eb03742be76","type":"message","text":"I assumed this it BlockArrays, but, this code doesn't work for me?\n```ERROR: MethodError: no method matching BlockArray{T,2,R,BS} where BS&lt;:Tuple{AbstractUnitRange{Int64},AbstractUnitRange{Int64}} where R&lt;:(AbstractArray{var\"#s24\",2} where var\"#s24\"&lt;:AbstractArray{T,2}) where T(::Array{Float64,2}, ::SparseMatrixCSC{Float64,Int64}, ::SparseMatrixCSC{Float64,Int64}, ::Array{Float64,2})```\n","user":"U012XER8K4M","ts":"1617459151.351700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kv0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I assumed this it BlockArrays, but, this code doesn't work for me?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ERROR: MethodError: no method matching BlockArray{T,2,R,BS} where BS<:Tuple{AbstractUnitRange{Int64},AbstractUnitRange{Int64}} where R<:(AbstractArray{var\"#s24\",2} where var\"#s24\"<:AbstractArray{T,2}) where T(::Array{Float64,2}, ::SparseMatrixCSC{Float64,Int64}, ::SparseMatrixCSC{Float64,Int64}, ::Array{Float64,2})"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"cfde1231-36a3-47f7-bb6a-5b9b2d1976b1","type":"message","text":"ah my bad","user":"U01L0RJC6FM","ts":"1617465205.356600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"M59","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah my bad"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"b4b950ad-8543-4c2c-a3bc-7d8cd454c5e2","type":"message","text":"I was quite distracted","user":"U01L0RJC6FM","ts":"1617465212.356800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hvD1b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was quite distracted"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"75bb54a7-aede-4318-a5fb-578a3e619cfb","type":"message","text":"ok now I am quite confused","user":"U01L0RJC6FM","ts":"1617465369.357500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=/WK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ok now I am quite confused"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"493e1157-f15a-4b07-bb12-fe6ea3e8aa9f","type":"message","text":"my MWE has no issues withe `code_warntype`","user":"U01L0RJC6FM","ts":"1617465405.357700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K1p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"my MWE has no issues withe "},{"type":"text","text":"code_warntype","style":{"code":true}}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"902d93ce-b110-49e7-82af-018d83215f42","type":"message","text":"I am sorry for the long code but this is sort of the minimum","user":"U01L0RJC6FM","ts":"1617465424.357900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UZN","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am sorry for the long code but this is sort of the minimum"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"12d56d3f-caab-4b3d-aabd-d9b7f3917798","type":"message","text":"```using SparseArrays, HssMatrices, LowRankApprox\n\n# 2x2 block matrix that can hold any type of \nstruct BlockMatrix{T, T11 &lt;: AbstractMatrix{T}, T12 &lt;: AbstractMatrix{T}, T21 &lt;: AbstractMatrix{T}, T22 &lt;: AbstractMatrix{T}} &lt;: AbstractMatrix{T}\n  A11::T11\n  A12::T12\n  A21::T21\n  A22::T22\n\n  # inner constructor checks for consistency among dimensions\n  function BlockMatrix(A11::AbstractMatrix{T}, A12::AbstractMatrix{T}, A21::AbstractMatrix{T}, A22::AbstractMatrix{T}) where T\n    size(A11, 1) == size(A12, 1) || throw(DimensionMismatch(\"first dimension of A11 and A12 do not match. Expected $(size(A11, 1)), got $(size(A12, 1))\"))\n    size(A11, 2) == size(A21, 2) || throw(DimensionMismatch(\"second dimension of A11 and A12 do not match. Expected $(size(A11, 2)), got $(size(A21, 2))\"))\n    size(A22, 1) == size(A21, 1) || throw(DimensionMismatch(\"first dimension of A22 and A21 do not match. Expected $(size(A22, 1)), got $(size(A21, 1))\"))\n    size(A22, 2) == size(A12, 2) || throw(DimensionMismatch(\"second dimension of A22 and A12 do not match. Expected $(size(A22, 2)), got $(size(A12, 2))\"))\n    new{T, typeof(A11), typeof(A12), typeof(A21), typeof(A22)}(A11, A12, A21, A22)\n  end\nend\n\nfunction _assemble_blocks(A::AbstractMatrix{T}, S1::AbstractMatrix{T}, S2::AbstractMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}; args...) where T\n  ni1 = length(int1); nb1 = length(bnd1)\n  ni2 = length(int2); nb2 = length(bnd2)\n  Aii = BlockMatrix(S1[1:ni1, 1:ni1], A[int1, int2], A[int2, int1], S2[1:ni2, 1:ni2])\n  Aib = BlockMatrix(S1[1:ni1, ni1+1:ni1+nb1], A[int1, bnd2], A[int2, bnd1], S2[1:ni2, ni2+1:ni2+nb2])\n  Abi = BlockMatrix(S1[ni1+1:ni1+nb1, 1:ni1], A[bnd1, int2], A[bnd2, int1], S2[ni2+1:ni2+nb2, 1:ni2])\n  Abb = BlockMatrix(S1[ni1+1:ni1+nb1, ni1+1:ni1+nb1], A[bnd1, bnd2], A[bnd2, bnd1], S2[ni2+1:ni2+nb2, ni2+1:ni2+nb2])\n  return Aii, Aib, Abi, Abb\nend\n\n# For HSS matrices we want to specialize the routine in order to exploit the pre-determined blocking which exposes interior DOFs\nfunction _assemble_blocks(A::AbstractMatrix{T}, S1::HssMatrix{T}, S2::HssMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}) where T\n  ni1 = length(int1); ni2 = length(int2); nb1 = length(bnd1); nb2 = length(bnd2)\n  # TODO: check that the blocking is actually\n  rcl1, ccl1 = cluster(S1.A11); rcl2, ccl2 = cluster(S2.A11)\n  # equilibrate blocking, checks only rcl, as ccl should be compatible with rcl\n  if !compatible(rcl1, rcl2)\n    while !compatible(rcl1, rcl2)\n      if depth(rcl1) &gt; depth(rcl2)\n        verbose &amp;&amp; println(\"Pruning clusters of node 1\")\n        rcl1 = prune_leaves!(rcl1); ccl1 = prune_leaves!(ccl1)\n        S1.A11 = prune_leaves!(S1.A11)\n      elseif depth(rcl1) &lt; depth(rcl2)\n        verbose &amp;&amp; println(\"Pruning clusters of node 2\")\n        rcl2 = prune_leaves!(rcl2); ccl2 = prune_leaves!(ccl2)\n        S2.A11 = prune_leaves!(S2.A11)\n      else\n        verbose &amp;&amp; println(\"Pruning both clusters\")\n        rcl1 = prune_leaves!(rcl1); ccl1 = prune_leaves!(ccl1)\n        rcl2 = prune_leaves!(rcl2); ccl2 = prune_leaves!(ccl2)\n        S1.A11 = prune_leaves!(S1.A11)\n        S2.A11 = prune_leaves!(S2.A11)\n      end\n    end\n  end\n  # extract generators of children Schur complements\n  Uint1, Vint1 = generators(S1.A11); Uint1 = Uint1*S1.B12\n  Uint2, Vint2 = generators(S2.A11); Uint2 = Uint2*S2.B12\n  Ubnd1, Vbnd1 = generators(S1.A22); Ubnd1 = Ubnd1*S1.B21\n  Ubnd2, Vbnd2 = generators(S2.A22); Ubnd2 = Ubnd2*S2.B21\n  # form the blocks\n  Aii = BlockMatrix(S1.A11, A[int1, int2], A[int2, int1], S2.A11)\n  Aib = BlockMatrix(LowRankMatrix(Uint1, Vbnd1), A[int1, bnd2], A[int2, bnd1], LowRankMatrix(Uint2, Vbnd2))\n  Abi = BlockMatrix(LowRankMatrix(Ubnd1, Vint1), A[bnd1, int2], A[bnd2, int1], LowRankMatrix(Ubnd2, Vint2))\n  Abb = BlockMatrix(S1.A22, A[bnd1, bnd2], A[bnd2, bnd1], S2.A22)\n  return Aii, Aib, Abi, Abb\nend\n\nA = sprandn(1000,1000,0.1);\nint1 = Vector(1:100); int2 = Vector(101:200)\nbnd1 = Vector(201:300); bnd2 = Vector(301:400)\nS1 = hss(randn(100,100)); S2 = hss(randn(100,100))```","user":"U01L0RJC6FM","ts":"1617466101.360500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"y4Sz","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using SparseArrays, HssMatrices, LowRankApprox\n\n# 2x2 block matrix that can hold any type of \nstruct BlockMatrix{T, T11 <: AbstractMatrix{T}, T12 <: AbstractMatrix{T}, T21 <: AbstractMatrix{T}, T22 <: AbstractMatrix{T}} <: AbstractMatrix{T}\n  A11::T11\n  A12::T12\n  A21::T21\n  A22::T22\n\n  # inner constructor checks for consistency among dimensions\n  function BlockMatrix(A11::AbstractMatrix{T}, A12::AbstractMatrix{T}, A21::AbstractMatrix{T}, A22::AbstractMatrix{T}) where T\n    size(A11, 1) == size(A12, 1) || throw(DimensionMismatch(\"first dimension of A11 and A12 do not match. Expected $(size(A11, 1)), got $(size(A12, 1))\"))\n    size(A11, 2) == size(A21, 2) || throw(DimensionMismatch(\"second dimension of A11 and A12 do not match. Expected $(size(A11, 2)), got $(size(A21, 2))\"))\n    size(A22, 1) == size(A21, 1) || throw(DimensionMismatch(\"first dimension of A22 and A21 do not match. Expected $(size(A22, 1)), got $(size(A21, 1))\"))\n    size(A22, 2) == size(A12, 2) || throw(DimensionMismatch(\"second dimension of A22 and A12 do not match. Expected $(size(A22, 2)), got $(size(A12, 2))\"))\n    new{T, typeof(A11), typeof(A12), typeof(A21), typeof(A22)}(A11, A12, A21, A22)\n  end\nend\n\nfunction _assemble_blocks(A::AbstractMatrix{T}, S1::AbstractMatrix{T}, S2::AbstractMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}; args...) where T\n  ni1 = length(int1); nb1 = length(bnd1)\n  ni2 = length(int2); nb2 = length(bnd2)\n  Aii = BlockMatrix(S1[1:ni1, 1:ni1], A[int1, int2], A[int2, int1], S2[1:ni2, 1:ni2])\n  Aib = BlockMatrix(S1[1:ni1, ni1+1:ni1+nb1], A[int1, bnd2], A[int2, bnd1], S2[1:ni2, ni2+1:ni2+nb2])\n  Abi = BlockMatrix(S1[ni1+1:ni1+nb1, 1:ni1], A[bnd1, int2], A[bnd2, int1], S2[ni2+1:ni2+nb2, 1:ni2])\n  Abb = BlockMatrix(S1[ni1+1:ni1+nb1, ni1+1:ni1+nb1], A[bnd1, bnd2], A[bnd2, bnd1], S2[ni2+1:ni2+nb2, ni2+1:ni2+nb2])\n  return Aii, Aib, Abi, Abb\nend\n\n# For HSS matrices we want to specialize the routine in order to exploit the pre-determined blocking which exposes interior DOFs\nfunction _assemble_blocks(A::AbstractMatrix{T}, S1::HssMatrix{T}, S2::HssMatrix{T}, int1::Vector{Int}, int2::Vector{Int}, bnd1::Vector{Int}, bnd2::Vector{Int}) where T\n  ni1 = length(int1); ni2 = length(int2); nb1 = length(bnd1); nb2 = length(bnd2)\n  # TODO: check that the blocking is actually\n  rcl1, ccl1 = cluster(S1.A11); rcl2, ccl2 = cluster(S2.A11)\n  # equilibrate blocking, checks only rcl, as ccl should be compatible with rcl\n  if !compatible(rcl1, rcl2)\n    while !compatible(rcl1, rcl2)\n      if depth(rcl1) > depth(rcl2)\n        verbose && println(\"Pruning clusters of node 1\")\n        rcl1 = prune_leaves!(rcl1); ccl1 = prune_leaves!(ccl1)\n        S1.A11 = prune_leaves!(S1.A11)\n      elseif depth(rcl1) < depth(rcl2)\n        verbose && println(\"Pruning clusters of node 2\")\n        rcl2 = prune_leaves!(rcl2); ccl2 = prune_leaves!(ccl2)\n        S2.A11 = prune_leaves!(S2.A11)\n      else\n        verbose && println(\"Pruning both clusters\")\n        rcl1 = prune_leaves!(rcl1); ccl1 = prune_leaves!(ccl1)\n        rcl2 = prune_leaves!(rcl2); ccl2 = prune_leaves!(ccl2)\n        S1.A11 = prune_leaves!(S1.A11)\n        S2.A11 = prune_leaves!(S2.A11)\n      end\n    end\n  end\n  # extract generators of children Schur complements\n  Uint1, Vint1 = generators(S1.A11); Uint1 = Uint1*S1.B12\n  Uint2, Vint2 = generators(S2.A11); Uint2 = Uint2*S2.B12\n  Ubnd1, Vbnd1 = generators(S1.A22); Ubnd1 = Ubnd1*S1.B21\n  Ubnd2, Vbnd2 = generators(S2.A22); Ubnd2 = Ubnd2*S2.B21\n  # form the blocks\n  Aii = BlockMatrix(S1.A11, A[int1, int2], A[int2, int1], S2.A11)\n  Aib = BlockMatrix(LowRankMatrix(Uint1, Vbnd1), A[int1, bnd2], A[int2, bnd1], LowRankMatrix(Uint2, Vbnd2))\n  Abi = BlockMatrix(LowRankMatrix(Ubnd1, Vint1), A[bnd1, int2], A[bnd2, int1], LowRankMatrix(Ubnd2, Vint2))\n  Abb = BlockMatrix(S1.A22, A[bnd1, bnd2], A[bnd2, bnd1], S2.A22)\n  return Aii, Aib, Abi, Abb\nend\n\nA = sprandn(1000,1000,0.1);\nint1 = Vector(1:100); int2 = Vector(101:200)\nbnd1 = Vector(201:300); bnd2 = Vector(301:400)\nS1 = hss(randn(100,100)); S2 = hss(randn(100,100))"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"89a11627-0a57-41c8-b0e0-43cac97c5e41","type":"message","text":"It seems the type instability is stemming from the fact that your HssMatrix is a union type.\n\nChanging the type annotation in the function signature from `::HssMatrix{T}` to `::H... where {H &lt;: HssMatrix[T}` won't help but could it be possible that somewhere in your Hssmatrix library you have a struct field annotated with `HssMatrix`?","user":"U01PLQWQXPV","ts":"1617467384.364800","team":"T68168MUP","edited":{"user":"U01PLQWQXPV","ts":"1617467703.000000"},"blocks":[{"type":"rich_text","block_id":"L0lTl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems the type instability is stemming from the fact that your HssMatrix is a union type.\n\nChanging the type annotation in the function signature from "},{"type":"text","text":"::HssMatrix{T}","style":{"code":true}},{"type":"text","text":" to "},{"type":"text","text":"::H... where {H <: HssMatrix[T}","style":{"code":true}},{"type":"text","text":" won't help but could it be possible that somewhere in your Hssmatrix library you have a struct field annotated with "},{"type":"text","text":"HssMatrix","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"724f9bd4-f276-4158-9a84-ba2316bfce77","type":"message","text":"I do... I realize this might have been a terrible mistake","user":"U01L0RJC6FM","ts":"1617467867.366000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hTQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do... I realize this might have been a terrible mistake"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"c9b2a1bc-347f-4533-ba52-b6c08fc04818","type":"message","text":"actually I just posted without seeing your message about this","user":"U01L0RJC6FM","ts":"1617467888.366300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JeZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"actually I just posted without seeing your message about this"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"9f13befa-45a0-4d71-be05-550f150d9154","type":"message","text":"UnionTypes or AbstractTypes make bad field annotations which prevents proper specialization and usually a way around this is to change something from\n```struct UnstableType\n  x::Union{...}\nend```\nto\n\n```struct StableType{T &lt;: Union{...}}\n  x::T\nend```\nSince `@code_warntype`  is flagging `Base.getproperty(S1, :A11)::HssMatrix{Float64}`, it seems the field `A11` is type unstable","user":"U01PLQWQXPV","ts":"1617467911.366500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"JwiNv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"UnionTypes or AbstractTypes make bad field annotations which prevents proper specialization and usually a way around this is to change something from\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct UnstableType\n  x::Union{...}\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nto\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct StableType{T <: Union{...}}\n  x::T\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nSince "},{"type":"text","text":"@code_warntype","style":{"code":true}},{"type":"text","text":"  is flagging "},{"type":"text","text":"Base.getproperty(S1, :A11)::HssMatrix{Float64}","style":{"code":true}},{"type":"text","text":", it seems the field "},{"type":"text","text":"A11","style":{"code":true}},{"type":"text","text":" is type unstable"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"560a8a92-c17a-4bb4-9a08-dcac6e4795cd","type":"message","text":"<https://github.com/bonevbs/HssMatrices.jl/blob/main/src/hssmatrix.jl>","user":"U01L0RJC6FM","ts":"1617467919.366700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5SpUh","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/bonevbs/HssMatrices.jl/blob/main/src/hssmatrix.jl"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"cecc4bac-6ae4-46ba-9bdb-0b051318b188","type":"message","text":"hmm this seems to be whats is causing all this pain... I am trying to think of a nice way of resolving this without rewriting the entire package","user":"U01L0RJC6FM","ts":"1617468053.366900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3xpM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm this seems to be whats is causing all this pain... I am trying to think of a nice way of resolving this without rewriting the entire package"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"a74c83eb-8b2a-49c5-8604-11f489c35214","type":"message","text":"I would believe the fix is quite straightforward, you just have to move the Union types in the field type annotations to the parametric part\n\nRegarding your package, I was actually not so long ago looking for HOLDR matrices in Julia!","user":"U01PLQWQXPV","ts":"1617468440.367400","team":"T68168MUP","edited":{"user":"U01PLQWQXPV","ts":"1617468481.000000"},"blocks":[{"type":"rich_text","block_id":"3zP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would believe the fix is quite straightforward, you just have to move the Union types in the field type annotations to the parametric part\n\nRegarding your package, I was actually not so long ago looking for HOLDR matrices in Julia!"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ea132b5c-8dfb-4b7c-8221-952843a828f0","type":"message","text":"oh that is cool!  are you working on HODLR matrices? I am on track for finishing my thesis so not much time for writing a package but if you start writing one I would be more than happy to contribute","user":"U01L0RJC6FM","ts":"1617468732.369100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BKsxy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh that is cool!  are you working on HODLR matrices? I am on track for finishing my thesis so not much time for writing a package but if you start writing one I would be more than happy to contribute"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"6788036a-0348-4add-9f09-f4e002882255","type":"message","text":"Not so much into detail. I am dealing with certain 2-point functions in physics which can very coarsely be seen in a HODLR form. If so, standard non-equilibrium problems can be evaluated in O(k * N^2) instead of O(N^3) steps... But yea, even though it's interesting I don't think I'll be spending much time with this, given that I am also approaching the finishing line of my thesis","user":"U01PLQWQXPV","ts":"1617469143.371900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k/tb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Not so much into detail. I am dealing with certain 2-point functions in physics which can very coarsely be seen in a HODLR form. If so, standard non-equilibrium problems can be evaluated in O(k * N^2) instead of O(N^3) steps... But yea, even though it's interesting I don't think I'll be spending much time with this, given that I am also approaching the finishing line of my thesis"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"},{"client_msg_id":"ef6866d0-7317-423f-9a7f-86fa358a6ab5","type":"message","text":"oh that sounds interesting. There are actually many interesting applications to hierarchical matrices and I believe many of them are still to be discovered","user":"U01L0RJC6FM","ts":"1617475393.376700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Uckds","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh that sounds interesting. There are actually many interesting applications to hierarchical matrices and I believe many of them are still to be discovered"}]}]}],"thread_ts":"1617445891.343600","parent_user_id":"U01L0RJC6FM"}]