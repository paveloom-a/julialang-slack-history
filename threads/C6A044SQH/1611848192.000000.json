[{"client_msg_id":"9838e3d1-7393-4f38-88c2-319296482b9c","type":"message","text":"Is it possible to mix ForwardDiff and ReverseDiff to calculate a hessian matrix? For example if the function had 100 input dimensions and 1 output dimension and you wanted to compute the hessian many times?\n\nfull question on <https://discourse.julialang.org/t/repeatedly-calculating-a-hessian-using-both-forwarddiff-and-reversediff/54051|discourse here>","user":"U01C2E6TYEM","ts":"1611848192.000000","team":"T68168MUP","attachments":[{"service_name":"JuliaLang","title":"Repeatedly calculating a hessian using both ForwardDiff and ReverseDiff","title_link":"https://discourse.julialang.org/t/repeatedly-calculating-a-hessian-using-both-forwarddiff-and-reversediff/54051","text":"I would like to calculate a Hessian matrix of a function f:\\mathbb{R}^n \\rightarrow \\mathbb{R} where n\\gg1. In my usecase the Jacobian of f is always needed, and the Hessian may or may not be needed (but this is known before calculation of the Jacobian). Additionally, I only require the Hessian with respect to the first m dimensions, again where n \\gg m &gt; 1, this is because the first m input dimensions are parameters, and the latter are data. I am aware that using diffresults one can recover th...","fallback":"JuliaLang: Repeatedly calculating a hessian using both ForwardDiff and ReverseDiff","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","ts":1611750107,"from_url":"https://discourse.julialang.org/t/repeatedly-calculating-a-hessian-using-both-forwarddiff-and-reversediff/54051","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/repeatedly-calculating-a-hessian-using-both-forwarddiff-and-reversediff/54051"}],"blocks":[{"type":"rich_text","block_id":"y4C","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is it possible to mix ForwardDiff and ReverseDiff to calculate a hessian matrix? For example if the function had 100 input dimensions and 1 output dimension and you wanted to compute the hessian many times?\n\nfull question on "},{"type":"link","url":"https://discourse.julialang.org/t/repeatedly-calculating-a-hessian-using-both-forwarddiff-and-reversediff/54051","text":"discourse here"}]}]}],"thread_ts":"1611848192.000000","reply_count":8,"reply_users_count":2,"latest_reply":"1611848871.001600","reply_users":["UD0NS8PDF","U01C2E6TYEM"],"subscribed":false},{"client_msg_id":"22fee56a-55d9-45b1-8357-67feefc45589","type":"message","text":"It looks like the compiled gradient tape builds in the fact that it’s for Float64, so you can’t then run it on dual numbers","user":"UD0NS8PDF","ts":"1611848330.000200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7OO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It looks like the compiled gradient tape builds in the fact that it’s for Float64, so you can’t then run it on dual numbers"}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"4b0ec47d-3b54-4e25-97cc-189e633a6108","type":"message","text":"I’m not sure how easy it will be to work around that. The dual type has a tag which I think you can disable (for perturbation confusion, there is some unsafe=true or something option). But how big is `m`? I think the number of partials is also part of the type.","user":"UD0NS8PDF","ts":"1611848480.000400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"/kYne","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’m not sure how easy it will be to work around that. The dual type has a tag which I think you can disable (for perturbation confusion, there is some unsafe=true or something option). But how big is "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":"? I think the number of partials is also part of the type."}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"b4cd5238-7dbf-4b77-830e-464a0cb5c400","type":"message","text":"For simplicity's sake one may assume that `m` is single digit, or even 1.","user":"U01C2E6TYEM","ts":"1611848694.000600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8FR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For simplicity's sake one may assume that "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":" is single digit, or even 1."}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"0abb2afa-bf56-4b85-8d64-0eca3ed1a8fb","type":"message","text":"I read about enabling `unsafe = true` but I feel like this is the exact case in which you would _want_ this sort of checking in place. I'm not sure if there is a way around it, if the gradient tape requires Float64s as inputs","user":"U01C2E6TYEM","ts":"1611848772.000800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PugJV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I read about enabling "},{"type":"text","text":"unsafe = true","style":{"code":true}},{"type":"text","text":" but I feel like this is the exact case in which you would "},{"type":"text","text":"want","style":{"italic":true}},{"type":"text","text":" this sort of checking in place. I'm not sure if there is a way around it, if the gradient tape requires Float64s as inputs"}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"64cb874f-bbff-468f-a171-8a0d1f29ba4c","type":"message","text":"Perhaps the inputs when calculating the tape in the first place could be specified to be duals, so it knows \"how\" to handle them when they come up.","user":"U01C2E6TYEM","ts":"1611848819.001000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4Kv=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Perhaps the inputs when calculating the tape in the first place could be specified to be duals, so it knows \"how\" to handle them when they come up."}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"b08dd12e-6b69-43c0-ad34-49c1ffae1c54","type":"message","text":"Then it’s easier, I think ForwardDiff calls this case vector mode (as opposed to chunk mode) and will use `m` partials.","user":"UD0NS8PDF","ts":"1611848825.001200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6Ww","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Then it’s easier, I think ForwardDiff calls this case vector mode (as opposed to chunk mode) and will use "},{"type":"text","text":"m","style":{"code":true}},{"type":"text","text":" partials."}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"89e91c81-ca56-4844-9009-24822a49e692","type":"message","text":"Yes, something like `Dual.(ones(7), [zeros(7) for _ in 1:7]...)`","user":"UD0NS8PDF","ts":"1611848836.001400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UjUVo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, something like "},{"type":"text","text":"Dual.(ones(7), [zeros(7) for _ in 1:7]...)","style":{"code":true}}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"},{"client_msg_id":"a0b53241-7f41-45a7-b6ac-f77d774e606d","type":"message","text":"Thank you, I'll try this suggestion.","user":"U01C2E6TYEM","ts":"1611848871.001600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ULxH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thank you, I'll try this suggestion."}]}]}],"thread_ts":"1611848192.000000","parent_user_id":"U01C2E6TYEM"}]