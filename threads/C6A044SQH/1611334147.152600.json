[{"client_msg_id":"9b2850ab-8f36-450b-a054-58f887017ba3","type":"message","text":"I've realized that you cannot get the pointer to a view of a static array. Is there any reason I should worry about defining a `Base.elsize` in my code to get around this? It does what I expect in a small example.\n```julia&gt; using StaticArrays\n\njulia&gt; m, n, k = 2, 3, 4;\n\njulia&gt; A = @MArray rand(m, n, k);\n\njulia&gt; l = 2;\n\njulia&gt; Av = @view A[:, :, l];\n\njulia&gt; pointer(A)\nPtr{Float64} @0x000000011cb68aa0\n\njulia&gt; pointer(Av)\nERROR: MethodError: no method matching elsize(::Type{MArray{Tuple{2,3,4},Float64,3,24}})\nClosest candidates are:\n  elsize(::Type{var\"#s91\"} where var\"#s91\"&lt;:(Array{T,N} where N)) where T at array.jl:220\n  elsize(::Base.CodeUnits{T,S} where S&lt;:AbstractString) where T at strings/basic.jl:724\n  elsize(::Random.UnsafeView{T}) where T at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Random/src/RNGs.jl:440\n  ...\nStacktrace:\n [1] elsize(::MArray{Tuple{2,3,4},Float64,3,24}) at ./abstractarray.jl:153\n [2] _memory_offset(::MArray{Tuple{2,3,4},Float64,3,24}, ::Int64, ::Int64, ::Int64) at ./abstractarray.jl:1016\n [3] unsafe_convert(::Type{Ptr{Float64}}, ::SubArray{Float64,2,MArray{Tuple{2,3,4},Float64,3,24},Tuple{Base.Slice{SOneTo{2}},Base.Slice{SOneTo{3}},Int64},true}) at ./subarray.jl:408\n [4] pointer(::SubArray{Float64,2,MArray{Tuple{2,3,4},Float64,3,24},Tuple{Base.Slice{SOneTo{2}},Base.Slice{SOneTo{3}},Int64},true}) at ./abstractarray.jl:1006\n [5] pointer(::SizedArray{Tuple{2,3},Float64,2,2,SubArray{Float64,2,MArray{Tuple{2,3,4},Float64,3,24},Tuple{Base.Slice{SOneTo{2}},Base.Slice{SOneTo{3}},Int64},true}}) at /Users/jekozdon/.julia/packages/StaticArrays/NTbHj/src/SizedArray.jl:129\n [6] top-level scope at REPL[7]:1\n\njulia&gt; Base.elsize(::StaticArray{Tp, T}) where {Tp, T} = sizeof(T)\n\njulia&gt; pointer(Av)\nPtr{Float64} @0x000000011cb68ad0\n\njulia&gt; @assert pointer(Av) == pointer(A) + sizeof(eltype(A)) * n * m * (l - 1)```\nI'm using Julia 1.5.3 with StaticArrays v1.0.1","user":"UCRHP2GHE","ts":"1611334147.152600","team":"T68168MUP","edited":{"user":"UCRHP2GHE","ts":"1611334307.000000"},"blocks":[{"type":"rich_text","block_id":"gk3H","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've realized that you cannot get the pointer to a view of a static array. Is there any reason I should worry about defining a "},{"type":"text","text":"Base.elsize","style":{"code":true}},{"type":"text","text":" in my code to get around this? It does what I expect in a small example.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> using StaticArrays\n\njulia> m, n, k = 2, 3, 4;\n\njulia> A = @MArray rand(m, n, k);\n\njulia> l = 2;\n\njulia> Av = @view A[:, :, l];\n\njulia> pointer(A)\nPtr{Float64} @0x000000011cb68aa0\n\njulia> pointer(Av)\nERROR: MethodError: no method matching elsize(::Type{MArray{Tuple{2,3,4},Float64,3,24}})\nClosest candidates are:\n  elsize(::Type{var\"#s91\"} where var\"#s91\"<:(Array{T,N} where N)) where T at array.jl:220\n  elsize(::Base.CodeUnits{T,S} where S<:AbstractString) where T at strings/basic.jl:724\n  elsize(::Random.UnsafeView{T}) where T at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.5/Random/src/RNGs.jl:440\n  ...\nStacktrace:\n [1] elsize(::MArray{Tuple{2,3,4},Float64,3,24}) at ./abstractarray.jl:153\n [2] _memory_offset(::MArray{Tuple{2,3,4},Float64,3,24}, ::Int64, ::Int64, ::Int64) at ./abstractarray.jl:1016\n [3] unsafe_convert(::Type{Ptr{Float64}}, ::SubArray{Float64,2,MArray{Tuple{2,3,4},Float64,3,24},Tuple{Base.Slice{SOneTo{2}},Base.Slice{SOneTo{3}},Int64},true}) at ./subarray.jl:408\n [4] pointer(::SubArray{Float64,2,MArray{Tuple{2,3,4},Float64,3,24},Tuple{Base.Slice{SOneTo{2}},Base.Slice{SOneTo{3}},Int64},true}) at ./abstractarray.jl:1006\n [5] pointer(::SizedArray{Tuple{2,3},Float64,2,2,SubArray{Float64,2,MArray{Tuple{2,3,4},Float64,3,24},Tuple{Base.Slice{SOneTo{2}},Base.Slice{SOneTo{3}},Int64},true}}) at /Users/jekozdon/.julia/packages/StaticArrays/NTbHj/src/SizedArray.jl:129\n [6] top-level scope at REPL[7]:1\n\njulia> Base.elsize(::StaticArray{Tp, T}) where {Tp, T} = sizeof(T)\n\njulia> pointer(Av)\nPtr{Float64} @0x000000011cb68ad0\n\njulia> @assert pointer(Av) == pointer(A) + sizeof(eltype(A)) * n * m * (l - 1)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI'm using Julia 1.5.3 with StaticArrays v1.0.1"}]}]}],"thread_ts":"1611334147.152600","reply_count":2,"reply_users_count":2,"latest_reply":"1611335732.154400","reply_users":["U7HAYKY9X","UCRHP2GHE"],"subscribed":false},{"client_msg_id":"a00712aa-7cfb-4d2b-b4a3-dca2f174cd21","type":"message","text":"You should generally not define methods when you are not the \"owner\" of either the type or the function. However, in this case, this has been fixed on StsticArrays master branch already, so it's probably safe to do so","user":"U7HAYKY9X","ts":"1611335611.154200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FchN=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You should generally not define methods when you are not the \"owner\" of either the type or the function. However, in this case, this has been fixed on StsticArrays master branch already, so it's probably safe to do so"}]}]}],"thread_ts":"1611334147.152600","parent_user_id":"UCRHP2GHE"},{"client_msg_id":"cb8335b2-93f8-442b-a8e6-cd11c51d68e2","type":"message","text":":face_palm: didn't think to check master... Thanks.","user":"UCRHP2GHE","ts":"1611335732.154400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MT2Q","elements":[{"type":"rich_text_section","elements":[{"type":"emoji","name":"face_palm"},{"type":"text","text":" didn't think to check master... Thanks."}]}]}],"thread_ts":"1611334147.152600","parent_user_id":"UCRHP2GHE","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]}]