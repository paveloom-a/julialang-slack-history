[{"client_msg_id":"98a77320-2473-4a33-a57f-37311a7a3b2f","type":"message","text":"I have a situation where I'm reading in a few hundred json files into dataframes, before doing some munging on the data. Each file is first checked that it is not empty, and does not contain empty json (\"[]\") before passing it to\n    table = jsontable(cap_file[end])\n    df = DataFrame(table)\n    df = @transform(df, time = string.(chop.(:time)))\n       @transform(df, time = DateTime.(:time))\nhowever, just occasionally, the time column has an incorrect format. Instead of using colons to separate time it is using periods. I can fix this with a regex, but what I want to do is rap the above in an exception handler, in the catch block try the regex fix, and then go ahead and do the transform again. However, I don't see a way to do a retry in Julia's exception handler. Am I missing something?","user":"U01GFAJRZ44","ts":"1610630951.013000","team":"T68168MUP","edited":{"user":"U01GFAJRZ44","ts":"1610631190.000000"},"blocks":[{"type":"rich_text","block_id":"b4iP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have a situation where I'm reading in a few hundred json files into dataframes, before doing some munging on the data. Each file is first checked that it is not empty, and does not contain empty json (\"[]\") before passing it to\n    table = jsontable(cap_file[end])\n    df = DataFrame(table)\n    df = @transform(df, time = string.(chop.(:time)))\n       @transform(df, time = DateTime.(:time))\nhowever, just occasionally, the time column has an incorrect format. Instead of using colons to separate time it is using periods. I can fix this with a regex, but what I want to do is rap the above in an exception handler, in the catch block try the regex fix, and then go ahead and do the transform again. However, I don't see a way to do a retry in Julia's exception handler. Am I missing something?"}]}]}],"thread_ts":"1610630951.013000","reply_count":1,"reply_users_count":1,"latest_reply":"1610650147.023400","reply_users":["U019K6Q9N15"],"subscribed":false},{"client_msg_id":"0c15fa4a-70fa-4b6a-b979-85b640d2a0ad","type":"message","text":"I think your proposed solution is more complex than it needs to be.\nWrite a function which will reliably convert the time to a date, e.g.\n```function parseTime(timeStr::String)::Date\n  if isColonString(timeStr)\n    return parseColonString(timeStr)\n  else if isDotString(timeStr)\n    return parseDotString(timeStr)\n  else\n    error(\"This is odd!\")\n  end\nend```\nwhere `isColonString` , `parseColonString` , `isDotString` , and `parseDotString` are all function you write yourself,\nand then do\n```df = @transform(df, time=parseTime(:time))```","user":"U019K6Q9N15","ts":"1610650147.023400","team":"T68168MUP","edited":{"user":"U019K6Q9N15","ts":"1610650365.000000"},"blocks":[{"type":"rich_text","block_id":"J+Iy7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think your proposed solution is more complex than it needs to be.\nWrite a function which will reliably convert the time to a date, e.g.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function parseTime(timeStr::String)::Date\n  if isColonString(timeStr)\n    return parseColonString(timeStr)\n  else if isDotString(timeStr)\n    return parseDotString(timeStr)\n  else\n    error(\"This is odd!\")\n  end\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"where "},{"type":"text","text":"isColonString","style":{"code":true}},{"type":"text","text":" , "},{"type":"text","text":"parseColonString","style":{"code":true}},{"type":"text","text":" , "},{"type":"text","text":"isDotString","style":{"code":true}},{"type":"text","text":" , and "},{"type":"text","text":"parseDotString","style":{"code":true}},{"type":"text","text":" are all function you write yourself,\nand then do\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"df = @transform(df, time=parseTime(:time))"}]}]}],"thread_ts":"1610630951.013000","parent_user_id":"U01GFAJRZ44"}]