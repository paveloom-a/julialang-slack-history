[{"client_msg_id":"0c8d268f-717e-4497-ae1b-3b2dbf54c816","type":"message","text":"Say I have an `x &lt;: AbstractArray{R,N+1}` of unknown concrete type. How can I get, without creating new arrays or subarrays, the type of `similar(x, new_dims)`?","user":"ULDCM1P9P","ts":"1617105150.000400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z2A","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Say I have an "},{"type":"text","text":"x <: AbstractArray{R,N+1}","style":{"code":true}},{"type":"text","text":" of unknown concrete type. How can I get, without creating new arrays or subarrays, the type of "},{"type":"text","text":"similar(x, new_dims)","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1617105150.000400","reply_count":9,"reply_users_count":2,"latest_reply":"1617108102.002300","reply_users":["U017LQ3A59U","ULDCM1P9P"],"is_locked":false,"subscribed":false},{"client_msg_id":"80390ebb-3d54-45af-8fc0-38b46bd85c03","type":"message","text":"In general you can't. If I define my own subtype of `AbstractArray` I can always add specific method to `similar` for my subtype that does crazy things with it.","user":"U017LQ3A59U","ts":"1617106933.000700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"v1L8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In general you can't. If I define my own subtype of "},{"type":"text","text":"AbstractArray","style":{"code":true}},{"type":"text","text":" I can always add specific method to "},{"type":"text","text":"similar","style":{"code":true}},{"type":"text","text":" for my subtype that does crazy things with it."}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"e2a710fe-2fd1-4731-8dd4-0ac747a92d30","type":"message","text":"hmm, I see. I was in fact interested in the type of something like `x[:,1:3,1]`, but I guess a similar comment applies :confused:","user":"ULDCM1P9P","ts":"1617107113.000900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dVoq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm, I see. I was in fact interested in the type of something like "},{"type":"text","text":"x[:,1:3,1]","style":{"code":true}},{"type":"text","text":", but I guess a similar comment applies "},{"type":"emoji","name":"confused"}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"e013edb3-b78c-4d0f-b67d-2bc471644ee2","type":"message","text":"Yeah with you example someone could decide to return a view by default while splicing for example, which could even be reasonnable. Why do you need the type?","user":"U017LQ3A59U","ts":"1617107211.001100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PMS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah with you example someone could decide to return a view by default while splicing for example, which could even be reasonnable. Why do you need the type?"}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"d87d2899-4d91-483f-a955-114a64e21528","type":"message","text":"I'm trying to be specific regarding the abstract type of a struct. For instance,\n```struct A{R,N} &lt;: AbstractVector{&lt;:AbstractArray{R,N}} end```\nfails, so I'd need to know exactly what to put inside the `&lt;: AbstractVector{...}` part, which will be dependent in that kind of way on one of my `struct` arguments.","user":"ULDCM1P9P","ts":"1617107500.001300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RTS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm trying to be specific regarding the abstract type of a struct. For instance,\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct A{R,N} <: AbstractVector{<:AbstractArray{R,N}} end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"fails, so I'd need to know exactly what to put inside the "},{"type":"text","text":"<: AbstractVector{...}","style":{"code":true}},{"type":"text","text":" part, which will be dependent in that kind of way on one of my "},{"type":"text","text":"struct","style":{"code":true}},{"type":"text","text":" arguments."}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"36d57d72-d7df-4443-be86-0da45cc5ad60","type":"message","text":"```struct A{R, N, T &lt;: AbstractArray{R, N}} &lt;: AbstractVector{T} end```\nwould be the most common solution I think","user":"U017LQ3A59U","ts":"1617107651.001500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jt0M2","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct A{R, N, T <: AbstractArray{R, N}} <: AbstractVector{T} end"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"would be the most common solution I think"}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"82ec5604-12a5-4bcf-9795-41b2bd8d759f","type":"message","text":"yes yes, the thing is that the T up there is not the type of any of my struct's constructor arguments: I have to infer it based on them.","user":"ULDCM1P9P","ts":"1617107877.001700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"NNo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yes yes, the thing is that the T up there is not the type of any of my struct's constructor arguments: I have to infer it based on them."}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"dc5f606b-4b4c-44cf-bccf-9266294c2a8b","type":"message","text":"You can have a constructor like\n```A(array::T) where {R, N, T &lt;: AbstractArray{R, N}} = A{R, N, T}(...)```\nto collect all the information needed","user":"U017LQ3A59U","ts":"1617107976.001900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W3K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can have a constructor like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"A(array::T) where {R, N, T <: AbstractArray{R, N}} = A{R, N, T}(...)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"to collect all the information needed"}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"c375e6a0-fc54-46b4-82cf-322b2f0cbc66","type":"message","text":"so, for instance, I'd receive an `Array{Float32,4}` and then `T` would be `Array{Float32,3}` or something like that. I remember there was a trick with something like `typeof(x).wrapper` but that's fragile.","user":"ULDCM1P9P","ts":"1617107990.002100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6tQR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"so, for instance, I'd receive an "},{"type":"text","text":"Array{Float32,4}","style":{"code":true}},{"type":"text","text":" and then "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" would be "},{"type":"text","text":"Array{Float32,3}","style":{"code":true}},{"type":"text","text":" or something like that. I remember there was a trick with something like "},{"type":"text","text":"typeof(x).wrapper","style":{"code":true}},{"type":"text","text":" but that's fragile."}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"},{"client_msg_id":"60237c41-df40-4a58-bc72-22b425945716","type":"message","text":"yeah, I'm afraid I'll just forget about the abstract type, because otherwise I'll be unnecessarily making it clumsier to instantiate my struct.","user":"ULDCM1P9P","ts":"1617108102.002300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Xud","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah, I'm afraid I'll just forget about the abstract type, because otherwise I'll be unnecessarily making it clumsier to instantiate my struct."}]}]}],"thread_ts":"1617105150.000400","parent_user_id":"ULDCM1P9P"}]