[{"client_msg_id":"6a293a33-5af7-4529-b8bf-4a8d1539e132","type":"message","text":"Hi everyone, I have many points stored columnwise in a `Matrix{Float64}`, and want to transform them with an affine map. I've been using CoordinateTransforms.jl, but it doesn't seem to have an efficient way to do this transformation in bulk:\n```julia&gt; pose = Translation([1., 1, 1]) ∘ LinearMap(UnitQuaternion(1., 0, 0, 0))\nAffineMap([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [1.0, 1.0, 1.0])```\nDirectly applying fails:\n```julia&gt; pose(ones(3, 100))\nERROR: DimensionMismatch(\"dimensions must match: a has dims (Base.OneTo(3), Base.OneTo(100)), must have singleton at dim 2\")\nStacktrace:\n [1] promote_shape at ./indices.jl:183 [inlined]\n [2] promote_shape at ./indices.jl:169 [inlined]\n [3] +(::Array{Float64,2}, ::Array{Float64,1}) at ./arraymath.jl:45\n [4] Translation at /home/drm/.julia/packages/CoordinateTransformations/ftuJq/src/affine.jl:20 [inlined]\n [5] (::AffineMap{UnitQuaternion{Float64},Array{Float64,1}})(::Array{Float64,2}) at /home/drm/.julia/packages/CoordinateTransformations/ftuJq/src/affine.jl:106\n [6] top-level scope at REPL[54]:1```\nBroadcasting the columns works, but then i need to hcat to get back to my original format:\n```julia&gt; pose.(eachcol(ones(3, 100)))\n100-element Array{SArray{Tuple{3},Float64,1,3},1}:\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n ⋮\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]```\nIs there a faster way? Should I use something besides CoordinateTransforms.jl? Thanks!","user":"UMC2RHKLZ","ts":"1610933212.206300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qCz2=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi everyone, I have many points stored columnwise in a "},{"type":"text","text":"Matrix{Float64}","style":{"code":true}},{"type":"text","text":", and want to transform them with an affine map. I've been using CoordinateTransforms.jl, but it doesn't seem to have an efficient way to do this transformation in bulk:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> pose = Translation([1., 1, 1]) ∘ LinearMap(UnitQuaternion(1., 0, 0, 0))\nAffineMap([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [1.0, 1.0, 1.0])"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Directly applying fails:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> pose(ones(3, 100))\nERROR: DimensionMismatch(\"dimensions must match: a has dims (Base.OneTo(3), Base.OneTo(100)), must have singleton at dim 2\")\nStacktrace:\n [1] promote_shape at ./indices.jl:183 [inlined]\n [2] promote_shape at ./indices.jl:169 [inlined]\n [3] +(::Array{Float64,2}, ::Array{Float64,1}) at ./arraymath.jl:45\n [4] Translation at /home/drm/.julia/packages/CoordinateTransformations/ftuJq/src/affine.jl:20 [inlined]\n [5] (::AffineMap{UnitQuaternion{Float64},Array{Float64,1}})(::Array{Float64,2}) at /home/drm/.julia/packages/CoordinateTransformations/ftuJq/src/affine.jl:106\n [6] top-level scope at REPL[54]:1"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Broadcasting the columns works, but then i need to hcat to get back to my original format:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> pose.(eachcol(ones(3, 100)))\n100-element Array{SArray{Tuple{3},Float64,1,3},1}:\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n ⋮\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]\n [2.0, 2.0, 2.0]"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a faster way? Should I use something besides CoordinateTransforms.jl? Thanks!"}]}]}],"thread_ts":"1610933212.206300","reply_count":1,"reply_users_count":1,"latest_reply":"1610935146.206800","reply_users":["UMC2RHKLZ"],"subscribed":false},{"client_msg_id":"faecbd3a-4c33-47c7-9a61-ffe2f42c4f05","type":"message","text":"This seems better:\n```julia&gt; pose.linear * ones(3, 100) .+ pose.translation\n3×100 Array{Float64,2}:\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  …  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0     2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0     2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0```","user":"UMC2RHKLZ","ts":"1610935146.206800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2xFZE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This seems better:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> pose.linear * ones(3, 100) .+ pose.translation\n3×100 Array{Float64,2}:\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  …  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0     2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0\n 2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0     2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0  2.0"}]}]}],"thread_ts":"1610933212.206300","parent_user_id":"UMC2RHKLZ"}]