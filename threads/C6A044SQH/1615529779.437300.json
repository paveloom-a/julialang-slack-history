[{"client_msg_id":"5aa2b728-1e67-4c5f-b194-623620350eef","type":"message","text":"I'm having some problems understanding this behavior of `unsafe_copyto!`:\n```julia&gt; mutable struct Foo\n       a::Int64\n       b::Int64\n       end\n\njulia&gt; f1=Foo(1,2)\nFoo(1, 2)\n\njulia&gt; f2=Foo(0,0)\nFoo(0, 0)\n\njulia&gt; pf1=Ptr{Foo}(pointer_from_objref(f1))\nPtr{Foo} @0x00007f834a134410\n\njulia&gt; pf2=Ptr{Foo}(pointer_from_objref(f2))\nPtr{Foo} @0x00007f8349ebe190\n\njulia&gt; unsafe_copyto!(pf2, pf1, 1)\nPtr{Foo} @0x00007f8349ebe190\n\njulia&gt; f2\nFoo(1, 0)```\nI am expecting f2 to be the same as f1 after the `unsafe_copyto!`, but only one of the fields is copied.  It looks like `unsafe_copyto!` ends up calling `memmove` to copy `n * aligned_size(T)` bytes.  I then discovered that `aligned_size(Foo)` returns 8 rather than 16.  Looking into `aligned_size(T)` it seems that if `T` is not \"allocatedinline\" then its \"aligned size\" is that of a pointer, which kinda fits the comment for `aligned_size` (\"amount of total space taken by T when stored in a container\").  It feels like `aligned_size` is really computing \"inline size\".\n\nIs this really how `unsafe_copyto!` is supposed to work?  FWIW, my motivation for this is to take a pointer to a C data structure and do an in-place version of `unsafe_load` by loading into an existing object instead of allocating a new one each time (i.e. I'm trying to use `unsafe_copyto!` to create an `unsafe_load!` function).  If `unsafe_copyto!` is not the right way to do this, what is?","user":"U01FKQQ7J0J","ts":"1615529779.437300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RfVcL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having some problems understanding this behavior of "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> mutable struct Foo\n       a::Int64\n       b::Int64\n       end\n\njulia> f1=Foo(1,2)\nFoo(1, 2)\n\njulia> f2=Foo(0,0)\nFoo(0, 0)\n\njulia> pf1=Ptr{Foo}(pointer_from_objref(f1))\nPtr{Foo} @0x00007f834a134410\n\njulia> pf2=Ptr{Foo}(pointer_from_objref(f2))\nPtr{Foo} @0x00007f8349ebe190\n\njulia> unsafe_copyto!(pf2, pf1, 1)\nPtr{Foo} @0x00007f8349ebe190\n\njulia> f2\nFoo(1, 0)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I am expecting f2 to be the same as f1 after the "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":", but only one of the fields is copied.  It looks like "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" ends up calling "},{"type":"text","text":"memmove","style":{"code":true}},{"type":"text","text":" to copy "},{"type":"text","text":"n * aligned_size(T)","style":{"code":true}},{"type":"text","text":" bytes.  I then discovered that "},{"type":"text","text":"aligned_size(Foo)","style":{"code":true}},{"type":"text","text":" returns 8 rather than 16.  Looking into "},{"type":"text","text":"aligned_size(T)","style":{"code":true}},{"type":"text","text":" it seems that if "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" is not \"allocatedinline\" then its \"aligned size\" is that of a pointer, which kinda fits the comment for "},{"type":"text","text":"aligned_size","style":{"code":true}},{"type":"text","text":" (\"amount of total space taken by T when stored in a container\").  It feels like "},{"type":"text","text":"aligned_size","style":{"code":true}},{"type":"text","text":" is really computing \"inline size\".\n\nIs this really how "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" is supposed to work?  FWIW, my motivation for this is to take a pointer to a C data structure and do an in-place version of "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":" by loading into an existing object instead of allocating a new one each time (i.e. I'm trying to use "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" to create an "},{"type":"text","text":"unsafe_load!","style":{"code":true}},{"type":"text","text":" function).  If "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" is not the right way to do this, what is?"}]}]}],"thread_ts":"1615529779.437300","reply_count":36,"reply_users_count":3,"latest_reply":"1615540603.448600","reply_users":["B01J9QZ4SP8","UH24GRBLL","U01FKQQ7J0J"],"subscribed":false,"reactions":[{"name":"bridge","users":["U01FKQQ7J0J"],"count":1}]},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1615529784.437400","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"type":"message","subtype":"bot_message","text":"Success, it has been cross posted <https://discourse.julialang.org/t/56999| to Discourse>. Keep and eye out on Discourse for responses and please add an answer there once you are satisfied with the solution so others can benefit as well. Happy debugging!","ts":"1615529856.437700","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"03a18b53-69f3-4a99-82f3-2edcdf5ae66b","type":"message","text":"what do you mean by \"allocating a new one each time\"?","user":"UH24GRBLL","ts":"1615532955.438000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Km9T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what do you mean by \"allocating a new one each time\"?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"2173d1ec-1438-4dca-b8cd-201e51351db3","type":"message","text":"what do you want to do with the memory? who is supposed to free it? who will access it (julia/C)?","user":"UH24GRBLL","ts":"1615533687.438300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yWbe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what do you want to do with the memory? who is supposed to free it? who will access it (julia/C)?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"b254d626-bbf1-4b8d-abc0-e57b71e6c99f","type":"message","text":"I'm calling a library function that takes a pointer to a pointer and sets the pointed-to-pointer to point to a data structure that lives in memory that the library manages.  I call this function many times.  I could use `unsafe_load`to copy the contents of the data structure pointed to by the pointer into a (presumably) newly allocated Julia struct that I wrote that matches the memory layout  of the library data structure, but that allocates a new instance of my struct on each call.  I don't need to all of these instances to persist as separate instances.  I would prefer to reuse one instance over and over ~so that each call to the Julia method wrapping the library function~.  I would like to pass a preallocated instance of my struct to the Julia method and have the method fill it in with the values from the data structure pointed to by the pointer supplied by the library function.","user":"U01FKQQ7J0J","ts":"1615536932.441900","team":"T68168MUP","edited":{"user":"U01FKQQ7J0J","ts":"1615537297.000000"},"blocks":[{"type":"rich_text","block_id":"R75","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm calling a library function that takes a pointer to a pointer and sets the pointed-to-pointer to point to a data structure that lives in memory that the library manages.  I call this function many times.  I could use "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":"to copy the contents of the data structure pointed to by the pointer into a (presumably) newly allocated Julia struct that I wrote that matches the memory layout  of the library data structure, but that allocates a new instance of my struct on each call.  I don't need to all of these instances to persist as separate instances.  I would prefer to reuse one instance over and over "},{"type":"text","text":"so that each call to the Julia method wrapping the library function","style":{"strike":true}},{"type":"text","text":".  I would like to pass a preallocated instance of my struct to the Julia method and have the method fill it in with the values from the data structure pointed to by the pointer supplied by the library function."}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"6d43d479-582b-462f-aa14-762d5fb7fb8c","type":"message","text":"&gt; lives in memory that the library manages.\nThen why are you trying to make the GC aware of the memory?","user":"UH24GRBLL","ts":"1615537565.442200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"gFz","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"lives in memory that the library manages."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nThen why are you trying to make the GC aware of the memory?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"ae1ed89d-a876-4382-a74a-f806237de53b","type":"message","text":"What you're describing would result in both julia and C saying \"no, I manage this\"","user":"UH24GRBLL","ts":"1615537588.442400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"72/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What you're describing would result in both julia and C saying \"no, I manage this\""}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"74cb5dbd-20a0-4c67-9e7d-b23899796a08","type":"message","text":"If C allocates &amp; manages the memory, just define the struct according to the equivalences (<https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#mapping-c-types-to-julia>) and let `ccall` give you the memory in a way julia understands to be handled by C","user":"UH24GRBLL","ts":"1615537718.442600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"VXTh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If C allocates & manages the memory, just define the struct according to the equivalences ("},{"type":"link","url":"https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#mapping-c-types-to-julia"},{"type":"text","text":") and let "},{"type":"text","text":"ccall","style":{"code":true}},{"type":"text","text":" give you the memory in a way julia understands to be handled by C"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"5ef3cede-7bc3-4ecb-91ae-441573f1c399","type":"message","text":"I want to copy the contents from library-managed memory to Julia-managed memory.","user":"U01FKQQ7J0J","ts":"1615537805.442800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z5e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want to copy the contents from library-managed memory to Julia-managed memory."}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"b66b3de7-8846-4cc9-bbc8-81e29c6fcf23","type":"message","text":"Ok","user":"UH24GRBLL","ts":"1615538109.443000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5TBWA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ok"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"b28a8ed9-85d7-4eea-933e-14f9e99313f9","type":"message","text":"to answer your question: yes, this is how `unsafe_copyto!` is supposed to work","user":"UH24GRBLL","ts":"1615538124.443200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Cu/P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"to answer your question: yes, this is how "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" is supposed to work"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"7568d0ed-33d0-4f90-ac4b-243bd84b8ee5","type":"message","text":"what you're looking for is probably this:\n\n```julia&gt; unsafe_copyto!(Ptr{UInt8}(pf2), Ptr{UInt8}(pf1), sizeof(Foo))\nPtr{UInt8} @0x00007f1708a7ce50                                      \n                                                                    \njulia&gt; f2                                                           \nFoo(1, 2)                                                           ```","user":"UH24GRBLL","ts":"1615538210.443400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I=T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what you're looking for is probably this:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> unsafe_copyto!(Ptr{UInt8}(pf2), Ptr{UInt8}(pf1), sizeof(Foo))\nPtr{UInt8} @0x00007f1708a7ce50                                      \n                                                                    \njulia> f2                                                           \nFoo(1, 2)                                                           "}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"7c64d37f-ff38-4956-a59b-9834974267ac","type":"message","text":"note that this may not work as expected if there are pointers in `Foo` and you wish to copy their contents as well","user":"UH24GRBLL","ts":"1615538249.443600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"spY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"note that this may not work as expected if there are pointers in "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" and you wish to copy their contents as well"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"515ae407-e0c9-4472-ac4a-94b712310f41","type":"message","text":"It's only ints of various sizes","user":"U01FKQQ7J0J","ts":"1615538271.443800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+/2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's only ints of various sizes"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"74d51098-6733-4872-9cd4-25a5a7e9c40c","type":"message","text":"May I ask why you want to copy the memory provided by the library in the first place?","user":"UH24GRBLL","ts":"1615538271.444000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"172","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"May I ask why you want to copy the memory provided by the library in the first place?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"790bda1c-f7bb-4739-90d5-9868de248d42","type":"message","text":"If performance is the reason, not copying seems preferrable","user":"UH24GRBLL","ts":"1615538413.444200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MMHD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If performance is the reason, not copying seems preferrable"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"71943f50-a5db-477d-84cd-d1ac3eb9970b","type":"message","text":"I agree that having some structure that I could \"re-aim\" to different memory locations would be ideal, but there's not an `unsafe_wrap!` so that would allocate a new Array every call.","user":"U01FKQQ7J0J","ts":"1615538505.444500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3Kr2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree that having some structure that I could \"re-aim\" to different memory locations would be ideal, but there's not an "},{"type":"text","text":"unsafe_wrap!","style":{"code":true}},{"type":"text","text":" so that would allocate a new Array every call."}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"4d9f666a-21f8-4ac1-8482-3b958cfcba00","type":"message","text":"I think using `sizeof(Foo)` is too big.\n```ulia&gt; unsafe_copyto!(pf2, pf1, 2)\nPtr{Foo} @0x00007fbe18d41a10\n\njulia&gt; f2\nFoo(1, 2)```","user":"U01FKQQ7J0J","ts":"1615538594.444700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"qQsv8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think using "},{"type":"text","text":"sizeof(Foo)","style":{"code":true}},{"type":"text","text":" is too big.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"ulia> unsafe_copyto!(pf2, pf1, 2)\nPtr{Foo} @0x00007fbe18d41a10\n\njulia> f2\nFoo(1, 2)"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"c74199d3-44eb-45d5-acce-36407b84d2ff","type":"message","text":"why would it be?","user":"UH24GRBLL","ts":"1615538614.444900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t//","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"why would it be?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"493cc0aa-f22b-459c-baba-d81a6198c920","type":"message","text":"ah, yes","user":"UH24GRBLL","ts":"1615538630.445100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oKZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ah, yes"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"83deeaec-4b6e-447d-b89a-b52f2ded5ca3","type":"message","text":"it should be `sizeof(Foo)÷8`","user":"UH24GRBLL","ts":"1615538648.445300","team":"T68168MUP","edited":{"user":"UH24GRBLL","ts":"1615538671.000000"},"blocks":[{"type":"rich_text","block_id":"sAv8g","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it should be "},{"type":"text","text":"sizeof(Foo)÷8","style":{"code":true}}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"53b868cc-8996-4990-9c41-c24bcd149761","type":"message","text":"`n` ends up getting multipled by the size of a pointer (8 in my case)","user":"U01FKQQ7J0J","ts":"1615538673.445600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L4OdI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"n","style":{"code":true}},{"type":"text","text":" ends up getting multipled by the size of a pointer (8 in my case)"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"4a45f845-18bd-49ed-8ea8-735ed4ef1903","type":"message","text":"maybe `sizeof(Foo)÷sizeof(Ptr)`","user":"U01FKQQ7J0J","ts":"1615538719.445800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EoOw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"maybe "},{"type":"text","text":"sizeof(Foo)÷sizeof(Ptr)","style":{"code":true}}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"bdf6a5ae-5ccc-42be-8943-1655f6af8bd3","type":"message","text":"I've converted to `Ptr{UInt8}` for `unsafe_copyto!`, so `sizeof(Foo)÷8` would be appropriate","user":"UH24GRBLL","ts":"1615538722.446000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+Pohd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I've converted to "},{"type":"text","text":"Ptr{UInt8}","style":{"code":true}},{"type":"text","text":" for "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":", so "},{"type":"text","text":"sizeof(Foo)÷8","style":{"code":true}},{"type":"text","text":" would be appropriate"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"9ee9f2e8-030f-418b-9753-2cc893b2905f","type":"message","text":"it makes sense to do everything in byte sized chunks since that's what `unsafe_copyto!` thinks in as well","user":"UH24GRBLL","ts":"1615538761.446200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UVrVP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"it makes sense to do everything in byte sized chunks since that's what "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" thinks in as well"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"9c4c418c-84eb-4289-b786-cab2e2377f33","type":"message","text":"as you noticed yourself, the size `unsafe_copyto!` thinks in is not dependent on `Ptr`, but on the `T` of `Prt{T}` - if that is aligned differently than `Ptr`, you'd get offsets","user":"UH24GRBLL","ts":"1615538917.446400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"KHtj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"as you noticed yourself, the size "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" thinks in is not dependent on "},{"type":"text","text":"Ptr","style":{"code":true}},{"type":"text","text":", but on the "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" of "},{"type":"text","text":"Prt{T}","style":{"code":true}},{"type":"text","text":" - if that is aligned differently than "},{"type":"text","text":"Ptr","style":{"code":true}},{"type":"text","text":", you'd get offsets"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"9fbe26d5-9146-4937-afb1-30a36fb670bb","type":"message","text":"Yeah, I think the problem/situation is that if `!isbitsunion(T) &amp;&amp; !allocatedinline(T)` then `unsafe_copyto!` works (somewhat unexpectedly, IMHO) in units of `sizeof(Ptr{Cvoid})` rather than `sizeof(T)`","user":"U01FKQQ7J0J","ts":"1615539318.446600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"oDi8J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I think the problem/situation is that if "},{"type":"text","text":"!isbitsunion(T) && !allocatedinline(T)","style":{"code":true}},{"type":"text","text":" then "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" works (somewhat unexpectedly, IMHO) in units of "},{"type":"text","text":"sizeof(Ptr{Cvoid})","style":{"code":true}},{"type":"text","text":" rather than "},{"type":"text","text":"sizeof(T)","style":{"code":true}}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"382354df-f3e9-45d5-bccd-737341a7e622","type":"message","text":"Your idea of converting to `Ptr{UInt8}` and using `sizeof(Foo)` does the trick\n```julia&gt; pf1=Ptr{UInt8}(pointer_from_objref(f1))\nPtr{UInt8} @0x00007fbe18cc0590\n\njulia&gt; pf2=Ptr{UInt8}(pointer_from_objref(f2))\nPtr{UInt8} @0x00007fbe18d41a10\n\njulia&gt; unsafe_copyto!(pf2, pf1, sizeof(Foo))\nPtr{UInt8} @0x00007fbe18d41a10\n\njulia&gt; f2\nFoo(1, 2)```\nThanks!","user":"U01FKQQ7J0J","ts":"1615539510.446800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hycn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Your idea of converting to "},{"type":"text","text":"Ptr{UInt8}","style":{"code":true}},{"type":"text","text":" and using `sizeof(Foo)` does the trick\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> pf1=Ptr{UInt8}(pointer_from_objref(f1))\nPtr{UInt8} @0x00007fbe18cc0590\n\njulia> pf2=Ptr{UInt8}(pointer_from_objref(f2))\nPtr{UInt8} @0x00007fbe18d41a10\n\njulia> unsafe_copyto!(pf2, pf1, sizeof(Foo))\nPtr{UInt8} @0x00007fbe18d41a10\n\njulia> f2\nFoo(1, 2)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks!"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"aae8e6e9-277a-40ac-94cc-21388b88306c","type":"message","text":"still, I'd recommend not copying the memory in the first place - presumably, the library sets values in the background (since you made your struct mutable, I assume)","user":"UH24GRBLL","ts":"1615540105.447000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"48Gw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"still, I'd recommend not copying the memory in the first place - presumably, the library sets values in the background (since you made your struct mutable, I assume)"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"1c321728-00a0-4350-8472-e6e856f4fb82","type":"message","text":"From the documentation of `unsafe_copyto!` I agree with you, please file an issue so we can either straighten out the documentation or fix the behaviour.","user":"UH24GRBLL","ts":"1615540146.447200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5=V","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"From the documentation of "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" I agree with you, please file an issue so we can either straighten out the documentation or fix the behaviour."}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J","reactions":[{"name":"+1","users":["U01FKQQ7J0J"],"count":1}]},{"client_msg_id":"ee3676eb-cc0e-4252-a2c9-a459bf3eada4","type":"message","text":"I'd love to not copy the memory, but how to do that without ~copying~allocating?  I think allocating is worse than copying as it's a small structure and likely in cache.","user":"U01FKQQ7J0J","ts":"1615540354.447400","team":"T68168MUP","edited":{"user":"U01FKQQ7J0J","ts":"1615540396.000000"},"blocks":[{"type":"rich_text","block_id":"yE171","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'd love to not copy the memory, but how to do that without "},{"type":"text","text":"copying","style":{"strike":true}},{"type":"text","text":"allocating?  I think allocating is worse than copying as it's a small structure and likely in cache."}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"f67be8e8-38ba-443b-909c-56014bea87f5","type":"message","text":"You can always have a `::Ptr{Foo}` in your main struct","user":"UH24GRBLL","ts":"1615540401.447800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"001","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can always have a "},{"type":"text","text":"::Ptr{Foo}","style":{"code":true}},{"type":"text","text":" in your main struct"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"26f93dce-1c28-419a-ba5a-53ea5fd4c271","type":"message","text":"and then pass a `Ptr` to that to your library","user":"UH24GRBLL","ts":"1615540409.448000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YVFm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and then pass a "},{"type":"text","text":"Ptr","style":{"code":true}},{"type":"text","text":" to that to your library"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"d5d71ab8-c3aa-44c6-acea-6888ba799248","type":"message","text":"you'll have to make sure though that the `Foo` is finalized by the library when the main struct is GC'd","user":"UH24GRBLL","ts":"1615540487.448200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"AhKCX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"you'll have to make sure though that the "},{"type":"text","text":"Foo","style":{"code":true}},{"type":"text","text":" is finalized by the library when the main struct is GC'd"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"d22b4b36-531c-409c-83cc-65bebf93b390","type":"message","text":"Sure, but what about dereferencing to access the fields?  Make functions that deference individual fields on the fly?","user":"U01FKQQ7J0J","ts":"1615540514.448400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6MOS","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Sure, but what about dereferencing to access the fields?  Make functions that deference individual fields on the fly?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"8d4f8b10-7077-403b-b310-7e55f70e9d67","type":"message","text":"Unfortunately, it's not an opaque structure","user":"U01FKQQ7J0J","ts":"1615540603.448600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"X5y7e","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Unfortunately, it's not an opaque structure"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"}]