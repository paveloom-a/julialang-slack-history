[{"client_msg_id":"5aa2b728-1e67-4c5f-b194-623620350eef","type":"message","text":"I'm having some problems understanding this behavior of `unsafe_copyto!`:\n```julia&gt; mutable struct Foo\n       a::Int64\n       b::Int64\n       end\n\njulia&gt; f1=Foo(1,2)\nFoo(1, 2)\n\njulia&gt; f2=Foo(0,0)\nFoo(0, 0)\n\njulia&gt; pf1=Ptr{Foo}(pointer_from_objref(f1))\nPtr{Foo} @0x00007f834a134410\n\njulia&gt; pf2=Ptr{Foo}(pointer_from_objref(f2))\nPtr{Foo} @0x00007f8349ebe190\n\njulia&gt; unsafe_copyto!(pf2, pf1, 1)\nPtr{Foo} @0x00007f8349ebe190\n\njulia&gt; f2\nFoo(1, 0)```\nI am expecting f2 to be the same as f1 after the `unsafe_copyto!`, but only one of the fields is copied.  It looks like `unsafe_copyto!` ends up calling `memmove` to copy `n * aligned_size(T)` bytes.  I then discovered that `aligned_size(Foo)` returns 8 rather than 16.  Looking into `aligned_size(T)` it seems that if `T` is not \"allocatedinline\" then its \"aligned size\" is that of a pointer, which kinda fits the comment for `aligned_size` (\"amount of total space taken by T when stored in a container\").  It feels like `aligned_size` is really computing \"inline size\".\n\nIs this really how `unsafe_copyto!` is supposed to work?  FWIW, my motivation for this is to take a pointer to a C data structure and do an in-place version of `unsafe_load` by loading into an existing object instead of allocating a new one each time (i.e. I'm trying to use `unsafe_copyto!` to create an `unsafe_load!` function).  If `unsafe_copyto!` is not the right way to do this, what is?","user":"U01FKQQ7J0J","ts":"1615529779.437300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RfVcL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having some problems understanding this behavior of "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":":\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> mutable struct Foo\n       a::Int64\n       b::Int64\n       end\n\njulia> f1=Foo(1,2)\nFoo(1, 2)\n\njulia> f2=Foo(0,0)\nFoo(0, 0)\n\njulia> pf1=Ptr{Foo}(pointer_from_objref(f1))\nPtr{Foo} @0x00007f834a134410\n\njulia> pf2=Ptr{Foo}(pointer_from_objref(f2))\nPtr{Foo} @0x00007f8349ebe190\n\njulia> unsafe_copyto!(pf2, pf1, 1)\nPtr{Foo} @0x00007f8349ebe190\n\njulia> f2\nFoo(1, 0)"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I am expecting f2 to be the same as f1 after the "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":", but only one of the fields is copied.  It looks like "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" ends up calling "},{"type":"text","text":"memmove","style":{"code":true}},{"type":"text","text":" to copy "},{"type":"text","text":"n * aligned_size(T)","style":{"code":true}},{"type":"text","text":" bytes.  I then discovered that "},{"type":"text","text":"aligned_size(Foo)","style":{"code":true}},{"type":"text","text":" returns 8 rather than 16.  Looking into "},{"type":"text","text":"aligned_size(T)","style":{"code":true}},{"type":"text","text":" it seems that if "},{"type":"text","text":"T","style":{"code":true}},{"type":"text","text":" is not \"allocatedinline\" then its \"aligned size\" is that of a pointer, which kinda fits the comment for "},{"type":"text","text":"aligned_size","style":{"code":true}},{"type":"text","text":" (\"amount of total space taken by T when stored in a container\").  It feels like "},{"type":"text","text":"aligned_size","style":{"code":true}},{"type":"text","text":" is really computing \"inline size\".\n\nIs this really how "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" is supposed to work?  FWIW, my motivation for this is to take a pointer to a C data structure and do an in-place version of "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":" by loading into an existing object instead of allocating a new one each time (i.e. I'm trying to use "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" to create an "},{"type":"text","text":"unsafe_load!","style":{"code":true}},{"type":"text","text":" function).  If "},{"type":"text","text":"unsafe_copyto!","style":{"code":true}},{"type":"text","text":" is not the right way to do this, what is?"}]}]}],"thread_ts":"1615529779.437300","reply_count":5,"reply_users_count":3,"latest_reply":"1615536932.441900","reply_users":["B01J9QZ4SP8","UH24GRBLL","U01FKQQ7J0J"],"subscribed":false,"reactions":[{"name":"bridge","users":["U01FKQQ7J0J"],"count":1}]},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1615529784.437400","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"type":"message","subtype":"bot_message","text":"Success, it has been cross posted <https://discourse.julialang.org/t/56999| to Discourse>. Keep and eye out on Discourse for responses and please add an answer there once you are satisfied with the solution so others can benefit as well. Happy debugging!","ts":"1615529856.437700","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"03a18b53-69f3-4a99-82f3-2edcdf5ae66b","type":"message","text":"what do you mean by \"allocating a new one each time\"?","user":"UH24GRBLL","ts":"1615532955.438000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Km9T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what do you mean by \"allocating a new one each time\"?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"2173d1ec-1438-4dca-b8cd-201e51351db3","type":"message","text":"what do you want to do with the memory? who is supposed to free it? who will access it (julia/C)?","user":"UH24GRBLL","ts":"1615533687.438300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yWbe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"what do you want to do with the memory? who is supposed to free it? who will access it (julia/C)?"}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"},{"client_msg_id":"b254d626-bbf1-4b8d-abc0-e57b71e6c99f","type":"message","text":"I'm calling a library function that takes a pointer to a pointer and sets the pointed-to-pointer to point to a data structure that lives in memory that the library manages.  I call this function many times.  I could use `unsafe_load`to copy the contents of the data structure pointed to by the pointer into a (presumably) newly allocated Julia struct that I wrote that matches the memory layout  of the library data structure, but that allocates a new instance of my struct on each call.  I don't need to all of these instances to persist as separate instances.  I would prefer to reuse one instance over and over so that each call to the Julia method wrapping the library function.  I would like to pass a preallocated instance of my struct to the Julia method and have the method fill it in with the values from the data structure pointed to by the pointer supplied by the library function.","user":"U01FKQQ7J0J","ts":"1615536932.441900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=SQ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm calling a library function that takes a pointer to a pointer and sets the pointed-to-pointer to point to a data structure that lives in memory that the library manages.  I call this function many times.  I could use "},{"type":"text","text":"unsafe_load","style":{"code":true}},{"type":"text","text":"to copy the contents of the data structure pointed to by the pointer into a (presumably) newly allocated Julia struct that I wrote that matches the memory layout  of the library data structure, but that allocates a new instance of my struct on each call.  I don't need to all of these instances to persist as separate instances.  I would prefer to reuse one instance over and over so that each call to the Julia method wrapping the library function.  I would like to pass a preallocated instance of my struct to the Julia method and have the method fill it in with the values from the data structure pointed to by the pointer supplied by the library function."}]}]}],"thread_ts":"1615529779.437300","parent_user_id":"U01FKQQ7J0J"}]