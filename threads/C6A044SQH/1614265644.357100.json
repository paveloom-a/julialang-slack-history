[{"client_msg_id":"bc835e2b-6d50-4bf3-a023-9ce1c026ae82","type":"message","text":"Mmh, compile time is getting out of hand… Is it possible I'm relying too much on StaticArrays?","user":"U01MG0TN079","ts":"1614265644.357100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"J/P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Mmh, compile time is getting out of hand… Is it possible I'm relying too much on StaticArrays?"}]}]}],"thread_ts":"1614265644.357100","reply_count":14,"reply_users_count":4,"latest_reply":"1614266243.359900","reply_users":["B01J9QZ4SP8","U01MG0TN079","UDB26738Q","U7HAYKY9X"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1614265645.357200","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"dc9436b5-0afc-46b2-9ef0-c21e77e6d1c4","type":"message","text":"and/or annotating too much?","user":"U01MG0TN079","ts":"1614265664.357500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"31E","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and/or annotating too much?"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"940f04bf-0505-4553-8279-62ae8b6fe465","type":"message","text":"how large are your static arrays?","user":"UDB26738Q","ts":"1614265669.357700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"I2qR8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"how large are your static arrays?"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"37ab277a-7e74-455d-b457-57384016b9ba","type":"message","text":"up to 20 elements vectors, 20×20 matrices","user":"U01MG0TN079","ts":"1614265700.357900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"L0x","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"up to 20 elements vectors, 20×20 matrices"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"92d9d3e6-b0fa-4537-8acd-5ff9526eee1f","type":"message","text":"that may be a bit too much, especially the 400-element matrices","user":"UDB26738Q","ts":"1614265727.358100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ar53I","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that may be a bit too much, especially the 400-element matrices"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"a3c9cac6-115d-42fe-97f7-a85ecdd32ea4","type":"message","text":"but I have a function type that depends on two static arrays sizes, say `n`  and `N` with `n≤N`  so I guess this means one compilation round per tuple?","user":"U01MG0TN079","ts":"1614265759.358300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IXlO9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but I have a function type that depends on two static arrays sizes, say "},{"type":"text","text":"n","style":{"code":true}},{"type":"text","text":"  and "},{"type":"text","text":"N","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"n≤N","style":{"code":true}},{"type":"text","text":"  so I guess this means one compilation round per tuple?"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"71340ada-a5cb-4690-a810-37f1f4df74d2","type":"message","text":"but there won't be many such matrices: essentially one, actually","user":"U01MG0TN079","ts":"1614265809.358500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"RiGTr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"but there won't be many such matrices: essentially one, actually"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"405d3de2-f43d-413b-90bd-3f0d9cee6bed","type":"message","text":"I mean, at any given time during runtime","user":"U01MG0TN079","ts":"1614265843.358700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"k6kq","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I mean, at any given time during runtime"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"d465f7e7-8f96-438c-b52b-9fe3a81c18e2","type":"message","text":"The issue is not only the number of different tuples, but that the compiler internally handles large tuples as having one type parameter per element, so it gets out of hand quickly","user":"U7HAYKY9X","ts":"1614265969.358900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"PqE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The issue is not only the number of different tuples, but that the compiler internally handles large tuples as having one type parameter per element, so it gets out of hand quickly"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"d588ff42-171e-4184-8712-6a9ed4150d47","type":"message","text":"Is there some kind of alternative for my size-known-in-advance vectors then?","user":"U01MG0TN079","ts":"1614266030.359100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TNveL","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there some kind of alternative for my size-known-in-advance vectors then?"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"41817dd6-7944-4c85-9f46-449df8a53ea3","type":"message","text":"SizedArray from StaticArrays, but that's heap-allocated, so not exactly the same. Still, might be useful?","user":"U7HAYKY9X","ts":"1614266081.359300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pWE2S","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"SizedArray from StaticArrays, but that's heap-allocated, so not exactly the same. Still, might be useful?"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"2d56a198-9daf-490c-8bf2-f4b33944d8d3","type":"message","text":"I had the idea that using staticarrays was a net win in the sense that \"the more the compiler knows, the best it can optimize\", but it seems now that type hinting in julia is more than simply giving the compiler more infos","user":"U01MG0TN079","ts":"1614266119.359500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eQe6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I had the idea that using staticarrays was a net win in the sense that \"the more the compiler knows, the best it can optimize\", but it seems now that type hinting in julia is more than simply giving the compiler more infos"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"4996afed-f293-4ed0-9829-28df02d756f9","type":"message","text":"in principle you're right, but if the compiler has too many options it'll also try to compile a lot of code","user":"UDB26738Q","ts":"1614266189.359700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6XPvD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"in principle you're right, but if the compiler has too many options it'll also try to compile a lot of code"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079"},{"client_msg_id":"98f6291a-0e14-48ab-99f9-a9f206dd4a3b","type":"message","text":"<@U7HAYKY9X> ah, thanks, I'll see if it helps","user":"U01MG0TN079","ts":"1614266243.359900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"R1cFj","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" ah, thanks, I'll see if it helps"}]}]}],"thread_ts":"1614265644.357100","parent_user_id":"U01MG0TN079","reactions":[{"name":"+1","users":["U7HAYKY9X"],"count":1}]}]