[{"client_msg_id":"59ae9e7f-33d1-47ae-bf92-d5c8598f938a","type":"message","text":"I am using `Distributed` to run replicate simulations on multiple processes and running into some \"world age\" issues. Essentially, I have a `evolve_worker(input, output)` function that has parameter objects in the `input` channel and then saves the data in the `output` channel. The parameter objects have a mix of scalar parameter values and functions like\n```struct Params\n    val::Int\n    func::Function\nend```\nI usually assign an anonymous function to the `func` field in `Params`.\n\nWhen I run `for w in workers() remote_do(evolve_worker, w, input, output) end`, julia complains about the `MethodError: no method matching` and `applicable method may be too new` in the part of `evolve_worker` that uses `Params.func`.\n\nLooking at <https://github.com/dfdx/Spark.jl/issues/78>, it seems like the solution is to invoke `Params.func` with `Base.invokelatest`. Is this right? Is there any better way of sending anonymous functions to distributed workers without running into world age issues?","user":"UKFUT8N5A","ts":"1609388942.413300","team":"T68168MUP","edited":{"user":"UKFUT8N5A","ts":"1609388976.000000"},"blocks":[{"type":"rich_text","block_id":"gj0K","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am using "},{"type":"text","text":"Distributed","style":{"code":true}},{"type":"text","text":" to run replicate simulations on multiple processes and running into some \"world age\" issues. Essentially, I have a "},{"type":"text","text":"evolve_worker(input, output)","style":{"code":true}},{"type":"text","text":" function that has parameter objects in the "},{"type":"text","text":"input","style":{"code":true}},{"type":"text","text":" channel and then saves the data in the "},{"type":"text","text":"output","style":{"code":true}},{"type":"text","text":" channel. The parameter objects have a mix of scalar parameter values and functions like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct Params\n    val::Int\n    func::Function\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\nI usually assign an anonymous function to the "},{"type":"text","text":"func","style":{"code":true}},{"type":"text","text":" field in "},{"type":"text","text":"Params","style":{"code":true}},{"type":"text","text":".\n\nWhen I run "},{"type":"text","text":"for w in workers() remote_do(evolve_worker, w, input, output) end","style":{"code":true}},{"type":"text","text":", julia complains about the "},{"type":"text","text":"MethodError: no method matching","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"applicable method may be too new","style":{"code":true}},{"type":"text","text":" in the part of "},{"type":"text","text":"evolve_worker","style":{"code":true}},{"type":"text","text":" that uses "},{"type":"text","text":"Params.func","style":{"code":true}},{"type":"text","text":".\n\nLooking at "},{"type":"link","url":"https://github.com/dfdx/Spark.jl/issues/78"},{"type":"text","text":", it seems like the solution is to invoke "},{"type":"text","text":"Params.func","style":{"code":true}},{"type":"text","text":" with "},{"type":"text","text":"Base.invokelatest","style":{"code":true}},{"type":"text","text":". Is this right? Is there any better way of sending anonymous functions to distributed workers without running into world age issues?"}]}]}],"thread_ts":"1609388942.413300","reply_count":1,"reply_users_count":1,"latest_reply":"1609389181.413500","reply_users":["U0179G7FG4F"],"subscribed":false},{"client_msg_id":"89c43646-7dd8-4fc5-ac3a-8c9219fab12e","type":"message","text":"Any chance you can just use threads where this won't be a problem?","user":"U0179G7FG4F","ts":"1609389181.413500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"T4wJ=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Any chance you can just use threads where this won't be a problem?"}]}]}],"thread_ts":"1609388942.413300","parent_user_id":"UKFUT8N5A"}]