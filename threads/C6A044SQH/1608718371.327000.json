[{"client_msg_id":"d6bfa55a-5aa3-44e6-aebc-7ebdc68a4d88","type":"message","text":"Is there a function that converts unicode characters to their latex representation? For example, \"μ\" would give back \"\\mu\" that can be interpreted as a math expression using latexstrings.","user":"UFCNUVC67","ts":"1608718371.327000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"uvi6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a function that converts unicode characters to their latex representation? For example, \"μ\" would give back \"\\mu\" that can be interpreted as a math expression using latexstrings."}]}]}],"thread_ts":"1608718371.327000","reply_count":7,"reply_users_count":2,"latest_reply":"1608721093.328300","reply_users":["U8HHPBKQR","UFCNUVC67"],"subscribed":false},{"client_msg_id":"a90f5262-5384-42e5-ac07-cd9f9f939ca8","type":"message","text":"```julia&gt; latexify(\"μ\")\nL\"$\\mu$\"```","user":"U8HHPBKQR","ts":"1608719187.327100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"EgDhc","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> latexify(\"μ\")\nL\"$\\mu$\""}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67"},{"client_msg_id":"957b4aa5-c006-4a9c-af63-75d8f5a058e8","type":"message","text":"<https://github.com/korsbo/Latexify.jl>","user":"U8HHPBKQR","ts":"1608719271.327300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W86kA","elements":[{"type":"rich_text_section","elements":[{"type":"link","url":"https://github.com/korsbo/Latexify.jl"}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67"},{"client_msg_id":"7d08144d-f898-4cc3-aa7e-ba9a02cd2eb5","type":"message","text":"Ah, this might be exactly what I'm looking for. I haven't managed to figure out how to have subscripts yet, such as conveting \"μ_{[1.0, 3.2]}\" to L\"\\mu_{[1.0, 3.2]}\" fails..","user":"UFCNUVC67","ts":"1608719943.327500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"zQw4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, this might be exactly what I'm looking for. I haven't managed to figure out how to have subscripts yet, such as conveting \"μ_{[1.0, 3.2]}\" to L\"\\mu_{[1.0, 3.2]}\" fails.."}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67"},{"client_msg_id":"52e89395-ddea-459b-a98b-a0f4b2789136","type":"message","text":"No idea if possible. Where does this \"mixed\"notation come from","user":"U8HHPBKQR","ts":"1608720321.327700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D/anC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No idea if possible. Where does this \"mixed\"notation come from"}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67"},{"client_msg_id":"57eb57bf-f72c-452b-85e2-35d56428ea21","type":"message","text":"It's from temporal logic, such as you always want μ to hold within some time interval, which is denoted as \"G_{[lBound,rBound]} μ\".","user":"UFCNUVC67","ts":"1608720546.327900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"QGO","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's from temporal logic, such as you always want μ to hold within some time interval, which is denoted as \"G_{[lBound,rBound]} μ\"."}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67"},{"client_msg_id":"8287f397-6d3e-4383-95eb-89393fdb55f5","type":"message","text":"Maybe best to do some regexp if it is a limited amount of variations?","user":"U8HHPBKQR","ts":"1608720790.328100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"d1Rxi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe best to do some regexp if it is a limited amount of variations?"}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67"},{"client_msg_id":"05d8c080-eace-4616-859e-61d8c0667177","type":"message","text":"I think I can avoid regexp. I am parsing the temporal logic formula anyway, so technically I can just use latexify at the last level (where the atomic predicates are defined), and construct the latexified expressions including higher level operators manually afterwards. Thanks!","user":"UFCNUVC67","ts":"1608721093.328300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0Rk/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think I can avoid regexp. I am parsing the temporal logic formula anyway, so technically I can just use latexify at the last level (where the atomic predicates are defined), and construct the latexified expressions including higher level operators manually afterwards. Thanks!"}]}]}],"thread_ts":"1608718371.327000","parent_user_id":"UFCNUVC67","reactions":[{"name":"+1","users":["U8HHPBKQR"],"count":1}]}]