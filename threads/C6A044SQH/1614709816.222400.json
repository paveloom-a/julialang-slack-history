[{"client_msg_id":"a24cc584-0172-4741-a259-e3b2e9bbab6a","type":"message","text":"I do not understand when to use Tuple vs Array. Consider the following pseudocode.\n```struct A \n var::NTuple{5, Float64} = (1, 2, 3, 4, 5) \nend \nstruct B \n var::Array{Int64, 1} = [1, 2, 3, 4, 5] \nend \n\n# increase by one \nA.var = A.var .+ 1 # does this create a new tuple? \nB.var = B.var .+ 1 # this mutates the array ```\nIs it more performance to simply mutate an array in place?","user":"U6Z8377N2","ts":"1614709816.222400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"92bvD","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I do not understand when to use Tuple vs Array. Consider the following pseudocode.\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"struct A \n var::NTuple{5, Float64} = (1, 2, 3, 4, 5) \nend \nstruct B \n var::Array{Int64, 1} = [1, 2, 3, 4, 5] \nend \n\n# increase by one \nA.var = A.var .+ 1 # does this create a new tuple? \nB.var = B.var .+ 1 # this mutates the array "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Is it more performance to simply mutate an array in place?"}]}]}],"thread_ts":"1614709816.222400","reply_count":9,"reply_users_count":3,"latest_reply":"1614711998.224400","reply_users":["B01J9QZ4SP8","U7HAYKY9X","U6Z8377N2"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1614709818.222500","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"d525c790-d020-4262-bcbd-8458b659cc17","type":"message","text":"It's also a little tricky. Quite tricky, actually. Tuples have the potential to be faster, but it requires the compiler to do things just right. And you can end up encountering many, many edge cases where it doesn't.\nA good rule of thumb is that small tuples (say, few tens of elements) are faster than arrays","user":"U7HAYKY9X","ts":"1614710067.222900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"V7=tK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's also a little tricky. Quite tricky, actually. Tuples have the potential to be faster, but it requires the compiler to do things just right. And you can end up encountering many, many edge cases where it doesn't.\nA good rule of thumb is that small tuples (say, few tens of elements) are faster than arrays"}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"d1f30489-92dd-4fbe-96d9-4b6672eba5f2","type":"message","text":"The key thing is that because tuples are immutable, the compiler is free to do all kinds of optimizations. For example, it's impossible to distinguish between two copies of immutable tuples, so the compiler can do copy them freely, store them on the stack and in registers, etc. etc.","user":"U7HAYKY9X","ts":"1614710143.223100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"FS8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The key thing is that because tuples are immutable, the compiler is free to do all kinds of optimizations. For example, it's impossible to distinguish between two copies of immutable tuples, so the compiler can do copy them freely, store them on the stack and in registers, etc. etc."}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"e8e1b7ec-27eb-4e69-8aad-8e69c5e36703","type":"message","text":"hmm I have a monolith struct with all kinds of types so I am not sure if the compiler will be smart enough in this case","user":"U6Z8377N2","ts":"1614710406.223300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"z0hP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hmm I have a monolith struct with all kinds of types so I am not sure if the compiler will be smart enough in this case"}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"41ce3a1e-cd6a-47b3-bd10-843f1bb2ff4d","type":"message","text":"I wonder if I can use StaticArrays to get the best of both worlds maybe","user":"U6Z8377N2","ts":"1614710475.223500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eE5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I wonder if I can use StaticArrays to get the best of both worlds maybe"}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"3577a077-d376-410a-85e6-fd6eb0f16354","type":"message","text":"For example, here is a portion of my struct\n```@with_kw mutable struct ModelParameters\n    β::Float64 = 0.0267      \n    β₊::Float64 = 0.0         \n    α::Float64 = 0.75         \n    ϵ₁::NTuple{5, Float64} = 0.26 .* (0.0, 0.0, 1, 1, 1)        \n    ϵ₂::NTuple{5, Float64} = 0.475 .* (0.0, 0.0, 1, 1, 1)   \n    λ::Array{Int64,1} = [0, 0, 0, 0, 0]            \n    s_vac::Float64 = 0  \n    v_vac::Float64 = 0                                          \n    covreached::Array{Bool,1} = [0, 0, 1, 1, 1]  \n    p::NTuple{5, Float64} = (0.3, 0.377, 0.328, 0.328, 0.188) \n    ρ₁::NTuple{5, Float64} = 0.52 .* (1.0, 1.0, 1.0, 1.0, 1.0)   \n    ρ₂::NTuple{5, Float64} = 0.95 .* (1.0, 1.0, 1.0, 1.0, 1.0) ```\nAs you can see, some variables are tuples and some I've started converting to Arrays since I need to mutate them","user":"U6Z8377N2","ts":"1614710559.223700","team":"T68168MUP","edited":{"user":"U6Z8377N2","ts":"1614710579.000000"},"blocks":[{"type":"rich_text","block_id":"ElnY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For example, here is a portion of my struct\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@with_kw mutable struct ModelParameters\n    β::Float64 = 0.0267      \n    β₊::Float64 = 0.0         \n    α::Float64 = 0.75         \n    ϵ₁::NTuple{5, Float64} = 0.26 .* (0.0, 0.0, 1, 1, 1)        \n    ϵ₂::NTuple{5, Float64} = 0.475 .* (0.0, 0.0, 1, 1, 1)   \n    λ::Array{Int64,1} = [0, 0, 0, 0, 0]            \n    s_vac::Float64 = 0  \n    v_vac::Float64 = 0                                          \n    covreached::Array{Bool,1} = [0, 0, 1, 1, 1]  \n    p::NTuple{5, Float64} = (0.3, 0.377, 0.328, 0.328, 0.188) \n    ρ₁::NTuple{5, Float64} = 0.52 .* (1.0, 1.0, 1.0, 1.0, 1.0)   \n    ρ₂::NTuple{5, Float64} = 0.95 .* (1.0, 1.0, 1.0, 1.0, 1.0) "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"As you can see, some variables are tuples and some I've started converting to Arrays since I need to mutate them"}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"ec62bd48-7c50-4c07-b916-a49a7f6b5f15","type":"message","text":"If your overall struct is mutable, you can use SetField to mutate it","user":"U7HAYKY9X","ts":"1614711952.224000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5VhT1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If your overall struct is mutable, you can use SetField to mutate it"}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"2963d174-9108-4b43-a0c8-dadd2584e1d7","type":"message","text":"To mutate the immutable tuples, I mean. So SetField just creates new tuples and updates the mutable struct.","user":"U7HAYKY9X","ts":"1614711970.224200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3t6Hr","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"To mutate the immutable tuples, I mean. So SetField just creates new tuples and updates the mutable struct."}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"},{"client_msg_id":"34e41c08-c944-4ad1-b635-31696ad213eb","type":"message","text":"You can also just use arrays, it's just that small typles are more efficient.\n(Also, StaticArrays just use a Tuple itself to store its data)","user":"U7HAYKY9X","ts":"1614711998.224400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ndP","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can also just use arrays, it's just that small typles are more efficient.\n(Also, StaticArrays just use a Tuple itself to store its data)"}]}]}],"thread_ts":"1614709816.222400","parent_user_id":"U6Z8377N2"}]