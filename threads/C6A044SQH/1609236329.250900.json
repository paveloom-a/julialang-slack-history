[{"client_msg_id":"942a8d7a-3530-48cd-baa0-f9f21ab2a6ec","type":"message","text":"Is there a reason not to add the catch-all method\n```filter(f, a) = filter(f, collect(a))```\nto Julia Base?","user":"U01GVKTVA23","ts":"1609236329.250900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"YFpIn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a reason not to add the catch-all method\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"filter(f, a) = filter(f, collect(a))"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"to Julia Base?"}]}]}],"thread_ts":"1609236329.250900","reply_count":7,"reply_users_count":5,"latest_reply":"1609250093.255100","reply_users":["U67G3QRJM","U01GVKTVA23","U6C5KSWAC","UH24GRBLL","UD0NS8PDF"],"subscribed":false},{"client_msg_id":"423357bb-555e-4377-816e-e0d71eac7bb7","type":"message","text":"Yes: `collect` allocates an array and you almost never need or want to do this. What are you trying to do?","user":"U67G3QRJM","ts":"1609244502.253100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Vdazs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes: "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":" allocates an array and you almost never need or want to do this. What are you trying to do?"}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23"},{"client_msg_id":"582fce3a-5f7f-45b6-91ab-5c17442ce9fd","type":"message","text":"Thanks for the response. Don't you always want to allocate an array when `filter`ing? Unless you want to apply the filter in some kind of lazy way--in which case you will need to be defining a method specific to your type anyway, no?\n\nI'm just trying to understand julia better. More concretely, I was surprised to find the output of `Iterators.flatten` needing a `collect` before it could be filtered:\n```a = [NaN, 20., 12.]\nb = Iterators.flatten([a, 2a])\nb |&gt; collect |&gt; x-&gt;filter(!isnan, x) # [20.0, 12.0, 40.0, 24.0]```","user":"U01GVKTVA23","ts":"1609245709.253300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S1GMi","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks for the response. Don't you always want to allocate an array when "},{"type":"text","text":"filter","style":{"code":true}},{"type":"text","text":"ing? Unless you want to apply the filter in some kind of lazy way--in which case you will need to be defining a method specific to your type anyway, no?\n\nI'm just trying to understand julia better. More concretely, I was surprised to find the output of "},{"type":"text","text":"Iterators.flatten","style":{"code":true}},{"type":"text","text":" needing a "},{"type":"text","text":"collect","style":{"code":true}},{"type":"text","text":" before it could be filtered:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"a = [NaN, 20., 12.]\nb = Iterators.flatten([a, 2a])\nb |> collect |> x->filter(!isnan, x) # [20.0, 12.0, 40.0, 24.0]"}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23"},{"client_msg_id":"d35c3f41-bb08-401b-9314-fe0a1401960a","type":"message","text":"You can use `Iterators.filter`:\n\n```julia&gt; a = [NaN, 20., 12.]\n3-element Array{Float64,1}:\n NaN\n  20.0\n  12.0\n\njulia&gt; b = Iterators.flatten([a, 2a])\nBase.Iterators.Flatten{Array{Array{Float64,1},1}}([[NaN, 20.0, 12.0], [NaN, 40.0, 24.0]])\n\njulia&gt; for x in Iterators.filter(!isnan, b); println(x); end\n20.0\n12.0\n40.0\n24.0```\n(not sure why that method isn't exported :shrug:)","user":"U6C5KSWAC","ts":"1609246257.253800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"MBA2b","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can use "},{"type":"text","text":"Iterators.filter","style":{"code":true}},{"type":"text","text":":\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> a = [NaN, 20., 12.]\n3-element Array{Float64,1}:\n NaN\n  20.0\n  12.0\n\njulia> b = Iterators.flatten([a, 2a])\nBase.Iterators.Flatten{Array{Array{Float64,1},1}}([[NaN, 20.0, 12.0], [NaN, 40.0, 24.0]])\n\njulia> for x in Iterators.filter(!isnan, b); println(x); end\n20.0\n12.0\n40.0\n24.0"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"\n(not sure why that method isn't exported "},{"type":"emoji","name":"shrug"},{"type":"text","text":")"}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23","reactions":[{"name":"+1","users":["U01GVKTVA23"],"count":1}]},{"client_msg_id":"9435c499-3239-45e5-a873-2a7c7c1eb5d2","type":"message","text":"Ah, I see `Iterators.filter` is a catch-all implemented with laziness... Nice one.\nI suppose it is not exported to keep the choice between lazy and eager, as implied by the `@docs Iterators.filter` ?? Same lazy/eager separation between `Iterators`/`Base` seems to go for `accumulate` and `reverse`. Wouldn't it be better to make the lazy implementation the default and distinguish between the two with an option `lazy::Bool`?","user":"U01GVKTVA23","ts":"1609247580.254100","team":"T68168MUP","edited":{"user":"U01GVKTVA23","ts":"1609247663.000000"},"blocks":[{"type":"rich_text","block_id":"1o7J0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah, I see "},{"type":"text","text":"Iterators.filter","style":{"code":true}},{"type":"text","text":" is a catch-all implemented with laziness... Nice one.\nI suppose it is not exported to keep the choice between lazy and eager, as implied by the "},{"type":"text","text":"@docs Iterators.filter","style":{"code":true}},{"type":"text","text":" ?? Same lazy/eager separation between "},{"type":"text","text":"Iterators","style":{"code":true}},{"type":"text","text":"/"},{"type":"text","text":"Base","style":{"code":true}},{"type":"text","text":" seems to go for "},{"type":"text","text":"accumulate","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"reverse","style":{"code":true}},{"type":"text","text":". Wouldn't it be better to make the lazy implementation the default and distinguish between the two with an option "},{"type":"text","text":"lazy::Bool","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23"},{"client_msg_id":"3215a579-e5f0-479d-a352-b311be39405d","type":"message","text":"making it a keyword would make it type unstable","user":"UH24GRBLL","ts":"1609249552.254700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+38Y4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"making it a keyword would make it type unstable"}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23"},{"client_msg_id":"b1aad82a-2aa3-4759-9f49-faaeb8809822","type":"message","text":"since the output type is no longer defined by the input types alone, but by the input values","user":"UH24GRBLL","ts":"1609249572.254900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5=fy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"since the output type is no longer defined by the input types alone, but by the input values"}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23"},{"client_msg_id":"72b5b735-8728-4384-9c6e-31dbea6e8b21","type":"message","text":"BTW there is also syntax for this, `(x for x in a if f(x))`","user":"UD0NS8PDF","ts":"1609250093.255100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j=1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"BTW there is also syntax for this, "},{"type":"text","text":"(x for x in a if f(x))","style":{"code":true}}]}]}],"thread_ts":"1609236329.250900","parent_user_id":"U01GVKTVA23"}]