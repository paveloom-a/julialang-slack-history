[{"client_msg_id":"911b07e4-60bd-4cea-b940-e89cf09caf14","type":"message","text":"I'm trying to find an efficient way to check monotonicity in an `N x 2` array. So for instance, my array would be `x = [[1 , 3, 5]  [4, 1, 6] ]` and I would want to check that `1 &lt; 3 &lt;5 ` and `4 &lt; 1 &lt; 6` and return true only if both are valid. I can do `issorted(x[:,1]) &amp; issorted(x[:,2])` but that only tests weak monotonicity.. might anyone have a suggestion?","user":"U91Q3595Y","ts":"1610033087.464400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"XbTZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm trying to find an efficient way to check monotonicity in an "},{"type":"text","text":"N x 2","style":{"code":true}},{"type":"text","text":" array. So for instance, my array would be "},{"type":"text","text":"x = [[1 , 3, 5]  [4, 1, 6] ]","style":{"code":true}},{"type":"text","text":" and I would want to check that `1 < 3 <5 ` and "},{"type":"text","text":"4 < 1 < 6","style":{"code":true}},{"type":"text","text":" and return true only if both are valid. I can do "},{"type":"text","text":"issorted(x[:,1]) & issorted(x[:,2])","style":{"code":true}},{"type":"text","text":" but that only tests weak monotonicity.. might anyone have a suggestion?"}]}]}],"thread_ts":"1610033087.464400","reply_count":24,"reply_users_count":9,"latest_reply":"1610064846.050800","reply_users":["URAB674RH","UEN48T0BT","U7HAYKY9X","U0179G7FG4F","U91Q3595Y","UD0NS8PDF","UBEF50B7C","UC7AF7NSU","UB197FRCL"],"subscribed":false},{"client_msg_id":"49c79b98-d3c6-42d2-a819-20709acfd996","type":"message","text":"issorted(x[:,1]) &amp;&amp; issorted(x[:,2])","user":"URAB674RH","ts":"1610033589.464500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"8B/gj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"issorted(x[:,1]) && issorted(x[:,2])"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"71e410be-1398-4c57-bb16-742498fe165c","type":"message","text":"What's the rank of the result you want? A single `Bool`? Or a `Vector{Bool}` with length `N`?","user":"UEN48T0BT","ts":"1610033718.464700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"3//iy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What's the rank of the result you want? A single "},{"type":"text","text":"Bool","style":{"code":true}},{"type":"text","text":"? Or a "},{"type":"text","text":"Vector{Bool}","style":{"code":true}},{"type":"text","text":" with length "},{"type":"text","text":"N","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"5e8cf9e1-8f66-4ec4-b519-e75e70319cb3","type":"message","text":"I would do it manually, though it's a little clumsy:\n```import Base.Order: ForwardOrdering, ReverseOrdering, Forward\n\nfunction is_monotonic(it, order::Union{ForwardOrdering, ReverseOrdering}=Forward\n)\n    f = order isa ForwardOrdering ? (x, y) -&gt; isless(y, x) : isless\n    itres = iterate(it)\n    itres === nothing &amp;&amp; return true\n    lastelem, state = itres::Tuple{Any, Any}\n    itres = iterate(it, state)\n    while itres !== nothing\n        x, state = itres::Tuple{Any, Any}\n        f(x, lastelem) || return false\n        lastelem = x\n        itres = iterate(it, state)\n    end\n    return true\nend```\nA better solution would use a functional style, perhaps using transducers.","user":"U7HAYKY9X","ts":"1610033891.464900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ZrX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would do it manually, though it's a little clumsy:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"import Base.Order: ForwardOrdering, ReverseOrdering, Forward\n\nfunction is_monotonic(it, order::Union{ForwardOrdering, ReverseOrdering}=Forward\n)\n    f = order isa ForwardOrdering ? (x, y) -> isless(y, x) : isless\n    itres = iterate(it)\n    itres === nothing && return true\n    lastelem, state = itres::Tuple{Any, Any}\n    itres = iterate(it, state)\n    while itres !== nothing\n        x, state = itres::Tuple{Any, Any}\n        f(x, lastelem) || return false\n        lastelem = x\n        itres = iterate(it, state)\n    end\n    return true\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"A better solution would use a functional style, perhaps using transducers."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"1e05d665-6688-4b6c-8141-af8e960cef1f","type":"message","text":"If it isn't performance critical, you can use `is_monotonic(x) = @views all(x[begin:end-1] .&lt; x[begin+1,end])` followed by `all(is_monotonic, eachrow(x)` for the `Nx2` matrix","user":"U0179G7FG4F","ts":"1610034072.465100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"SGO8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"If it isn't performance critical, you can use "},{"type":"text","text":"is_monotonic(x) = @views all(x[begin:end-1] .< x[begin+1,end])","style":{"code":true}},{"type":"text","text":" followed by "},{"type":"text","text":"all(is_monotonic, eachrow(x)","style":{"code":true}},{"type":"text","text":" for the "},{"type":"text","text":"Nx2","style":{"code":true}},{"type":"text","text":" matrix"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"224F6A20-CF6F-4777-842F-0B9B0E307FF5","type":"message","text":"<@UEN48T0BT> I’m going for a single Boolean (for the “all” condition)","user":"U91Q3595Y","ts":"1610035316.466100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"+j/cl","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UEN48T0BT"},{"type":"text","text":" I’m going for a single Boolean (for the “all” condition)"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"+1","users":["UEN48T0BT"],"count":1}]},{"client_msg_id":"C3118937-2CB4-4CF8-BD80-B47DBBBCE06C","type":"message","text":"Thanks <@U7HAYKY9X> and <@U0179G7FG4F> — I’ll try these out. I don’t think this should be a performance bottleneck. I’m surprised there isn’t anything cleaner though. I thought maybe there’s a trick with ‘map’ but I couldn’t get one to work..","user":"U91Q3595Y","ts":"1610035397.468200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OtZp","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks "},{"type":"user","user_id":"U7HAYKY9X"},{"type":"text","text":" and "},{"type":"user","user_id":"U0179G7FG4F"},{"type":"text","text":" — I’ll try these out. I don’t think this should be a performance bottleneck. I’m surprised there isn’t anything cleaner though. I thought maybe there’s a trick with ‘map’ but I couldn’t get one to work.."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"160fe2b3-7f72-4f8f-badd-0bb525b6d1d7","type":"message","text":"Man, is it just me or is that function actually really hard to implement in a way that works for all iterables and is efficient?","user":"U7HAYKY9X","ts":"1610035825.468400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Q7V7","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Man, is it just me or is that function actually really hard to implement in a way that works for all iterables and is efficient?"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"disappointed","users":["U91Q3595Y"],"count":1}]},{"client_msg_id":"7ee0d856-99b4-4fae-b3f2-2dbca31800a6","type":"message","text":"You can write `all(&gt;(0), diff(x, dims=1))`?","user":"UD0NS8PDF","ts":"1610035840.468600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kTXJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You can write "},{"type":"text","text":"all(>(0), diff(x, dims=1))","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"dart","users":["U91Q3595Y"],"count":1}]},{"client_msg_id":"139a8a89-bd73-4cc2-aa67-61e3da305bdd","type":"message","text":"Or just `all(issorted, eachcol(x))`","user":"UD0NS8PDF","ts":"1610035899.469000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"c+AV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Or just "},{"type":"text","text":"all(issorted, eachcol(x))","style":{"code":true}}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"+1","users":["U019N1ECQ9Z"],"count":1}]},{"client_msg_id":"05930cfa-1a17-49dc-81d1-1dd5cb6a6391","type":"message","text":"`all(r -&gt; issorted(r) &amp;&amp; allunique(r), eachrow(x))`","user":"UBEF50B7C","ts":"1610035930.469200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"C7UW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"all(r -> issorted(r) && allunique(r), eachrow(x))","style":{"code":true}}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"tada","users":["U0179G7FG4F","U91Q3595Y"],"count":2},{"name":"pray","users":["U91Q3595Y"],"count":1}]},{"client_msg_id":"462032d4-501c-4117-92a8-221b57adcdfa","type":"message","text":"`issorted` doesn't test strict monotonicity but `all(&gt;(0), diff(x, dims=1))` works I think!","user":"U91Q3595Y","ts":"1610035948.469500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ocIQI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"issorted","style":{"code":true}},{"type":"text","text":" doesn't test strict monotonicity but "},{"type":"text","text":"all(>(0), diff(x, dims=1))","style":{"code":true}},{"type":"text","text":" works I think!"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"afb55857-5050-4814-9cbd-a75bdaffffde","type":"message","text":"This does too (I hadn't thought of including a uniqueness check directly) `all(r -&gt; issorted(r) &amp;&amp; allunique(r), eachrow(x))`","user":"U91Q3595Y","ts":"1610035978.469800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UKY","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"This does too (I hadn't thought of including a uniqueness check directly) "},{"type":"text","text":"all(r -> issorted(r) && allunique(r), eachrow(x))","style":{"code":true}}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"e8247edb-a1cb-4773-ad5d-7822fa48d72c","type":"message","text":"Oh right, sorry, I missed the strong/weak bit. `diff` works although it allocates of course.","user":"UD0NS8PDF","ts":"1610035992.470100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"eQdh","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oh right, sorry, I missed the strong/weak bit. "},{"type":"text","text":"diff","style":{"code":true}},{"type":"text","text":" works although it allocates of course."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"pray","users":["U91Q3595Y"],"count":1}]},{"client_msg_id":"58878098-5e26-4034-bd1e-3666e0e16c2f","type":"message","text":"Thanks everyone!","user":"U91Q3595Y","ts":"1610036016.470500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9VPEf","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Thanks everyone!"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"406d82de-baaf-42bd-a614-3a06045c56f0","type":"message","text":"the `allunique` test still isn't going to be efficient. The extra knowledge that repeats can only be adjacent would make it much faster. (the current algorithm constructs a set with `O(n)` elements","user":"U0179G7FG4F","ts":"1610036065.470800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"iMuAy","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the "},{"type":"text","text":"allunique","style":{"code":true}},{"type":"text","text":" test still isn't going to be efficient. The extra knowledge that repeats can only be adjacent would make it much faster. (the current algorithm constructs a set with "},{"type":"text","text":"O(n)","style":{"code":true}},{"type":"text","text":" elements"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"993b5f72-3e9f-4b34-b9a2-983db109dacf","type":"message","text":"It is a bit weird that there seems to be no canonical way to iterate over consecutive pairs without some weird usage of folds","user":"UBEF50B7C","ts":"1610038659.471200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"w0SJJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It is a bit weird that there seems to be no canonical way to iterate over consecutive pairs without some weird usage of folds"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"+1","users":["U0179G7FG4F","U91Q3595Y","U7HAYKY9X"],"count":3}]},{"client_msg_id":"70756985-4acc-45c2-9b36-963b95501fe6","type":"message","text":"Does this count as weird?\n```julia&gt; all(eachcol(x)) do c\n         all(Base.splat(&lt;),zip(c,Iterators.drop(c,1)))\n       end\ntrue```\nHow might a better pattern look, I wonder?\n\nWould be nice if you could write `all(&lt;, c, Iterators.drop(c,1))` to get the zip, like map allows.","user":"UD0NS8PDF","ts":"1610038892.471600","team":"T68168MUP","edited":{"user":"UD0NS8PDF","ts":"1610039138.000000"},"blocks":[{"type":"rich_text","block_id":"9HHlE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Does this count as weird?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> all(eachcol(x)) do c\n         all(Base.splat(<),zip(c,Iterators.drop(c,1)))\n       end\ntrue"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"How might a better pattern look, I wonder?\n\nWould be nice if you could write "},{"type":"text","text":"all(<, c, Iterators.drop(c,1))","style":{"code":true}},{"type":"text","text":" to get the zip, like map allows."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"+1","users":["U0179G7FG4F"],"count":1}]},{"client_msg_id":"3db19346-b6d2-4afe-8f3c-61bea7ac8339","type":"message","text":"that was one of the first things I tried","user":"U0179G7FG4F","ts":"1610039302.472000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BUc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"that was one of the first things I tried"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"aa706504-d753-428c-a04a-57928a8e21d2","type":"message","text":"and then I was sad","user":"U0179G7FG4F","ts":"1610039307.472200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0v1JG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"and then I was sad"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"85a7808a-dbfa-4134-afcd-386fa1ff9dc8","type":"message","text":"I think a clean good design would be if transducers had a peel function that allowed you to apply a map operation to only the first element. <@UC7AF7NSU> how would you solve this?","user":"U7HAYKY9X","ts":"1610043345.476200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DdJa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think a clean good design would be if transducers had a peel function that allowed you to apply a map operation to only the first element. "},{"type":"user","user_id":"UC7AF7NSU"},{"type":"text","text":" how would you solve this?"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"f05cf7c7-5d77-44e7-996f-5bf5e6297a81","type":"message","text":"mcabbott's `zip`-`drop` combo looks good to me. You can also use iterator comprehension instead of `splat`. Alternative more direct method is to use `IterTools.partition`: <https://juliacollections.github.io/IterTools.jl/latest/#IterTools.partition> Unlike `Iterators.partition` which yields vectors, `IterTools.partition` yields tuples so I think it is (can be) efficient.\n\nI'm actually thinking to add a version of `Transducers.Partition` that produces tuples instead of vectors. It can be used to parallelize something like this quite easily.","user":"UC7AF7NSU","ts":"1610058218.034400","team":"T68168MUP","edited":{"user":"UC7AF7NSU","ts":"1610058255.000000"},"blocks":[{"type":"rich_text","block_id":"orW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"mcabbott's "},{"type":"text","text":"zip","style":{"code":true}},{"type":"text","text":"-"},{"type":"text","text":"drop","style":{"code":true}},{"type":"text","text":" combo looks good to me. You can also use iterator comprehension instead of "},{"type":"text","text":"splat","style":{"code":true}},{"type":"text","text":". Alternative more direct method is to use "},{"type":"text","text":"IterTools.partition","style":{"code":true}},{"type":"text","text":": "},{"type":"link","url":"https://juliacollections.github.io/IterTools.jl/latest/#IterTools.partition"},{"type":"text","text":" Unlike "},{"type":"text","text":"Iterators.partition","style":{"code":true}},{"type":"text","text":" which yields vectors, "},{"type":"text","text":"IterTools.partition","style":{"code":true}},{"type":"text","text":" yields tuples so I think it is (can be) efficient.\n\nI'm actually thinking to add a version of "},{"type":"text","text":"Transducers.Partition","style":{"code":true}},{"type":"text","text":" that produces tuples instead of vectors. It can be used to parallelize something like this quite easily."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"d4210947-a713-429d-90e6-f97b74c70aa4","type":"message","text":"I see, and unlike `Iterators.partition` it accepts a step size, so you can have overlap.","user":"UD0NS8PDF","ts":"1610058493.034700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yoaJj","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see, and unlike "},{"type":"text","text":"Iterators.partition","style":{"code":true}},{"type":"text","text":" it accepts a step size, so you can have overlap."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"8f5fd4a9-0eef-4b97-9d03-cdb13631f313","type":"message","text":"oh yes, I forgot that `Iterator.partition` doesn't have step size.","user":"UC7AF7NSU","ts":"1610062441.050300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sEDCE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"oh yes, I forgot that "},{"type":"text","text":"Iterator.partition","style":{"code":true}},{"type":"text","text":" doesn't have step size."}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y"},{"client_msg_id":"d091866f-9e44-4ee8-98ca-d8eb0e4960a7","type":"message","text":"`issorted` also accepts a different operator, e.g.,\n```julia&gt; issorted([1, 1, 2, 3], lt=≤)\nfalse```","user":"UB197FRCL","ts":"1610064846.050800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"9q7Z","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"issorted","style":{"code":true}},{"type":"text","text":" also accepts a different operator, e.g.,\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> issorted([1, 1, 2, 3], lt=≤)\nfalse"}]}]}],"thread_ts":"1610033087.464400","parent_user_id":"U91Q3595Y","reactions":[{"name":"+1","users":["UD0NS8PDF","U0179G7FG4F","U7HAYKY9X","U91Q3595Y"],"count":4},{"name":"dart","users":["U7HAYKY9X","U91Q3595Y"],"count":2}]}]