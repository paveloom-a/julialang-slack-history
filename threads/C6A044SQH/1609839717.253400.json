[{"client_msg_id":"ddd14760-0485-4a19-af0c-35106f781d6e","type":"message","text":"I am new, but not new to REPL's (coming from Lisp), and slightly confused about using the Julia REPL in a particular way. I have a package, which works correctly from the REPL and everything using Revise.jl, but I am not sure how to \"put the REPL in the scope of my package\". What I mean, is all functions from my package that I call must be fully qualified as `MyPackage.some_func()`, even after `using MyPackage`. How can I tell my REPL to switch packages such that I only have to issue `foo()`?","user":"U01J6E8RS12","ts":"1609839717.253400","team":"T68168MUP","edited":{"user":"U01J6E8RS12","ts":"1609839754.000000"},"blocks":[{"type":"rich_text","block_id":"RAlB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I am new, but not new to REPL's (coming from Lisp), and slightly confused about using the Julia REPL in a particular way. I have a package, which works correctly from the REPL and everything using Revise.jl, but I am not sure how to \"put the REPL in the scope of my package\". What I mean, is all functions from my package that I call must be fully qualified as "},{"type":"text","text":"MyPackage.some_func()","style":{"code":true}},{"type":"text","text":", even after "},{"type":"text","text":"using MyPackage","style":{"code":true}},{"type":"text","text":". How can I tell my REPL to switch packages such that I only have to issue "},{"type":"text","text":"foo()","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1609839717.253400","reply_count":20,"reply_users_count":6,"latest_reply":"1609859783.276100","reply_users":["UD0NS8PDF","U01J6E8RS12","U01HXQ6EBH9","UH24GRBLL","U6QPTG69E","UC4QQPG4A"],"subscribed":false},{"client_msg_id":"a06d9d98-c12c-4568-a8c1-fe52e8b8c1ba","type":"message","text":"You either need `export foo, some_func` inside the package, or `using MyPackage: foo, some_func` from outside of it.","user":"UD0NS8PDF","ts":"1609839831.253600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"f9G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You either need "},{"type":"text","text":"export foo, some_func","style":{"code":true}},{"type":"text","text":" inside the package, or "},{"type":"text","text":"using MyPackage: foo, some_func","style":{"code":true}},{"type":"text","text":" from outside of it."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"9833c02f-0de5-4319-a847-c7eed8f7ce5a","type":"message","text":"I see. Is there by chance a package offering a macro for annotating functions/types/etc with exports? I envision this package to have hundreds of functions, and managing them all in a toplevel `export` section away from their declarations is going to be a maintenance disaster.","user":"U01J6E8RS12","ts":"1609839967.253800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"bQ=1","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I see. Is there by chance a package offering a macro for annotating functions/types/etc with exports? I envision this package to have hundreds of functions, and managing them all in a toplevel "},{"type":"text","text":"export","style":{"code":true}},{"type":"text","text":" section away from their declarations is going to be a maintenance disaster."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"87591a77-c767-4f2d-a151-0cd1c3f26b41","type":"message","text":"Surely people have written such things. But the usual style is to try not to need so many, via parametric types / different methods of the same function / extending Base functions for your types.","user":"UD0NS8PDF","ts":"1609840195.254000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ziw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Surely people have written such things. But the usual style is to try not to need so many, via parametric types / different methods of the same function / extending Base functions for your types."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"73F63B7D-B1F3-430C-970F-B3B4C2DFF9CA","type":"message","text":"I'm new as well, but this seems to be the only thing I could find out there that does exactly what you want. ( `exportall`) Even so, it would appear ill-advised. There are some alternative solutions mentioned in this thread as well, although they don't really do exactly what you want. <https://discourse.julialang.org/t/exportall/4970/16|https://discourse.julialang.org/t/exportall/4970/16>","user":"U01HXQ6EBH9","ts":"1609842156.256900","team":"T68168MUP","edited":{"user":"U01HXQ6EBH9","ts":"1609842201.000000"},"attachments":[{"service_name":"JuliaLang","title":"Exportall?","title_link":"https://discourse.julialang.org/t/exportall/4970/16","text":"Here’s a version of the export-all code chunk from @stevengj that is updated for Julia v1.0. (Well, for v1.4 at least. I haven’t tested on v1.0). # export all for n in names(@__MODULE__; all=true) if Base.isidentifier(n) &amp;&amp; n ∉ (Symbol(@__MODULE__), :eval, :include) @eval export $n end end When I’m developing a new package, I find it pretty convenient to just export all the functions in the package. Later when the code stabilizes I can choose which functions to export, but init...","fallback":"JuliaLang: Exportall?","thumb_url":"https://aws1.discourse-cdn.com/business5/uploads/julialang/original/2X/1/12829a7ba92b924d4ce81099cbf99785bee9b405.png","ts":1595454428,"from_url":"https://discourse.julialang.org/t/exportall/4970/16","thumb_width":408,"thumb_height":263,"service_icon":"https://aws1.discourse-cdn.com/business5/uploads/julialang/optimized/2X/6/6ca888e296f59ca2a599807f7d5edd489e3d1829_2_180x180.png","id":1,"original_url":"https://discourse.julialang.org/t/exportall/4970/16"}],"blocks":[{"type":"rich_text","block_id":"abKm","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm new as well, but this seems to be the only thing I could find out there that does exactly what you want. ( "},{"type":"text","text":"exportal","style":{"code":true}},{"type":"text","text":"l","style":{"code":true}},{"type":"text","text":") Even so, it would appear ill-advised. There are some alternative solutions mentioned in this thread as well, although they don't really do exactly what you want. "},{"type":"link","url":"https://discourse.julialang.org/t/exportall/4970/16","text":"https://discourse.julialang.org/t/exportall/4970/16"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"82c35a03-0e05-423e-b007-9c045884c579","type":"message","text":"hundreds of functions with different names, all to be used? That sounds like it could be multiple packages for individual pieces of functionality instead :thinking_face:","user":"UH24GRBLL","ts":"1609843174.260300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7/phd","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"hundreds of functions with different names, all to be used? That sounds like it could be multiple packages for individual pieces of functionality instead "},{"type":"emoji","name":"thinking_face"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"3ad024a1-c0c1-4456-bc57-2ce6b739a96d","type":"message","text":"would also allow people to only depend on the stuff they need, making their dependencies smaller","user":"UH24GRBLL","ts":"1609843194.260500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"lBA","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"would also allow people to only depend on the stuff they need, making their dependencies smaller"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"7fe8e5c0-9df1-4a76-889f-ff849e1fc3e7","type":"message","text":"What you asked might be available in the future: <https://github.com/JuliaLang/julia/pull/33872>","user":"U6QPTG69E","ts":"1609843633.260700","team":"T68168MUP","edited":{"user":"U6QPTG69E","ts":"1609843645.000000"},"blocks":[{"type":"rich_text","block_id":"gG6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"What you asked might be available in the future: "},{"type":"link","url":"https://github.com/JuliaLang/julia/pull/33872"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12","reactions":[{"name":"+1","users":["UD0NS8PDF"],"count":1}]},{"client_msg_id":"4d4b02f9-028e-4e1b-a524-7e013f359c81","type":"message","text":"Well game engines are complex.","user":"U01J6E8RS12","ts":"1609843696.261000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"5Fo","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Well game engines are complex."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"ab96777b-41c6-480e-88b7-ceed12960f74","type":"message","text":"There are a lot of disjoint mathematical functions, even with generic programming. Porting quite a large linear algebra library with specific semantics from my other language's codebase.","user":"U01J6E8RS12","ts":"1609843746.261200","team":"T68168MUP","edited":{"user":"U01J6E8RS12","ts":"1609843766.000000"},"blocks":[{"type":"rich_text","block_id":"LepK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There are a lot of disjoint mathematical functions, even with generic programming. Porting quite a large linear algebra library with specific semantics from my other language's codebase."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"e60c1fd6-b632-4f03-b758-ffeb3e2c7ad2","type":"message","text":"do you know about `LinearAlgebra`, the stdlib?","user":"UH24GRBLL","ts":"1609843843.261500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"t9P","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"do you know about "},{"type":"text","text":"LinearAlgebra","style":{"code":true}},{"type":"text","text":", the stdlib?"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"4c4f8b64-4649-4cc4-b08e-cd1374d90266","type":"message","text":"Yes, it will be a basis, but not what I require.","user":"U01J6E8RS12","ts":"1609843863.261700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4Mne","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, it will be a basis, but not what I require."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"584c6841-2f71-4205-8ad0-238fb337cad8","type":"message","text":"Is there a plan for a game engine based on julia? I'd be interested to see that develop, is there a link?","user":"UC4QQPG4A","ts":"1609856228.263300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hFa","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a plan for a game engine based on julia? I'd be interested to see that develop, is there a link?"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"77991935-dea8-422d-a382-3be657513327","type":"message","text":"<@UC4QQPG4A> There is GameZero.jl, which is a simple framework for teaching game development.\n\nI am a new Julia user that spent the last 10 years writing an engine in Lisp more akin to Unity that I am planning on writing in Julia, but the scope is so large that I wouldn't hold your breath.","user":"U01J6E8RS12","ts":"1609858885.269300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Z7D","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"UC4QQPG4A"},{"type":"text","text":" There is GameZero.jl, which is a simple framework for teaching game development.\n\nI am a new Julia user that spent the last 10 years writing an engine in Lisp more akin to Unity that I am planning on writing in Julia, but the scope is so large that I wouldn't hold your breath."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"c42c8d79-e464-4a5f-a2d4-e2b143f90ce1","type":"message","text":"I'm not aware of any other efforts or serious game developers using Julia, but it seems like a perfect language for doing such.","user":"U01J6E8RS12","ts":"1609858932.269500","team":"T68168MUP","edited":{"user":"U01J6E8RS12","ts":"1609858947.000000"},"blocks":[{"type":"rich_text","block_id":"UW6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not aware of any other efforts or serious game developers using Julia, but it seems like a perfect language for doing such."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"107f62ad-76f5-48dd-8d98-8cadd6d751e5","type":"message","text":"I agree! I have felt for very long that Julia would shine  as a language for a game engine. There are a couple hurdles like hiding the GC and packaging but I suspect such a project would be very helpful indeed in pushing the language further","user":"UC4QQPG4A","ts":"1609859232.272100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"n8Vv","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree! I have felt for very long that Julia would shine  as a language for a game engine. There are a couple hurdles like hiding the GC and packaging but I suspect such a project would be very helpful indeed in pushing the language further"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"72ed163d-9444-4772-be62-3caaab9b61f7","type":"message","text":"I agree. The GC can be worked around in various ways, but the best optimization is just not having the work to optimize away. In other words, pre-allocate as much as possible so the GC doesn't have anything to do.","user":"U01J6E8RS12","ts":"1609859347.272500","team":"T68168MUP","edited":{"user":"U01J6E8RS12","ts":"1609859363.000000"},"blocks":[{"type":"rich_text","block_id":"17kWK","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I agree. The GC can be worked around in various ways, but the best optimization is just not having the work to optimize away. In other words, pre-allocate as much as possible so the GC doesn't have anything to do."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"8e0ac118-f96e-47bf-ba2f-aa32518954ea","type":"message","text":"One thing I'd personally love to see would be a julia frontend/syntax for shaders","user":"UH24GRBLL","ts":"1609859423.272800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IMG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"One thing I'd personally love to see would be a julia frontend/syntax for shaders"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"d76de5a2-7ec7-42de-b13f-8cf64fc947fc","type":"message","text":"all current efforts I'm aware of are basically traditional game engines","user":"UH24GRBLL","ts":"1609859453.273000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ewkoX","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"all current efforts I'm aware of are basically traditional game engines"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"6b5e98c6-019b-434a-872b-9d770e39e2e3","type":"message","text":"Yes, writing a GLSL compiler in Lisp was the game changer for my engine (no pun intended). Having a shader function look and feel just like a regular function allowed for re-using them across shader programs without nasty includes or C-style ifdef macros, and allows to selectively recompile them as a game is running to differentiate between subtle changes.","user":"U01J6E8RS12","ts":"1609859679.275500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OBW","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yes, writing a GLSL compiler in Lisp was the game changer for my engine (no pun intended). Having a shader function look and feel just like a regular function allowed for re-using them across shader programs without nasty includes or C-style ifdef macros, and allows to selectively recompile them as a game is running to differentiate between subtle changes."}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"},{"client_msg_id":"d54f0c9b-fab2-4efb-8ca9-f1b1fc22bc1f","type":"message","text":"You may be interested at what the folks at <https://github.com/JuliaGPU> are doing and how they're building julia -&gt; CUDA compilers","user":"UH24GRBLL","ts":"1609859783.276100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"aEsl","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"You may be interested at what the folks at "},{"type":"link","url":"https://github.com/JuliaGPU"},{"type":"text","text":" are doing and how they're building julia -> CUDA compilers"}]}]}],"thread_ts":"1609839717.253400","parent_user_id":"U01J6E8RS12"}]