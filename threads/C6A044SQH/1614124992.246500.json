[{"client_msg_id":"f38c647c-7272-46a7-9227-dfc7217b65b4","type":"message","text":"I'm pretty new to Julia and today I'm really struggling with multiplication. I'm noticing that there's a difference between scalars, 1-d arrays, and 2-d arrays when using the multiplication operator (very different from Matlab). I keep having issues with multiplying the wrong types of objects together even though it is a mathematically correct statement. For example, I want to do x^Ty, where x and y are column vectors with n elements, which I would think would be accomplished by x'*y, but Julia throws an error because x is Array{Float64,2} while y is Array{Float64,1} and suggests that I do element-wise multiplication instead. Is there a way to make y Array{Float64,2}? Any good resources to read so I can sort out my issue of multiplying the wrong objects and how to convert between Float64, Array{Float64,1}, and Array{Float64,2}? Coming from a Matlab background I don't care if I have a scalar, 1-d array with one element, or a 2-d array with one element because the multiplication operator works all the same, so keeping track of the object type is not something I'm used to doing.","user":"U01M3EUHL20","ts":"1614124992.246500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hZn","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm pretty new to Julia and today I'm really struggling with multiplication. I'm noticing that there's a difference between scalars, 1-d arrays, and 2-d arrays when using the multiplication operator (very different from Matlab). I keep having issues with multiplying the wrong types of objects together even though it is a mathematically correct statement. For example, I want to do x^Ty, where x and y are column vectors with n elements, which I would think would be accomplished by x'*y, but Julia throws an error because x is Array{Float64,2} while y is Array{Float64,1} and suggests that I do element-wise multiplication instead. Is there a way to make y Array{Float64,2}? Any good resources to read so I can sort out my issue of multiplying the wrong objects and how to convert between Float64, Array{Float64,1}, and Array{Float64,2}? Coming from a Matlab background I don't care if I have a scalar, 1-d array with one element, or a 2-d array with one element because the multiplication operator works all the same, so keeping track of the object type is not something I'm used to doing."}]}]}],"thread_ts":"1614124992.246500","reply_count":20,"reply_users_count":6,"latest_reply":"1614137553.252300","reply_users":["B01J9QZ4SP8","U9MD78Z9N","UDB26738Q","UH8A351DJ","U01M3EUHL20","U0138UTB7A4"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1614124993.246600","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"type":"message","text":"There is a really good talk on this called \"taking vector transpose seriously\" on youtube. I recommend watching that as it helped me, it also constrasted stuff with MatLab","user":"U9MD78Z9N","ts":"1614125066.246800","team":"T68168MUP","thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"6d7b2d20-4b21-4206-b802-4fdaed046b40","type":"message","text":"can you please provide a concrete example of what you tried?\n```julia&gt; x = rand(3)\n3-element Vector{Float64}:\n 0.331899283068698\n 0.7316759668560349\n 0.8992248287925988\n\njulia&gt; y = rand(3)\n3-element Vector{Float64}:\n 0.042707054222515195\n 0.8882982299927427\n 0.7654895569839029\n\njulia&gt; x' * y\n1.3524681227862456```","user":"UDB26738Q","ts":"1614125110.247000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jrB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"can you please provide a concrete example of what you tried?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> x = rand(3)\n3-element Vector{Float64}:\n 0.331899283068698\n 0.7316759668560349\n 0.8992248287925988\n\njulia> y = rand(3)\n3-element Vector{Float64}:\n 0.042707054222515195\n 0.8882982299927427\n 0.7654895569839029\n\njulia> x' * y\n1.3524681227862456"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"9bc37a7e-011e-4ee1-9ccc-07c7d09ef095","type":"message","text":"I think OP had something like this:\n```julia&gt; b = reshape(a, 3,1)\n3×1 Matrix{Float64}:\n 0.0957598823007022\n 0.3664695156484836\n 0.2167466247738168\n\njulia&gt; a\n3-element Vector{Float64}:\n 0.0957598823007022\n 0.3664695156484836\n 0.2167466247738168\n\njulia&gt; b' * a\n1-element Vector{Float64}:\n 0.19044896030872022```\nbut it still kinda works. You can make sure a vector is a vector (and not a Nx1 matrix by using `vec`):\n```julia&gt; vec(b)' * a\n0.19044896030872022```","user":"UH8A351DJ","ts":"1614125336.247200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BJ=1L","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think OP had something like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> b = reshape(a, 3,1)\n3×1 Matrix{Float64}:\n 0.0957598823007022\n 0.3664695156484836\n 0.2167466247738168\n\njulia> a\n3-element Vector{Float64}:\n 0.0957598823007022\n 0.3664695156484836\n 0.2167466247738168\n\njulia> b' * a\n1-element Vector{Float64}:\n 0.19044896030872022"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"but it still kinda works. You can make sure a vector is a vector (and not a Nx1 matrix by using "},{"type":"text","text":"vec","style":{"code":true}},{"type":"text","text":"):\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> vec(b)' * a\n0.19044896030872022"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"39411f3f-7c31-4725-b418-8cc3c87ece18","type":"message","text":"```function f1(x)\n    return exp.(-x).*tan.(x)\nend\nfunction df1(x)\n    return -exp.(-x).*tan.(x) + exp.(-x).*sec.(x).^2\nend\nx0 = [-pi/2 + pi*rand()]\nx1 = rand(MvNormal(vec(x0),vec(sqrt(h).*ones(1,1))))\nError = norm(f0 + h.*df1(x0)*x1 - f1(x0+h.*x1),2)\nMethodError: no method matching *(::Array{Float64,1}, ::Array{Float64,1})\nClosest candidates are:\n  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:538\n  *(!Matched::ChainRulesCore.One, ::Any) at C:\\Users\\super\\.julia\\packages\\ChainRulesCore\\eBwSt\\src\\differential_arithmetic.jl:98\n  *(!Matched::ChainRulesCore.Zero, ::Any) at C:\\Users\\super\\.julia\\packages\\ChainRulesCore\\eBwSt\\src\\differential_arithmetic.jl:68\n  ...\n\nStacktrace:\n [1] top-level scope at In[487]:9\n [2] include_string(::Function, ::Module, ::String, ::String) at .\\loading.jl:1091```\n","user":"U01M3EUHL20","ts":"1614126359.247600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D5cPm","elements":[{"type":"rich_text_preformatted","elements":[{"type":"text","text":"function f1(x)\n    return exp.(-x).*tan.(x)\nend\nfunction df1(x)\n    return -exp.(-x).*tan.(x) + exp.(-x).*sec.(x).^2\nend\nx0 = [-pi/2 + pi*rand()]\nx1 = rand(MvNormal(vec(x0),vec(sqrt(h).*ones(1,1))))\nError = norm(f0 + h.*df1(x0)*x1 - f1(x0+h.*x1),2)\nMethodError: no method matching *(::Array{Float64,1}, ::Array{Float64,1})\nClosest candidates are:\n  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:538\n  *(!Matched::ChainRulesCore.One, ::Any) at C:\\Users\\super\\.julia\\packages\\ChainRulesCore\\eBwSt\\src\\differential_arithmetic.jl:98\n  *(!Matched::ChainRulesCore.Zero, ::Any) at C:\\Users\\super\\.julia\\packages\\ChainRulesCore\\eBwSt\\src\\differential_arithmetic.jl:68\n  ...\n\nStacktrace:\n [1] top-level scope at In[487]:9\n [2] include_string(::Function, ::Module, ::String, ::String) at .\\loading.jl:1091"}]},{"type":"rich_text_section","elements":[]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"9eeb7ac9-0b1d-45ff-8764-b0a9457b677d","type":"message","text":"Here's one example.","user":"U01M3EUHL20","ts":"1614126373.247800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"DZBn=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Here's one example."}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"eab3866c-7c00-4e03-b36f-08680946d07c","type":"message","text":"well, multiplication between two vector is not commonly defined. You either have element-wise multiplication, or a dot product and you need to show which one you want. (by either doing `.*` or `dot()` or the `a' * b`we just looked at)","user":"UH8A351DJ","ts":"1614126514.248000","team":"T68168MUP","edited":{"user":"UH8A351DJ","ts":"1614126556.000000"},"blocks":[{"type":"rich_text","block_id":"nK4y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"well, multiplication between two vector is not commonly defined. You either have element-wise multiplication, or a dot product and you need to show which one you want. (by either doing "},{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":" or "},{"type":"text","text":"dot()","style":{"code":true}},{"type":"text","text":" or the "},{"type":"text","text":"a' * b","style":{"code":true}},{"type":"text","text":"we just looked at)"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"e8acb1fd-b5e8-4534-8f59-dba48942a1c0","type":"message","text":"It seems to me what is causing the issue is that `df1(x0)*x1` that you showed in your example. `df1(x0)` is a 1-element Array(Float64,1). (I can't tell how many elements are in `x1`, but it seems like it would be `Array{Float64,1}`. Not sure if you wanted `df1(x0)` to be such in that case. Maybe you didn't want to surround x0 in brackets? Maybe something like `x0 = -pi/2 + pi*rand()` might work better and be what you wanted?","user":"U0138UTB7A4","ts":"1614127642.248400","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1614128327.000000"},"blocks":[{"type":"rich_text","block_id":"=Vb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It seems to me what is causing the issue is that "},{"type":"text","text":"df1(x0)*x1","style":{"code":true}},{"type":"text","text":" that you showed in your example. "},{"type":"text","text":"df1(x0)","style":{"code":true}},{"type":"text","text":" is a 1-element Array(Float64,1). (I can't tell how many elements are in "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":", but it seems like it would be "},{"type":"text","text":"Array{Float64,1}","style":{"code":true}},{"type":"text","text":". Not sure if you wanted `df1(x0)` to be such in that case. Maybe you didn't want to surround x0 in brackets? Maybe something like "},{"type":"text","text":"x0 = -pi/2 + pi*rand()","style":{"code":true}},{"type":"text","text":" might work better and be what you wanted?"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"59402d8d-0b52-4c30-93e8-97bfd96d4e2c","type":"message","text":"As <@UH8A351DJ> said, the `*` operation between `Array{Float64, 1}` and `Array{Float64,1}` is not commonly defined. Usually its one or the other: a dot product, or element-wise multiplication.\n\nIn this case, (I'm guessing) Since `df1(x0)` is just a 1-element Array, I'm assuming you want that number inside to multiply all those elements inside `x1`? If so, then I would try `x0 = -pi/2 + pi*rand()`","user":"U0138UTB7A4","ts":"1614127732.248600","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1614128125.000000"},"blocks":[{"type":"rich_text","block_id":"fhkR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"As "},{"type":"user","user_id":"UH8A351DJ"},{"type":"text","text":" said, the "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" operation between "},{"type":"text","text":"Array{Float64, 1}","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"Array{Float64,1}","style":{"code":true}},{"type":"text","text":" is not commonly defined. Usually its one or the other: a dot product, or element-wise multiplication.\n\nIn this case, (I'm guessing) Since "},{"type":"text","text":"df1(x0)","style":{"code":true}},{"type":"text","text":" is just a 1-element Array, I'm assuming you want that number inside to multiply all those elements inside "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":"? If so, then I would try "},{"type":"text","text":"x0 = -pi/2 + pi*rand()","style":{"code":true}}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"ab40e876-ed61-4fc0-a21d-5f5e0660e7b7","type":"message","text":"I want the line `df1(x0)*x1` to be able to handle Matrix * Vector, Vector^T * Vector, and Scalar * Scalar operations. Is there a way to accomplish this in one line? From what I've gathered I think I want `df1(x0)` and `x1`  to be `Array{Float64,2}` to make this happen. Does that sound right?","user":"U01M3EUHL20","ts":"1614128388.249300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"0tTtC","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I want the line "},{"type":"text","text":"df1(x0)*x1","style":{"code":true}},{"type":"text","text":" to be able to handle Matrix * Vector, Vector^T * Vector, and Scalar * Scalar operations. Is there a way to accomplish this in one line? From what I've gathered I think I want "},{"type":"text","text":"df1(x0)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":"  to be "},{"type":"text","text":"Array{Float64,2}","style":{"code":true}},{"type":"text","text":" to make this happen. Does that sound right?"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"f8160de4-d991-48ce-8a73-1e7007342c7a","type":"message","text":"if you want everything element-wise, just do it, `df1(x0) .* x1`","user":"UH8A351DJ","ts":"1614128431.249500","team":"T68168MUP","edited":{"user":"UH8A351DJ","ts":"1614128446.000000"},"blocks":[{"type":"rich_text","block_id":"csgR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"if you want everything element-wise, just do it, "},{"type":"text","text":"df1(x0) .* x1","style":{"code":true}}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"2a674939-02fe-4d8a-8886-08f8f5c8b59e","type":"message","text":"`.*` works on scalar too","user":"UH8A351DJ","ts":"1614128461.249800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"6dkG","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":" works on scalar too"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"c3a04444-4e55-4bd1-8299-3d7c0f3beea7","type":"message","text":"Yeah I can't quite tell, but maybe df1(x0) and x1 will always have the same length/same type that you just want to multiply element-wise if they are Arrays, or multiply together if they are scalars? Then `.*` works.","user":"U0138UTB7A4","ts":"1614128559.250000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"IfwMB","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah I can't quite tell, but maybe df1(x0) and x1 will always have the same length/same type that you just want to multiply element-wise if they are Arrays, or multiply together if they are scalars? Then "},{"type":"text","text":".*","style":{"code":true}},{"type":"text","text":" works."}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"6562d387-79ab-4845-814d-7100fc9d6307","type":"message","text":"&gt; I want the line df1(x0)*x1 to be able to handle Matrix * Vector, Vector^T * Vector, and Scalar * Scalar operations. \nI'm having a hard time understanding what you mean by this. Those different type of products seem to produce different results?","user":"U0138UTB7A4","ts":"1614128590.250200","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1614128784.000000"},"blocks":[{"type":"rich_text","block_id":"Ovj=O","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"I want the line df1(x0)*x1 to be able to handle Matrix * Vector, Vector^T * Vector, and Scalar * Scalar operations. "}]},{"type":"rich_text_section","elements":[{"type":"text","text":"I'm having a hard time understanding what you mean by this. Those different type of products seem to produce different results?"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20","reactions":[{"name":"point_up","users":["UDB26738Q"],"count":1}]},{"client_msg_id":"d1c5cab1-2e47-408d-9c6c-628c41ab92db","type":"message","text":"Is there a way to type in Latex in here?\nIn the provided example `x0`, `x1`, and `df1(x0)` are all in the real number field R (scalars), but `x0` , `x1` , and `df1` could be in R^n as well, making all of these n-element column vectors. In this case I want `df1(x0)*x1` to be a dot product between vectors. `df1` could also be an nxn matrix when `x0` and `x1` are n-element column vectors. In this case I want  `df1(x0)*x1` to be matrix multiplication. Can all three of these operations be accomplished in one line of code?","user":"U01M3EUHL20","ts":"1614129248.250800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"GJs5","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Is there a way to type in Latex in here?\nIn the provided example "},{"type":"text","text":"x0","style":{"code":true}},{"type":"text","text":", "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":", and "},{"type":"text","text":"df1(x0)","style":{"code":true}},{"type":"text","text":" are all in the real number field R (scalars), but "},{"type":"text","text":"x0","style":{"code":true}},{"type":"text","text":" , "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":" , and "},{"type":"text","text":"df1","style":{"code":true}},{"type":"text","text":" could be in R^n as well, making all of these n-element column vectors. In this case I want "},{"type":"text","text":"df1(x0)*x1","style":{"code":true}},{"type":"text","text":" to be a dot product between vectors. "},{"type":"text","text":"df1","style":{"code":true}},{"type":"text","text":" could also be an nxn matrix when "},{"type":"text","text":"x0","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":" are n-element column vectors. In this case I want  "},{"type":"text","text":"df1(x0)*x1","style":{"code":true}},{"type":"text","text":" to be matrix multiplication. Can all three of these operations be accomplished in one line of code?"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"e9fb2574-ddfd-44e2-a843-ab6891a1ebf2","type":"message","text":"Feel free to write the LaTeX code and I could render it myself to view it, unfortunately I don't think Slack does the automatic rendering? Alternatively you might be able to post an image screenshot of the equation. Hmm I think I understand what you mean. I will need to think","user":"U0138UTB7A4","ts":"1614129385.251000","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1614129406.000000"},"blocks":[{"type":"rich_text","block_id":"Xv/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Feel free to write the LaTeX code and I could render it myself to view it, unfortunately I don't think Slack does the automatic rendering? Alternatively you might be able to post an image screenshot of the equation. Hmm I think I understand what you mean. I will need to think"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"cc07b3db-3375-4d6e-85d6-76e06ca7a03e","type":"message","text":"I'm not an expert in Julia, so maybe others will have suggestions. But it seems to be that you can't use one line of code all-together in one spot to accomplish it all.\n\n`df1(x0) * x1` would be able to handle the cases where `dx1(x0)` and `x1` are the scalars\n`df1(x0)' * x1` would handle doing the dot product\n`df1(x0) * x1` would handle when doing that matrix multiplication\n\nYou might be able to use multiple dispatch to try to code a function using different input-type-signatures based on whether `x0` and `x1` are scalars or not, so that you would use the same function name, but Julia would use the appropriate function definition at the right time. But not sure if that's what you might want to do","user":"U0138UTB7A4","ts":"1614129917.251300","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1614130344.000000"},"blocks":[{"type":"rich_text","block_id":"/Jb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm not an expert in Julia, so maybe others will have suggestions. But it seems to be that you can't use one line of code all-together in one spot to accomplish it all.\n\n"},{"type":"text","text":"df1(x0) * x1","style":{"code":true}},{"type":"text","text":" would be able to handle the cases where "},{"type":"text","text":"dx1(x0)","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":" are the scalars\n"},{"type":"text","text":"df1(x0)' * x1","style":{"code":true}},{"type":"text","text":" would handle doing the dot product\n"},{"type":"text","text":"df1(x0) * x1","style":{"code":true}},{"type":"text","text":" would handle when doing that matrix multiplication\n\nYou might be able to use multiple dispatch to try to code a function using different input-type-signatures based on whether "},{"type":"text","text":"x0","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"x1","style":{"code":true}},{"type":"text","text":" are scalars or not, so that you would use the same function name, but Julia would use the appropriate function definition at the right time. But not sure if that's what you might want to do"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"f535d7f0-1e7f-4d8d-96ef-a71da5410d95","type":"message","text":"Another thought I had is that since they're all fundamentally different products and results, it might be appropriate to also just code them all differently as different functions? But I'm not sure what would be appropriate for your code specifically","user":"U0138UTB7A4","ts":"1614129994.251500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"7DM1l","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Another thought I had is that since they're all fundamentally different products and results, it might be appropriate to also just code them all differently as different functions? But I'm not sure what would be appropriate for your code specifically"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"ebbb5cfb-0181-4651-8e58-3ce9a16896cf","type":"message","text":"Hopefully others have some thoughts as well! Let me know if you have any questions (e.g. if you haven't seen/heard multiple dispatch before, I'm still fairly new but I can try my best to explain it)","user":"U0138UTB7A4","ts":"1614130035.251700","team":"T68168MUP","edited":{"user":"U0138UTB7A4","ts":"1614130131.000000"},"blocks":[{"type":"rich_text","block_id":"nAT6","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hopefully others have some thoughts as well! Let me know if you have any questions (e.g. if you haven't seen/heard multiple dispatch before, I'm still fairly new but I can try my best to explain it)"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"},{"client_msg_id":"7d302df6-b43a-4661-95b6-8c2d6634f0cd","type":"message","text":"I was thinking about this too and I think `df1(x0) * x1` can be used for all three cases as long as I am using the right object for each quantity. Thank you everybody for your input!","user":"U01M3EUHL20","ts":"1614137553.252300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"n25","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I was thinking about this too and I think "},{"type":"text","text":"df1(x0) * x1","style":{"code":true}},{"type":"text","text":" can be used for all three cases as long as I am using the right object for each quantity. Thank you everybody for your input!"}]}]}],"thread_ts":"1614124992.246500","parent_user_id":"U01M3EUHL20"}]