[{"client_msg_id":"323ce321-b1f9-4722-92f0-07418756b344","type":"message","text":"Hi! I'm having issues with JuMP, when trying to solve a problem with multiple nonlinear constraints...\nSo for example if I have a multivariable problem with nonlinear constraint function `constraints()` which returns 2 equality constraints, is it possible to do something like\n```model = Model(with_optimizer(Ipopt.Optimizer, print_level=2))\n@variable(model, xvar[1:2])\n\nregister(model, :constraint, 2, constraints, jac_constraints)\n@NLexpression(model, cs[1:2], constraints(xvar...))\nfor ii = 1:2\n    @NLconstraint(model, cs[ii]==0)\nend```\nCurrently, when doing something like the above, I get an error as follows:\n`ERROR: LoadError: TypeError: in typeassert, expected Float64, got a value of type Array{Float64,1}`","user":"U01HA6ZBSN6","ts":"1617942021.346900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cNJ=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hi! I'm having issues with JuMP, when trying to solve a problem with multiple nonlinear constraints...\nSo for example if I have a multivariable problem with nonlinear constraint function "},{"type":"text","text":"constraints()","style":{"code":true}},{"type":"text","text":" which returns 2 equality constraints, is it possible to do something like\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"model = Model(with_optimizer(Ipopt.Optimizer, print_level=2))\n@variable(model, xvar[1:2])\n\nregister(model, :constraint, 2, constraints, jac_constraints)\n@NLexpression(model, cs[1:2], constraints(xvar...))\nfor ii = 1:2\n    @NLconstraint(model, cs[ii]==0)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Currently, when doing something like the above, I get an error as follows:\n"},{"type":"text","text":"ERROR: LoadError: TypeError: in typeassert, expected Float64, got a value of type Array{Float64,1}","style":{"code":true}}]}]}],"thread_ts":"1617942021.346900","reply_count":1,"reply_users_count":1,"latest_reply":"1617942059.347000","reply_users":["U01HA6ZBSN6"],"is_locked":false,"subscribed":false},{"client_msg_id":"7aaaedb9-a182-4481-a668-c999c07f3d6d","type":"message","text":"For reference, here's a code that recreates this issue:\n\n```using JuMP\nusing Ipopt\nusing ForwardDiff\n\n## OBjective\nfunction rosenbrock(xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    return rosenbrock_nosplat(x)\nend\n\nfunction rosenbrock_nosplat(x)\n    return (1 - x[1])^2 + 100(x[2] - x[1]^2)^2\nend\n\nfunction ∇rosenbrock(xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    grad = ForwardDiff.gradient(rosenbrock_nosplat, x0)\n    return grad\nend\n\n\n## Constraints\nfunction circle_line_nosplat(x)\n    return [x[1]^2 + x[2]^2, x[2] - x[1]^2]\nend\n\nfunction circle_line(xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    return circle_line_nosplat(x)\nend\n\nfunction ∇circle_line(g, xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    grad = ForwardDiff.jacobian(circle_line_nosplat, x)\n#     g[1] = grad[1]\n#     g[2] = grad[2]\n    g = grad;\nend\n\n## build the model\nmodel = Model(with_optimizer(Ipopt.Optimizer, print_level=2))\n@variable(model, xvar[1:2])\n\n# objective\nregister(model, :rosenbrock, 2, rosenbrock, ∇rosenbrock)\n@NLobjective(model, Min, rosenbrock(xvar...))\n\n# constraints\nregister(model, :circle_line, 2, circle_line, ∇circle_line)\n@NLexpression(model, cs[1:2], circle_line(xvar...))\nfor ii = 1:2\n    @NLconstraint(model, cs[ii]==0)\nend\n\n## Solve problem\nprintln(\"Solving...\")\nres = optimize!(model)\nprintln(\"Optimize done!\")\nprintln(\"x = \", value(xvar[1]), \" y = \", value(xvar[2]))\ntermination_status(model)\nprimal_status(model)```","user":"U01HA6ZBSN6","ts":"1617942059.347000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"W39T4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For reference, here's a code that recreates this issue:\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"using JuMP\nusing Ipopt\nusing ForwardDiff\n\n## OBjective\nfunction rosenbrock(xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    return rosenbrock_nosplat(x)\nend\n\nfunction rosenbrock_nosplat(x)\n    return (1 - x[1])^2 + 100(x[2] - x[1]^2)^2\nend\n\nfunction ∇rosenbrock(xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    grad = ForwardDiff.gradient(rosenbrock_nosplat, x0)\n    return grad\nend\n\n\n## Constraints\nfunction circle_line_nosplat(x)\n    return [x[1]^2 + x[2]^2, x[2] - x[1]^2]\nend\n\nfunction circle_line(xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    return circle_line_nosplat(x)\nend\n\nfunction ∇circle_line(g, xtuple...)\n    # unpack tuple to array\n    x = [i for i in xtuple]\n    grad = ForwardDiff.jacobian(circle_line_nosplat, x)\n#     g[1] = grad[1]\n#     g[2] = grad[2]\n    g = grad;\nend\n\n## build the model\nmodel = Model(with_optimizer(Ipopt.Optimizer, print_level=2))\n@variable(model, xvar[1:2])\n\n# objective\nregister(model, :rosenbrock, 2, rosenbrock, ∇rosenbrock)\n@NLobjective(model, Min, rosenbrock(xvar...))\n\n# constraints\nregister(model, :circle_line, 2, circle_line, ∇circle_line)\n@NLexpression(model, cs[1:2], circle_line(xvar...))\nfor ii = 1:2\n    @NLconstraint(model, cs[ii]==0)\nend\n\n## Solve problem\nprintln(\"Solving...\")\nres = optimize!(model)\nprintln(\"Optimize done!\")\nprintln(\"x = \", value(xvar[1]), \" y = \", value(xvar[2]))\ntermination_status(model)\nprimal_status(model)"}]}]}],"thread_ts":"1617942021.346900","parent_user_id":"U01HA6ZBSN6"}]