[{"client_msg_id":"c5295e3b-3374-4afe-abbc-ec3d14274a89","type":"message","text":"Anyone have advice on debugging inference failures?\n```julia&gt; @code_warntype vload(ptr, i, False())\nVariables\n  #self#::Core.Const(VectorizationBase.vload)\n  ptr::VectorizationBase.StridedPointer{Float64, 1, 1, 0, (1,), Tuple{StaticInt{8}}, Tuple{StaticInt{1}}}\n  i::Tuple{MM{32, 1, Int64}}\n  A::Core.Const(False())\n\nBody::Union{VectorizationBase.VecUnroll{3, _A, _B, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, T, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, T} where T} where _A\n1 ─      nothing\n│   %2 = VectorizationBase.pointer(ptr)::Ptr{Float64}\n│   %3 = VectorizationBase.linear_index(ptr, i)::VectorizationBase.LazyMulAdd{8, 0, MM{32, 1, Int64}}\n│   %4 = VectorizationBase.vload(%2, %3, A)::Union{VectorizationBase.VecUnroll{3, _A, _B, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, T, _C} where _C&lt;:VectorizationBase.AbstractSIMDVector{_A, T} where T} where _A\n└──      return %4\n\njulia&gt; p = pointer(ptr); li = VectorizationBase.linear_index(ptr, i);\n\njulia&gt; @code_warntype vload(p, li, False())\nVariables\n  #self#::Core.Const(VectorizationBase.vload)\n  ptr::Ptr{Float64}\n  i::VectorizationBase.LazyMulAdd{8, 0, MM{32, 1, Int64}}\n  A::Core.Const(False())\n\nBody::VectorizationBase.VecUnroll{3, 8, Float64, Vec{8, Float64}}\n1 ─      nothing\n│   %2 = VectorizationBase.register_size()::Core.Const(static(64))\n│   %3 = VectorizationBase._vload(ptr, i, A, %2)::VectorizationBase.VecUnroll{3, 8, Float64, Vec{8, Float64}}\n└──      return %3```\nThe call `VectorizationBase.vload(%2, %3, A)` isn't inferred even though all three arguments are.\nYet, when I call that method directly, inference succeeds.\n\nAnyone know why inference can fail like this? And when it does, what sort of changes can make it succeed?","user":"UAUPJLBQX","ts":"1611985578.158400","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1611985735.000000"},"blocks":[{"type":"rich_text","block_id":"9nc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Anyone have advice on debugging inference failures?\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"julia> @code_warntype vload(ptr, i, False())\nVariables\n  #self#::Core.Const(VectorizationBase.vload)\n  ptr::VectorizationBase.StridedPointer{Float64, 1, 1, 0, (1,), Tuple{StaticInt{8}}, Tuple{StaticInt{1}}}\n  i::Tuple{MM{32, 1, Int64}}\n  A::Core.Const(False())\n\nBody::Union{VectorizationBase.VecUnroll{3, _A, _B, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, T, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, T} where T} where _A\n1 ─      nothing\n│   %2 = VectorizationBase.pointer(ptr)::Ptr{Float64}\n│   %3 = VectorizationBase.linear_index(ptr, i)::VectorizationBase.LazyMulAdd{8, 0, MM{32, 1, Int64}}\n│   %4 = VectorizationBase.vload(%2, %3, A)::Union{VectorizationBase.VecUnroll{3, _A, _B, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, _B, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, _B} where _B, VectorizationBase.VecUnroll{3, _A, T, _C} where _C<:VectorizationBase.AbstractSIMDVector{_A, T} where T} where _A\n└──      return %4\n\njulia> p = pointer(ptr); li = VectorizationBase.linear_index(ptr, i);\n\njulia> @code_warntype vload(p, li, False())\nVariables\n  #self#::Core.Const(VectorizationBase.vload)\n  ptr::Ptr{Float64}\n  i::VectorizationBase.LazyMulAdd{8, 0, MM{32, 1, Int64}}\n  A::Core.Const(False())\n\nBody::VectorizationBase.VecUnroll{3, 8, Float64, Vec{8, Float64}}\n1 ─      nothing\n│   %2 = VectorizationBase.register_size()::Core.Const(static(64))\n│   %3 = VectorizationBase._vload(ptr, i, A, %2)::VectorizationBase.VecUnroll{3, 8, Float64, Vec{8, Float64}}\n└──      return %3"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"The call "},{"type":"text","text":"VectorizationBase.vload(%2, %3, A)","style":{"code":true}},{"type":"text","text":" isn't inferred even though all three arguments are.\nYet, when I call that method directly, inference succeeds.\n\nAnyone know why inference can fail like this? And when it does, what sort of changes can make it succeed?"}]}]}],"thread_ts":"1611985578.158400","reply_count":38,"reply_users_count":5,"latest_reply":"1612153635.326300","reply_users":["B01J9QZ4SP8","U8D9768Q6","UAUPJLBQX","U6N6VQE30","UDSU53PEG"],"subscribed":false,"reactions":[{"name":"bridge","users":["UAUPJLBQX"],"count":1}]},{"type":"message","subtype":"bot_message","text":"Hey <@UAUPJLBQX>, Thanks for asking this question. Is it okay if we cross post this to Discourse for further visibility and in case someone has the same question in the future? If so, please react with :bridge: on the original message you sent above above ^ (not this threaded reply). Note that only reactions from the posts author will trigger a re-post. Thank you for being here!","ts":"1611985582.158500","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"type":"message","subtype":"bot_message","text":"Hey <@UAUPJLBQX>! Thanks for asking this question. It has been cross posted to discourse here: <https://discourse.julialang.org/t/anyone-have-advice-on-debugging-inference-failures-julia-gt-code-warntype-vl>. Please add an answer there once you are satisfied with the solution so others can benefit as well.\n\nNote that if someone answers on Discourse, you will *not* be notified directly, so it may be worth keeping the page open until a solution is found. Happy debugging!","ts":"1611985617.158900","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"b57786c5-9b55-4524-a7d0-7c0d06c49ae3","type":"message","text":"I doubt I can tell you anything you don't already know, but my understanding is that the compiler has a cost model for evaluating when inference is getting too expensive and decides to give up","user":"U8D9768Q6","ts":"1611985903.160200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dFR/","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I doubt I can tell you anything you don't already know, but my understanding is that the compiler has a cost model for evaluating when inference is getting too expensive and decides to give up"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"d5576620-622f-42f4-a3dd-d51bc5744b6a","type":"message","text":"=(","user":"UAUPJLBQX","ts":"1611985944.160400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Jq3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"=("}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"60ed68f5-f966-4285-8c42-c0d396c6866d","type":"message","text":"I figured it was hitting some limit.","user":"UAUPJLBQX","ts":"1611985955.160600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Yfbw","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I figured it was hitting some limit."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"8e10cb86-76bc-4782-bd08-b425e6e1b1c9","type":"message","text":"Where is `False` defined?","user":"U8D9768Q6","ts":"1611985985.160800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Ac8hb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Where is "},{"type":"text","text":"False","style":{"code":true}},{"type":"text","text":" defined?"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"2f0d130b-e695-44b2-bfee-a7383e736f8b","type":"message","text":"ArrayInterface","user":"UAUPJLBQX","ts":"1611985995.161000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pSIk","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"ArrayInterface"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"ad919ec5-700a-4afb-9081-321fe8d2f449","type":"message","text":"It's just a singleton","user":"UAUPJLBQX","ts":"1611986032.161200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"OStKU","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's just a singleton"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"6da3330c-7c6d-4fae-aaa7-1d5796bc2dac","type":"message","text":"The existence of compiler heuristics I can't overrule is the sort of reason why I often write tons of giant generated functions.","user":"UAUPJLBQX","ts":"1611986095.161400","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1611986127.000000"},"blocks":[{"type":"rich_text","block_id":"bS+K8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"The existence of compiler heuristics I can't overrule is the sort of reason why I often write tons of giant generated functions."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"cca619f6-3845-4efb-bc31-ead1c774ee3b","type":"message","text":"Yeah, I was just about to try writing a generated function to get around it","user":"U8D9768Q6","ts":"1611986121.161600","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"vUb","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah, I was just about to try writing a generated function to get around it"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"0ea22e12-4e21-4a62-8c18-ee50a472ee6c","type":"message","text":"Fortunately, I beleive those heuristics *can* be overruled with the new AbstractInterpreter stuff","user":"U8D9768Q6","ts":"1611986171.161900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j+mSR","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fortunately, I beleive those heuristics "},{"type":"text","text":"can","style":{"bold":true}},{"type":"text","text":" be overruled with the new AbstractInterpreter stuff"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"27bb219e-4ad4-4e83-81eb-a9cea9b4507f","type":"message","text":"Don't the GPU libraries already do really aggressive inference and inlining somehow?","user":"UAUPJLBQX","ts":"1611986252.162100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"jnpH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Don't the GPU libraries already do really aggressive inference and inlining somehow?"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"6c79cdda-5406-448d-9742-d9bc6fe9d2e9","type":"message","text":"My understanding is that they essentially have their own manual abstract interpretation step where they recursively descend through code_typed and inline it all into one big  function","user":"U8D9768Q6","ts":"1611986425.162300","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1611986506.000000"},"blocks":[{"type":"rich_text","block_id":"0AE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"My understanding is that they essentially have their own manual abstract interpretation step where they recursively descend through code_typed and inline it all into one big  function"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"f546df45-6b05-4ebf-b615-c61cbc3accb8","type":"message","text":"Maybe I should move LoopVectorization in that direction eventually to avoid limitations like this","user":"UAUPJLBQX","ts":"1611986581.162800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4P4Im","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Maybe I should move LoopVectorization in that direction eventually to avoid limitations like this"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"21ff67ee-bee2-4378-a7dd-d2e964c421a1","type":"message","text":"should be a lot easier once AbstractInterpreter is more usable.","user":"UAUPJLBQX","ts":"1611986630.163000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"TmhW2","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"should be a lot easier once AbstractInterpreter is more usable."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"6fcf26cc-a3d0-4758-a7b1-6329313b1d9d","type":"message","text":"I assume it'd be better to just use the AbstractInterpreter stuff than rolling your own","user":"U8D9768Q6","ts":"1611986664.163200","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1611986680.000000"},"blocks":[{"type":"rich_text","block_id":"atCe","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I assume it'd be better to just use the AbstractInterpreter stuff than rolling your own"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"57368543-ac4e-4d47-b48a-c435c05e969d","type":"message","text":"But for now, adding a type assert fixed it.","user":"UAUPJLBQX","ts":"1611987324.163500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kc3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"But for now, adding a type assert fixed it."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"5fdfe667-b66c-4902-a902-bc79ef7a3e78","type":"message","text":"Fixed the type instability, that is, yet the `_vload` call is still not inlinling.","user":"UAUPJLBQX","ts":"1611987869.163700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"cb8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Fixed the type instability, that is, yet the "},{"type":"text","text":"_vload","style":{"code":true}},{"type":"text","text":" call is still not inlinling."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"e9d37d93-1259-4483-9037-1b4f8ccb420b","type":"message","text":"Which is annoying, because the function is cheaper to execute than it is to call.","user":"UAUPJLBQX","ts":"1611988221.163900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"S0+2r","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Which is annoying, because the function is cheaper to execute than it is to call."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"818C069D-1AC9-4FA9-AB6A-CC3DB07C8F19","type":"message","text":"Mhm. I’d really love a call site inline mechanism.  ","user":"U8D9768Q6","ts":"1611988966.164800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"LCzs","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Mhm. I’d really love a call site inline mechanism.  "}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"0B8465CF-E094-49B2-82F1-5B0ABF1FA3A6","type":"message","text":"Putting `@inline` on the _vload def doesn’t help?","user":"U8D9768Q6","ts":"1611989015.165800","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"1q0","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Putting "},{"type":"text","text":"@inline","style":{"code":true}},{"type":"text","text":" on the _vload def doesn’t help?"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"0816ad0a-3ff9-4849-bea7-1c15d7dff619","type":"message","text":"I would too.\nIt was a generated function, and had/has `Expr(:meta,:inline)`","user":"UAUPJLBQX","ts":"1611989209.166000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"yFKJ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I would too.\nIt was a generated function, and had/has "},{"type":"text","text":"Expr(:meta,:inline)","style":{"code":true}}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"2560587c-0289-46a6-895c-3779235e0d3d","type":"message","text":"I have a big chain of function calls leading there. Combining two links in the chain into 1 lets it inline.","user":"UAUPJLBQX","ts":"1611989275.166200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sGh9","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I have a big chain of function calls leading there. Combining two links in the chain into 1 lets it inline."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"cbe0569c-477b-42d8-9963-5c328a72c336","type":"message","text":"I'm worried that if anything calls this function and declares itself `@inline` , that then suddenly that function will inline, but the load function won't.","user":"UAUPJLBQX","ts":"1611989361.166500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"D06a","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I'm worried that if anything calls this function and declares itself "},{"type":"text","text":"@inline","style":{"code":true}},{"type":"text","text":" , that then suddenly that function will inline, but the load function won't."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"A43692AE-EED2-48B1-B3E4-CD7BF62AF884","type":"message","text":"Bit of a house of cards...","user":"U8D9768Q6","ts":"1611989392.167000","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1611989421.000000"},"blocks":[{"type":"rich_text","block_id":"uA3m","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Bit of a house of cards..."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"e5bacf7d-2f09-42da-ab8d-1f16a84863fa","type":"message","text":"Yeah =(","user":"UAUPJLBQX","ts":"1611989442.167300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"2bF","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Yeah =("}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"A33B8FE8-F3B6-44C6-B50B-67AB17189D6F","type":"message","text":"I think this is also a problem with generated functions. Using them often means you have to make more because they make compiler unhappy and throw off heuristics","user":"U8D9768Q6","ts":"1611989628.168700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dpV7B","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I think this is also a problem with generated functions. Using them often means you have to make more because they make compiler unhappy and throw off heuristics"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"8A7922FC-9820-4016-8EF9-1806954986CB","type":"message","text":"So it’s conceiveable that using less generated functions here could solve the problem. Not sure if that’s practical though ","user":"U8D9768Q6","ts":"1611989663.170000","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"79/i","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So it’s conceiveable that using less generated functions here could solve the problem. Not sure if that’s practical though "}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"0a142a75-747e-4398-affd-3be494833dd8","type":"message","text":"These problems surfaced on a PR that was reducing the number of generated functions. It may take a lot more to get over the hill.","user":"UAUPJLBQX","ts":"1611989889.170200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ETH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"These problems surfaced on a PR that was reducing the number of generated functions. It may take a lot more to get over the hill."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"455cef04-eb52-4adc-94dc-275d84c07033","type":"message","text":"Needing `llvmcall` ultimately limits how much I can move away from `@generated`.","user":"UAUPJLBQX","ts":"1611989945.170400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"ahZE","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Needing "},{"type":"text","text":"llvmcall","style":{"code":true}},{"type":"text","text":" ultimately limits how much I can move away from "},{"type":"text","text":"@generated","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"fe46b47d-607b-4c35-bb25-35cdf919dcd9","type":"message","text":"`llvmcall` is also considered expensive to the inliner. Meaning, even though `llvmcall` is often doing something trivial like mapping to a single assembly instruction, it's given a weight 40 times higher.","user":"UAUPJLBQX","ts":"1611989954.170600","team":"T68168MUP","edited":{"user":"UAUPJLBQX","ts":"1611990006.000000"},"blocks":[{"type":"rich_text","block_id":"dMqH","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"llvmcall","style":{"code":true}},{"type":"text","text":" is also considered expensive to the inliner. Meaning, even though "},{"type":"text","text":"llvmcall","style":{"code":true}},{"type":"text","text":" is often doing something trivial like mapping to a single assembly instruction, it's given a weight 40 times higher."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"0e8a40bd-c7b4-4f77-9783-34df7afd240f","type":"message","text":"So unless that changes, I will always be fighting the heuristics.","user":"UAUPJLBQX","ts":"1611990054.170900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"=77","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"So unless that changes, I will always be fighting the heuristics."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"65545674-A829-49C6-8C23-1BB7DEE1E4AD","type":"message","text":"Oof. ","user":"U8D9768Q6","ts":"1611990061.171200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"K=PUc","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Oof. "}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"2DDD4D25-DAA1-47A0-BC70-126216A30D4F","type":"message","text":"I’d really like per-module compiler heuristics","user":"U8D9768Q6","ts":"1611990091.172200","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"pi+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I’d really like per-module compiler heuristics"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"E8A4D8AF-5957-4EC3-B184-DA762B01B2A8","type":"message","text":"Like the per-module optimization level thing, but be able to change stuff like tuple recursion limit, online cost model, etc","user":"U8D9768Q6","ts":"1611990130.173500","team":"T68168MUP","edited":{"user":"U8D9768Q6","ts":"1611990186.000000"},"blocks":[{"type":"rich_text","block_id":"k9YZ","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Like the per-module optimization level thing, but be able to change stuff like tuple recursion limit, online cost model, etc"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX","reactions":[{"name":"10000","users":["UAUPJLBQX"],"count":1}]},{"client_msg_id":"3c1e367c-ea78-4838-b5e4-0ee85a7cc9a6","type":"message","text":"&gt; llvmcall is also considered expensive to the inliner. Meaning, even though llvmcall is often doing something trivial like mapping to a single assembly instruction, it's given a weight 40 times higher.\nBut here you can annotate in llvm ir that the function should alwaysinline, right?","user":"U6N6VQE30","ts":"1612007044.178600","team":"T68168MUP","edited":{"user":"U6N6VQE30","ts":"1612007155.000000"},"blocks":[{"type":"rich_text","block_id":"qgo","elements":[{"type":"rich_text_quote","elements":[{"type":"text","text":"llvmcall is also considered expensive to the inliner. Meaning, even though llvmcall is often doing something trivial like mapping to a single assembly instruction, it's given a weight 40 times higher."}]},{"type":"rich_text_section","elements":[{"type":"text","text":"But here you can annotate in llvm ir that the function should alwaysinline, right?"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"43f6f4ce-b25b-4611-990f-af7aed5dfe0e","type":"message","text":"That the llvm function inlines. But this is then considered expensive, making the Julia function using it less likely to inline.","user":"UAUPJLBQX","ts":"1612024805.200500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"53C","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"That the llvm function inlines. But this is then considered expensive, making the Julia function using it less likely to inline."}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"},{"client_msg_id":"df1aae52-f8be-4b1c-b089-ab38e0e1d113","type":"message","text":"It's definitly an issue in those cases where labelling inline working becomes a matter of hard to reason heuristics","user":"UDSU53PEG","ts":"1612153635.326300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"sMh+p","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It's definitly an issue in those cases where labelling inline working becomes a matter of hard to reason heuristics"}]}]}],"thread_ts":"1611985578.158400","parent_user_id":"UAUPJLBQX"}]