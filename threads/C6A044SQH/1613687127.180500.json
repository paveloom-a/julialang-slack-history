[{"client_msg_id":"f6462723-cd61-4acd-8ca1-80a5c21f97e1","type":"message","text":"the standard linked list implementation in base/linked_list.jl looks like this:\n```mutable struct InvasiveLinkedList{T}\n    # Invasive list requires that T have a field `.next &gt;: U{T, Nothing}` and `.queue &gt;: U{ILL{T}, Nothing}`\n    head::Union{T, Nothing}\n    tail::Union{T, Nothing}\n    InvasiveLinkedList{T}() where {T} = new{T}(nothing, nothing)\nend```\nSince head and tail aren't concrete types, is this going to incur a performance penalty when accessing those fields or is this a case where you can rely on compiler optimizations (union splitting?) to make it still as fast as if head and tail were just ::T ?","user":"U01GRS159T8","ts":"1613687127.180500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"A9yx","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"the standard linked list implementation in base/linked_list.jl looks like this:\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"mutable struct InvasiveLinkedList{T}\n    # Invasive list requires that T have a field `.next >: U{T, Nothing}` and `.queue >: U{ILL{T}, Nothing}`\n    head::Union{T, Nothing}\n    tail::Union{T, Nothing}\n    InvasiveLinkedList{T}() where {T} = new{T}(nothing, nothing)\nend"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"Since head and tail aren't concrete types, is this going to incur a performance penalty when accessing those fields or is this a case where you can rely on compiler optimizations (union splitting?) to make it still as fast as if head and tail were just ::T ?"}]}]}],"thread_ts":"1613687127.180500","reply_count":3,"reply_users_count":2,"latest_reply":"1613688309.183300","reply_users":["B01J9QZ4SP8","U8D9768Q6"],"subscribed":false},{"type":"message","subtype":"bot_message","text":"Can we cross post this publicly to <https://discourse.julialang.org|Discourse> for further visibility? React with :bridge: on the message above to approve. <https://github.com/JuliaCommunity/SlackBridge/blob/main/README.md#faq|More info here>","ts":"1613687128.180600","username":"HelpDeskBot","bot_id":"B01J9QZ4SP8","thread_ts":"1613687127.180500","parent_user_id":"U01GRS159T8"},{"client_msg_id":"F55A6122-D8D7-43D8-AD77-DA0D50BE80DD","type":"message","text":"It won’t be just as fast as if they were ::T because you’ll still need a branch, but yes, Union splitting should do a great deal for you here","user":"U8D9768Q6","ts":"1613688180.183100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"o9G","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It won’t be just as fast as if they were ::T because you’ll still need a branch, but yes, Union splitting should do a great deal for you here"}]}]}],"thread_ts":"1613687127.180500","parent_user_id":"U01GRS159T8"},{"client_msg_id":"4411e0e3-6fcd-41ff-91c5-7c2f555bd4f7","type":"message","text":"However, union splitting is not a guaranteed optimization and can be finnicky in some cases. If you want something more reliable, you can do manual union splitting by branching with `isa`.\n\nThis is actually a context where my SumTypes.jl package makes some sense and will do the union splitting for you.","user":"U8D9768Q6","ts":"1613688309.183300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"a+=","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"However, union splitting is not a guaranteed optimization and can be finnicky in some cases. If you want something more reliable, you can do manual union splitting by branching with "},{"type":"text","text":"isa","style":{"code":true}},{"type":"text","text":".\n\nThis is actually a context where my SumTypes.jl package makes some sense and will do the union splitting for you."}]}]}],"thread_ts":"1613687127.180500","parent_user_id":"U01GRS159T8"}]