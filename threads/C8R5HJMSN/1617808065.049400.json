[{"client_msg_id":"81ddcbc4-f39d-4812-9407-0d121796e91a","type":"message","text":"Can I get opinions on this?\n\n```\n#=\n# There are 2 types of array terms:\n#   `ArrayOp{T&lt;:AbstractArray}` and `Term{&lt;:AbstractArray}`\n#\n# - ArrayOp represents a Einstein-notation-inspired array operation.\n#   it contains a field `.term` which is a `Term` that represents the\n#   operation that resulted in the `ArrayOp`.\n#   I.e. will be `A*b` for the operation `(i,) =&gt; A[i,j] * b[j]` for example.\n#   The `.term` can be `Unknown()` if not known (e.g. after differentiation).\n#   - calling `shape` on an `ArrayOp` will return the shape of the array or `Unknown()`\n#   - do not rely on the `symtype` or `shape` information of the `.term` when looking at an `ArrayOp`.\n#     call `shape`, `symtype` and `ndims` directly on the `ArrayOp`.\n# - `Term{&lt;:AbstractArray}`\n#   - calling `shape` on it will return the shape of the array or `Unknown()`, and uses\n#     the `ArrayShapeCtx` metadata context to store this.\n#\n# The Array type parameter must contain the dimension.\n#=#```","user":"U68907M46","ts":"1617808065.049400","team":"T68168MUP","edited":{"user":"U68907M46","ts":"1617808346.000000"},"blocks":[{"type":"rich_text","block_id":"n+T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can I get opinions on this?\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\n#=\n# There are 2 types of array terms:\n#   `ArrayOp{T<:AbstractArray}` and `Term{<:AbstractArray}`\n#\n# - ArrayOp represents a Einstein-notation-inspired array operation.\n#   it contains a field `.term` which is a `Term` that represents the\n#   operation that resulted in the `ArrayOp`.\n#   I.e. will be `A*b` for the operation `(i,) => A[i,j] * b[j]` for example.\n#   The `.term` can be `Unknown()` if not known (e.g. after differentiation).\n#   - calling `shape` on an `ArrayOp` will return the shape of the array or `Unknown()`\n#   - do not rely on the `symtype` or `shape` information of the `.term` when looking at an `ArrayOp`.\n#     call `shape`, `symtype` and `ndims` directly on the `ArrayOp`.\n# - `Term{<:AbstractArray}`\n#   - calling `shape` on it will return the shape of the array or `Unknown()`, and uses\n#     the `ArrayShapeCtx` metadata context to store this.\n#\n# The Array type parameter must contain the dimension.\n#=#"}]}]}],"thread_ts":"1617808065.049400","reply_count":4,"reply_users_count":1,"latest_reply":"1617809187.053100","reply_users":["U68907M46"],"is_locked":false,"subscribed":false},{"client_msg_id":"03809260-97bb-42c2-8458-912ac657e176","type":"message","text":"For matching with rules, there will be a special `@array_rule` macro which will match on the `.term` and may or may result in `ArrayOp`. So for example, `@array_rule A'**B' =&gt; (B**A)'`  would match the LHS using the `.term`  and then call the expression on the RHS with `A` and `B` as the `ArrayOp`  resulting in a new `ArrayOp` where the `.term` is `(B*A)'` ........","user":"U68907M46","ts":"1617808580.052400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Gp6f","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For matching with rules, there will be a special "},{"type":"text","text":"@array_rule","style":{"code":true}},{"type":"text","text":" macro which will match on the "},{"type":"text","text":".term","style":{"code":true}},{"type":"text","text":" and may or may result in "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":". So for example, "},{"type":"text","text":"@array_rule A'*","style":{"code":true}},{"type":"text","text":"B' => (B*","style":{"bold":true,"code":true}},{"type":"text","text":"A)'","style":{"code":true}},{"type":"text","text":"  would match the LHS using the "},{"type":"text","text":".term","style":{"code":true}},{"type":"text","text":"  and then call the expression on the RHS with "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" as the "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":"  resulting in a new "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":" where the "},{"type":"text","text":".term","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"(B*A)'","style":{"code":true}},{"type":"text","text":" ........"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"349a9eb8-d273-4dd6-9864-08396d823a06","type":"message","text":"<@U8D9768Q6>, <@U6788D83U>","user":"U68907M46","ts":"1617808584.052600","team":"T68168MUP","edited":{"user":"U68907M46","ts":"1617808602.000000"},"blocks":[{"type":"rich_text","block_id":"rYE","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8D9768Q6"},{"type":"text","text":", "},{"type":"user","user_id":"U6788D83U"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"6c580dee-2125-4e3c-839b-904fc5e02f59","type":"message","text":"There can also be a different macro which matches the Einsum notation and rewrites that...","user":"U68907M46","ts":"1617808633.052900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HItRM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There can also be a different macro which matches the Einsum notation and rewrites that..."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"c73b91ff-d0d8-4f73-927d-d97647ef00cf","type":"message","text":"At first I was thinking of making `Term{&lt;:AbstractArray}` the main thing and store the `ArrayOp` as metadata, but there are cases where you don't know the `Term` yet you want the metadata. Another thing I explored is making the `ArrayOp` behave like a function that takes positional arguments... So `Term(@arrayop((*) _1[i,k]*_2[k,j], A, B)` but you keep having to substitute _1 and _2 with A and B, and do the same to apply rules on non-trivial terms.","user":"U68907M46","ts":"1617809187.053100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hpI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"At first I was thinking of making "},{"type":"text","text":"Term{<:AbstractArray}","style":{"code":true}},{"type":"text","text":" the main thing and store the "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":" as metadata, but there are cases where you don't know the "},{"type":"text","text":"Term","style":{"code":true}},{"type":"text","text":" yet you want the metadata. Another thing I explored is making the "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":" behave like a function that takes positional arguments... So "},{"type":"text","text":"Term(@arrayop((*) _1[i,k]*_2[k,j], A, B)","style":{"code":true}},{"type":"text","text":" but you keep having to substitute _1 and _2 with A and B, and do the same to apply rules on non-trivial terms."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"}]