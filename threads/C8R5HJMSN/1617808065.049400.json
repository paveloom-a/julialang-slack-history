[{"client_msg_id":"81ddcbc4-f39d-4812-9407-0d121796e91a","type":"message","text":"Can I get opinions on this?\n\n```\n#=\n# There are 2 types of array terms:\n#   `ArrayOp{T&lt;:AbstractArray}` and `Term{&lt;:AbstractArray}`\n#\n# - ArrayOp represents a Einstein-notation-inspired array operation.\n#   it contains a field `.term` which is a `Term` that represents the\n#   operation that resulted in the `ArrayOp`.\n#   I.e. will be `A*b` for the operation `(i,) =&gt; A[i,j] * b[j]` for example.\n#   The `.term` can be `Unknown()` if not known (e.g. after differentiation).\n#   - calling `shape` on an `ArrayOp` will return the shape of the array or `Unknown()`\n#   - do not rely on the `symtype` or `shape` information of the `.term` when looking at an `ArrayOp`.\n#     call `shape`, `symtype` and `ndims` directly on the `ArrayOp`.\n# - `Term{&lt;:AbstractArray}`\n#   - calling `shape` on it will return the shape of the array or `Unknown()`, and uses\n#     the `ArrayShapeCtx` metadata context to store this.\n#\n# The Array type parameter must contain the dimension.\n#=#```","user":"U68907M46","ts":"1617808065.049400","team":"T68168MUP","edited":{"user":"U68907M46","ts":"1617808346.000000"},"blocks":[{"type":"rich_text","block_id":"n+T","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Can I get opinions on this?\n\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"\n#=\n# There are 2 types of array terms:\n#   `ArrayOp{T<:AbstractArray}` and `Term{<:AbstractArray}`\n#\n# - ArrayOp represents a Einstein-notation-inspired array operation.\n#   it contains a field `.term` which is a `Term` that represents the\n#   operation that resulted in the `ArrayOp`.\n#   I.e. will be `A*b` for the operation `(i,) => A[i,j] * b[j]` for example.\n#   The `.term` can be `Unknown()` if not known (e.g. after differentiation).\n#   - calling `shape` on an `ArrayOp` will return the shape of the array or `Unknown()`\n#   - do not rely on the `symtype` or `shape` information of the `.term` when looking at an `ArrayOp`.\n#     call `shape`, `symtype` and `ndims` directly on the `ArrayOp`.\n# - `Term{<:AbstractArray}`\n#   - calling `shape` on it will return the shape of the array or `Unknown()`, and uses\n#     the `ArrayShapeCtx` metadata context to store this.\n#\n# The Array type parameter must contain the dimension.\n#=#"}]}]}],"thread_ts":"1617808065.049400","reply_count":13,"reply_users_count":2,"latest_reply":"1617826096.055300","reply_users":["U68907M46","U8D9768Q6"],"is_locked":false,"subscribed":false},{"client_msg_id":"03809260-97bb-42c2-8458-912ac657e176","type":"message","text":"For matching with rules, there will be a special `@array_rule` macro which will match on the `.term` and may or may result in `ArrayOp`. So for example, `@array_rule A'**B' =&gt; (B**A)'`  would match the LHS using the `.term`  and then call the expression on the RHS with `A` and `B` as the `ArrayOp`  resulting in a new `ArrayOp` where the `.term` is `(B*A)'` ........","user":"U68907M46","ts":"1617808580.052400","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Gp6f","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"For matching with rules, there will be a special "},{"type":"text","text":"@array_rule","style":{"code":true}},{"type":"text","text":" macro which will match on the "},{"type":"text","text":".term","style":{"code":true}},{"type":"text","text":" and may or may result in "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":". So for example, "},{"type":"text","text":"@array_rule A'*","style":{"code":true}},{"type":"text","text":"B' => (B*","style":{"bold":true,"code":true}},{"type":"text","text":"A)'","style":{"code":true}},{"type":"text","text":"  would match the LHS using the "},{"type":"text","text":".term","style":{"code":true}},{"type":"text","text":"  and then call the expression on the RHS with "},{"type":"text","text":"A","style":{"code":true}},{"type":"text","text":" and "},{"type":"text","text":"B","style":{"code":true}},{"type":"text","text":" as the "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":"  resulting in a new "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":" where the "},{"type":"text","text":".term","style":{"code":true}},{"type":"text","text":" is "},{"type":"text","text":"(B*A)'","style":{"code":true}},{"type":"text","text":" ........"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"349a9eb8-d273-4dd6-9864-08396d823a06","type":"message","text":"<@U8D9768Q6>, <@U6788D83U>","user":"U68907M46","ts":"1617808584.052600","team":"T68168MUP","edited":{"user":"U68907M46","ts":"1617808602.000000"},"blocks":[{"type":"rich_text","block_id":"rYE","elements":[{"type":"rich_text_section","elements":[{"type":"user","user_id":"U8D9768Q6"},{"type":"text","text":", "},{"type":"user","user_id":"U6788D83U"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"6c580dee-2125-4e3c-839b-904fc5e02f59","type":"message","text":"There can also be a different macro which matches the Einsum notation and rewrites that...","user":"U68907M46","ts":"1617808633.052900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"HItRM","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"There can also be a different macro which matches the Einsum notation and rewrites that..."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"c73b91ff-d0d8-4f73-927d-d97647ef00cf","type":"message","text":"At first I was thinking of making `Term{&lt;:AbstractArray}` the main thing and store the `ArrayOp` as metadata, but there are cases where you don't know the `Term` yet you want the metadata. Another thing I explored is making the `ArrayOp` behave like a function that takes positional arguments... So `Term(@arrayop((*) _1[i,k]*_2[k,j], A, B)` but you keep having to substitute _1 and _2 with A and B, and do the same to apply rules on non-trivial terms.","user":"U68907M46","ts":"1617809187.053100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hpI","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"At first I was thinking of making "},{"type":"text","text":"Term{<:AbstractArray}","style":{"code":true}},{"type":"text","text":" the main thing and store the "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":" as metadata, but there are cases where you don't know the "},{"type":"text","text":"Term","style":{"code":true}},{"type":"text","text":" yet you want the metadata. Another thing I explored is making the "},{"type":"text","text":"ArrayOp","style":{"code":true}},{"type":"text","text":" behave like a function that takes positional arguments... So "},{"type":"text","text":"Term(@arrayop((*) _1[i,k]*_2[k,j], A, B)","style":{"code":true}},{"type":"text","text":" but you keep having to substitute _1 and _2 with A and B, and do the same to apply rules on non-trivial terms."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"171ccdbc-e38f-4b05-9df2-c1605f765554","type":"message","text":"Hope all this makes sense, it took me a while to evaluate everything, so I'm happy to answer questions. I still think the resulting implementation is not as straightforward as I'd like, but I can't seem to make it be simpler.","user":"U68907M46","ts":"1617809339.053300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"dZ8","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Hope all this makes sense, it took me a while to evaluate everything, so I'm happy to answer questions. I still think the resulting implementation is not as straightforward as I'd like, but I can't seem to make it be simpler."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"f0af9325-1551-4e53-865a-8b0c75c5dfec","type":"message","text":"In your example, does\n```@arrayop((*), _1[i,k]*_2[k,j])```\nmean the product over all `k`?","user":"U8D9768Q6","ts":"1617811340.053900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"l83/y","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"In your example, does\n"}]},{"type":"rich_text_preformatted","elements":[{"type":"text","text":"@arrayop((*), _1[i,k]*_2[k,j])"}]},{"type":"rich_text_section","elements":[{"type":"text","text":"mean the product over all "},{"type":"text","text":"k","style":{"code":true}},{"type":"text","text":"?"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"c8e52067-2b12-4c02-a83a-311d8b12f152","type":"message","text":"I like this, I think it's a good idea","user":"U8D9768Q6","ts":"1617811365.054100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"UhC3","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"I like this, I think it's a good idea"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"e8f75cf6-cafd-485b-8df1-896c2c53c090","type":"message","text":"No, the `*` is sort of the high-level operation, i.e. It is saying `_1 * _2` is the same as the tensor expression.","user":"U68907M46","ts":"1617816664.054300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"BS8Ow","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"No, the "},{"type":"text","text":"*","style":{"code":true}},{"type":"text","text":" is sort of the high-level operation, i.e. It is saying "},{"type":"text","text":"_1 * _2","style":{"code":true}},{"type":"text","text":" is the same as the tensor expression."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"3947adb6-5b60-48da-a147-534020c8b72d","type":"message","text":"It can be `Unknown()`  in the other case","user":"U68907M46","ts":"1617816685.054500","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"j3K/+","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"It can be "},{"type":"text","text":"Unknown()","style":{"code":true}},{"type":"text","text":"  in the other case"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"679995ee-3711-47da-910c-5974fc97f93c","type":"message","text":"Ah. Well, then I'd say we should also have a slot for the reduction operator.","user":"U8D9768Q6","ts":"1617819904.054700","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"Lx9J","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Ah. Well, then I'd say we should also have a slot for the reduction operator."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"6951c175-a7af-4a88-a951-c5e3f5fc60ee","type":"message","text":"Some index notation expressions are well defined in terms of reductions other than `+`.","user":"U8D9768Q6","ts":"1617819923.054900","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"kFYIz","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"Some index notation expressions are well defined in terms of reductions other than "},{"type":"text","text":"+","style":{"code":true}},{"type":"text","text":"."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"0287e99b-8579-4a8a-948f-b00442eebc8a","type":"message","text":"yeah I have that, but just didn't use it in the example.","user":"U68907M46","ts":"1617826093.055100","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"hgJ4","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"yeah I have that, but just didn't use it in the example."}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"},{"client_msg_id":"1e86f3c2-48cd-47ce-9a6e-b61d87f5feb2","type":"message","text":"+ by default","user":"U68907M46","ts":"1617826096.055300","team":"T68168MUP","blocks":[{"type":"rich_text","block_id":"4uNV","elements":[{"type":"rich_text_section","elements":[{"type":"text","text":"+ by default"}]}]}],"thread_ts":"1617808065.049400","parent_user_id":"U68907M46"}]